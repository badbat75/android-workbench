diff -Naur linux-3.18.14/drivers/clk/clk.c samsung/drivers/clk/clk.c
--- linux-3.18.14/drivers/clk/clk.c	2015-05-20 17:04:50.000000000 +0200
+++ samsung/drivers/clk/clk.c	2018-10-29 07:24:36.000000000 +0100
@@ -114,6 +114,134 @@
 	NULL,
 };
 
+#ifdef CONFIG_COMMON_CLK_FREQ_STATS_ACCOUNTING
+
+#ifdef CONFIG_COMMON_CLK_BEGIN_ACCOUNTING_FROM_BOOT
+static bool freq_stats_on = true;
+#else
+static bool freq_stats_on;
+#endif /*CONFIG_COMMON_CLK_BEGIN_ACCOUNTING_FROM_BOOT*/
+
+static void free_tree(struct rb_node *node)
+{
+	struct freq_stats *this;
+
+	if (!node)
+		return;
+
+	free_tree(node->rb_left);
+	free_tree(node->rb_right);
+
+	this = rb_entry(node, struct freq_stats, node);
+	kfree(this);
+}
+
+static struct freq_stats *freq_stats_insert(struct rb_root *freq_stats_table,
+		unsigned long rate)
+{
+	struct rb_node **new = &(freq_stats_table->rb_node), *parent = NULL;
+	struct freq_stats *this;
+
+	/* Figure out where to put new node */
+	while (*new) {
+		this = rb_entry(*new, struct freq_stats, node);
+		parent = *new;
+
+		if (rate < this->rate)
+			new = &((*new)->rb_left);
+		else if (rate > this->rate)
+			new = &((*new)->rb_right);
+		else
+			return this;
+	}
+
+	this = kzalloc(sizeof(*this), GFP_ATOMIC);
+	this->rate = rate;
+
+	/* Add new node and rebalance tree. */
+	rb_link_node(&this->node, parent, new);
+	rb_insert_color(&this->node, freq_stats_table);
+
+	return this;
+}
+
+static void generic_print_freq_stats_table(struct seq_file *m,
+				struct clk *clk,
+				bool indent, int level)
+{
+	struct rb_node *pos;
+	struct freq_stats *cur;
+
+	if (indent)
+		seq_printf(m, "%*s*%s%20s", level * 3 + 1, "",
+			!clk->current_freq_stats ? "[" : "",
+			"default_freq");
+	else
+		seq_printf(m, "%2s%20s", !clk->current_freq_stats ? "[" : "",
+			"default_freq");
+
+	if (!clk->current_freq_stats && !ktime_equal(clk->start_time,
+					ktime_set(0, 0)))
+		seq_printf(m, "%40llu",
+			ktime_to_ms(ktime_add(clk->default_freq_time,
+			ktime_sub(ktime_get(), clk->start_time))));
+	else
+		seq_printf(m, "%40llu", ktime_to_ms(clk->default_freq_time));
+
+	if (!clk->current_freq_stats)
+		seq_puts(m, "]");
+
+	seq_puts(m, "\n");
+
+	for (pos = rb_first(&clk->freq_stats_table); pos; pos = rb_next(pos)) {
+		cur = rb_entry(pos, typeof(*cur), node);
+
+		if (indent)
+			seq_printf(m, "%*s*%s%20lu", level * 3 + 1, "",
+				cur->rate == clk->rate ? "[" : "", cur->rate);
+		else
+			seq_printf(m, "%2s%20lu", cur->rate == clk->rate ?
+				"[" : "", cur->rate);
+
+		if (cur->rate == clk->rate && !ktime_equal(clk->start_time,
+					ktime_set(0, 0)))
+			seq_printf(m, "%40llu",
+			ktime_to_ms(ktime_add(cur->time_spent,
+			ktime_sub(ktime_get(), clk->start_time))));
+		else
+			seq_printf(m, "%40llu", ktime_to_ms(cur->time_spent));
+
+		if (cur->rate == clk->rate)
+			seq_puts(m, "]");
+		seq_puts(m, "\n");
+	}
+}
+
+static int clock_print_freq_stats_table(struct seq_file *m, void *unused)
+{
+	struct clk *clk = m->private;
+
+	if (!(clk->flags & CLK_GET_RATE_NOCACHE))
+		generic_print_freq_stats_table(m, clk, false, 0);
+
+	return 0;
+}
+
+static int freq_stats_table_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, clock_print_freq_stats_table,
+		inode->i_private);
+}
+
+static const struct file_operations freq_stats_table_fops = {
+	.open           = freq_stats_table_open,
+	.read           = seq_read,
+	.llseek         = seq_lseek,
+	.release        = seq_release,
+};
+#endif /*CONFIG_COMMON_CLK_FREQ_STATS_ACCOUNTING*/
+
+
 static void clk_summary_show_one(struct seq_file *s, struct clk *c, int level)
 {
 	if (!c)
@@ -124,6 +252,12 @@
 		   30 - level * 3, c->name,
 		   c->enable_count, c->prepare_count, clk_get_rate(c),
 		   clk_get_accuracy(c), clk_get_phase(c));
+
+#ifdef CONFIG_COMMON_CLK_FREQ_STATS_ACCOUNTING
+	if (!(c->flags & CLK_GET_RATE_NOCACHE))
+		generic_print_freq_stats_table(s, c, true, level);
+#endif /*CONFIG_COMMON_CLK_FREQ_STATS_ACCOUNTING*/
+
 }
 
 static void clk_summary_show_subtree(struct seq_file *s, struct clk *c,
@@ -240,6 +374,79 @@
 	.release	= single_release,
 };
 
+#ifdef CONFIG_COMMON_CLK_FREQ_STATS_ACCOUNTING
+static int freq_stats_get(void *unused, u64 *val)
+{
+	*val = freq_stats_on;
+	return 0;
+}
+
+static void clk_traverse_subtree(struct clk *clk, int freq_stats_on)
+{
+	struct clk *child;
+	struct rb_node *node;
+
+	if (!clk)
+		return;
+
+	if (freq_stats_on) {
+		for (node = rb_first(&clk->freq_stats_table);
+			node; node = rb_next(node))
+			rb_entry(node, struct freq_stats, node)->time_spent =
+							ktime_set(0, 0);
+
+		clk->current_freq_stats = freq_stats_insert(
+						&clk->freq_stats_table,
+						clk_get_rate(clk));
+
+		if (clk->enable_count > 0)
+			clk->start_time = ktime_get();
+	} else {
+		if (clk->enable_count > 0) {
+			if (!clk->current_freq_stats)
+				clk->default_freq_time =
+				ktime_add(clk->default_freq_time,
+				ktime_sub(ktime_get(), clk->start_time));
+			else
+				clk->current_freq_stats->time_spent =
+				ktime_add(clk->current_freq_stats->time_spent,
+				ktime_sub(ktime_get(), clk->start_time));
+
+			clk->start_time = ktime_set(0, 0);
+		}
+	}
+	hlist_for_each_entry(child, &clk->children, child_node)
+		clk_traverse_subtree(child, freq_stats_on);
+}
+
+static int freq_stats_set(void *data, u64 val)
+{
+	struct clk *c;
+	unsigned long flags;
+	struct hlist_head **lists = (struct hlist_head **)data;
+
+	clk_prepare_lock();
+	flags = clk_enable_lock();
+
+	if (val == 0)
+		freq_stats_on = 0;
+	else
+		freq_stats_on = 1;
+
+	for (; *lists; lists++)
+		hlist_for_each_entry(c, *lists, child_node)
+			clk_traverse_subtree(c, freq_stats_on);
+
+	clk_enable_unlock(flags);
+	clk_prepare_unlock();
+
+	return 0;
+}
+DEFINE_SIMPLE_ATTRIBUTE(freq_stats_fops, freq_stats_get,
+			freq_stats_set, "%llu\n");
+#endif /*CONFIG_COMMON_CLK_FREQ_STATS_ACCOUNTING*/
+
+/* caller must hold prepare_lock */
 static int clk_debug_create_one(struct clk *clk, struct dentry *pdentry)
 {
 	struct dentry *d;
@@ -291,6 +498,14 @@
 	if (!d)
 		goto err_out;
 
+#ifdef CONFIG_COMMON_CLK_FREQ_STATS_ACCOUNTING
+	d = debugfs_create_file("frequency_stats_table", S_IRUGO, clk->dentry,
+			clk, &freq_stats_table_fops);
+
+	if (!d)
+		goto err_out;
+#endif /*CONFIG_COMMON_CLK_FREQ_STATS_ACCOUNTING*/
+
 	if (clk->ops->debug_init) {
 		ret = clk->ops->debug_init(clk->hw, clk->dentry);
 		if (ret)
@@ -403,6 +618,13 @@
 	if (!d)
 		return -ENOMEM;
 
+#ifdef CONFIG_COMMON_CLK_FREQ_STATS_ACCOUNTING
+	d = debugfs_create_file("freq_stats_on", S_IRUGO|S_IWUSR,
+				rootdir, &all_lists, &freq_stats_fops);
+	if (!d)
+		return -ENOMEM;
+#endif /*CONFIG_COMMON_CLK_FREQ_STATS_ACCOUNTING*/
+
 	mutex_lock(&clk_debug_lock);
 	hlist_for_each_entry(clk, &clk_debug_list, debug_node)
 		clk_debug_create_one(clk, rootdir);
@@ -852,6 +1074,22 @@
 	if (clk->ops->disable)
 		clk->ops->disable(clk->hw);
 
+#ifdef CONFIG_COMMON_CLK_FREQ_STATS_ACCOUNTING
+
+	if (freq_stats_on) {
+		if (!clk->current_freq_stats)
+			clk->default_freq_time =
+			ktime_add(clk->default_freq_time,
+			ktime_sub(ktime_get(), clk->start_time));
+		else
+			clk->current_freq_stats->time_spent =
+			ktime_add(clk->current_freq_stats->time_spent,
+			ktime_sub(ktime_get(), clk->start_time));
+
+		clk->start_time = ktime_set(0, 0);
+	}
+#endif /*CONFIG_COMMON_CLK_FREQ_STATS_ACCOUNTING*/
+
 	__clk_disable(clk->parent);
 }
 
@@ -903,6 +1141,11 @@
 				return ret;
 			}
 		}
+
+#ifdef CONFIG_COMMON_CLK_FREQ_STATS_ACCOUNTING
+	if (freq_stats_on)
+		clk->start_time = ktime_get();
+#endif /*CONFIG_COMMON_CLK_FREQ_STATS_ACCOUNTING*/
 	}
 
 	clk->enable_count++;
@@ -1483,6 +1726,32 @@
 
 	clk->rate = clk_recalc(clk, best_parent_rate);
 
+#ifdef CONFIG_COMMON_CLK_FREQ_STATS_ACCOUNTING
+	if (freq_stats_on) {
+		if (!ktime_equal(clk->start_time, ktime_set(0, 0))) {
+			if (!clk->current_freq_stats)
+				clk->default_freq_time =
+					ktime_add(clk->default_freq_time,
+					ktime_sub(ktime_get(),
+					clk->start_time));
+			else
+				clk->current_freq_stats->time_spent =
+					ktime_add(
+					clk->current_freq_stats->time_spent,
+					ktime_sub(ktime_get(),
+					clk->start_time));
+		}
+
+		clk->current_freq_stats = freq_stats_insert(
+						&clk->freq_stats_table,
+						clk->rate);
+
+		if (clk->enable_count > 0)
+			clk->start_time = ktime_get();
+	}
+#endif /*CONFIG_COMMON_CLK_FREQ_STATS_ACCOUNTING*/
+
+
 	if (clk->notifier_count && old_rate != clk->rate)
 		__clk_notify(clk, POST_RATE_CHANGE, old_rate, clk->rate);
 
@@ -1534,10 +1803,6 @@
 	/* prevent racing with updates to the clock topology */
 	clk_prepare_lock();
 
-	/* bail early if nothing to do */
-	if (rate == clk_get_rate(clk))
-		goto out;
-
 	if ((clk->flags & CLK_SET_RATE_GATE) && clk->prepare_count) {
 		ret = -EBUSY;
 		goto out;
@@ -1680,9 +1945,6 @@
 	/* prevent racing with updates to the clock topology */
 	clk_prepare_lock();
 
-	if (clk->parent == parent)
-		goto out;
-
 	/* check that we are allowed to re-parent if the clock is in use */
 	if ((clk->flags & CLK_SET_PARENT_GATE) && clk->prepare_count) {
 		ret = -EBUSY;
@@ -2112,6 +2374,11 @@
 
 	kfree(clk->parent_names);
 	kfree(clk->name);
+
+#ifdef CONFIG_COMMON_CLK_FREQ_STATS_ACCOUNTING
+	free_tree(clk->freq_stats_table.rb_node);
+#endif/*CONFIG_COMMON_CLK_FREQ_STATS_ACCOUNTING*/
+
 	kfree(clk);
 }
 
diff -Naur linux-3.18.14/drivers/clk/clk-composite.c samsung/drivers/clk/clk-composite.c
--- linux-3.18.14/drivers/clk/clk-composite.c	2015-05-20 17:04:50.000000000 +0200
+++ samsung/drivers/clk/clk-composite.c	2018-10-29 07:24:36.000000000 +0100
@@ -21,7 +21,7 @@
 
 #define to_clk_composite(_hw) container_of(_hw, struct clk_composite, hw)
 
-static u8 clk_composite_get_parent(struct clk_hw *hw)
+static int clk_composite_get_parent(struct clk_hw *hw)
 {
 	struct clk_composite *composite = to_clk_composite(hw);
 	const struct clk_ops *mux_ops = composite->mux_ops;
diff -Naur linux-3.18.14/drivers/clk/clkdev.c samsung/drivers/clk/clkdev.c
--- linux-3.18.14/drivers/clk/clkdev.c	2015-05-20 17:04:50.000000000 +0200
+++ samsung/drivers/clk/clkdev.c	2018-10-29 07:24:36.000000000 +0100
@@ -221,7 +221,7 @@
 }
 
 #define MAX_DEV_ID	20
-#define MAX_CON_ID	16
+#define MAX_CON_ID	40
 
 struct clk_lookup_alloc {
 	struct clk_lookup cl;
diff -Naur linux-3.18.14/drivers/clk/clk-mux.c samsung/drivers/clk/clk-mux.c
--- linux-3.18.14/drivers/clk/clk-mux.c	2015-05-20 17:04:50.000000000 +0200
+++ samsung/drivers/clk/clk-mux.c	2018-10-29 07:24:36.000000000 +0100
@@ -29,7 +29,7 @@
 
 #define to_clk_mux(_hw) container_of(_hw, struct clk_mux, hw)
 
-static u8 clk_mux_get_parent(struct clk_hw *hw)
+static int clk_mux_get_parent(struct clk_hw *hw)
 {
 	struct clk_mux *mux = to_clk_mux(hw);
 	int num_parents = __clk_get_num_parents(hw->clk);
diff -Naur linux-3.18.14/drivers/clk/Kconfig samsung/drivers/clk/Kconfig
--- linux-3.18.14/drivers/clk/Kconfig	2015-05-20 17:04:50.000000000 +0200
+++ samsung/drivers/clk/Kconfig	2018-10-29 07:24:36.000000000 +0100
@@ -134,6 +134,24 @@
 	---help---
 	  Sypport for the Marvell PXA SoC.
 
+config COMMON_CLK_FREQ_STATS_ACCOUNTING
+	bool "Enable clock frequency stats accounting"
+	depends on COMMON_CLK
+	depends on DEBUG_FS
+	---help---
+	 Allows accounting of the time spent by various clocks in each
+	 of its operating frequency. The stats get reported as a part
+	 of clk_summary. Would be be useful in finding out which
+	 components are running at what power states to debug
+	 battery consumption issues.
+
+config COMMON_CLK_BEGIN_ACCOUNTING_FROM_BOOT
+	bool "Start clock frequency stats accounting from boot"
+	depends on COMMON_CLK_FREQ_STATS_ACCOUNTING
+	---help---
+	 Enabling this option starts the frequency accounting right from
+	 the boot.
+
 source "drivers/clk/qcom/Kconfig"
 
 endmenu
diff -Naur linux-3.18.14/drivers/clk/samsung/clk-exynos7870.c samsung/drivers/clk/samsung/clk-exynos7870.c
--- linux-3.18.14/drivers/clk/samsung/clk-exynos7870.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/clk/samsung/clk-exynos7870.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,346 @@
+/*
+ * Copyright (c) 2015 Samsung Electronics Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This file contains clocks of Exynos7870.
+ */
+
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/clk-provider.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+
+#include <dt-bindings/clock/exynos7870.h>
+#include "../../soc/samsung/pwrcal/S5E7870/S5E7870-vclk.h"
+#include "composite.h"
+
+#if defined(CONFIG_ECT)
+#include <soc/samsung/ect_parser.h>
+#endif
+
+enum exynos7870_clks {
+	none,
+
+	oscclk = 1,
+
+	/* The group of clocks in mfcmscl */
+	mscl_sysmmu = 10, mfc_sysmmu, mfcmscl_ppmu, mfcmscl_bts, gate_mscl_bi, gate_mscl_poly, gate_jpeg, gate_mfc,
+
+	/* The group of clocks in g3d */
+	g3d_sysmmu = 50, g3d_ppmu, g3d_bts, gate_g3d,
+
+	/* The group of clocks related with pwm and mct in peri */
+	peri_pwm_motor = 100, peri_sclk_pwm_motor, peri_mct,
+
+	/* The group of clocks related with i2c in peri */
+	i2c_sensor1 = 110, i2c_sensor2, i2c_tsp, i2c_touchkey, i2c_fuelgauge, i2c_spkamp, i2c_nfc, i2c_muic, i2c_ifpmic,
+
+	/* The group of clocks related with hsi2c in peri */
+	hsi2c_frontcam = 130, hsi2c_maincam, hsi2c_depthcam, hsi2c_frontsensor, hsi2c_rearaf, hsi2c_rearsensor,
+
+	/* The group of clocks related with gpio in peri */
+	gpio_touch = 150, gpio_top, gpio_nfc, gpio_ese, gpio_alive,
+
+	/* The group of clocks related with wdt in peri */
+	wdt_cpucl0 = 160, wdt_cpucl1,
+
+	/* The group of clocks related with uart in peri */
+	uart_debug = 170, uart_btwififm, uart_sensor,
+
+	/* The group of clocks related with tmu in peri */
+	peri_tmu_g3d = 180, peri_tmu_cpucl1, peri_tmu_cpucl0,
+
+	 /* The group of clocks related with spi in peri */
+	peri_spi_sensorhub = 190, peri_spi_voiceprocessor, peri_spi_ese, peri_spi_rearfrom, peri_spi_frontfrom,
+
+	/* The group of clocks related with rtc in peri */
+	peri_rtc_alive = 210, peri_rtc_top,
+
+	/* The group of etc clocks in peri */
+	peri_chipid = 220, peri_otp_con_top,
+
+
+	/* The group of clocks in fsys */
+	fsys_sysmmu = 300, fsys_ppmu, fsys_bts,
+	fsys_mmc0 = 310, fsys_mmc1, fsys_mmc2, fsys_sclk_mmc0, fsys_sclk_mmc1, fsys_sclk_mmc2,
+	fsys_sss = 330,  fsys_rtic, fsys_pdma0, fsys_pdma1, fsys_sromc, fsys_usb20drd, fsys_usb20drd_phyclock,
+	usb_pll = 350,
+
+	/* The group of clocks in dispaud */
+	dispaud_sysmmu = 400, dispaud_ppmu, dispaud_bts,
+	dispaud_decon = 410, dispaud_dsim0, dispaud_mixer, dispaud_mi2s_aud, dispaud_mi2s_amp,
+	dispaud_bus = 430, dispaud_decon_int_vclk, dispaud_decon_int_eclk, dispaud_mipiphy_txbyteclkhs, dispaud_mipiphy_rxclkesc0,
+	decon_vclk = 450, decon_vclk_local, decon_eclk, decon_eclk_local,
+	disp_pll = 460, aud_pll, d1_i2s, d1_mixer,
+	oscclk_aud = 470,
+
+	/* The group of clocks in isp */
+	isp_sysmmu = 500, isp_ppmu, isp_bts,
+	isp_cam = 510, isp_isp, isp_vra, pxmxdx_vra, pxmxdx_cam, pxmxdx_isp,
+	isp_s_rxbyteclkhs0_s4 = 520, isp_s_rxbyteclkhs0_s4s,
+	isp_pll = 530,
+
+	/* The group of clocks in mif */
+	mif_adcif = 600, mif_hsi2c_mif, mmc0_sclk, mmc1_sclk, mmc2_sclk,
+	ufsunipro_sclk = 610, ufsunipro_cfg_sclk, usb20drd_sclk,
+	uart_sensor_sclk = 620, uart_btwififm_sclk, uart_debug_sclk,
+	spi_frontfrom_sclk = 630, spi_rearfrom_sclk, spi_ese_sclk, spi_voiceprocessor_sclk, spi_sensorhub_sclk,
+	isp_sensor0_sclk = 640, isp_sensor1_sclk, isp_sensor2_sclk,
+
+	/* number of dfs driver starts from 2000 */
+	dfs_mif = 2000, dfs_mif_sw, dfs_int, dfs_cam, dfs_disp,
+
+	nr_clks,
+};
+
+/* fixed rate clocks generated outside the soc */
+static struct samsung_fixed_rate exynos7870_fixed_rate_ext_clks[] __initdata = {
+	FRATE(oscclk, "fin_pll", NULL, CLK_IS_ROOT, 26000000),
+};
+
+static struct of_device_id ext_clk_match[] __initdata = {
+	{ .compatible = "samsung,exynos7870-oscclk", .data = (void *)0, },
+};
+
+static struct init_vclk exynos7870_mfcmscl_vclks[] __initdata = {
+	/* MFC & MSCL ACLK */
+	VCLK(mscl_sysmmu, gate_mfcmscl_sysmmu_mscl, "gate_mfcmscl_sysmmu_mscl", 0, 0, NULL),
+	VCLK(mfc_sysmmu, gate_mfcmscl_sysmmu_mfc, "gate_mfcmscl_sysmmu_mfc", 0, 0, NULL),
+	VCLK(mfcmscl_ppmu, gate_mfcmscl_ppmu, "gate_mfcmscl_ppmu", 0, 0, NULL),
+	VCLK(mfcmscl_bts, gate_mfcmscl_bts, "gate_mfcmscl_bts", 0, 0, NULL),
+	VCLK(gate_mscl_bi, gate_mfcmscl_mscl_bi, "gate_mfcmscl_mscl_bi", 0, 0, NULL),
+	VCLK(gate_mscl_poly, gate_mfcmscl_mscl_poly, "gate_mfcmscl_mscl_poly", 0, 0, NULL),
+	VCLK(gate_jpeg, gate_mfcmscl_jpeg, "gate_mfcmscl_jpeg", 0, 0, NULL),
+	VCLK(gate_mfc, gate_mfcmscl_mfc, "gate_mfcmscl_mfc", 0, 0, NULL),
+};
+
+static struct init_vclk exynos7870_g3d_vclks[] __initdata = {
+	/* G3D ACLK */
+	VCLK(g3d_sysmmu, gate_g3d_sysmmu, "gate_g3d_sysmmu", 0, 0, NULL),
+	VCLK(g3d_ppmu, gate_g3d_ppmu, "gate_g3d_ppmu", 0, 0, NULL),
+	VCLK(g3d_bts, gate_g3d_bts, "gate_g3d_bts", 0, 0, "gate_g3d_bts_alias"),
+	VCLK(gate_g3d, gate_g3d_g3d, "gate_g3d_g3d", 0, 0, "vclk_g3d"),
+};
+
+static struct init_vclk exynos7870_peri_vclks[] __initdata = {
+	/* PERI PWM ACLK & SCLK */
+	VCLK(peri_pwm_motor, gate_peri_pwm_motor, "gate_peri_pwm_motor", 0, 0, NULL),
+	VCLK(peri_sclk_pwm_motor, gate_peri_sclk_pwm_motor, "gate_peri_sclk_pwm_motor", 0, 0, NULL),
+	/* PERI MCT ACLK */
+	VCLK(peri_mct, gate_peri_mct, "gate_peri_mct", 0, 0, NULL),
+	/* PERI I2C ACLK */
+	VCLK(i2c_sensor1, gate_peri_i2c_sensor1, "gate_peri_i2c_sensor1", 0, 0, NULL),
+	VCLK(i2c_sensor2, gate_peri_i2c_sensor2, "gate_peri_i2c_sensor2", 0, 0, NULL),
+	VCLK(i2c_tsp, gate_peri_i2c_tsp, "gate_peri_i2c_tsp", 0, 0, NULL),
+	VCLK(i2c_touchkey, gate_peri_i2c_touchkey, "gate_peri_i2c_touchkey", 0, 0, NULL),
+	VCLK(i2c_fuelgauge, gate_peri_i2c_fuelgauge, "gate_peri_i2c_fuelgauge", 0, 0, NULL),
+	VCLK(i2c_spkamp, gate_peri_i2c_spkamp, "gate_peri_i2c_spkamp", 0, 0, NULL),
+	VCLK(i2c_nfc, gate_peri_i2c_nfc, "gate_peri_i2c_nfc", 0, 0, "i2c2_pclk"),
+	VCLK(i2c_muic, gate_peri_i2c_muic, "gate_peri_i2c_muic", 0, 0, NULL),
+	VCLK(i2c_ifpmic, gate_peri_i2c_ifpmic, "gate_peri_i2c_ifpmic", 0, 0, NULL),
+	/* PERI HSI2C ACLK */
+	VCLK(hsi2c_frontcam, gate_peri_hsi2c_frontcam, "gate_peri_hsi2c_frontcam", 0, 0, NULL),
+	VCLK(hsi2c_maincam, gate_peri_hsi2c_maincam, "gate_peri_hsi2c_maincam", 0, 0, NULL),
+	VCLK(hsi2c_depthcam, gate_peri_hsi2c_depthcam, "gate_peri_hsi2c_depthcam", 0, 0, NULL),
+	VCLK(hsi2c_frontsensor, gate_peri_hsi2c_frontsensor, "gate_peri_hsi2c_frontsensor", 0, 0, NULL),
+	VCLK(hsi2c_rearaf,gate_peri_hsi2c_rearaf, "gate_peri_hsi2c_rearaf", 0, 0, NULL),
+	VCLK(hsi2c_rearsensor, gate_peri_hsi2c_rearsensor, "gate_peri_hsi2c_rearsensor", 0, 0, NULL),
+	/* PERI GPIO ACLK */
+	VCLK(gpio_touch, gate_peri_gpio_touch, "gate_peri_gpio_touch", 0, 0, NULL),
+	VCLK(gpio_top, gate_peri_gpio_top, "gate_peri_gpio_top", 0, 0, NULL),
+	VCLK(gpio_nfc, gate_peri_gpio_nfc, "gate_peri_gpio_nfc", 0, 0, NULL),
+	VCLK(gpio_ese, gate_peri_gpio_ese, "gate_peri_gpio_ese", 0, 0, NULL),
+	VCLK(gpio_alive, gate_peri_gpio_alive, "gate_peri_gpio_alive", 0, 0, NULL),
+	/* PERI WDT ACLK */
+	VCLK(wdt_cpucl0, gate_peri_wdt_cpucl0, "gate_peri_wdt_cpucl0", 0, 0, NULL),
+	VCLK(wdt_cpucl1, gate_peri_wdt_cpucl1, "gate_peri_wdt_cpucl1", 0, 0, NULL),
+	/* PERI UART ACLK */
+	VCLK(uart_debug, gate_peri_uart_debug, "gate_peri_uart_debug", 0, 0, "console-pclk2"),
+	VCLK(uart_btwififm, gate_peri_uart_btwififm, "gate_peri_uart_btwififm", 0, 0, NULL),
+	VCLK(uart_sensor, gate_peri_uart_sensor, "gate_peri_uart_sensor", 0, 0, NULL),
+	/* PERI TMU ACLK */
+	VCLK(peri_tmu_g3d, gate_peri_tmu_g3d, "gate_peri_tmu_g3d", 0, 0, NULL),
+	VCLK(peri_tmu_cpucl1, gate_peri_tmu_cpucl1, "gate_peri_tmu_cpucl1", 0, 0, NULL),
+	VCLK(peri_tmu_cpucl0, gate_peri_tmu_cpucl0, "gate_peri_tmu_cpucl0", 0, 0, NULL),
+	/* PERI SPI ACLK */
+	VCLK(peri_spi_sensorhub, gate_peri_spi_sensorhub, "gate_peri_spi_sensorhub", 0, 0, NULL),
+	VCLK(peri_spi_voiceprocessor, gate_peri_spi_voiceprocessor, "gate_peri_spi_voiceprocessor", 0, 0, NULL),
+#ifdef CONFIG_SENSORS_FINGERPRINT
+	VCLK(peri_spi_ese, gate_peri_spi_ese, "gate_peri_spi_ese", 0, 0, "fp-spi-pclk"),
+#else
+	VCLK(peri_spi_ese, gate_peri_spi_ese, "gate_peri_spi_ese", 0, 0, NULL),
+#endif
+	VCLK(peri_spi_rearfrom, gate_peri_spi_rearfrom, "gate_peri_spi_rearfrom", 0, 0, NULL),
+	VCLK(peri_spi_frontfrom, gate_peri_spi_frontfrom, "gate_peri_spi_frontfrom", 0, 0, NULL),
+	/* PERI RTC ACLK */
+	VCLK(peri_rtc_alive, gate_peri_rtc_alive, "gate_peri_rtc_alive", 0, 0, NULL),
+	VCLK(peri_rtc_top, gate_peri_rtc_top, "gate_peri_rtc_top", 0, 0, NULL),
+	/* PERI ETC ACLK */
+	VCLK(peri_chipid, gate_peri_chipid, "gate_peri_chipid", 0, 0, NULL),
+	VCLK(peri_otp_con_top, gate_peri_otp_con_top, "gate_peri_otp_con_top", 0, 0, NULL),
+};
+
+static struct init_vclk exynos7870_fsys_vclks[] __initdata = {
+	/* FSYS COMMON*/
+	VCLK(fsys_sysmmu, gate_fsys_sysmmu, "gate_fsys_sysmmu", 0, 0, NULL),
+	VCLK(fsys_ppmu, gate_fsys_ppmu, "gate_fsys_ppmu", 0, 0, NULL),
+	VCLK(fsys_bts, gate_fsys_bts, "gate_fsys_bts", 0, 0, NULL),
+	VCLK(fsys_usb20drd, gate_fsys_usb20drd, "gate_fsys_usb20drd", 0, 0, NULL),
+	VCLK(fsys_mmc0, gate_fsys_mmc0, "gate_fsys_mmc0", 0, 0, NULL),
+	VCLK(fsys_mmc1, gate_fsys_mmc1, "gate_fsys_mmc1", 0, 0, NULL),
+	VCLK(fsys_mmc2, gate_fsys_mmc2, "gate_fsys_mmc2", 0, 0, NULL),
+	VCLK(fsys_sclk_mmc0, gate_fsys_sclk_mmc0, "gate_fsys_sclk_mmc0", 0, 0, NULL),
+	VCLK(fsys_sclk_mmc1, gate_fsys_sclk_mmc1, "gate_fsys_sclk_mmc1", 0, 0, NULL),
+	VCLK(fsys_sclk_mmc2, gate_fsys_sclk_mmc2, "gate_fsys_sclk_mmc2", 0, 0, NULL),
+	VCLK(fsys_sss, gate_fsys_sss, "gate_fsys_sss", 0, 0, NULL),
+	VCLK(fsys_rtic, gate_fsys_rtic, "gate_fsys_rtic", 0, 0, NULL),
+	VCLK(fsys_pdma0, gate_fsys_pdma0, "gate_fsys_pdma0", 0, 0, NULL),
+#ifdef CONFIG_SENSORS_FINGERPRINT
+	VCLK(fsys_pdma1, gate_fsys_pdma1, "gate_fsys_pdma1", 0, 0, "apb_pclk"),
+#else
+	VCLK(fsys_pdma1, gate_fsys_pdma1, "gate_fsys_pdma1", 0, 0, NULL),
+#endif
+	VCLK(fsys_sromc, gate_fsys_sromc, "gate_fsys_sromc", 0, 0, NULL),
+	VCLK(fsys_usb20drd_phyclock, umux_fsys_clkphy_fsys_usb20drd_phyclock_user, "umux_fsys_clkphy_fsys_usb20drd_phyclock_user", 0, 0, NULL),
+
+	VCLK(usb_pll, p1_usb_pll, "p1_usb_pll", 0, 0, NULL),
+};
+
+static struct init_vclk exynos7870_dispaud_vclks[] __initdata = {
+	/* DISPAUD ACLK */
+	VCLK(dispaud_sysmmu, gate_dispaud_sysmmu, "gate_dispaud_sysmmu", 0, 0, NULL),
+	VCLK(dispaud_ppmu, gate_dispaud_ppmu, "gate_dispaud_ppmu", 0, 0, NULL),
+	VCLK(dispaud_bts, gate_dispaud_bts, "gate_dispaud_bts", 0, 0, NULL),
+	VCLK(dispaud_decon, gate_dispaud_decon, "gate_dispaud_decon", 0, 0, NULL),
+	VCLK(dispaud_dsim0, gate_dispaud_dsim0, "gate_dispaud_dsim0", 0, 0, NULL),
+	VCLK(dispaud_mixer, gate_dispaud_mixer, "gate_dispaud_mixer", 0, 0, NULL),
+	VCLK(dispaud_mi2s_aud, gate_dispaud_mi2s_aud, "gate_dispaud_mi2s_aud", 0, 0, NULL),
+	VCLK(dispaud_mi2s_amp, gate_dispaud_mi2s_amp, "gate_dispaud_mi2s_amp", 0, 0, NULL),
+	/*
+	VCLK(dispaud_bus, umux_dispaud_clkcmu_dispaud_bus_user, "umux_dispaud_clkcmu_dispaud_bus_user", 0, 0, NULL),
+	VCLK(dispaud_decon_int_vclk, umux_dispaud_clkcmu_dispaud_decon_int_vclk_user, "umux_dispaud_clkcmu_dispaud_decon_int_vclk_user", 0, 0, NULL),
+	VCLK(dispaud_decon_int_eclk, umux_dispaud_clkcmu_dispaud_decon_int_eclk_user, "umux_dispaud_clkcmu_dispaud_decon_int_eclk_user", 0, 0, NULL),
+	*/
+	VCLK(dispaud_mipiphy_txbyteclkhs, umux_dispaud_clkphy_dispaud_mipiphy_txbyteclkhs_user, "umux_dispaud_clkphy_dispaud_mipiphy_txbyteclkhs_user", 0, 0, NULL),
+	VCLK(dispaud_mipiphy_rxclkesc0, umux_dispaud_clkphy_dispaud_mipiphy_rxclkesc0_user, "umux_dispaud_clkphy_dispaud_mipiphy_rxclkesc0_user", 0, 0, NULL),
+
+	/* DISPAUD SCLK */
+	VCLK(decon_vclk, sclk_decon_vclk, "sclk_decon_vclk", 0, 0, NULL),
+	VCLK(decon_vclk_local, sclk_decon_vclk_local, "sclk_decon_vclk_local", 0, 0, NULL),
+	VCLK(decon_eclk, sclk_decon_eclk, "sclk_decon_eclk", 0, 0, NULL),
+	VCLK(decon_eclk_local, sclk_decon_eclk_local, "sclk_decon_eclk_local", 0, 0, NULL),
+	/* DISPAUD PLL */
+	VCLK(disp_pll, p1_disp_pll, "p1_disp_pll", 0, 0, NULL),
+	VCLK(aud_pll, p1_aud_pll, "p1_aud_pll", 0, 0, NULL),
+
+	VCLK(d1_i2s, d1_dispaud_mi2s, "d1_dispaud_mi2s", 0, 0, NULL),
+	VCLK(d1_mixer, d1_dispaud_mixer, "d1_dispaud_mixer", 0, 0, NULL),
+	VCLK(oscclk_aud, pxmxdx_oscclk_aud, "pxmxdx_oscclk_aud", 0, 0, NULL),
+};
+static struct init_vclk exynos7870_isp_vclks[] __initdata = {
+	VCLK(isp_sysmmu, gate_isp_sysmmu, "gate_isp_sysmmu", 0, 0, NULL),
+	VCLK(isp_ppmu, gate_isp_ppmu, "gate_isp_ppmu", 0, 0, NULL),
+	VCLK(isp_bts, gate_isp_bts, "gate_isp_bts", 0, 0, NULL),
+	VCLK(isp_cam, gate_isp_cam, "gate_isp_cam", 0, 0, NULL),
+	VCLK(isp_isp, gate_isp_isp, "gate_isp_isp", 0, 0, NULL),
+	VCLK(isp_vra, gate_isp_vra, "gate_isp_vra", 0, 0, NULL),
+
+	VCLK(pxmxdx_vra, pxmxdx_isp_vra, "pxmxdx_isp_vra", 0, 0, NULL),
+	VCLK(pxmxdx_cam, pxmxdx_isp_cam, "pxmxdx_isp_cam", 0, 0, NULL),
+	VCLK(pxmxdx_isp, pxmxdx_isp_isp, "pxmxdx_isp_isp", 0, 0, NULL),
+
+	VCLK(isp_s_rxbyteclkhs0_s4, umux_isp_clkphy_isp_s_rxbyteclkhs0_s4_user, "umux_isp_clkphy_isp_s_rxbyteclkhs0_s4_user", 0, 0, NULL),
+	VCLK(isp_s_rxbyteclkhs0_s4s, umux_isp_clkphy_isp_s_rxbyteclkhs0_s4s_user, "umux_isp_clkphy_isp_s_rxbyteclkhs0_s4s_user", 0, 0, NULL),
+
+	VCLK(isp_pll, p1_isp_pll, "p1_isp_pll", 0, 0, NULL),
+};
+
+static struct init_vclk exynos7870_mif_vclks[] __initdata = {
+	VCLK(mif_adcif, gate_mif_adcif, "gate_mif_adcif", 0, 0, NULL),
+	VCLK(mif_hsi2c_mif, gate_mif_hsi2c_mif, "gate_mif_hsi2c_mif", 0, 0, NULL),
+
+	VCLK(mmc0_sclk, sclk_mmc0, "sclk_mmc0", 0, 0, NULL),
+	VCLK(mmc1_sclk, sclk_mmc1, "sclk_mmc1", 0, 0, NULL),
+	VCLK(mmc2_sclk, sclk_mmc2, "sclk_mmc2", 0, 0, NULL),
+	/*
+	VCLK(ufsunipro_sclk, sclk_ufsunipro, "sclk_ufsunipro", 0, 0, NULL),
+	VCLK(ufsunipro_cfg_sclk, sclk_ufsunipro_cfg, "sclk_ufsunipro_cfg", 0, 0, NULL),
+	*/
+	VCLK(usb20drd_sclk, sclk_usb20drd, "sclk_usb20drd" , 0, 0, NULL),
+	VCLK(uart_sensor_sclk, sclk_uart_sensor, "sclk_uart_sensor", 0, 0, "console-sclk0"),
+	VCLK(uart_btwififm_sclk, sclk_uart_btwififm, "sclk_uart_btwififm", 0, 0, NULL),
+	VCLK(uart_debug_sclk, sclk_uart_debug, "sclk_uart_debug", 0, 0, "console-sclk2"),
+	VCLK(spi_frontfrom_sclk, sclk_spi_frontfrom, "sclk_spi_frontfrom", 0, 0, NULL),
+	VCLK(spi_rearfrom_sclk, sclk_spi_rearfrom, "sclk_spi_rearfrom", 0, 0, NULL),
+#ifdef CONFIG_SENSORS_FINGERPRINT
+	VCLK(spi_ese_sclk, sclk_spi_ese, "sclk_spi_ese", 0, 0, "fp-spi-sclk"),
+#else
+	VCLK(spi_ese_sclk, sclk_spi_ese, "sclk_spi_ese", 0, 0, NULL),
+#endif
+	VCLK(spi_voiceprocessor_sclk, sclk_spi_voiceprocessor, "sclk_spi_voiceprocessor", 0, 0, NULL),
+	VCLK(spi_sensorhub_sclk, sclk_spi_sensorhub, "sclk_spi_sensorhub", 0, 0, NULL),
+	VCLK(isp_sensor0_sclk, sclk_isp_sensor0, "sclk_isp_sensor0", 0, 0, NULL),
+	VCLK(isp_sensor1_sclk, sclk_isp_sensor1, "sclk_isp_sensor1", 0, 0, NULL),
+	VCLK(isp_sensor2_sclk, sclk_isp_sensor2, "sclk_isp_sensor2", 0, 0, NULL),
+};
+
+static struct init_vclk exynos7870_dfs_vclks[] __initdata = {
+	/* DFS */
+	VCLK(dfs_mif, dvfs_mif, "dvfs_mif", 0, VCLK_DFS, NULL),
+	VCLK(dfs_mif_sw, dvfs_mif, "dvfs_mif_sw", 0, VCLK_DFS_SWITCH, NULL),
+	VCLK(dfs_int, dvfs_int, "dvfs_int", 0, VCLK_DFS, NULL),
+	VCLK(dfs_cam, dvfs_cam, "dvfs_cam", 0, VCLK_DFS, NULL),
+	VCLK(dfs_disp, dvfs_disp, "dvfs_disp", 0, VCLK_DFS, NULL),
+};
+
+/* register exynos7870 clocks */
+void __init exynos7870_clk_init(struct device_node *np)
+{
+	struct samsung_clk_provider *ctx;
+	void __iomem *reg_base;
+	int ret;
+
+	if (np) {
+		reg_base = of_iomap(np, 0);
+		if (!reg_base)
+			panic("%s: failed to map registers\n", __func__);
+	} else {
+		panic("%s: unable to determine soc\n", __func__);
+	}
+
+#if defined(CONFIG_ECT)
+	ect_parse_binary_header();
+#endif
+
+	ret = cal_init();
+	if (ret)
+		pr_err("%s: unable to initialize power cal\n", __func__);
+
+	ctx = samsung_clk_init(np, reg_base, nr_clks);
+	if (!ctx)
+		panic("%s: unable to allocate context.\n", __func__);
+
+	samsung_register_of_fixed_ext(ctx, exynos7870_fixed_rate_ext_clks,
+			ARRAY_SIZE(exynos7870_fixed_rate_ext_clks), ext_clk_match);
+
+	/* Regist clock local IP */
+	samsung_register_vclk(ctx, exynos7870_mfcmscl_vclks, ARRAY_SIZE(exynos7870_mfcmscl_vclks));
+	samsung_register_vclk(ctx, exynos7870_g3d_vclks, ARRAY_SIZE(exynos7870_g3d_vclks));
+	samsung_register_vclk(ctx, exynos7870_peri_vclks, ARRAY_SIZE(exynos7870_peri_vclks));
+	samsung_register_vclk(ctx, exynos7870_fsys_vclks, ARRAY_SIZE(exynos7870_fsys_vclks));
+	samsung_register_vclk(ctx, exynos7870_dispaud_vclks, ARRAY_SIZE(exynos7870_dispaud_vclks));
+	samsung_register_vclk(ctx, exynos7870_isp_vclks, ARRAY_SIZE(exynos7870_isp_vclks));
+	samsung_register_vclk(ctx, exynos7870_mif_vclks, ARRAY_SIZE(exynos7870_mif_vclks));
+	samsung_register_vclk(ctx, exynos7870_dfs_vclks, ARRAY_SIZE(exynos7870_dfs_vclks));
+
+	samsung_clk_of_add_provider(np, ctx);
+
+	clk_register_fixed_factor(NULL, "pwm-clock", "gate_peri_sclk_pwm_motor", CLK_SET_RATE_PARENT, 1, 1);
+
+	pr_info("EXYNOS7870: Clock setup completed\n");
+}
+CLK_OF_DECLARE(exynos7870_clks, "samsung,exynos7870-clock", exynos7870_clk_init);
diff -Naur linux-3.18.14/drivers/clk/samsung/clk-exynos8890.c samsung/drivers/clk/samsung/clk-exynos8890.c
--- linux-3.18.14/drivers/clk/samsung/clk-exynos8890.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/clk/samsung/clk-exynos8890.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,544 @@
+/*
+ * Copyright (c) 2015 Samsung Electronics Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This file contains clocks of Exynos8890.
+ */
+
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/clk-provider.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+
+#include <dt-bindings/clock/exynos8890.h>
+#include "../../soc/samsung/pwrcal/S5E8890/S5E8890-vclk.h"
+#include "composite.h"
+
+#if defined(CONFIG_ECT)
+#include <soc/samsung/ect_parser.h>
+#endif
+
+enum exynos8890_clks {
+	none,
+
+	oscclk = 1,
+
+	/* number for mfc driver starts from 10 */
+	mfc_hpm = 10, mfc_mfc, mfc_ppmu,
+
+	/* number for mscl driver starts from 50 */
+	mscl_mscl0 = 50, mscl_jpeg, mscl_mscl1, mscl_g2d, mscl_ppmu, mscl_bts,
+
+	/* number for imem driver starts from 100 */
+	gate_apm = 100, gate_sss, gate_gic400, gate_rtic, gate_mc, gate_intmem, gate_alv, gate_ppmu,
+
+	/* number for peris driver starts from 150 */
+	peris_sfr = 150, peris_hpm, peris_mct, wdt_mngs, wdt_apollo, sysreg_peris, monocnt_apbif, rtc_apbif, top_rtc, otp_con_top, peris_chipid, peris_tmu, peris_sysreg, peris_monocnt,
+
+	/* number for peric0 driver starts from 200 */
+	gate_hsi2c0 = 200, gate_hsi2c1, gate_hsi2c4, gate_hsi2c5, gate_hsi2c9, gate_hsi2c10, gate_hsi2c11, puart0, suart0, gate_adcif, gate_pwm, gate_sclk_pwm,
+
+	/* number for peric1 driver starts from 250 */
+	gate_hsi2c2 = 250, gate_hsi2c3, gate_hsi2c6, gate_hsi2c7, gate_hsi2c8, gate_hsi2c12, gate_hsi2c13, gate_hsi2c14,
+	gate_uart1, gate_uart2, gate_uart3, gate_uart4, gate_uart5, suart1, suart2, suart3, suart4, suart5,
+	gate_spi0, gate_spi1, gate_spi2, gate_spi3, gate_spi4, gate_spi5, gate_spi6, gate_spi7,
+	sclk_peric1_spi0, sclk_peric1_spi1, sclk_peric1_spi2, sclk_peric1_spi3, sclk_peric1_spi4, sclk_peric1_spi5, sclk_peric1_spi6, sclk_peric1_spi7,
+	gate_gpio_nfc, gate_gpio_touch, gate_gpio_fp, gate_gpio_ese, promise_int, promise_disp, ap2cp_mif_pll_out, gate_i2s1, gate_pcm1, gate_spdif,
+
+	/* number for isp0 driver starts from 400 */
+	gate_fimc_isp0 = 400, gate_fimc_tpu, isp0, isp0_tpu, isp0_trex, isp0_ppmu, isp0_bts,
+
+	/* number for isp1 driver starts from 450 */
+	gate_fimc_isp1 = 450, isp1, isp1_ppmu, isp1_bts,
+
+	/* number for isp sensor driver starts from 500 */
+	isp_sensor0 = 500, isp_sensor1, isp_sensor2, isp_sensor3,
+
+	/* number for cam0 driver starts from 550 */
+	gate_csis0 = 550, gate_csis1, gate_fimc_bns, fimc_3aa0, fimc_3aa1, cam0_hpm, pxmxdx_csis0, pxmxdx_csis1, pxmxdx_csis2, pxmxdx_csis3,
+	pxmxdx_3aa0, pxmxdx_3aa1, pxmxdx_trex, hs0_csis0_rx_byte, hs1_csis0_rx_byte, hs2_csis0_rx_byte, hs3_csis0_rx_byte, hs0_csis1_rx_byte, hs1_csis1_rx_byte, cam0_ppmu, cam0_bts,
+
+	/* number for cam1 driver starts from 600 */
+	gate_isp_cpu = 600, gate_csis2, gate_csis3, gate_fimc_vra, gate_mc_scaler, gate_i2c0_isp, gate_i2c1_isp, gate_i2c2_isp, gate_i2c3_isp, gate_wdt_isp,
+	gate_mcuctl_isp, gate_uart_isp, gate_pdma_isp, gate_pwm_isp, gate_spi0_isp, gate_spi1_isp, isp_spi0, isp_spi1, isp_uart, gate_sclk_pwm_isp,
+	gate_sclk_uart_isp, cam1_arm, cam1_vra, cam1_trex, cam1_bus, cam1_peri, cam1_csis2, cam1_csis3, cam1_scl, cam1_phy0_csis2, cam1_phy1_csis2,
+	cam1_phy2_csis2, cam1_phy3_csis2, cam1_phy0_csis3, cam1_ppmu, cam1_bts,
+
+	/* number for audio driver starts from 650 */
+	gate_mi2s = 650, gate_pcm, gate_slimbus, gate_sclk_mi2s, d1_sclk_i2s, gate_sclk_pcm, d1_sclk_pcm, gate_sclk_slimbus, sclk_slimbus, sclk_cp_i2s,
+	sclk_asrc, aud_pll, aud_cp, aud_lpass, aud_dma, aud_ppmu, aud_bts,
+
+	/* number for fsys0 driver starts from 700 */
+	gate_usbdrd30 = 700, gate_usbhost20, usbdrd30 = 703, sclk_fsys0_mmc0, ufsunipro20, phy24m, ufsunipro_cfg, gate_udrd30_phyclock, gate_udrd30_pipe, gate_ufs_tx0,
+	gate_ufs_rx0, usbhost20_phyclock, usbhost20phy_ref = 715, fsys_200 = 719, fsys0_etr_usb, gate_mmc, gate_pdma0, gate_pdmas, gate_ufs_linkemedded,
+
+	/* number for fsys1 driver starts from 750 */
+	gate_ufs20_sdcard = 750, fsys1_hpm, fsys1_sclk_mmc2, ufsunipro20_sdcard, pcie_phy, sclk_ufsunipro_sdcard, ufs_link_sdcard_tx0, ufs_link_sdcard_rx0,
+	pcie_wifi0_tx0, pcie_wifi0_rx0, pcie_wifi1_tx0, pcie_wifi1_rx0, wifi0_dig_refclk, wifi1_dig_refclk, gate_mmc2 =767, gate_sromc, gate_pciewifi0,
+	gate_pciewifi1, fsys1_ppmu, fsys1_bts,
+
+	/* number for g3d driver starts from 800 */
+	gate_g3d = 800, gate_g3d_iram, g3d_bts, g3d_ppmu,
+
+	/* number for disp0 driver starts from 850 */
+	gate_decon0 = 850, gate_dsim0, gate_dsim1, gate_dsim2, gate_hdmi, gate_dp, gate_hpm_apbif_disp0, decon0_eclk0, decon0_vclk0, decon0_vclk1,
+	decon0_eclk0_local, decon0_vclk0_local, decon0_vclk1_local, hdmi_audio, disp_pll,
+	mipidphy0_rxclkesc0, mipidphy0_bitclkdiv8, mipidphy1_rxclkesc0, mipidphy1_bitclkdiv8, mipidphy2_rxclkesc0, mipidphy2_bitclkdiv8,
+	dpphy_ch0_txd, dpphy_ch1_txd, dpphy_ch2_txd, dpphy_ch3_txd, dptx_phy_i_ref_clk_24m,
+	mipi_dphy_m1s0, mipi_dphy_m4s0, mipi_dphy_m4s4, phyclk_hdmiphy_tmds_20b, phyclk_hdmiphy_pixel, mipidphy0_bitclkdiv2_user,
+	mipidphy1_bitclkdiv2_user, mipidphy2_bitclkdiv2_user,
+
+	/* number for disp1 driver starts from 900 */
+	gate_decon1 = 900, gate_hpmdisp1, decon1_eclk0, decon1_eclk1, decon1_eclk0_local, decon1_eclk1_local,
+	disp1_phyclk_mipidphy0_bitclkdiv2_user, disp1_phyclk_mipidphy1_bitclkdiv2_user,
+	disp1_phyclk_mipidphy2_bitclkdiv2_user, disp1_phyclk_disp1_hdmiphy_pixel_clko_user, disp1_ppmu, disp1_bts,
+
+	/* number for ccore driver starts from 950 */
+	ccore_i2c = 950,
+
+	/* number for clkout port starts from 1000 */
+	oscclk_nfc = 1000, oscclk_aud,
+
+	/* clk id for sysmmu: 1100 ~ 1149
+	 * NOTE: clock IDs of sysmmus are defined in
+	 * include/dt-bindings/clock/exynos8890.h
+	 */
+	sysmmu_last = 1149,
+
+	nr_clks,
+};
+
+static struct samsung_fixed_rate exynos8890_fixed_rate_ext_clks[] __initdata = {
+	FRATE(oscclk, "fin_pll", NULL, CLK_IS_ROOT, 0),
+};
+
+static struct of_device_id ext_clk_match[] __initdata = {
+	{ .compatible = "samsung,exynos8890-oscclk", .data = (void *)0, },
+};
+
+static struct init_vclk exynos8890_clkout_vclks[] __initdata = {
+	VCLK(oscclk_nfc, pxmxdx_oscclk_nfc, "pxmxdx_oscclk_nfc", 0, 0, NULL),
+	VCLK(oscclk_aud, pxmxdx_oscclk_aud, "pxmxdx_oscclk_aud", 0, 0, NULL),
+};
+
+static struct init_vclk exynos8890_ccore_vclks[] __initdata = {
+	VCLK(ccore_i2c, gate_ccore_i2c, "gate_ccore_i2c", 0, 0, NULL),
+};
+
+static struct init_vclk exynos8890_mfc_vclks[] __initdata = {
+	/* MFC */
+	VCLK(mfc_hpm, gate_mfc_hpm, "mfc_hpm", 0, 0, NULL),
+	VCLK(mfc_mfc, gate_mfc_mfc, "mfc_mfc", 0, 0, NULL),
+	VCLK(CLK_VCLK_SYSMMU_MFC, gate_mfc_sysmmu, "mfc_sysmmu", 0, 0, NULL),
+	VCLK(mfc_ppmu, gate_mfc_ppmu, "mfc_ppmu", 0, 0, NULL),
+};
+
+static struct init_vclk exynos8890_mscl_vclks[] __initdata = {
+	/* MSCL */
+	VCLK(mscl_mscl0, gate_mscl_mscl0, "gate_mscl_mscl0", 0, 0, NULL),
+	VCLK(mscl_jpeg, gate_mscl_jpeg, "gate_mscl_jpeg", 0, 0, NULL),
+	VCLK(mscl_mscl1, gate_mscl_mscl1, "gate_mscl_mscl1", 0, 0, NULL),
+	VCLK(mscl_g2d, gate_mscl_g2d, "gate_mscl_g2d", 0, 0, NULL),
+	VCLK(CLK_VCLK_SYSMMU_MSCL, gate_mscl_sysmmu, "gate_mscl_sysmmu", 0, 0, NULL),
+	VCLK(mscl_ppmu, gate_mscl_ppmu, "gate_mscl_ppmu", 0, 0, NULL),
+	VCLK(mscl_bts, gate_mscl_bts, "gate_mscl_bts", 0, 0, NULL),
+};
+
+static struct init_vclk exynos8890_imem_vclks[] __initdata = {
+	/* IMEM */
+	VCLK(gate_apm, gate_imem_apm, "gate_imem_apm", 0, 0, NULL),
+	VCLK(gate_sss, gate_imem_sss, "gate_imem_sss", 0, 0, NULL),
+	VCLK(gate_gic400, gate_imem_gic400, "gate_imem_gic400", 0, 0, NULL),
+	VCLK(gate_rtic, gate_imem_rtic, "gate_imem_rtic", 0, 0, NULL),
+	VCLK(gate_mc, gate_imem_mc, "gate_imem_mc", 0, 0, NULL),
+	VCLK(gate_intmem, gate_imem_intmem, "gate_imem_intmem", 0, 0, NULL),
+	VCLK(gate_alv, gate_imem_intmem_alv, "gate_imem_intmem_alv", 0, 0, NULL),
+	VCLK(gate_ppmu, gate_imem_ppmu, "gate_imem_ppmu", 0, 0, NULL),
+};
+
+static struct init_vclk exynos8890_peris_vclks[] __initdata = {
+	/* PERIS */
+	VCLK(peris_sfr, gate_peris_sfr_apbif_hdmi_cec, "gate_peris_sfr_apbif_hdmi_cec", 0, 0, NULL),
+	VCLK(peris_hpm, gate_peris_hpm, "gate_peris_hpm", 0, 0, NULL),
+	VCLK(peris_mct, gate_peris_mct, "gate_peris_mct", 0, 0, NULL),
+	VCLK(wdt_mngs, gate_peris_wdt_mngs, "gate_peris_wdt_mngs", 0, 0, NULL),
+	VCLK(wdt_apollo, gate_peris_wdt_apollo, "gate_peris_wdt_apollo", 0, 0, NULL),
+	VCLK(rtc_apbif, gate_peris_rtc_apbif, "gate_peris_rtc_apbif", 0, 0, NULL),
+	VCLK(top_rtc, gate_peris_top_rtc, "gate_peris_top_rtc", 0, 0, NULL),
+	VCLK(otp_con_top, gate_peris_otp_con_top, "gate_peris_otp_con_top", 0, 0, NULL),
+	VCLK(peris_chipid, gate_peris_chipid, "gate_peris_chipid", 0, 0, NULL),
+	VCLK(peris_tmu, gate_peris_tmu, "gate_peris_tmu", 0, 0, NULL),
+	VCLK(peris_sysreg, gate_peris_sysreg_peris, "gate_peris_sysreg_peris", 0, 0, NULL),
+	VCLK(peris_monocnt, gate_peris_monocnt_apbif, "gate_peris_monocnt_apbif", 0, 0, NULL),
+};
+
+static struct init_vclk exynos8890_peric0_vclks[] __initdata = {
+	/* PERIC0 */
+	VCLK(gate_hsi2c0, gate_peric0_hsi2c0, "gate_peric0_hsi2c0", 0, 0, NULL),
+	VCLK(gate_hsi2c1, gate_peric0_hsi2c1, "gate_peric0_hsi2c1", 0, 0, NULL),
+	VCLK(gate_hsi2c4, gate_peric0_hsi2c4, "gate_peric0_hsi2c4", 0, 0, NULL),
+	VCLK(gate_hsi2c5, gate_peric0_hsi2c5, "gate_peric0_hsi2c5", 0, 0, NULL),
+	VCLK(gate_hsi2c9, gate_peric0_hsi2c9, "gate_peric0_hsi2c9", 0, 0, NULL),
+	VCLK(gate_hsi2c10, gate_peric0_hsi2c10, "gate_peric0_hsi2c10", 0, 0, NULL),
+	VCLK(gate_hsi2c11, gate_peric0_hsi2c11, "gate_peric0_hsi2c11", 0, 0, NULL),
+	VCLK(puart0, gate_peric0_uart0, "gate_peric0_uart0", 0, 0, "console-pclk0"),
+	VCLK(suart0, sclk_uart0, "sclk_uart0", 0, 0, "console-sclk0"),
+	VCLK(gate_adcif, gate_peric0_adcif, "gate_peric0_adcif", 0, 0, NULL),
+	VCLK(gate_pwm, gate_peric0_pwm, "gate_peric0_pwm", 0, 0, NULL),
+	VCLK(gate_sclk_pwm, gate_peric0_sclk_pwm, "gate_peric0_sclk_pwm", 0, 0, NULL),
+};
+
+static struct init_vclk exynos8890_peric1_vclks[] __initdata = {
+	/* PERIC1 HSI2C */
+	VCLK(gate_hsi2c2, gate_peric1_hsi2c2, "gate_hsi2c2", 0, 0, NULL),
+	VCLK(gate_hsi2c3, gate_peric1_hsi2c3, "gate_hsi2c3", 0, 0, NULL),
+	VCLK(gate_hsi2c6, gate_peric1_hsi2c6, "gate_hsi2c6", 0, 0, NULL),
+	VCLK(gate_hsi2c7, gate_peric1_hsi2c7, "gate_hsi2c7", 0, 0, NULL),
+	VCLK(gate_hsi2c8, gate_peric1_hsi2c8, "gate_hsi2c8", 0, 0, NULL),
+	VCLK(gate_hsi2c12, gate_peric1_hsi2c12, "gate_hsi2c12", 0, 0, NULL),
+	VCLK(gate_hsi2c13, gate_peric1_hsi2c13, "gate_hsi2c13", 0, 0, NULL),
+	VCLK(gate_hsi2c14, gate_peric1_hsi2c14, "gate_hsi2c14", 0, 0, NULL),
+	/* PERIC1 UART0~5 */
+	VCLK(gate_uart1, gate_peric1_uart1, "gate_uart1", 0, 0, "console-pclk1"),
+	VCLK(gate_uart2, gate_peric1_uart2, "gate_uart2", 0, 0, "console-pclk2"),
+	VCLK(gate_uart3, gate_peric1_uart3, "gate_uart3", 0, 0, "console-pclk3"),
+	VCLK(gate_uart4, gate_peric1_uart4, "gate_uart4", 0, 0, "console-pclk4"),
+	VCLK(gate_uart5, gate_peric1_uart5, "gate_uart5", 0, 0, "console-pclk5"),
+	VCLK(suart1, sclk_uart1, "sclk_uart1", 0, 0, "console-sclk1"),
+	VCLK(suart2, sclk_uart2, "sclk_uart2", 0, 0, "console-sclk2"),
+	VCLK(suart3, sclk_uart3, "sclk_uart3", 0, 0, "console-sclk3"),
+	VCLK(suart4, sclk_uart4, "sclk_uart4", 0, 0, "console-sclk4"),
+	VCLK(suart5, sclk_uart5, "sclk_uart5", 0, 0, "console-sclk5"),
+	/* PERIC1 SPI0~7 */
+	VCLK(gate_spi0, gate_peric1_spi0, "gate_spi0", 0, 0, NULL),
+	VCLK(gate_spi1, gate_peric1_spi1, "gate_spi1", 0, 0, NULL),
+	VCLK(gate_spi2, gate_peric1_spi2, "gate_spi2", 0, 0, NULL),
+	VCLK(gate_spi3, gate_peric1_spi3, "gate_spi3", 0, 0, NULL),
+	VCLK(gate_spi4, gate_peric1_spi4, "gate_spi4", 0, 0, NULL),
+	VCLK(gate_spi5, gate_peric1_spi5, "gate_spi5", 0, 0, NULL),
+	VCLK(gate_spi6, gate_peric1_spi6, "gate_spi6", 0, 0, NULL),
+	VCLK(gate_spi7, gate_peric1_spi7, "gate_spi7", 0, 0, NULL),
+	VCLK(sclk_peric1_spi0, sclk_spi0, "sclk_spi0", 0, 0, NULL),
+	VCLK(sclk_peric1_spi1, sclk_spi1, "sclk_spi1", 0, 0, NULL),
+	VCLK(sclk_peric1_spi2, sclk_spi2, "sclk_spi2", 0, 0, NULL),
+	VCLK(sclk_peric1_spi3, sclk_spi3, "sclk_spi3", 0, 0, NULL),
+	VCLK(sclk_peric1_spi4, sclk_spi4, "sclk_spi4", 0, 0, NULL),
+	VCLK(sclk_peric1_spi5, sclk_spi5, "sclk_spi5", 0, 0, NULL),
+	VCLK(sclk_peric1_spi6, sclk_spi6, "sclk_spi6", 0, 0, NULL),
+	VCLK(sclk_peric1_spi7, sclk_spi7, "sclk_spi7", 0, 0, NULL),
+	/* PERIC1 GPIO */
+	VCLK(gate_gpio_nfc, gate_peric1_gpio_nfc, "gate_gpio_nfc", 0, 0, NULL),
+	VCLK(gate_gpio_touch, gate_peric1_gpio_touch, "gate_gpio_touch", 0, 0, NULL),
+	VCLK(gate_gpio_fp, gate_peric1_gpio_fp, "gate_gpio_fp", 0, 0, NULL),
+	VCLK(gate_gpio_ese, gate_peric1_gpio_ese, "gate_gpio_ese", 0, 0, NULL),
+	/* PERIC1 promise */
+	VCLK(promise_int, sclk_promise_int, "sclk_promise_int", 0, 0, NULL),
+	VCLK(promise_disp, sclk_promise_disp, "sclk_promise_disp", 0, 0, NULL),
+	VCLK(ap2cp_mif_pll_out, sclk_ap2cp_mif_pll_out, "sclk_ap2cp_mif_pll_out", 0, 0, NULL),
+	VCLK(gate_i2s1, gate_peric1_i2s1, "gate_peric1_i2s1", 0, 0, NULL),
+	VCLK(gate_pcm1, gate_peric1_pcm1, "gate_peric1_pcm1", 0, 0, NULL),
+	VCLK(gate_spdif, gate_peric1_spdif, "gate_peric1_spdif", 0, 0, NULL),
+};
+
+static struct init_vclk exynos8890_isp0_vclks[] __initdata = {
+	/* ISP0 */
+	VCLK(gate_fimc_isp0, gate_isp0_fimc_isp0, "gate_fimc_isp0", 0, 0, NULL),
+	VCLK(gate_fimc_tpu, gate_isp0_fimc_tpu, "gate_isp0_fimc_tpu", 0, 0, NULL),
+	VCLK(isp0, pxmxdx_isp0_isp0, "clk_isp0", 0, 0, NULL),
+	VCLK(isp0_tpu, pxmxdx_isp0_tpu, "clk_isp0_tpu", 0, 0, NULL),
+	VCLK(isp0_trex, pxmxdx_isp0_trex, "clk_isp0_trex", 0, 0, NULL),
+	VCLK(CLK_VCLK_SYSMMU_ISP0, gate_isp0_sysmmu, "gate_isp0_sysmmu", 0, 0, NULL),
+	VCLK(isp0_ppmu, gate_isp0_ppmu, "gate_isp0_ppmu", 0, 0, NULL),
+	VCLK(isp0_bts, gate_isp0_bts, "gate_isp0_bts", 0, 0, NULL),
+};
+
+static struct init_vclk exynos8890_isp1_vclks[] __initdata = {
+	/* ISP1 */
+	VCLK(gate_fimc_isp1, gate_isp1_fimc_isp1, "gate_isp1_fimc_isp1", 0, 0, NULL),
+	VCLK(isp1, pxmxdx_isp1_isp1, "clk_isp1", 0, 0, NULL),
+	VCLK(isp1_ppmu, gate_isp1_ppmu, "gate_isp1_ppmu", 0, 0, NULL),
+	VCLK(isp1_bts, gate_isp1_bts, "gate_isp1_bts", 0, 0, NULL),
+};
+
+static struct init_vclk exynos8890_isp_sensor_vclks[] __initdata = {
+	/* ISP1 */
+	VCLK(isp_sensor0, sclk_isp_sensor0, "sclk_isp_sensor0", 0, 0, NULL),
+	VCLK(isp_sensor1, sclk_isp_sensor1, "sclk_isp_sensor1", 0, 0, NULL),
+	VCLK(isp_sensor2, sclk_isp_sensor2, "sclk_isp_sensor2", 0, 0, NULL),
+	VCLK(isp_sensor3, sclk_isp_sensor3, "sclk_isp_sensor3", 0, 0, NULL),
+};
+
+static struct init_vclk exynos8890_cam0_vclks[] __initdata = {
+	/* CAM0 */
+	VCLK(gate_csis0, gate_cam0_csis0, "gate_cam0_csis0", 0, 0, NULL),
+	VCLK(gate_csis1, gate_cam0_csis1, "gate_cam0_csis1", 0, 0, NULL),
+	VCLK(gate_fimc_bns, gate_cam0_fimc_bns, "gate_cam0_fimc_bns", 0, 0, NULL),
+	VCLK(fimc_3aa0, gate_cam0_fimc_3aa0, "gate_cam0_fimc_3aa0", 0, 0, NULL),
+	VCLK(fimc_3aa1, gate_cam0_fimc_3aa1, "gate_cam0_fimc_3aa1", 0, 0, NULL),
+	VCLK(cam0_hpm, gate_cam0_hpm, "gate_cam0_hpm", 0, 0, NULL),
+	VCLK(pxmxdx_csis0, pxmxdx_cam0_csis0, "gate_pxmxdx_cam0_csis0", 0, 0, NULL),
+	VCLK(pxmxdx_csis1, pxmxdx_cam0_csis1, "gate_pxmxdx_cam0_csis1", 0, 0, NULL),
+	VCLK(pxmxdx_csis2, pxmxdx_cam0_csis2, "gate_pxmxdx_cam0_csis2", 0, 0, NULL),
+	VCLK(pxmxdx_csis3, pxmxdx_cam0_csis3, "gate_pxmxdx_cam0_csis3", 0, 0, NULL),
+	VCLK(pxmxdx_3aa0, pxmxdx_cam0_3aa0, "gate_pxmxdx_cam0_3aa0", 0, 0, NULL),
+	VCLK(pxmxdx_3aa1, pxmxdx_cam0_3aa1, "gate_pxmxdx_cam0_3aa1", 0, 0, NULL),
+	VCLK(pxmxdx_trex, pxmxdx_cam0_trex, "gate_pxmxdx_cam0_trex", 0, 0, NULL),
+	VCLK(hs0_csis0_rx_byte, umux_cam0_phyclk_rxbyteclkhs0_csis0_user, "umux_cam0_phyclk_rxbyteclkhs0_csis0_user", 0, 0, NULL),
+	VCLK(hs1_csis0_rx_byte, umux_cam0_phyclk_rxbyteclkhs1_csis0_user, "umux_cam0_phyclk_rxbyteclkhs1_csis0_user", 0, 0, NULL),
+	VCLK(hs2_csis0_rx_byte, umux_cam0_phyclk_rxbyteclkhs2_csis0_user, "umux_cam0_phyclk_rxbyteclkhs2_csis0_user", 0, 0, NULL),
+	VCLK(hs3_csis0_rx_byte, umux_cam0_phyclk_rxbyteclkhs3_csis0_user, "umux_cam0_phyclk_rxbyteclkhs3_csis0_user", 0, 0, NULL),
+	VCLK(hs0_csis1_rx_byte, umux_cam0_phyclk_rxbyteclkhs0_csis1_user, "umux_cam0_phyclk_rxbyteclkhs0_csis1_user", 0, 0, NULL),
+	VCLK(hs1_csis1_rx_byte, umux_cam0_phyclk_rxbyteclkhs1_csis1_user, "umux_cam0_phyclk_rxbyteclkhs1_csis1_user", 0, 0, NULL),
+	VCLK(CLK_VCLK_SYSMMU_CAM0, gate_cam0_sysmmu, "gate_cam0_sysmmu", 0, 0, NULL),
+	VCLK(cam0_ppmu, gate_cam0_ppmu, "gate_cam0_ppmu", 0, 0, NULL),
+	VCLK(cam0_bts, gate_cam0_bts, "gate_cam0_bts", 0, 0, NULL),
+};
+
+static struct init_vclk exynos8890_cam1_vclks[] __initdata = {
+	/* CAM1 */
+	VCLK(gate_isp_cpu, gate_cam1_isp_cpu, "gate_cam1_isp_cpu", 0, 0, NULL),
+	VCLK(gate_csis2, gate_cam1_csis2, "gate_cam1_csis2", 0, 0, NULL),
+	VCLK(gate_csis3, gate_cam1_csis3, "gate_cam1_csis3", 0, 0, NULL),
+	VCLK(gate_fimc_vra, gate_cam1_fimc_vra, "gate_cam1_fimc_vra", 0, 0, NULL),
+	VCLK(gate_mc_scaler, gate_cam1_mc_scaler, "gate_cam1_mc_scaler", 0, 0, NULL),
+	VCLK(gate_i2c0_isp, gate_cam1_i2c0_isp, "gate_cam1_i2c0_isp", 0, 0, NULL),
+	VCLK(gate_i2c1_isp, gate_cam1_i2c1_isp, "gate_cam1_i2c1_isp", 0, 0, NULL),
+	VCLK(gate_i2c2_isp, gate_cam1_i2c2_isp, "gate_cam1_i2c2_isp", 0, 0, NULL),
+	VCLK(gate_i2c3_isp, gate_cam1_i2c3_isp, "gate_cam1_i2c3_isp", 0, 0, NULL),
+	VCLK(gate_wdt_isp, gate_cam1_wdt_isp, "gate_cam1_wdt_isp", 0, 0, NULL),
+	VCLK(gate_mcuctl_isp, gate_cam1_mcuctl_isp, "gate_cam1_mcuctl_isp", 0, 0, NULL),
+	VCLK(gate_uart_isp, gate_cam1_uart_isp, "gate_cam1_uart_isp", 0, 0, NULL),
+	VCLK(gate_pdma_isp, gate_cam1_pdma_isp, "gate_cam1_pdma_isp", 0, 0, NULL),
+	VCLK(gate_pwm_isp, gate_cam1_pwm_isp, "gate_cam1_pwm_isp", 0, 0, NULL),
+	VCLK(gate_spi0_isp, gate_cam1_spi0_isp, "gate_cam1_spi0_isp", 0, 0, NULL),
+	VCLK(gate_spi1_isp, gate_cam1_spi1_isp, "gate_cam1_spi1_isp", 0, 0, NULL),
+	/* rate clock source */
+	VCLK(isp_spi0, sclk_isp_spi0, "sclk_isp_spi0", 0, 0, NULL),
+	VCLK(isp_spi1, sclk_isp_spi1, "sclk_isp_spi1", 0, 0, NULL),
+	VCLK(isp_uart, sclk_isp_uart, "sclk_isp_uart", 0, 0, NULL),
+	VCLK(gate_sclk_pwm_isp, gate_cam1_sclk_pwm_isp, "gate_cam1_sclk_pwm_isp", 0, 0, NULL),
+	VCLK(gate_sclk_uart_isp, gate_cam1_sclk_uart_isp, "gate_cam1_sclk_uart_isp", 0, 0, NULL),
+	/* rate clock source */
+	VCLK(cam1_arm, pxmxdx_cam1_arm, "pxmxdx_cam1_arm", 0, 0, NULL),
+	VCLK(cam1_vra, pxmxdx_cam1_vra, "pxmxdx_cam1_vra", 0, 0, NULL),
+	VCLK(cam1_trex, pxmxdx_cam1_trex, "pxmxdx_cam1_trex", 0, 0, NULL),
+	VCLK(cam1_bus, pxmxdx_cam1_bus, "pxmxdx_cam1_bus", 0, 0, NULL),
+	VCLK(cam1_peri, pxmxdx_cam1_peri, "pxmxdx_cam1_peri", 0, 0, NULL),
+	VCLK(cam1_csis2, pxmxdx_cam1_csis2, "pxmxdx_cam1_csis2", 0, 0, NULL),
+	VCLK(cam1_csis3, pxmxdx_cam1_csis3, "pxmxdx_cam1_csis3", 0, 0, NULL),
+	VCLK(cam1_scl, pxmxdx_cam1_scl, "pxmxdx_cam1_scl", 0, 0, NULL),
+	/* usermux */
+	VCLK(cam1_phy0_csis2, umux_cam1_phyclk_rxbyteclkhs0_csis2_user, "phyclk_rxbyteclkhs0_csis2_user", 0, 0, NULL),
+	VCLK(cam1_phy1_csis2, umux_cam1_phyclk_rxbyteclkhs1_csis2_user, "phyclk_rxbyteclkhs1_csis2_user", 0, 0, NULL),
+	VCLK(cam1_phy2_csis2, umux_cam1_phyclk_rxbyteclkhs2_csis2_user, "phyclk_rxbyteclkhs2_csis2_user", 0, 0, NULL),
+	VCLK(cam1_phy3_csis2, umux_cam1_phyclk_rxbyteclkhs3_csis2_user, "phyclk_rxbyteclkhs3_csis2_user", 0, 0, NULL),
+	VCLK(cam1_phy0_csis3, umux_cam1_phyclk_rxbyteclkhs0_csis3_user, "phyclk_rxbyteclkhs0_csis3_user", 0, 0, NULL),
+	VCLK(CLK_VCLK_SYSMMU_CAM1, gate_cam1_sysmmu, "gate_cam1_sysmmu", 0, 0, NULL),
+	VCLK(cam1_ppmu, gate_cam1_ppmu, "gate_cam1_ppmu", 0, 0, NULL),
+	VCLK(cam1_bts, gate_cam1_bts, "gate_cam1_bts", 0, 0, NULL),
+};
+
+static struct init_vclk exynos8890_audio_vclks[] __initdata = {
+	/* AUDIO */
+	VCLK(gate_mi2s, gate_aud_mi2s, "gate_aud_mi2s", 0, 0, NULL),
+	VCLK(gate_pcm, gate_aud_pcm, "gate_aud_pcm", 0, 0, NULL),
+	VCLK(gate_slimbus, gate_aud_slimbus, "gate_aud_slimbus", 0, 0, NULL),
+	VCLK(gate_sclk_mi2s, gate_aud_sclk_mi2s, "gate_aud_sclk_mi2s", 0, 0, NULL),
+	VCLK(d1_sclk_i2s, d1_sclk_i2s_local, "dout_sclk_i2s_local", 0, 0, NULL),
+	VCLK(gate_sclk_pcm, gate_aud_sclk_pcm, "gate_aud_sclk_pcm", 0, 0, NULL),
+	VCLK(d1_sclk_pcm, d1_sclk_pcm_local, "dout_sclk_pcm_local", 0, 0, NULL),
+	VCLK(gate_sclk_slimbus, gate_aud_sclk_slimbus, "gate_aud_sclk_slimbus", 0, 0, NULL),
+	VCLK(sclk_slimbus, d1_sclk_slimbus, "dout_sclk_slimbus", 0, 0, NULL),
+	VCLK(sclk_cp_i2s, d1_sclk_cp_i2s, "dout_sclk_cp_i2s", 0, 0, NULL),
+	VCLK(sclk_asrc, d1_sclk_asrc, "dout_sclk_asrc", 0, 0, NULL),
+	VCLK(aud_pll, p1_aud_pll, "sclk_aud_pll", 0, 0, NULL),
+	VCLK(aud_cp, pxmxdx_aud_cp, "gate_aud_cp", 0, 0, NULL),
+	VCLK(aud_lpass, gate_aud_lpass, "gate_aud_lpass", 0, 0, NULL),
+	VCLK(aud_dma, gate_aud_dma, "gate_aud_dma", 0, 0, NULL),
+	VCLK(CLK_VCLK_SYSMMU_AUD, gate_aud_sysmmu, "gate_aud_sysmmu", 0, 0, NULL),
+	VCLK(aud_ppmu, gate_aud_ppmu, "gate_aud_ppmu", 0, 0, NULL),
+	VCLK(aud_bts, gate_aud_bts, "gate_aud_bts", 0, 0, NULL),
+};
+
+static struct init_vclk exynos8890_fsys0_vclks[] __initdata = {
+	/* FSYS0 */
+	VCLK(gate_usbdrd30, gate_fsys0_usbdrd30, "gate_fsys0_usbdrd30", 0, 0, NULL),
+	VCLK(gate_usbhost20, gate_fsys0_usbhost20, "gate_fsys0_usbhost20", 0, 0, NULL),
+	VCLK(usbdrd30, sclk_usbdrd30, "sclk_usbdrd30", 0, 0, NULL),
+	VCLK(sclk_fsys0_mmc0, sclk_mmc0, "sclk_mmc0", 0, 0, NULL),
+	VCLK(ufsunipro20, sclk_ufsunipro20, "sclk_ufsunipro20", 0, 0, NULL),
+	VCLK(phy24m, sclk_phy24m, "sclk_phy24m", 0, 0, NULL),
+	VCLK(ufsunipro_cfg, sclk_ufsunipro_cfg, "sclk_ufsunipro_cfg", 0, 0, NULL),
+	/* UMUX GATE related clock sources */
+	VCLK(gate_udrd30_phyclock, umux_fsys0_phyclk_usbdrd30_udrd30_phyclock_user, "umux_fsys0_phyclk_usbdrd30_udrd30_phyclock_user", 0, 0, NULL),
+	VCLK(gate_udrd30_pipe, umux_fsys0_phyclk_usbdrd30_udrd30_pipe_pclk_user, "umux_fsys0_phyclk_usbdrd30_udrd30_pipe_pclk_user", 0, 0, NULL),
+	VCLK(gate_ufs_tx0, umux_fsys0_phyclk_ufs_tx0_symbol_user, "umux_fsys0_phyclk_ufs_tx0_symbol_user", 0, 0, NULL),
+	VCLK(gate_ufs_rx0, umux_fsys0_phyclk_ufs_rx0_symbol_user, "umux_fsys0_phyclk_ufs_rx0_symbol_user", 0, 0, NULL),
+	VCLK(usbhost20_phyclock, umux_fsys0_phyclk_usbhost20_phyclock_user, "umux_fsys0_phyclk_usbhost20_phyclock_user", 0, 0, NULL),
+	VCLK(usbhost20phy_ref, umux_fsys0_phyclk_usbhost20phy_ref_clk, "umux_fsys0_phyclk_usbhost20phy_ref_clk", 0, 0, NULL),
+	VCLK(fsys_200, pxmxdx_fsys0, "aclk_ufs", 0, 0, NULL),
+	VCLK(fsys0_etr_usb, gate_fsys0_etr_usb, "gate_fsys0_etr_usb", 0, 0, "etr_clk"),
+	VCLK(gate_mmc, gate_fsys0_mmc0, "gate_fsys0_mmc0", 0, 0, NULL),
+	VCLK(gate_pdma0, gate_fsys0_pdma0, "gate_fsys0_pdma0", 0, 0, NULL),
+	VCLK(gate_pdmas, gate_fsys0_pdmas, "gate_fsys0_pdmas", 0, 0, NULL),
+	VCLK(gate_ufs_linkemedded, gate_fsys0_ufs_linkemedded, "gate_fsys0_ufs_linkemedded", 0, 0, NULL),
+};
+
+static struct init_vclk exynos8890_fsys1_vclks[] __initdata = {
+	/* FSYS1 */
+	VCLK(fsys1_hpm, gate_fsys1_hpm, "gate_fsys1_hpm", 0, 0, NULL),
+	VCLK(fsys1_sclk_mmc2, sclk_mmc2, "sclk_mmc2", 0, 0, NULL),
+	VCLK(ufsunipro20_sdcard, sclk_ufsunipro20_sdcard, "sclk_ufsunipro20_sdcard", 0, 0, NULL),
+	VCLK(pcie_phy, sclk_pcie_phy, "sclk_pcie_phy", 0, 0, NULL),
+	VCLK(sclk_ufsunipro_sdcard, sclk_ufsunipro_sdcard_cfg, "sclk_ufsunipro_sdcard_cfg", 0, 0, NULL),
+	/* UMUX GATE related clock sources */
+	VCLK(ufs_link_sdcard_tx0, umux_fsys1_phyclk_ufs_link_sdcard_tx0_symbol_user, "umux_fsys1_phyclk_ufs_link_sdcard_tx0_symbol_user", 0, 0, NULL),
+	VCLK(ufs_link_sdcard_rx0, umux_fsys1_phyclk_ufs_link_sdcard_rx0_symbol_user, "umux_fsys1_phyclk_ufs_link_sdcard_rx0_symbol_user", 0, 0, NULL),
+	VCLK(pcie_wifi0_tx0, umux_fsys1_phyclk_pcie_wifi0_tx0_user, "umux_fsys1_phyclk_pcie_wifi0_tx0_user", 0, 0, NULL),
+	VCLK(pcie_wifi0_rx0, umux_fsys1_phyclk_pcie_wifi0_rx0_user, "umux_fsys1_phyclk_pcie_wifi0_rx0_user", 0, 0, NULL),
+	VCLK(pcie_wifi1_tx0, umux_fsys1_phyclk_pcie_wifi1_tx0_user, "umux_fsys1_phyclk_pcie_wifi1_tx0_user", 0, 0, NULL),
+	VCLK(pcie_wifi1_rx0, umux_fsys1_phyclk_pcie_wifi1_rx0_user, "umux_fsys1_phyclk_pcie_wifi1_rx0_user", 0, 0, NULL),
+	VCLK(wifi0_dig_refclk, umux_fsys1_phyclk_pcie_wifi0_dig_refclk_user, "umux_fsys1_phyclk_pcie_wifi0_dig_refclk_user", 0, 0, NULL),
+	VCLK(wifi1_dig_refclk, umux_fsys1_phyclk_pcie_wifi1_dig_refclk_user, "umux_fsys1_phyclk_pcie_wifi1_dig_refclk_user", 0, 0, NULL),
+	VCLK(gate_mmc2, gate_fsys1_mmc2, "gate_fsys1_mmc2", 0, 0, NULL),
+	VCLK(gate_ufs20_sdcard, gate_fsys1_ufs20_sdcard, "gate_fsys1_ufs20_sdcard", 0, 0, NULL),
+	VCLK(gate_sromc, gate_fsys1_sromc, "gate_fsys1_sromc", 0, 0, NULL),
+	VCLK(gate_pciewifi0, gate_fsys1_pciewifi0, "gate_fsys1_pciewifi0", 0, 0, NULL),
+	VCLK(gate_pciewifi1, gate_fsys1_pciewifi1, "gate_fsys1_pciewifi1", 0, 0, NULL),
+	VCLK(fsys1_ppmu, gate_fsys1_ppmu, "gate_fsys1_ppmu", 0, 0, NULL),
+	VCLK(fsys1_bts, gate_fsys1_bts, "gate_fsys1_bts", 0, 0, NULL),
+};
+
+static struct init_vclk exynos8890_g3d_vclks[] __initdata = {
+	/* G3D */
+	VCLK(gate_g3d, gate_g3d_g3d, "gate_g3d_g3d", 0, 0, "vclk_g3d"),
+	VCLK(gate_g3d_iram, gate_g3d_iram_path_test, "g3d_iram_path", 0, 0, NULL),
+	VCLK(g3d_bts, gate_g3d_bts, "gate_g3d_bts", 0, 0, NULL),
+	VCLK(g3d_ppmu, gate_g3d_ppmu, "gate_g3d_ppmu", 0, 0, NULL),
+};
+
+static struct init_vclk exynos8890_disp0_vclks[] __initdata = {
+	/* DISP0 */
+	VCLK(gate_decon0, gate_disp0_decon0, "gate_disp0_decon0", 0, 0, NULL),
+	VCLK(gate_dsim0, gate_disp0_dsim0, "gate_disp0_dsim0", 0, 0, NULL),
+	VCLK(gate_dsim1, gate_disp0_dsim1, "gate_disp0_dsim1", 0, 0, NULL),
+	VCLK(gate_dsim2, gate_disp0_dsim2, "gate_disp0_dsim2", 0, 0, NULL),
+	VCLK(gate_hdmi, gate_disp0_hdmi, "gate_disp0_hdmi", 0, 0, NULL),
+	VCLK(gate_dp, gate_disp0_dp, "gate_disp0_dp", 0, 0, NULL),
+	VCLK(gate_hpm_apbif_disp0, gate_disp0_hpm_apbif_disp0, "gate_disp0_hpm_apbif_disp0", 0, 0, NULL),
+	/* special clock - sclk */
+	VCLK(decon0_eclk0, sclk_decon0_eclk0, "sclk_decon0_eclk0", 0, 0, NULL),
+	VCLK(decon0_vclk0, sclk_decon0_vclk0, "sclk_decon0_vclk0", 0, 0, NULL),
+	VCLK(decon0_vclk1, sclk_decon0_vclk1, "sclk_decon0_vclk1", 0, 0, NULL),
+	VCLK(decon0_eclk0_local, sclk_decon0_eclk0_local, "sclk_decon0_eclk0_local", 0, 0, NULL),
+	VCLK(decon0_vclk0_local, sclk_decon0_vclk0_local, "sclk_decon0_vclk0_local", 0, 0, NULL),
+	VCLK(decon0_vclk1_local, sclk_decon0_vclk1_local, "sclk_decon0_vclk1_local", 0, 0, NULL),
+	VCLK(hdmi_audio, sclk_hdmi_audio, "sclk_hdmi_audio", 0, 0, NULL),
+	/* PLL clock source */
+	VCLK(disp_pll, p1_disp_pll, "p1_disp_pll", 0, 0, "disp_pll"),
+	/* USERMUX related clock source */
+	VCLK(mipidphy0_rxclkesc0, umux_disp0_phyclk_mipidphy0_rxclkesc0_user, "umux_disp0_phyclk_mipidphy0_rxclkesc0_user", 0, 0, NULL),
+	VCLK(mipidphy0_bitclkdiv8, umux_disp0_phyclk_mipidphy0_bitclkdiv8_user, "umux_disp0_phyclk_mipidphy0_bitclkdiv8_user", 0, 0, NULL),
+	VCLK(mipidphy1_rxclkesc0, umux_disp0_phyclk_mipidphy1_rxclkesc0_user, "umux_disp0_phyclk_mipidphy1_rxclkesc0_user", 0, 0, NULL),
+	VCLK(mipidphy1_bitclkdiv8, umux_disp0_phyclk_mipidphy1_bitclkdiv8_user, "umux_disp0_phyclk_mipidphy1_bitclkdiv8_user", 0, 0, NULL),
+	VCLK(mipidphy2_rxclkesc0, umux_disp0_phyclk_mipidphy2_rxclkesc0_user, "umux_disp0_phyclk_mipidphy2_rxclkesc0_user", 0, 0, NULL),
+	VCLK(mipidphy2_bitclkdiv8, umux_disp0_phyclk_mipidphy2_bitclkdiv8_user, "umux_disp0_phyclk_mipidphy2_bitclkdiv8_user", 0, 0, NULL),
+	VCLK(dpphy_ch0_txd, umux_disp0_phyclk_dpphy_ch0_txd_clk_user, "umux_disp0_phyclk_dpphy_ch0_txd_clk_user", 0, 0, NULL),
+	VCLK(dpphy_ch1_txd, umux_disp0_phyclk_dpphy_ch1_txd_clk_user, "umux_disp0_phyclk_dpphy_ch1_txd_clk_user", 0, 0, NULL),
+	VCLK(dpphy_ch2_txd, umux_disp0_phyclk_dpphy_ch2_txd_clk_user, "umux_disp0_phyclk_dpphy_ch2_txd_clk_user", 0, 0, NULL),
+	VCLK(dpphy_ch3_txd, umux_disp0_phyclk_dpphy_ch3_txd_clk_user, "umux_disp0_phyclk_dpphy_ch3_txd_clk_user", 0, 0, NULL),
+	VCLK(dptx_phy_i_ref_clk_24m, gate_disp0_oscclk_i_dptx_phy_i_ref_clk_24m, "gate_disp0_oscclk_i_dptx_phy_i_ref_clk_24m", 0, 0, NULL),
+	VCLK(mipi_dphy_m1s0, gate_disp0_oscclk_i_mipi_dphy_m1s0_m_xi, "gate_disp0_oscclk_i_mipi_dphy_m1s0_m_xi", 0, 0, NULL),
+	VCLK(mipi_dphy_m4s0, gate_disp0_oscclk_i_mipi_dphy_m4s0_m_xi, "gate_disp0_oscclk_i_mipi_dphy_m4s0_m_xi", 0, 0, NULL),
+	VCLK(mipi_dphy_m4s4, gate_disp0_oscclk_i_mipi_dphy_m4s4_m_xi, "gate_disp0_oscclk_i_mipi_dphy_m4s4_m_xi", 0, 0, NULL),
+	VCLK(phyclk_hdmiphy_tmds_20b, umux_disp0_phyclk_hdmiphy_tmds_clko_user, "umux_disp0_phyclk_hdmiphy_tmds_clko_user", 0, 0, NULL),
+	VCLK(phyclk_hdmiphy_pixel, umux_disp0_phyclk_hdmiphy_pixel_clko_user, "umux_disp0_phyclk_hdmiphy_pixel_clko_user", 0, 0, NULL),
+	VCLK(mipidphy0_bitclkdiv2_user, umux_disp0_phyclk_mipidphy0_bitclkdiv2_user, "umux_disp0_phyclk_mipidphy0_bitclkdiv2_user", 0, 0, NULL),
+	VCLK(mipidphy1_bitclkdiv2_user, umux_disp0_phyclk_mipidphy1_bitclkdiv2_user, "umux_disp0_phyclk_mipidphy1_bitclkdiv2_user", 0, 0, NULL),
+	VCLK(mipidphy2_bitclkdiv2_user, umux_disp0_phyclk_mipidphy2_bitclkdiv2_user, "umux_disp0_phyclk_mipidphy2_bitclkdiv2_user", 0, 0, NULL),
+	VCLK(CLK_VCLK_SYSMMU_DISP0, gate_disp0_sysmmu, "gate_disp0_sysmmu", 0, 0, NULL),
+};
+
+static struct init_vclk exynos8890_disp1_vclks[] __initdata = {
+	/* DISP1 */
+	VCLK(gate_decon1, gate_disp1_decon1, "gate_disp1_decon1", 0, 0, NULL),
+	VCLK(gate_hpmdisp1, gate_disp1_hpmdisp1, "gate_disp1_hpmdisp1", 0, 0, NULL),
+	/* special clock - sclk */
+	VCLK(decon1_eclk0, sclk_decon1_eclk0, "sclk_decon1_eclk0", 0, 0, NULL),
+	VCLK(decon1_eclk1, sclk_decon1_eclk1, "sclk_decon1_eclk1", 0, 0, NULL),
+	VCLK(decon1_eclk0_local, sclk_decon1_eclk0_local, "sclk_decon1_eclk0_local", 0, 0, NULL),
+	VCLK(decon1_eclk1_local, sclk_decon1_eclk1_local, "sclk_decon1_eclk1_local", 0, 0, NULL),
+	/* USERMUX related clock source */
+	VCLK(disp1_phyclk_mipidphy0_bitclkdiv2_user, umux_disp1_phyclk_mipidphy0_bitclkdiv2_user, "umux_disp1_phyclk_mipidphy0_bitclkdiv2_user", 0, 0, NULL),
+	VCLK(disp1_phyclk_mipidphy1_bitclkdiv2_user, umux_disp1_phyclk_mipidphy1_bitclkdiv2_user, "umux_disp1_phyclk_mipidphy1_bitclkdiv2_user", 0, 0, NULL),
+	VCLK(disp1_phyclk_mipidphy2_bitclkdiv2_user, umux_disp1_phyclk_mipidphy2_bitclkdiv2_user, "umux_disp1_phyclk_mipidphy2_bitclkdiv2_user", 0, 0, NULL),
+	VCLK(disp1_phyclk_disp1_hdmiphy_pixel_clko_user, umux_disp1_phyclk_disp1_hdmiphy_pixel_clko_user, "umux_disp1_phyclk_disp1_hdmiphy_pixel_clko_user", 0, 0, NULL),
+	VCLK(CLK_VCLK_SYSMMU_DISP1, gate_disp1_sysmmu, "gate_disp1_sysmmu", 0, 0, NULL),
+	VCLK(disp1_ppmu, gate_disp1_ppmu, "gate_disp1_ppmu", 0, 0, NULL),
+	VCLK(disp1_bts, gate_disp1_bts, "gate_disp1_bts", 0, 0, NULL),
+};
+
+void __init exynos8890_clk_init(struct device_node *np)
+{
+	struct samsung_clk_provider *ctx;
+	void __iomem *reg_base;
+	int ret;
+
+	BUILD_BUG_ON(mscl_jpeg != CLK_GATE_SMFC);
+
+	if (np) {
+		reg_base = of_iomap(np, 0);
+		if (!reg_base)
+			panic("%s: failed to map registers\n", __func__);
+	} else {
+		panic("%s: unable to determine soc\n", __func__);
+	}
+
+#if defined(CONFIG_ECT)
+	ect_parse_binary_header();
+#endif
+
+	ret = cal_init();
+	if (ret)
+		pr_err("%s: unable to initialize power cal\n", __func__);
+
+	ctx = samsung_clk_init(np, reg_base, nr_clks);
+	if (!ctx)
+		panic("%s: unable to allocate context.\n", __func__);
+
+	samsung_register_of_fixed_ext(ctx, exynos8890_fixed_rate_ext_clks,
+			ARRAY_SIZE(exynos8890_fixed_rate_ext_clks),
+			ext_clk_match);
+
+	/* Regist clock local IP */
+	samsung_register_vclk(ctx, exynos8890_audio_vclks, ARRAY_SIZE(exynos8890_audio_vclks));
+	samsung_register_vclk(ctx, exynos8890_cam0_vclks, ARRAY_SIZE(exynos8890_cam0_vclks));
+	samsung_register_vclk(ctx, exynos8890_cam1_vclks, ARRAY_SIZE(exynos8890_cam1_vclks));
+	samsung_register_vclk(ctx, exynos8890_disp0_vclks, ARRAY_SIZE(exynos8890_disp0_vclks));
+	samsung_register_vclk(ctx, exynos8890_disp1_vclks, ARRAY_SIZE(exynos8890_disp1_vclks));
+	samsung_register_vclk(ctx, exynos8890_fsys0_vclks, ARRAY_SIZE(exynos8890_fsys0_vclks));
+	samsung_register_vclk(ctx, exynos8890_fsys1_vclks, ARRAY_SIZE(exynos8890_fsys1_vclks));
+	samsung_register_vclk(ctx, exynos8890_g3d_vclks, ARRAY_SIZE(exynos8890_g3d_vclks));
+	samsung_register_vclk(ctx, exynos8890_imem_vclks, ARRAY_SIZE(exynos8890_imem_vclks));
+	samsung_register_vclk(ctx, exynos8890_isp0_vclks, ARRAY_SIZE(exynos8890_isp0_vclks));
+	samsung_register_vclk(ctx, exynos8890_isp1_vclks, ARRAY_SIZE(exynos8890_isp1_vclks));
+	samsung_register_vclk(ctx, exynos8890_isp_sensor_vclks, ARRAY_SIZE(exynos8890_isp1_vclks));
+	samsung_register_vclk(ctx, exynos8890_mfc_vclks, ARRAY_SIZE(exynos8890_mfc_vclks));
+	samsung_register_vclk(ctx, exynos8890_mscl_vclks, ARRAY_SIZE(exynos8890_mscl_vclks));
+	samsung_register_vclk(ctx, exynos8890_peric0_vclks, ARRAY_SIZE(exynos8890_peric0_vclks));
+	samsung_register_vclk(ctx, exynos8890_peric1_vclks, ARRAY_SIZE(exynos8890_peric1_vclks));
+	samsung_register_vclk(ctx, exynos8890_peris_vclks, ARRAY_SIZE(exynos8890_peris_vclks));
+	samsung_register_vclk(ctx, exynos8890_ccore_vclks, ARRAY_SIZE(exynos8890_ccore_vclks));
+	samsung_register_vclk(ctx, exynos8890_clkout_vclks, ARRAY_SIZE(exynos8890_clkout_vclks));
+
+	samsung_clk_of_add_provider(np, ctx);
+
+	clk_register_fixed_factor(NULL, "pwm-clock", "gate_peric0_pwm",CLK_SET_RATE_PARENT, 1, 1);
+
+	pr_info("EXYNOS8890: Clock setup completed\n");
+}
+CLK_OF_DECLARE(exynos8890_clks, "samsung,exynos8890-clock", exynos8890_clk_init);
diff -Naur linux-3.18.14/drivers/clk/samsung/clk-exynos8890_evt0.c samsung/drivers/clk/samsung/clk-exynos8890_evt0.c
--- linux-3.18.14/drivers/clk/samsung/clk-exynos8890_evt0.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/clk/samsung/clk-exynos8890_evt0.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,552 @@
+/*
+ * Copyright (c) 2015 Samsung Electronics Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This file contains clocks of Exynos8890.
+ */
+
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/clk-provider.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+
+#include <dt-bindings/clock/exynos8890.h>
+#include "../../soc/samsung/pwrcal/S5E8890/S5E8890-vclk.h"
+#include "composite.h"
+
+#if defined(CONFIG_ECT)
+#include <soc/samsung/ect_parser.h>
+#endif
+
+enum exynos8890_clks {
+	none,
+
+	oscclk = 1,
+
+	/* number for mfc driver starts from 10 */
+	mfc_hpm = 10, mfc_mfc, mfc_ppmu,
+
+	/* number for mscl driver starts from 50 */
+	mscl_mscl0 = 50, mscl_jpeg, mscl_mscl1, mscl_g2d, mscl_ppmu, mscl_bts,
+
+	/* number for imem driver starts from 100 */
+	gate_apm = 100, gate_sss, gate_gic400, gate_rtic, gate_mc, gate_intmem, gate_alv, gate_ppmu,
+
+	/* number for peris driver starts from 150 */
+	peris_sfr = 150, peris_hpm, peris_mct, wdt_mngs, wdt_apollo, sysreg_peris, monocnt_apbif, rtc_apbif, top_rtc, otp_con_top, peris_chipid, peris_tmu, peris_sysreg, peris_monocnt,
+
+	/* number for peric0 driver starts from 200 */
+	gate_hsi2c0 = 200, gate_hsi2c1, gate_hsi2c4, gate_hsi2c5, gate_hsi2c9, gate_hsi2c10, gate_hsi2c11, puart0, suart0, gate_adcif, gate_pwm, gate_sclk_pwm,
+
+	/* number for peric1 driver starts from 250 */
+	gate_hsi2c2 = 250, gate_hsi2c3, gate_hsi2c6, gate_hsi2c7, gate_hsi2c8, gate_hsi2c12, gate_hsi2c13, gate_hsi2c14,
+	gate_uart1, gate_uart2, gate_uart3, gate_uart4, gate_uart5, suart1, suart2, suart3, suart4, suart5,
+	gate_spi0, gate_spi1, gate_spi2, gate_spi3, gate_spi4, gate_spi5, gate_spi6, gate_spi7,
+	sclk_peric1_spi0, sclk_peric1_spi1, sclk_peric1_spi2, sclk_peric1_spi3, sclk_peric1_spi4, sclk_peric1_spi5, sclk_peric1_spi6, sclk_peric1_spi7,
+	gate_gpio_nfc, gate_gpio_touch, gate_gpio_fp, gate_gpio_ese, promise_int, promise_disp, ap2cp_mif_pll_out, gate_i2s1, gate_pcm1, gate_spdif,
+
+	/* number for isp0 driver starts from 400 */
+	gate_fimc_isp0 = 400, gate_fimc_tpu, isp0, isp0_tpu, isp0_trex, isp0_ppmu, isp0_bts,
+
+	/* number for isp1 driver starts from 450 */
+	gate_fimc_isp1 = 450, isp1, isp1_ppmu, isp1_bts,
+
+	/* number for isp sensor driver starts from 500 */
+	isp_sensor0 = 500, isp_sensor1, isp_sensor2, isp_sensor3,
+
+	/* number for cam0 driver starts from 550 */
+	gate_csis0 = 550, gate_csis1, gate_fimc_bns, fimc_3aa0, fimc_3aa1, cam0_hpm, pxmxdx_csis0, pxmxdx_csis1, pxmxdx_csis2, pxmxdx_csis3,
+	pxmxdx_3aa0, pxmxdx_3aa1, pxmxdx_trex, hs0_csis0_rx_byte, hs1_csis0_rx_byte, hs2_csis0_rx_byte, hs3_csis0_rx_byte, hs0_csis1_rx_byte, hs1_csis1_rx_byte, cam0_ppmu, cam0_bts,
+
+	/* number for cam1 driver starts from 600 */
+	gate_isp_cpu = 600, gate_csis2, gate_csis3, gate_fimc_vra, gate_mc_scaler, gate_i2c0_isp, gate_i2c1_isp, gate_i2c2_isp, gate_i2c3_isp, gate_wdt_isp,
+	gate_mcuctl_isp, gate_uart_isp, gate_pdma_isp, gate_pwm_isp, gate_spi0_isp, gate_spi1_isp, isp_spi0, isp_spi1, isp_uart, gate_sclk_pwm_isp,
+	gate_sclk_uart_isp, cam1_arm, cam1_vra, cam1_trex, cam1_bus, cam1_peri, cam1_csis2, cam1_csis3, cam1_scl, cam1_phy0_csis2, cam1_phy1_csis2,
+	cam1_phy2_csis2, cam1_phy3_csis2, cam1_phy0_csis3, cam1_ppmu, cam1_bts,
+
+	/* number for audio driver starts from 650 */
+	gate_mi2s = 650, gate_pcm, gate_slimbus, gate_sclk_mi2s, d1_sclk_i2s, gate_sclk_pcm, d1_sclk_pcm, gate_sclk_slimbus, sclk_slimbus, sclk_cp_i2s,
+	sclk_asrc, aud_pll, aud_cp, aud_lpass, aud_dma, aud_ppmu, aud_bts,
+
+	/* number for fsys0 driver starts from 700 */
+	gate_usbdrd30 = 700, gate_usbhost20, usbdrd30 = 703, sclk_fsys0_mmc0, ufsunipro20, phy24m, ufsunipro_cfg, gate_udrd30_phyclock, gate_udrd30_pipe, gate_ufs_tx0,
+	gate_ufs_rx0, usbhost20_phyclock, usbhost20_freeclk, usbhost20_clk48, usbhost20phy_ref, ufs_rx_pwm, ufs_tx_pwm, ufs_refclk_out, fsys_200, fsys0_etr_usb, gate_mmc, gate_pdma0, gate_pdmas, gate_ufs_linkemedded,
+
+	/* number for fsys1 driver starts from 750 */
+	gate_ufs20_sdcard = 750, fsys1_hpm, fsys1_sclk_mmc2, ufsunipro20_sdcard, pcie_phy, sclk_ufsunipro_sdcard, ufs_link_sdcard_tx0, ufs_link_sdcard_rx0,
+	pcie_wifi0_tx0, pcie_wifi0_rx0, pcie_wifi1_tx0, pcie_wifi1_rx0, wifi0_dig_refclk, wifi1_dig_refclk, sdcard_rx_pwm, sdcard_tx_pwm, sdcard_refclk, gate_mmc2,
+	gate_sromc, gate_pciewifi0, gate_pciewifi1, fsys1_ppmu, fsys1_bts,
+
+	/* number for g3d driver starts from 800 */
+	gate_g3d = 800, gate_g3d_iram, g3d_bts, g3d_ppmu,
+
+	/* number for disp0 driver starts from 850 */
+	gate_decon0 = 850, gate_dsim0, gate_dsim1, gate_dsim2, gate_hdmi, gate_dp, gate_hpm_apbif_disp0, decon0_eclk0, decon0_vclk0, decon0_vclk1,
+	decon0_eclk0_local, decon0_vclk0_local, decon0_vclk1_local, hdmi_audio, disp_pll,
+	mipidphy0_rxclkesc0, mipidphy0_bitclkdiv8, mipidphy1_rxclkesc0, mipidphy1_bitclkdiv8, mipidphy2_rxclkesc0, mipidphy2_bitclkdiv8,
+	dpphy_ch0_txd, dpphy_ch1_txd, dpphy_ch2_txd, dpphy_ch3_txd, dptx_phy_i_ref_clk_24m,
+	mipi_dphy_m1s0, mipi_dphy_m4s0, mipi_dphy_m4s4, phyclk_hdmiphy_tmds_20b, phyclk_hdmiphy_pixel, mipidphy0_bitclkdiv2_user,
+	mipidphy1_bitclkdiv2_user, mipidphy2_bitclkdiv2_user,
+
+	/* number for disp1 driver starts from 900 */
+	gate_decon1 = 900, gate_hpmdisp1, decon1_eclk0, decon1_eclk1, decon1_eclk0_local, decon1_eclk1_local,
+	disp1_phyclk_mipidphy0_bitclkdiv2_user, disp1_phyclk_mipidphy1_bitclkdiv2_user,
+	disp1_phyclk_mipidphy2_bitclkdiv2_user, disp1_phyclk_disp1_hdmiphy_pixel_clko_user, disp1_ppmu, disp1_bts,
+
+	/* number for ccore driver starts from 950 */
+	ccore_i2c = 950,
+
+	/* number for clkout port starts from 1000 */
+	oscclk_nfc = 1000, oscclk_aud,
+
+	/* clk id for sysmmu: 1100 ~ 1149
+	 * NOTE: clock IDs of sysmmus are defined in
+	 * include/dt-bindings/clock/exynos8890.h
+	 */
+	sysmmu_last = 1149,
+
+	nr_clks,
+};
+
+static struct samsung_fixed_rate exynos8890_fixed_rate_ext_clks[] __initdata = {
+	FRATE(oscclk, "fin_pll", NULL, CLK_IS_ROOT, 0),
+};
+
+static struct of_device_id ext_clk_match[] __initdata = {
+	{ .compatible = "samsung,exynos8890-oscclk", .data = (void *)0, },
+};
+
+static struct init_vclk exynos8890_clkout_vclks[] __initdata = {
+	VCLK(oscclk_nfc, pxmxdx_oscclk_nfc, "pxmxdx_oscclk_nfc", 0, 0, NULL),
+	VCLK(oscclk_aud, pxmxdx_oscclk_aud, "pxmxdx_oscclk_aud", 0, 0, NULL),
+};
+
+static struct init_vclk exynos8890_ccore_vclks[] __initdata = {
+	VCLK(ccore_i2c, gate_ccore_i2c, "gate_ccore_i2c", 0, 0, NULL),
+};
+
+static struct init_vclk exynos8890_mfc_vclks[] __initdata = {
+	/* MFC */
+	VCLK(mfc_hpm, gate_mfc_hpm, "mfc_hpm", 0, 0, NULL),
+	VCLK(mfc_mfc, gate_mfc_mfc, "mfc_mfc", 0, 0, NULL),
+	VCLK(CLK_VCLK_SYSMMU_MFC, gate_mfc_sysmmu, "mfc_sysmmu", 0, 0, NULL),
+	VCLK(mfc_ppmu, gate_mfc_ppmu, "mfc_ppmu", 0, 0, NULL),
+};
+
+static struct init_vclk exynos8890_mscl_vclks[] __initdata = {
+	/* MSCL */
+	VCLK(mscl_mscl0, gate_mscl_mscl0, "gate_mscl_mscl0", 0, 0, NULL),
+	VCLK(mscl_jpeg, gate_mscl_jpeg, "gate_mscl_jpeg", 0, 0, NULL),
+	VCLK(mscl_mscl1, gate_mscl_mscl1, "gate_mscl_mscl1", 0, 0, NULL),
+	VCLK(mscl_g2d, gate_mscl_g2d, "gate_mscl_g2d", 0, 0, NULL),
+	VCLK(CLK_VCLK_SYSMMU_MSCL, gate_mscl_sysmmu, "gate_mscl_sysmmu", 0, 0, NULL),
+	VCLK(mscl_ppmu, gate_mscl_ppmu, "gate_mscl_ppmu", 0, 0, NULL),
+	VCLK(mscl_bts, gate_mscl_bts, "gate_mscl_bts", 0, 0, NULL),
+};
+
+static struct init_vclk exynos8890_imem_vclks[] __initdata = {
+	/* IMEM */
+	VCLK(gate_apm, gate_imem_apm, "gate_imem_apm", 0, 0, NULL),
+	VCLK(gate_sss, gate_imem_sss, "gate_imem_sss", 0, 0, NULL),
+	VCLK(gate_gic400, gate_imem_gic400, "gate_imem_gic400", 0, 0, NULL),
+	VCLK(gate_rtic, gate_imem_rtic, "gate_imem_rtic", 0, 0, NULL),
+	VCLK(gate_mc, gate_imem_mc, "gate_imem_mc", 0, 0, NULL),
+	VCLK(gate_intmem, gate_imem_intmem, "gate_imem_intmem", 0, 0, NULL),
+	VCLK(gate_alv, gate_imem_intmem_alv, "gate_imem_intmem_alv", 0, 0, NULL),
+	VCLK(gate_ppmu, gate_imem_ppmu, "gate_imem_ppmu", 0, 0, NULL),
+};
+
+static struct init_vclk exynos8890_peris_vclks[] __initdata = {
+	/* PERIS */
+	VCLK(peris_sfr, gate_peris_sfr_apbif_hdmi_cec, "gate_peris_sfr_apbif_hdmi_cec", 0, 0, NULL),
+	VCLK(peris_hpm, gate_peris_hpm, "gate_peris_hpm", 0, 0, NULL),
+	VCLK(peris_mct, gate_peris_mct, "gate_peris_mct", 0, 0, NULL),
+	VCLK(wdt_mngs, gate_peris_wdt_mngs, "gate_peris_wdt_mngs", 0, 0, NULL),
+	VCLK(wdt_apollo, gate_peris_wdt_apollo, "gate_peris_wdt_apollo", 0, 0, NULL),
+	VCLK(rtc_apbif, gate_peris_rtc_apbif, "gate_peris_rtc_apbif", 0, 0, NULL),
+	VCLK(top_rtc, gate_peris_top_rtc, "gate_peris_top_rtc", 0, 0, NULL),
+	VCLK(otp_con_top, gate_peris_otp_con_top, "gate_peris_otp_con_top", 0, 0, NULL),
+	VCLK(peris_chipid, gate_peris_chipid, "gate_peris_chipid", 0, 0, NULL),
+	VCLK(peris_tmu, gate_peris_tmu, "gate_peris_tmu", 0, 0, NULL),
+	VCLK(peris_sysreg, gate_peris_sysreg_peris, "gate_peris_sysreg_peris", 0, 0, NULL),
+	VCLK(peris_monocnt, gate_peris_monocnt_apbif, "gate_peris_monocnt_apbif", 0, 0, NULL),
+};
+
+static struct init_vclk exynos8890_peric0_vclks[] __initdata = {
+	/* PERIC0 */
+	VCLK(gate_hsi2c0, gate_peric0_hsi2c0, "gate_peric0_hsi2c0", 0, 0, NULL),
+	VCLK(gate_hsi2c1, gate_peric0_hsi2c1, "gate_peric0_hsi2c1", 0, 0, NULL),
+	VCLK(gate_hsi2c4, gate_peric0_hsi2c4, "gate_peric0_hsi2c4", 0, 0, NULL),
+	VCLK(gate_hsi2c5, gate_peric0_hsi2c5, "gate_peric0_hsi2c5", 0, 0, NULL),
+	VCLK(gate_hsi2c9, gate_peric0_hsi2c9, "gate_peric0_hsi2c9", 0, 0, NULL),
+	VCLK(gate_hsi2c10, gate_peric0_hsi2c10, "gate_peric0_hsi2c10", 0, 0, NULL),
+	VCLK(gate_hsi2c11, gate_peric0_hsi2c11, "gate_peric0_hsi2c11", 0, 0, NULL),
+	VCLK(puart0, gate_peric0_uart0, "gate_peric0_uart0", 0, 0, "console-pclk0"),
+	VCLK(suart0, sclk_uart0, "sclk_uart0", 0, 0, "console-sclk0"),
+	VCLK(gate_adcif, gate_peric0_adcif, "gate_peric0_adcif", 0, 0, NULL),
+	VCLK(gate_pwm, gate_peric0_pwm, "gate_peric0_pwm", 0, 0, NULL),
+	VCLK(gate_sclk_pwm, gate_peric0_sclk_pwm, "gate_peric0_sclk_pwm", 0, 0, NULL),
+};
+
+static struct init_vclk exynos8890_peric1_vclks[] __initdata = {
+	/* PERIC1 HSI2C */
+	VCLK(gate_hsi2c2, gate_peric1_hsi2c2, "gate_hsi2c2", 0, 0, NULL),
+	VCLK(gate_hsi2c3, gate_peric1_hsi2c3, "gate_hsi2c3", 0, 0, NULL),
+	VCLK(gate_hsi2c6, gate_peric1_hsi2c6, "gate_hsi2c6", 0, 0, NULL),
+	VCLK(gate_hsi2c7, gate_peric1_hsi2c7, "gate_hsi2c7", 0, 0, NULL),
+	VCLK(gate_hsi2c8, gate_peric1_hsi2c8, "gate_hsi2c8", 0, 0, NULL),
+	VCLK(gate_hsi2c12, gate_peric1_hsi2c12, "gate_hsi2c12", 0, 0, NULL),
+	VCLK(gate_hsi2c13, gate_peric1_hsi2c13, "gate_hsi2c13", 0, 0, NULL),
+	VCLK(gate_hsi2c14, gate_peric1_hsi2c14, "gate_hsi2c14", 0, 0, NULL),
+	/* PERIC1 UART0~5 */
+	VCLK(gate_uart1, gate_peric1_uart1, "gate_uart1", 0, 0, "console-pclk1"),
+	VCLK(gate_uart2, gate_peric1_uart2, "gate_uart2", 0, 0, "console-pclk2"),
+	VCLK(gate_uart3, gate_peric1_uart3, "gate_uart3", 0, 0, "console-pclk3"),
+	VCLK(gate_uart4, gate_peric1_uart4, "gate_uart4", 0, 0, "console-pclk4"),
+	VCLK(gate_uart5, gate_peric1_uart5, "gate_uart5", 0, 0, "console-pclk5"),
+	VCLK(suart1, sclk_uart1, "sclk_uart1", 0, 0, "console-sclk1"),
+	VCLK(suart2, sclk_uart2, "sclk_uart2", 0, 0, "console-sclk2"),
+	VCLK(suart3, sclk_uart3, "sclk_uart3", 0, 0, "console-sclk3"),
+	VCLK(suart4, sclk_uart4, "sclk_uart4", 0, 0, "console-sclk4"),
+	VCLK(suart5, sclk_uart5, "sclk_uart5", 0, 0, "console-sclk5"),
+	/* PERIC1 SPI0~7 */
+	VCLK(gate_spi0, gate_peric1_spi0, "gate_spi0", 0, 0, NULL),
+	VCLK(gate_spi1, gate_peric1_spi1, "gate_spi1", 0, 0, NULL),
+	VCLK(gate_spi2, gate_peric1_spi2, "gate_spi2", 0, 0, NULL),
+	VCLK(gate_spi3, gate_peric1_spi3, "gate_spi3", 0, 0, NULL),
+	VCLK(gate_spi4, gate_peric1_spi4, "gate_spi4", 0, 0, NULL),
+	VCLK(gate_spi5, gate_peric1_spi5, "gate_spi5", 0, 0, NULL),
+	VCLK(gate_spi6, gate_peric1_spi6, "gate_spi6", 0, 0, NULL),
+	VCLK(gate_spi7, gate_peric1_spi7, "gate_spi7", 0, 0, NULL),
+	VCLK(sclk_peric1_spi0, sclk_spi0, "sclk_spi0", 0, 0, NULL),
+	VCLK(sclk_peric1_spi1, sclk_spi1, "sclk_spi1", 0, 0, NULL),
+	VCLK(sclk_peric1_spi2, sclk_spi2, "sclk_spi2", 0, 0, NULL),
+	VCLK(sclk_peric1_spi3, sclk_spi3, "sclk_spi3", 0, 0, NULL),
+	VCLK(sclk_peric1_spi4, sclk_spi4, "sclk_spi4", 0, 0, NULL),
+	VCLK(sclk_peric1_spi5, sclk_spi5, "sclk_spi5", 0, 0, NULL),
+	VCLK(sclk_peric1_spi6, sclk_spi6, "sclk_spi6", 0, 0, NULL),
+	VCLK(sclk_peric1_spi7, sclk_spi7, "sclk_spi7", 0, 0, NULL),
+	/* PERIC1 GPIO */
+	VCLK(gate_gpio_nfc, gate_peric1_gpio_nfc, "gate_gpio_nfc", 0, 0, NULL),
+	VCLK(gate_gpio_touch, gate_peric1_gpio_touch, "gate_gpio_touch", 0, 0, NULL),
+	VCLK(gate_gpio_fp, gate_peric1_gpio_fp, "gate_gpio_fp", 0, 0, NULL),
+	VCLK(gate_gpio_ese, gate_peric1_gpio_ese, "gate_gpio_ese", 0, 0, NULL),
+	/* PERIC1 promise */
+	VCLK(promise_int, sclk_promise_int, "sclk_promise_int", 0, 0, NULL),
+	VCLK(promise_disp, sclk_promise_disp, "sclk_promise_disp", 0, 0, NULL),
+	VCLK(ap2cp_mif_pll_out, sclk_ap2cp_mif_pll_out, "sclk_ap2cp_mif_pll_out", 0, 0, NULL),
+	VCLK(gate_i2s1, gate_peric1_i2s1, "gate_peric1_i2s1", 0, 0, NULL),
+	VCLK(gate_pcm1, gate_peric1_pcm1, "gate_peric1_pcm1", 0, 0, NULL),
+	VCLK(gate_spdif, gate_peric1_spdif, "gate_peric1_spdif", 0, 0, NULL),
+};
+
+static struct init_vclk exynos8890_isp0_vclks[] __initdata = {
+	/* ISP0 */
+	VCLK(gate_fimc_isp0, gate_isp0_fimc_isp0, "gate_fimc_isp0", 0, 0, NULL),
+	VCLK(gate_fimc_tpu, gate_isp0_fimc_tpu, "gate_isp0_fimc_tpu", 0, 0, NULL),
+	VCLK(isp0, pxmxdx_isp0_isp0, "clk_isp0", 0, 0, NULL),
+	VCLK(isp0_tpu, pxmxdx_isp0_tpu, "clk_isp0_tpu", 0, 0, NULL),
+	VCLK(isp0_trex, pxmxdx_isp0_trex, "clk_isp0_trex", 0, 0, NULL),
+	VCLK(CLK_VCLK_SYSMMU_ISP0, gate_isp0_sysmmu, "gate_isp0_sysmmu", 0, 0, NULL),
+	VCLK(isp0_ppmu, gate_isp0_ppmu, "gate_isp0_ppmu", 0, 0, NULL),
+	VCLK(isp0_bts, gate_isp0_bts, "gate_isp0_bts", 0, 0, NULL),
+};
+
+static struct init_vclk exynos8890_isp1_vclks[] __initdata = {
+	/* ISP1 */
+	VCLK(gate_fimc_isp1, gate_isp1_fimc_isp1, "gate_isp1_fimc_isp1", 0, 0, NULL),
+	VCLK(isp1, pxmxdx_isp1_isp1, "clk_isp1", 0, 0, NULL),
+	VCLK(isp1_ppmu, gate_isp1_ppmu, "gate_isp1_ppmu", 0, 0, NULL),
+	VCLK(isp1_bts, gate_isp1_bts, "gate_isp1_bts", 0, 0, NULL),
+};
+
+static struct init_vclk exynos8890_isp_sensor_vclks[] __initdata = {
+	/* ISP1 */
+	VCLK(isp_sensor0, sclk_isp_sensor0, "sclk_isp_sensor0", 0, 0, NULL),
+	VCLK(isp_sensor1, sclk_isp_sensor1, "sclk_isp_sensor1", 0, 0, NULL),
+	VCLK(isp_sensor2, sclk_isp_sensor2, "sclk_isp_sensor2", 0, 0, NULL),
+	VCLK(isp_sensor3, sclk_isp_sensor3, "sclk_isp_sensor3", 0, 0, NULL),
+};
+
+static struct init_vclk exynos8890_cam0_vclks[] __initdata = {
+	/* CAM0 */
+	VCLK(gate_csis0, gate_cam0_csis0, "gate_cam0_csis0", 0, 0, NULL),
+	VCLK(gate_csis1, gate_cam0_csis1, "gate_cam0_csis1", 0, 0, NULL),
+	VCLK(gate_fimc_bns, gate_cam0_fimc_bns, "gate_cam0_fimc_bns", 0, 0, NULL),
+	VCLK(fimc_3aa0, gate_cam0_fimc_3aa0, "gate_cam0_fimc_3aa0", 0, 0, NULL),
+	VCLK(fimc_3aa1, gate_cam0_fimc_3aa1, "gate_cam0_fimc_3aa1", 0, 0, NULL),
+	VCLK(cam0_hpm, gate_cam0_hpm, "gate_cam0_hpm", 0, 0, NULL),
+	VCLK(pxmxdx_csis0, pxmxdx_cam0_csis0, "gate_pxmxdx_cam0_csis0", 0, 0, NULL),
+	VCLK(pxmxdx_csis1, pxmxdx_cam0_csis1, "gate_pxmxdx_cam0_csis1", 0, 0, NULL),
+	VCLK(pxmxdx_csis2, pxmxdx_cam0_csis2, "gate_pxmxdx_cam0_csis2", 0, 0, NULL),
+	VCLK(pxmxdx_csis3, pxmxdx_cam0_csis3, "gate_pxmxdx_cam0_csis3", 0, 0, NULL),
+	VCLK(pxmxdx_3aa0, pxmxdx_cam0_3aa0, "gate_pxmxdx_cam0_3aa0", 0, 0, NULL),
+	VCLK(pxmxdx_3aa1, pxmxdx_cam0_3aa1, "gate_pxmxdx_cam0_3aa1", 0, 0, NULL),
+	VCLK(pxmxdx_trex, pxmxdx_cam0_trex, "gate_pxmxdx_cam0_trex", 0, 0, NULL),
+	VCLK(hs0_csis0_rx_byte, umux_cam0_phyclk_rxbyteclkhs0_csis0_user, "umux_cam0_phyclk_rxbyteclkhs0_csis0_user", 0, 0, NULL),
+	VCLK(hs1_csis0_rx_byte, umux_cam0_phyclk_rxbyteclkhs1_csis0_user, "umux_cam0_phyclk_rxbyteclkhs1_csis0_user", 0, 0, NULL),
+	VCLK(hs2_csis0_rx_byte, umux_cam0_phyclk_rxbyteclkhs2_csis0_user, "umux_cam0_phyclk_rxbyteclkhs2_csis0_user", 0, 0, NULL),
+	VCLK(hs3_csis0_rx_byte, umux_cam0_phyclk_rxbyteclkhs3_csis0_user, "umux_cam0_phyclk_rxbyteclkhs3_csis0_user", 0, 0, NULL),
+	VCLK(hs0_csis1_rx_byte, umux_cam0_phyclk_rxbyteclkhs0_csis1_user, "umux_cam0_phyclk_rxbyteclkhs0_csis1_user", 0, 0, NULL),
+	VCLK(hs1_csis1_rx_byte, umux_cam0_phyclk_rxbyteclkhs1_csis1_user, "umux_cam0_phyclk_rxbyteclkhs1_csis1_user", 0, 0, NULL),
+	VCLK(CLK_VCLK_SYSMMU_CAM0, gate_cam0_sysmmu, "gate_cam0_sysmmu", 0, 0, NULL),
+	VCLK(cam0_ppmu, gate_cam0_ppmu, "gate_cam0_ppmu", 0, 0, NULL),
+	VCLK(cam0_bts, gate_cam0_bts, "gate_cam0_bts", 0, 0, NULL),
+};
+
+static struct init_vclk exynos8890_cam1_vclks[] __initdata = {
+	/* CAM1 */
+	VCLK(gate_isp_cpu, gate_cam1_isp_cpu, "gate_cam1_isp_cpu", 0, 0, NULL),
+	VCLK(gate_csis2, gate_cam1_csis2, "gate_cam1_csis2", 0, 0, NULL),
+	VCLK(gate_csis3, gate_cam1_csis3, "gate_cam1_csis3", 0, 0, NULL),
+	VCLK(gate_fimc_vra, gate_cam1_fimc_vra, "gate_cam1_fimc_vra", 0, 0, NULL),
+	VCLK(gate_mc_scaler, gate_cam1_mc_scaler, "gate_cam1_mc_scaler", 0, 0, NULL),
+	VCLK(gate_i2c0_isp, gate_cam1_i2c0_isp, "gate_cam1_i2c0_isp", 0, 0, NULL),
+	VCLK(gate_i2c1_isp, gate_cam1_i2c1_isp, "gate_cam1_i2c1_isp", 0, 0, NULL),
+	VCLK(gate_i2c2_isp, gate_cam1_i2c2_isp, "gate_cam1_i2c2_isp", 0, 0, NULL),
+	VCLK(gate_i2c3_isp, gate_cam1_i2c3_isp, "gate_cam1_i2c3_isp", 0, 0, NULL),
+	VCLK(gate_wdt_isp, gate_cam1_wdt_isp, "gate_cam1_wdt_isp", 0, 0, NULL),
+	VCLK(gate_mcuctl_isp, gate_cam1_mcuctl_isp, "gate_cam1_mcuctl_isp", 0, 0, NULL),
+	VCLK(gate_uart_isp, gate_cam1_uart_isp, "gate_cam1_uart_isp", 0, 0, NULL),
+	VCLK(gate_pdma_isp, gate_cam1_pdma_isp, "gate_cam1_pdma_isp", 0, 0, NULL),
+	VCLK(gate_pwm_isp, gate_cam1_pwm_isp, "gate_cam1_pwm_isp", 0, 0, NULL),
+	VCLK(gate_spi0_isp, gate_cam1_spi0_isp, "gate_cam1_spi0_isp", 0, 0, NULL),
+	VCLK(gate_spi1_isp, gate_cam1_spi1_isp, "gate_cam1_spi1_isp", 0, 0, NULL),
+	/* rate clock source */
+	VCLK(isp_spi0, sclk_isp_spi0, "sclk_isp_spi0", 0, 0, NULL),
+	VCLK(isp_spi1, sclk_isp_spi1, "sclk_isp_spi1", 0, 0, NULL),
+	VCLK(isp_uart, sclk_isp_uart, "sclk_isp_uart", 0, 0, NULL),
+	VCLK(gate_sclk_pwm_isp, gate_cam1_sclk_pwm_isp, "gate_cam1_sclk_pwm_isp", 0, 0, NULL),
+	VCLK(gate_sclk_uart_isp, gate_cam1_sclk_uart_isp, "gate_cam1_sclk_uart_isp", 0, 0, NULL),
+	/* rate clock source */
+	VCLK(cam1_arm, pxmxdx_cam1_arm, "pxmxdx_cam1_arm", 0, 0, NULL),
+	VCLK(cam1_vra, pxmxdx_cam1_vra, "pxmxdx_cam1_vra", 0, 0, NULL),
+	VCLK(cam1_trex, pxmxdx_cam1_trex, "pxmxdx_cam1_trex", 0, 0, NULL),
+	VCLK(cam1_bus, pxmxdx_cam1_bus, "pxmxdx_cam1_bus", 0, 0, NULL),
+	VCLK(cam1_peri, pxmxdx_cam1_peri, "pxmxdx_cam1_peri", 0, 0, NULL),
+	VCLK(cam1_csis2, pxmxdx_cam1_csis2, "pxmxdx_cam1_csis2", 0, 0, NULL),
+	VCLK(cam1_csis3, pxmxdx_cam1_csis3, "pxmxdx_cam1_csis3", 0, 0, NULL),
+	VCLK(cam1_scl, pxmxdx_cam1_scl, "pxmxdx_cam1_scl", 0, 0, NULL),
+	/* usermux */
+	VCLK(cam1_phy0_csis2, umux_cam1_phyclk_rxbyteclkhs0_csis2_user, "phyclk_rxbyteclkhs0_csis2_user", 0, 0, NULL),
+	VCLK(cam1_phy1_csis2, umux_cam1_phyclk_rxbyteclkhs1_csis2_user, "phyclk_rxbyteclkhs1_csis2_user", 0, 0, NULL),
+	VCLK(cam1_phy2_csis2, umux_cam1_phyclk_rxbyteclkhs2_csis2_user, "phyclk_rxbyteclkhs2_csis2_user", 0, 0, NULL),
+	VCLK(cam1_phy3_csis2, umux_cam1_phyclk_rxbyteclkhs3_csis2_user, "phyclk_rxbyteclkhs3_csis2_user", 0, 0, NULL),
+	VCLK(cam1_phy0_csis3, umux_cam1_phyclk_rxbyteclkhs0_csis3_user, "phyclk_rxbyteclkhs0_csis3_user", 0, 0, NULL),
+	VCLK(CLK_VCLK_SYSMMU_CAM1, gate_cam1_sysmmu, "gate_cam1_sysmmu", 0, 0, NULL),
+	VCLK(cam1_ppmu, gate_cam1_ppmu, "gate_cam1_ppmu", 0, 0, NULL),
+	VCLK(cam1_bts, gate_cam1_bts, "gate_cam1_bts", 0, 0, NULL),
+};
+
+static struct init_vclk exynos8890_audio_vclks[] __initdata = {
+	/* AUDIO */
+	VCLK(gate_mi2s, gate_aud_mi2s, "gate_aud_mi2s", 0, 0, NULL),
+	VCLK(gate_pcm, gate_aud_pcm, "gate_aud_pcm", 0, 0, NULL),
+	VCLK(gate_slimbus, gate_aud_slimbus, "gate_aud_slimbus", 0, 0, NULL),
+	VCLK(gate_sclk_mi2s, gate_aud_sclk_mi2s, "gate_aud_sclk_mi2s", 0, 0, NULL),
+	VCLK(d1_sclk_i2s, d1_sclk_i2s_local, "dout_sclk_i2s_local", 0, 0, NULL),
+	VCLK(gate_sclk_pcm, gate_aud_sclk_pcm, "gate_aud_sclk_pcm", 0, 0, NULL),
+	VCLK(d1_sclk_pcm, d1_sclk_pcm_local, "dout_sclk_pcm_local", 0, 0, NULL),
+	VCLK(gate_sclk_slimbus, gate_aud_sclk_slimbus, "gate_aud_sclk_slimbus", 0, 0, NULL),
+	VCLK(sclk_slimbus, d1_sclk_slimbus, "dout_sclk_slimbus", 0, 0, NULL),
+	VCLK(sclk_cp_i2s, d1_sclk_cp_i2s, "dout_sclk_cp_i2s", 0, 0, NULL),
+	VCLK(sclk_asrc, d1_sclk_asrc, "dout_sclk_asrc", 0, 0, NULL),
+	VCLK(aud_pll, p1_aud_pll, "sclk_aud_pll", 0, 0, NULL),
+	VCLK(aud_cp, pxmxdx_aud_cp, "gate_aud_cp", 0, 0, NULL),
+	VCLK(aud_lpass, gate_aud_lpass, "gate_aud_lpass", 0, 0, NULL),
+	VCLK(aud_dma, gate_aud_dma, "gate_aud_dma", 0, 0, NULL),
+	VCLK(CLK_VCLK_SYSMMU_AUD, gate_aud_sysmmu, "gate_aud_sysmmu", 0, 0, NULL),
+	VCLK(aud_ppmu, gate_aud_ppmu, "gate_aud_ppmu", 0, 0, NULL),
+	VCLK(aud_bts, gate_aud_bts, "gate_aud_bts", 0, 0, NULL),
+};
+
+static struct init_vclk exynos8890_fsys0_vclks[] __initdata = {
+	/* FSYS0 */
+	VCLK(gate_usbdrd30, gate_fsys0_usbdrd30, "gate_fsys0_usbdrd30", 0, 0, NULL),
+	VCLK(gate_usbhost20, gate_fsys0_usbhost20, "gate_fsys0_usbhost20", 0, 0, NULL),
+	VCLK(usbdrd30, sclk_usbdrd30, "sclk_usbdrd30", 0, 0, NULL),
+	VCLK(sclk_fsys0_mmc0, sclk_mmc0, "sclk_mmc0", 0, 0, NULL),
+	VCLK(ufsunipro20, sclk_ufsunipro20, "sclk_ufsunipro20", 0, 0, NULL),
+	VCLK(phy24m, sclk_phy24m, "sclk_phy24m", 0, 0, NULL),
+	VCLK(ufsunipro_cfg, sclk_ufsunipro_cfg, "sclk_ufsunipro_cfg", 0, 0, NULL),
+	/* UMUX GATE related clock sources */
+	VCLK(gate_udrd30_phyclock, umux_fsys0_phyclk_usbdrd30_udrd30_phyclock_user, "umux_fsys0_phyclk_usbdrd30_udrd30_phyclock_user", 0, 0, NULL),
+	VCLK(gate_udrd30_pipe, umux_fsys0_phyclk_usbdrd30_udrd30_pipe_pclk_user, "umux_fsys0_phyclk_usbdrd30_udrd30_pipe_pclk_user", 0, 0, NULL),
+	VCLK(gate_ufs_tx0, umux_fsys0_phyclk_ufs_tx0_symbol_user, "umux_fsys0_phyclk_ufs_tx0_symbol_user", 0, 0, NULL),
+	VCLK(gate_ufs_rx0, umux_fsys0_phyclk_ufs_rx0_symbol_user, "umux_fsys0_phyclk_ufs_rx0_symbol_user", 0, 0, NULL),
+	VCLK(usbhost20_phyclock, umux_fsys0_phyclk_usbhost20_phyclock_user, "umux_fsys0_phyclk_usbhost20_phyclock_user", 0, 0, NULL),
+	VCLK(usbhost20_freeclk, umux_fsys0_phyclk_usbhost20_freeclk_user, "umux_fsys0_phyclk_usbhost20_freeclk_user", 0, 0, NULL),
+	VCLK(usbhost20_clk48, umux_fsys0_phyclk_usbhost20_clk48mohci_user, "umux_fsys0_phyclk_usbhost20_clk48mohci_user", 0, 0, NULL),
+	VCLK(usbhost20phy_ref, umux_fsys0_phyclk_usbhost20phy_ref_clk, "umux_fsys0_phyclk_usbhost20phy_ref_clk", 0, 0, NULL),
+	VCLK(ufs_rx_pwm, umux_fsys0_phyclk_ufs_rx_pwm_clk_user, "umux_fsys0_phyclk_ufs_rx_pwm_clk_user", 0, 0, NULL),
+	VCLK(ufs_tx_pwm, umux_fsys0_phyclk_ufs_tx_pwm_clk_user, "umux_fsys0_phyclk_ufs_tx_pwm_clk_user", 0, 0, NULL),
+	VCLK(ufs_refclk_out, umux_fsys0_phyclk_ufs_refclk_out_soc_user, "umux_fsys0_phyclk_ufs_refclk_out_soc_user", 0, 0, NULL),
+	VCLK(fsys_200, pxmxdx_fsys0, "aclk_ufs", 0, 0, NULL),
+	VCLK(fsys0_etr_usb, gate_fsys0_etr_usb, "gate_fsys0_etr_usb", 0, 0, "etr_clk"),
+	VCLK(gate_mmc, gate_fsys0_mmc0, "gate_fsys0_mmc0", 0, 0, NULL),
+	VCLK(gate_pdma0, gate_fsys0_pdma0, "gate_fsys0_pdma0", 0, 0, NULL),
+	VCLK(gate_pdmas, gate_fsys0_pdmas, "gate_fsys0_pdmas", 0, 0, NULL),
+	VCLK(gate_ufs_linkemedded, gate_fsys0_ufs_linkemedded, "gate_fsys0_ufs_linkemedded", 0, 0, NULL),
+};
+
+static struct init_vclk exynos8890_fsys1_vclks[] __initdata = {
+	/* FSYS1 */
+	VCLK(fsys1_hpm, gate_fsys1_hpm, "gate_fsys1_hpm", 0, 0, NULL),
+	VCLK(fsys1_sclk_mmc2, sclk_mmc2, "sclk_mmc2", 0, 0, NULL),
+	VCLK(ufsunipro20_sdcard, sclk_ufsunipro20_sdcard, "sclk_ufsunipro20_sdcard", 0, 0, NULL),
+	VCLK(pcie_phy, sclk_pcie_phy, "sclk_pcie_phy", 0, 0, NULL),
+	VCLK(sclk_ufsunipro_sdcard, sclk_ufsunipro_sdcard_cfg, "sclk_ufsunipro_sdcard_cfg", 0, 0, NULL),
+	/* UMUX GATE related clock sources */
+	VCLK(ufs_link_sdcard_tx0, umux_fsys1_phyclk_ufs_link_sdcard_tx0_symbol_user, "umux_fsys1_phyclk_ufs_link_sdcard_tx0_symbol_user", 0, 0, NULL),
+	VCLK(ufs_link_sdcard_rx0, umux_fsys1_phyclk_ufs_link_sdcard_rx0_symbol_user, "umux_fsys1_phyclk_ufs_link_sdcard_rx0_symbol_user", 0, 0, NULL),
+	VCLK(pcie_wifi0_tx0, umux_fsys1_phyclk_pcie_wifi0_tx0_user, "umux_fsys1_phyclk_pcie_wifi0_tx0_user", 0, 0, NULL),
+	VCLK(pcie_wifi0_rx0, umux_fsys1_phyclk_pcie_wifi0_rx0_user, "umux_fsys1_phyclk_pcie_wifi0_rx0_user", 0, 0, NULL),
+	VCLK(pcie_wifi1_tx0, umux_fsys1_phyclk_pcie_wifi1_tx0_user, "umux_fsys1_phyclk_pcie_wifi1_tx0_user", 0, 0, NULL),
+	VCLK(pcie_wifi1_rx0, umux_fsys1_phyclk_pcie_wifi1_rx0_user, "umux_fsys1_phyclk_pcie_wifi1_rx0_user", 0, 0, NULL),
+	VCLK(wifi0_dig_refclk, umux_fsys1_phyclk_pcie_wifi0_dig_refclk_user, "umux_fsys1_phyclk_pcie_wifi0_dig_refclk_user", 0, 0, NULL),
+	VCLK(wifi1_dig_refclk, umux_fsys1_phyclk_pcie_wifi1_dig_refclk_user, "umux_fsys1_phyclk_pcie_wifi1_dig_refclk_user", 0, 0, NULL),
+	VCLK(sdcard_rx_pwm, umux_fsys1_phyclk_ufs_link_sdcard_rx_pwm_clk_user, "umux_fsys1_phyclk_ufs_link_sdcard_rx_pwm_clk_user", 0, 0, NULL),
+	VCLK(sdcard_tx_pwm, umux_fsys1_phyclk_ufs_link_sdcard_tx_pwm_clk_user, "umux_fsys1_phyclk_ufs_link_sdcard_tx_pwm_clk_user", 0, 0, NULL),
+	VCLK(sdcard_refclk, umux_fsys1_phyclk_ufs_link_sdcard_refclk_out_soc_user, "umux_fsys1_phyclk_ufs_link_sdcard_refclk_out_soc_user", 0, 0, NULL),
+	VCLK(gate_mmc2, gate_fsys1_mmc2, "gate_fsys1_mmc2", 0, 0, NULL),
+	VCLK(gate_ufs20_sdcard, gate_fsys1_ufs20_sdcard, "gate_fsys1_ufs20_sdcard", 0, 0, NULL),
+	VCLK(gate_sromc, gate_fsys1_sromc, "gate_fsys1_sromc", 0, 0, NULL),
+	VCLK(gate_pciewifi0, gate_fsys1_pciewifi0, "gate_fsys1_pciewifi0", 0, 0, NULL),
+	VCLK(gate_pciewifi1, gate_fsys1_pciewifi1, "gate_fsys1_pciewifi1", 0, 0, NULL),
+	VCLK(fsys1_ppmu, gate_fsys1_ppmu, "gate_fsys1_ppmu", 0, 0, NULL),
+	VCLK(fsys1_bts, gate_fsys1_bts, "gate_fsys1_bts", 0, 0, NULL),
+};
+
+static struct init_vclk exynos8890_g3d_vclks[] __initdata = {
+	/* G3D */
+	VCLK(gate_g3d, gate_g3d_g3d, "gate_g3d_g3d", 0, 0, "vclk_g3d"),
+	VCLK(gate_g3d_iram, gate_g3d_iram_path_test, "g3d_iram_path", 0, 0, NULL),
+	VCLK(g3d_bts, gate_g3d_bts, "gate_g3d_bts", 0, 0, NULL),
+	VCLK(g3d_ppmu, gate_g3d_ppmu, "gate_g3d_ppmu", 0, 0, NULL),
+};
+
+static struct init_vclk exynos8890_disp0_vclks[] __initdata = {
+	/* DISP0 */
+	VCLK(gate_decon0, gate_disp0_decon0, "gate_disp0_decon0", 0, 0, NULL),
+	VCLK(gate_dsim0, gate_disp0_dsim0, "gate_disp0_dsim0", 0, 0, NULL),
+	VCLK(gate_dsim1, gate_disp0_dsim1, "gate_disp0_dsim1", 0, 0, NULL),
+	VCLK(gate_dsim2, gate_disp0_dsim2, "gate_disp0_dsim2", 0, 0, NULL),
+	VCLK(gate_hdmi, gate_disp0_hdmi, "gate_disp0_hdmi", 0, 0, NULL),
+	VCLK(gate_dp, gate_disp0_dp, "gate_disp0_dp", 0, 0, NULL),
+	VCLK(gate_hpm_apbif_disp0, gate_disp0_hpm_apbif_disp0, "gate_disp0_hpm_apbif_disp0", 0, 0, NULL),
+	/* special clock - sclk */
+	VCLK(decon0_eclk0, sclk_decon0_eclk0, "sclk_decon0_eclk0", 0, 0, NULL),
+	VCLK(decon0_vclk0, sclk_decon0_vclk0, "sclk_decon0_vclk0", 0, 0, NULL),
+	VCLK(decon0_vclk1, sclk_decon0_vclk1, "sclk_decon0_vclk1", 0, 0, NULL),
+	VCLK(decon0_eclk0_local, sclk_decon0_eclk0_local, "sclk_decon0_eclk0_local", 0, 0, NULL),
+	VCLK(decon0_vclk0_local, sclk_decon0_vclk0_local, "sclk_decon0_vclk0_local", 0, 0, NULL),
+	VCLK(decon0_vclk1_local, sclk_decon0_vclk1_local, "sclk_decon0_vclk1_local", 0, 0, NULL),
+	VCLK(hdmi_audio, sclk_hdmi_audio, "sclk_hdmi_audio", 0, 0, NULL),
+	/* PLL clock source */
+	VCLK(disp_pll, p1_disp_pll, "p1_disp_pll", 0, 0, "disp_pll"),
+	/* USERMUX related clock source */
+	VCLK(mipidphy0_rxclkesc0, umux_disp0_phyclk_mipidphy0_rxclkesc0_user, "umux_disp0_phyclk_mipidphy0_rxclkesc0_user", 0, 0, NULL),
+	VCLK(mipidphy0_bitclkdiv8, umux_disp0_phyclk_mipidphy0_bitclkdiv8_user, "umux_disp0_phyclk_mipidphy0_bitclkdiv8_user", 0, 0, NULL),
+	VCLK(mipidphy1_rxclkesc0, umux_disp0_phyclk_mipidphy1_rxclkesc0_user, "umux_disp0_phyclk_mipidphy1_rxclkesc0_user", 0, 0, NULL),
+	VCLK(mipidphy1_bitclkdiv8, umux_disp0_phyclk_mipidphy1_bitclkdiv8_user, "umux_disp0_phyclk_mipidphy1_bitclkdiv8_user", 0, 0, NULL),
+	VCLK(mipidphy2_rxclkesc0, umux_disp0_phyclk_mipidphy2_rxclkesc0_user, "umux_disp0_phyclk_mipidphy2_rxclkesc0_user", 0, 0, NULL),
+	VCLK(mipidphy2_bitclkdiv8, umux_disp0_phyclk_mipidphy2_bitclkdiv8_user, "umux_disp0_phyclk_mipidphy2_bitclkdiv8_user", 0, 0, NULL),
+	VCLK(dpphy_ch0_txd, umux_disp0_phyclk_dpphy_ch0_txd_clk_user, "umux_disp0_phyclk_dpphy_ch0_txd_clk_user", 0, 0, NULL),
+	VCLK(dpphy_ch1_txd, umux_disp0_phyclk_dpphy_ch1_txd_clk_user, "umux_disp0_phyclk_dpphy_ch1_txd_clk_user", 0, 0, NULL),
+	VCLK(dpphy_ch2_txd, umux_disp0_phyclk_dpphy_ch2_txd_clk_user, "umux_disp0_phyclk_dpphy_ch2_txd_clk_user", 0, 0, NULL),
+	VCLK(dpphy_ch3_txd, umux_disp0_phyclk_dpphy_ch3_txd_clk_user, "umux_disp0_phyclk_dpphy_ch3_txd_clk_user", 0, 0, NULL),
+	VCLK(dptx_phy_i_ref_clk_24m, gate_disp0_oscclk_i_dptx_phy_i_ref_clk_24m, "gate_disp0_oscclk_i_dptx_phy_i_ref_clk_24m", 0, 0, NULL),
+	VCLK(mipi_dphy_m1s0, gate_disp0_oscclk_i_mipi_dphy_m1s0_m_xi, "gate_disp0_oscclk_i_mipi_dphy_m1s0_m_xi", 0, 0, NULL),
+	VCLK(mipi_dphy_m4s0, gate_disp0_oscclk_i_mipi_dphy_m4s0_m_xi, "gate_disp0_oscclk_i_mipi_dphy_m4s0_m_xi", 0, 0, NULL),
+	VCLK(mipi_dphy_m4s4, gate_disp0_oscclk_i_mipi_dphy_m4s4_m_xi, "gate_disp0_oscclk_i_mipi_dphy_m4s4_m_xi", 0, 0, NULL),
+	VCLK(phyclk_hdmiphy_tmds_20b, umux_disp0_phyclk_hdmiphy_tmds_clko_user, "umux_disp0_phyclk_hdmiphy_tmds_clko_user", 0, 0, NULL),
+	VCLK(phyclk_hdmiphy_pixel, umux_disp0_phyclk_hdmiphy_pixel_clko_user, "umux_disp0_phyclk_hdmiphy_pixel_clko_user", 0, 0, NULL),
+	VCLK(mipidphy0_bitclkdiv2_user, umux_disp0_phyclk_mipidphy0_bitclkdiv2_user, "umux_disp0_phyclk_mipidphy0_bitclkdiv2_user", 0, 0, NULL),
+	VCLK(mipidphy1_bitclkdiv2_user, umux_disp0_phyclk_mipidphy1_bitclkdiv2_user, "umux_disp0_phyclk_mipidphy1_bitclkdiv2_user", 0, 0, NULL),
+	VCLK(mipidphy2_bitclkdiv2_user, umux_disp0_phyclk_mipidphy2_bitclkdiv2_user, "umux_disp0_phyclk_mipidphy2_bitclkdiv2_user", 0, 0, NULL),
+	VCLK(CLK_VCLK_SYSMMU_DISP0, gate_disp0_sysmmu, "gate_disp0_sysmmu", 0, 0, NULL),
+};
+
+static struct init_vclk exynos8890_disp1_vclks[] __initdata = {
+	/* DISP1 */
+	VCLK(gate_decon1, gate_disp1_decon1, "gate_disp1_decon1", 0, 0, NULL),
+	VCLK(gate_hpmdisp1, gate_disp1_hpmdisp1, "gate_disp1_hpmdisp1", 0, 0, NULL),
+	/* special clock - sclk */
+	VCLK(decon1_eclk0, sclk_decon1_eclk0, "sclk_decon1_eclk0", 0, 0, NULL),
+	VCLK(decon1_eclk1, sclk_decon1_eclk1, "sclk_decon1_eclk1", 0, 0, NULL),
+	VCLK(decon1_eclk0_local, sclk_decon1_eclk0_local, "sclk_decon1_eclk0_local", 0, 0, NULL),
+	VCLK(decon1_eclk1_local, sclk_decon1_eclk1_local, "sclk_decon1_eclk1_local", 0, 0, NULL),
+	/* USERMUX related clock source */
+	VCLK(disp1_phyclk_mipidphy0_bitclkdiv2_user, umux_disp1_phyclk_mipidphy0_bitclkdiv2_user, "umux_disp1_phyclk_mipidphy0_bitclkdiv2_user", 0, 0, NULL),
+	VCLK(disp1_phyclk_mipidphy1_bitclkdiv2_user, umux_disp1_phyclk_mipidphy1_bitclkdiv2_user, "umux_disp1_phyclk_mipidphy1_bitclkdiv2_user", 0, 0, NULL),
+	VCLK(disp1_phyclk_mipidphy2_bitclkdiv2_user, umux_disp1_phyclk_mipidphy2_bitclkdiv2_user, "umux_disp1_phyclk_mipidphy2_bitclkdiv2_user", 0, 0, NULL),
+	VCLK(disp1_phyclk_disp1_hdmiphy_pixel_clko_user, umux_disp1_phyclk_disp1_hdmiphy_pixel_clko_user, "umux_disp1_phyclk_disp1_hdmiphy_pixel_clko_user", 0, 0, NULL),
+	VCLK(CLK_VCLK_SYSMMU_DISP1, gate_disp1_sysmmu, "gate_disp1_sysmmu", 0, 0, NULL),
+	VCLK(disp1_ppmu, gate_disp1_ppmu, "gate_disp1_ppmu", 0, 0, NULL),
+	VCLK(disp1_bts, gate_disp1_bts, "gate_disp1_bts", 0, 0, NULL),
+};
+
+void __init exynos8890_clk_init(struct device_node *np)
+{
+	struct samsung_clk_provider *ctx;
+	void __iomem *reg_base;
+	int ret;
+
+	BUILD_BUG_ON(mscl_jpeg != CLK_GATE_SMFC);
+
+	if (np) {
+		reg_base = of_iomap(np, 0);
+		if (!reg_base)
+			panic("%s: failed to map registers\n", __func__);
+	} else {
+		panic("%s: unable to determine soc\n", __func__);
+	}
+
+#if defined(CONFIG_ECT)
+	ect_parse_binary_header();
+#endif
+
+	ret = cal_init();
+	if (ret)
+		pr_err("%s: unable to initialize power cal\n", __func__);
+
+	ctx = samsung_clk_init(np, reg_base, nr_clks);
+	if (!ctx)
+		panic("%s: unable to allocate context.\n", __func__);
+
+	samsung_register_of_fixed_ext(ctx, exynos8890_fixed_rate_ext_clks,
+			ARRAY_SIZE(exynos8890_fixed_rate_ext_clks),
+			ext_clk_match);
+
+	/* Regist clock local IP */
+	samsung_register_vclk(ctx, exynos8890_audio_vclks, ARRAY_SIZE(exynos8890_audio_vclks));
+	samsung_register_vclk(ctx, exynos8890_cam0_vclks, ARRAY_SIZE(exynos8890_cam0_vclks));
+	samsung_register_vclk(ctx, exynos8890_cam1_vclks, ARRAY_SIZE(exynos8890_cam1_vclks));
+	samsung_register_vclk(ctx, exynos8890_disp0_vclks, ARRAY_SIZE(exynos8890_disp0_vclks));
+	samsung_register_vclk(ctx, exynos8890_disp1_vclks, ARRAY_SIZE(exynos8890_disp1_vclks));
+	samsung_register_vclk(ctx, exynos8890_fsys0_vclks, ARRAY_SIZE(exynos8890_fsys0_vclks));
+	samsung_register_vclk(ctx, exynos8890_fsys1_vclks, ARRAY_SIZE(exynos8890_fsys1_vclks));
+	samsung_register_vclk(ctx, exynos8890_g3d_vclks, ARRAY_SIZE(exynos8890_g3d_vclks));
+	samsung_register_vclk(ctx, exynos8890_imem_vclks, ARRAY_SIZE(exynos8890_imem_vclks));
+	samsung_register_vclk(ctx, exynos8890_isp0_vclks, ARRAY_SIZE(exynos8890_isp0_vclks));
+	samsung_register_vclk(ctx, exynos8890_isp1_vclks, ARRAY_SIZE(exynos8890_isp1_vclks));
+	samsung_register_vclk(ctx, exynos8890_isp_sensor_vclks, ARRAY_SIZE(exynos8890_isp1_vclks));
+	samsung_register_vclk(ctx, exynos8890_mfc_vclks, ARRAY_SIZE(exynos8890_mfc_vclks));
+	samsung_register_vclk(ctx, exynos8890_mscl_vclks, ARRAY_SIZE(exynos8890_mscl_vclks));
+	samsung_register_vclk(ctx, exynos8890_peric0_vclks, ARRAY_SIZE(exynos8890_peric0_vclks));
+	samsung_register_vclk(ctx, exynos8890_peric1_vclks, ARRAY_SIZE(exynos8890_peric1_vclks));
+	samsung_register_vclk(ctx, exynos8890_peris_vclks, ARRAY_SIZE(exynos8890_peris_vclks));
+	samsung_register_vclk(ctx, exynos8890_ccore_vclks, ARRAY_SIZE(exynos8890_ccore_vclks));
+	samsung_register_vclk(ctx, exynos8890_clkout_vclks, ARRAY_SIZE(exynos8890_clkout_vclks));
+
+	samsung_clk_of_add_provider(np, ctx);
+
+	clk_register_fixed_factor(NULL, "pwm-clock", "gate_peric0_pwm",CLK_SET_RATE_PARENT, 1, 1);
+
+	pr_info("EXYNOS8890: Clock setup completed\n");
+}
+CLK_OF_DECLARE(exynos8890_clks, "samsung,exynos8890-clock", exynos8890_clk_init);
diff -Naur linux-3.18.14/drivers/clk/samsung/clk-exynos-pwm.c samsung/drivers/clk/samsung/clk-exynos-pwm.c
--- linux-3.18.14/drivers/clk/samsung/clk-exynos-pwm.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/clk/samsung/clk-exynos-pwm.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,190 @@
+/*
+ * Copyright (c) 2013 Samsung Electronics Co., Ltd.
+ * Author: Hyunki Koo <hyunki00.koo@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Common Clock Framework support for pwm timer Clock Controller.
+*/
+
+#include <linux/clkdev.h>
+#include <linux/io.h>
+#include <linux/clk-provider.h>
+#include <linux/of_address.h>
+
+#include "clk.h"
+
+/* Each of the timers 0 through 5 go through the following
+ * clock tree, with the inputs depending on the timers.
+ *
+ * pclk ---- [ prescaler 0 ] -+---> timer 0
+ *			      +---> timer 1
+ *
+ * pclk ---- [ prescaler 1 ] -+---> timer 2
+ *			      +---> timer 3
+ *			      \---> timer 4
+ *
+ * Which are fed into the timers as so:
+ *
+ * prescaled 0 ---- [ div 2,4,8,16 ] ---\
+ *				       [mux] -> timer 0 (tin)
+ * tclk 0 ------------------------------/
+ *
+ * prescaled 0 ---- [ div 2,4,8,16 ] ---\
+ *				       [mux] -> timer 1 (tin)
+ * tclk 0 ------------------------------/
+ *
+ *
+ * prescaled 1 ---- [ div 2,4,8,16 ] ---\
+ *				       [mux] -> timer 2 (tin)
+ * tclk 1 ------------------------------/
+ *
+ * prescaled 1 ---- [ div 2,4,8,16 ] ---\
+ *				       [mux] -> timer 3 (tin)
+ * tclk 1 ------------------------------/
+ *
+ * prescaled 1 ---- [ div 2,4,8, 16 ] --\
+ *				       [mux] -> timer 4 (tin)
+ * tclk 1 ------------------------------/
+ *
+ * Since the mux and the divider are tied together in the
+ * same register space, it is impossible to set the parent
+ * and the rate at the same time. To avoid this, we add an
+ * intermediate 'prescaled-and-divided' clock to select
+ * as the parent for the timer input clock called tdiv.
+ *
+ * prescaled clk --> pwm-tdiv ---\
+ *                             [ mux ] --> timer X
+ * tclk -------------------------/
+ *
+ * tclk is deprecated in exynos
+ *
+*/
+
+static DEFINE_SPINLOCK(lock);
+static struct clk **clk_table;
+static struct clk_onecell_data clk_data;
+
+#define REG_TCFG0			0x00
+#define REG_TCFG1			0x04
+#define REG_TCON			0x08
+#define REG_TINT_CSTAT			0x44
+#define MASK_TCFG0_PRESCALE0		0x00FF
+#define MASK_TCFG0_PRESCALE1		0xFF00
+
+enum exynos_pwm_clks {
+	pwm_clock = 0,
+	pwm_scaler0,
+	pwm_scaler1,
+	pwm_tclk0,
+	pwm_tclk1,
+	pwm_tdiv0 = 5,
+	pwm_tdiv1,
+	pwm_tdiv2,
+	pwm_tdiv3,
+	pwm_tdiv4,
+	pwm_tin0 = 10,
+	pwm_tin1,
+	pwm_tin2,
+	pwm_tin3,
+	pwm_tin4,
+	exynos_pwm_max_clks,
+};
+
+static const char *pwm_tin0_p[] = { "pwm-tdiv0", "pwm-tclk" };
+static const char *pwm_tin1_p[] = { "pwm-tdiv1", "pwm-tclk" };
+static const char *pwm_tin2_p[] = { "pwm-tdiv2", "pwm-tclk" };
+static const char *pwm_tin3_p[] = { "pwm-tdiv3", "pwm-tclk" };
+static const char *pwm_tin4_p[] = { "pwm-tdiv4", "pwm-tclk" };
+
+static const struct clk_div_table pwm_div_table[5] = {
+	/* { val, div } */
+	{ 0, 1 },
+	{ 1, 2 },
+	{ 2, 4 },
+	{ 3, 8 },
+	{ 4, 16 },
+};
+
+/* register exynos_pwm clocks */
+void __init exynos_pwm_clk_init(struct device_node *np)
+{
+	static void __iomem *reg_base;
+	unsigned int reg_tcfg0;
+
+	reg_base = of_iomap(np, 0);
+
+	if (!reg_base) {
+		pr_err("%s: failed to map pwm registers\n", __func__);
+		return;
+	}
+
+	clk_table = kzalloc(sizeof(struct clk *) * exynos_pwm_max_clks,
+				GFP_KERNEL);
+	if (!clk_table) {
+		pr_err("%s: could not allocate clk lookup table\n", __func__);
+		return;
+	}
+
+	clk_data.clks = clk_table;
+	clk_data.clk_num = exynos_pwm_max_clks;
+	of_clk_add_provider(np, of_clk_src_onecell_get, &clk_data);
+
+	reg_tcfg0 = __raw_readl(reg_base + REG_TCFG0);
+	reg_tcfg0 &= ~(MASK_TCFG0_PRESCALE0 | MASK_TCFG0_PRESCALE1);
+	__raw_writel(reg_tcfg0, reg_base + REG_TCFG0);
+	__raw_writel(0, reg_base + REG_TCFG1);
+
+	clk_table[pwm_scaler0] = clk_register_divider(NULL, "pwm-scaler0",
+				"pwm-clock", 0, reg_base + REG_TCFG0, 0, 8,
+				CLK_DIVIDER_ALLOW_ZERO, &lock);
+	clk_table[pwm_scaler1] = clk_register_divider(NULL, "pwm-scaler1",
+				"pwm-clock", 0, reg_base + REG_TCFG0, 8, 8,
+				CLK_DIVIDER_ALLOW_ZERO, &lock);
+
+	clk_table[pwm_tdiv0] = clk_register_divider_table(NULL, "pwm-tdiv0",
+				"pwm-scaler0", 0, reg_base + REG_TCFG1, 0, 4,
+				CLK_DIVIDER_ALLOW_ZERO, pwm_div_table, &lock);
+
+	clk_table[pwm_tdiv1] = clk_register_divider_table(NULL, "pwm-tdiv1",
+				"pwm-scaler0", 0, reg_base + REG_TCFG1, 4, 4,
+				CLK_DIVIDER_ALLOW_ZERO, pwm_div_table, &lock);
+
+	clk_table[pwm_tdiv2] = clk_register_divider_table(NULL, "pwm-tdiv2",
+				"pwm-scaler1", 0, reg_base + REG_TCFG1, 8, 4,
+				CLK_DIVIDER_ALLOW_ZERO, pwm_div_table, &lock);
+
+	clk_table[pwm_tdiv3] = clk_register_divider_table(NULL, "pwm-tdiv3",
+				"pwm-scaler1", 0, reg_base + REG_TCFG1, 12, 4,
+				CLK_DIVIDER_ALLOW_ZERO, pwm_div_table, &lock);
+
+	clk_table[pwm_tdiv4] = clk_register_divider_table(NULL, "pwm-tdiv4",
+				"pwm-scaler1", 0, reg_base + REG_TCFG1, 16, 4,
+				CLK_DIVIDER_ALLOW_ZERO, pwm_div_table, &lock);
+
+	clk_table[pwm_tin0] = clk_register_mux(NULL, "pwm-tin0",
+				pwm_tin0_p, ARRAY_SIZE(pwm_tin0_p), 0,
+				reg_base + REG_TCFG1, 3, 0, 0, &lock);
+
+	clk_table[pwm_tin1] = clk_register_mux(NULL, "pwm-tin1",
+				pwm_tin1_p, ARRAY_SIZE(pwm_tin1_p), 0,
+				reg_base + REG_TCFG1, 7, 0, 0, &lock);
+
+	clk_table[pwm_tin2] = clk_register_mux(NULL, "pwm-tin2",
+				pwm_tin2_p, ARRAY_SIZE(pwm_tin2_p), 0,
+				reg_base + REG_TCFG1, 11, 0, 0, &lock);
+
+	clk_table[pwm_tin3] = clk_register_mux(NULL, "pwm-tin3",
+				pwm_tin3_p, ARRAY_SIZE(pwm_tin3_p), 0,
+				reg_base + REG_TCFG1, 15, 0, 0, &lock);
+
+	clk_table[pwm_tin4] = clk_register_mux(NULL, "pwm-tin4",
+				pwm_tin4_p, ARRAY_SIZE(pwm_tin4_p), 0,
+				reg_base + REG_TCFG1, 19, 0, 0, &lock);
+
+	pr_info("Exynos: pwm: clock setup completed\n");
+}
+CLK_OF_DECLARE(exynos_pwm_clk, "samsung,exynos-pwm-clock",
+		exynos_pwm_clk_init);
diff -Naur linux-3.18.14/drivers/clk/samsung/composite.c samsung/drivers/clk/samsung/composite.c
--- linux-3.18.14/drivers/clk/samsung/composite.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/clk/samsung/composite.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,1620 @@
+/*
+ * Copyright (c) 2014 Samsung Electronics Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This file contains the utility functions for composite clocks.
+ */
+
+#include <linux/syscore_ops.h>
+#include <linux/errno.h>
+#include <linux/clk-private.h>
+#include <linux/log2.h>
+#include <linux/of.h>
+#include <linux/exynos-ss.h>
+#include <linux/delay.h>
+#include "composite.h"
+#include "../../soc/samsung/pwrcal/pwrcal.h"
+
+#define PLL_STAT_OSC	(0x0)
+#define PLL_STAT_PLL	(0x1)
+#define PLL_STAT_CHANGE	(0x4)
+#define PLL_STAT_MASK	(0x7)
+
+#define to_comp_pll(_hw) container_of(_hw, struct samsung_composite_pll, hw)
+#define to_comp_mux(_hw) container_of(_hw, struct samsung_composite_mux, hw)
+#define to_comp_divider(_hw) container_of(_hw, struct samsung_composite_divider, hw)
+#define to_usermux(_hw) container_of(_hw, struct clk_samsung_usermux, hw)
+#define to_vclk(_hw) container_of(_hw, struct samsung_vclk, hw)
+
+static DEFINE_SPINLOCK(lock);
+
+#ifdef CONFIG_PM_SLEEP
+void samsung_clk_save(void __iomem *base,
+				    struct samsung_clk_reg_dump *rd,
+				    unsigned int num_regs)
+{
+	for (; num_regs > 0; --num_regs, ++rd)
+		rd->value = readl(base + rd->offset);
+}
+
+void samsung_clk_restore(void __iomem *base,
+				      const struct samsung_clk_reg_dump *rd,
+				      unsigned int num_regs)
+{
+	for (; num_regs > 0; --num_regs, ++rd)
+		writel(rd->value, base + rd->offset);
+}
+
+struct samsung_clk_reg_dump *samsung_clk_alloc_reg_dump(
+						const unsigned long *rdump,
+						unsigned long nr_rdump)
+{
+	struct samsung_clk_reg_dump *rd;
+	unsigned int i;
+
+	rd = kcalloc(nr_rdump, sizeof(*rd), GFP_KERNEL);
+	if (!rd)
+		return NULL;
+
+	for (i = 0; i < nr_rdump; ++i)
+		rd[i].offset = rdump[i];
+
+	return rd;
+}
+#endif /* CONFIG_PM_SLEEP */
+
+/* setup the essentials required to support clock lookup using ccf */
+struct samsung_clk_provider *__init samsung_clk_init(struct device_node *np,
+			void __iomem *base, unsigned long nr_clks)
+{
+	struct samsung_clk_provider *ctx;
+	struct clk **clk_table;
+	int i;
+
+	if (!np)
+		return NULL;
+
+	ctx = kzalloc(sizeof(struct samsung_clk_provider), GFP_KERNEL);
+	if (!ctx)
+		panic("could not allocate clock provider context.\n");
+
+	clk_table = kcalloc(nr_clks, sizeof(struct clk *), GFP_KERNEL);
+	if (!clk_table)
+		panic("could not allocate clock lookup table\n");
+
+	for (i = 0; i < nr_clks; ++i)
+		clk_table[i] = ERR_PTR(-ENOENT);
+
+	ctx->reg_base = base;
+	ctx->clk_data.clks = clk_table;
+	ctx->clk_data.clk_num = nr_clks;
+	spin_lock_init(&ctx->lock);
+
+	return ctx;
+}
+
+void __init samsung_clk_of_add_provider(struct device_node *np,
+				struct samsung_clk_provider *ctx)
+{
+	if (np) {
+		if (of_clk_add_provider(np, of_clk_src_onecell_get,
+					&ctx->clk_data))
+			panic("could not register clk provider\n");
+	}
+}
+
+/* add a clock instance to the clock lookup table used for dt based lookup */
+static void samsung_clk_add_lookup(struct samsung_clk_provider *ctx, struct clk *clk,
+					unsigned int id)
+{
+	if (ctx->clk_data.clks && id)
+		ctx->clk_data.clks[id] = clk;
+}
+
+/* register a list of fixed clocks */
+void __init samsung_register_fixed_rate(struct samsung_clk_provider *ctx,
+		struct samsung_fixed_rate *list, unsigned int nr_clk)
+{
+	struct clk *clk;
+	unsigned int idx, ret;
+
+	for (idx = 0; idx < nr_clk; idx++, list++) {
+		clk = clk_register_fixed_rate(NULL, list->name,
+			list->parent_name, list->flags, list->fixed_rate);
+		if (IS_ERR(clk)) {
+			pr_err("%s: failed to register clock %s\n", __func__,
+				list->name);
+			continue;
+		}
+
+		samsung_clk_add_lookup(ctx, clk, list->id);
+
+		/*
+		 * Unconditionally add a clock lookup for the fixed rate clocks.
+		 * There are not many of these on any of Samsung platforms.
+		 */
+		ret = clk_register_clkdev(clk, list->name, NULL);
+		if (ret)
+			pr_err("%s: failed to register clock lookup for %s",
+				__func__, list->name);
+	}
+}
+
+/* register a list of fixed factor clocks */
+void __init samsung_register_fixed_factor(struct samsung_clk_provider *ctx,
+		struct samsung_fixed_factor *list, unsigned int nr_clk)
+{
+	struct clk *clk;
+	unsigned int idx, ret;
+
+	for (idx = 0; idx < nr_clk; idx++, list++) {
+		clk = clk_register_fixed_factor(NULL, list->name,
+			list->parent_name, list->flags, list->mult, list->div);
+		if (IS_ERR(clk)) {
+			pr_err("%s: failed to register clock %s\n", __func__,
+				list->name);
+			continue;
+		}
+
+		samsung_clk_add_lookup(ctx, clk, list->id);
+
+		ret = clk_register_clkdev(clk, list->name, NULL);
+		if (ret)
+			pr_err("%s: failed to register clock lookup for %s",
+				__func__, list->name);
+	}
+}
+
+/*
+ * obtain the clock speed of all external fixed clock sources from device
+ * tree and register it
+ */
+void __init samsung_register_of_fixed_ext(struct samsung_clk_provider *ctx,
+			struct samsung_fixed_rate *fixed_rate_clk,
+			unsigned int nr_fixed_rate_clk,
+			struct of_device_id *clk_matches)
+{
+	const struct of_device_id *match;
+	struct device_node *np;
+	u32 freq;
+
+	for_each_matching_node_and_match(np, clk_matches, &match) {
+		if (of_property_read_u32(np, "clock-frequency", &freq))
+			continue;
+		fixed_rate_clk[(unsigned long)match->data].fixed_rate = freq;
+	}
+	samsung_register_fixed_rate(ctx, fixed_rate_clk, nr_fixed_rate_clk);
+}
+
+/* operation functions for pll clocks */
+static const struct samsung_pll_rate_table *samsung_get_pll_settings(
+				struct samsung_composite_pll *pll, unsigned long rate)
+{
+	const struct samsung_pll_rate_table  *rate_table = pll->rate_table;
+	int i;
+
+	for (i = 0; i < pll->rate_count; i++) {
+		if (rate == rate_table[i].rate)
+			return &rate_table[i];
+	}
+
+	return NULL;
+}
+
+static long samsung_pll_round_rate(struct clk_hw *hw,
+			unsigned long drate, unsigned long *prate)
+{
+	struct samsung_composite_pll *pll = to_comp_pll(hw);
+	const struct samsung_pll_rate_table *rate_table = pll->rate_table;
+	int i;
+
+	/* Assumming rate_table is in descending order */
+	for (i = 0; i < pll->rate_count; i++) {
+		if (drate >= rate_table[i].rate)
+			return rate_table[i].rate;
+	}
+
+	/* return minimum supported value */
+	return rate_table[i - 1].rate;
+}
+
+static int samsung_composite_pll_is_enabled(struct clk_hw *hw)
+{
+	struct samsung_composite_pll *pll = to_comp_pll(hw);
+	int set = pll->pll_flag & PLL_BYPASS ? 0 : 1;
+	unsigned int reg;
+
+	reg = readl(pll->enable_reg);
+
+	return (((reg >> pll->enable_bit) & 1) == set) ? 1 : 0;
+}
+
+static int samsung_composite_pll_enable(struct clk_hw *hw)
+{
+	struct samsung_composite_pll *pll = to_comp_pll(hw);
+	int set = pll->pll_flag & PLL_BYPASS ? 0 : 1;
+	unsigned int reg;
+
+	/* Setting Enable register */
+	reg = readl(pll->enable_reg);
+	if (set)
+		reg |= (1 << pll->enable_bit);
+	else
+		reg &= ~(1 << pll->enable_bit);
+	writel(reg, pll->enable_reg);
+
+	/* setting CTRL mux register to 1 */
+	reg = readl(pll->sel_reg);
+	reg |= (1 << pll->sel_bit);
+	writel(reg, pll->sel_reg);
+
+	/* check status for mux setting */
+	do {
+		cpu_relax();
+		reg = readl(pll->stat_reg);
+	} while (((reg >> pll->stat_bit) & PLL_STAT_MASK) != PLL_STAT_PLL);
+
+	return 0;
+}
+
+static void samsung_composite_pll_disable(struct clk_hw *hw)
+{
+	struct samsung_composite_pll *pll = to_comp_pll(hw);
+	int set = pll->pll_flag & PLL_BYPASS ? 0 : 1;
+	unsigned int reg;
+
+	/* setting CTRL mux register to 0 */
+	reg = readl(pll->sel_reg);
+	reg &= ~(1 << pll->sel_bit);
+	writel(reg, pll->sel_reg);
+
+	/* check status for mux setting */
+	do {
+		cpu_relax();
+		reg = readl(pll->stat_reg);
+	} while (((reg >> pll->stat_bit) & PLL_STAT_MASK) != PLL_STAT_OSC);
+
+	/* Setting Register */
+	reg = readl(pll->enable_reg);
+	if (set)
+		reg &= ~(1 << pll->enable_bit);
+	else
+		reg |= (1 << pll->enable_bit);
+
+	writel(reg, pll->enable_reg);
+}
+
+static unsigned long samsung_pll145xx_recalc_rate(struct clk_hw *hw,
+				unsigned long parent_rate)
+{
+	struct samsung_composite_pll *pll = to_comp_pll(hw);
+	u32 mdiv, pdiv, sdiv, pll_con;
+	u64 fvco = parent_rate;
+
+	pll_con = readl(pll->con_reg);
+	mdiv = (pll_con >> PLL145XX_MDIV_SHIFT) & PLL145XX_MDIV_MASK;
+	pdiv = (pll_con >> PLL145XX_PDIV_SHIFT) & PLL145XX_PDIV_MASK;
+	sdiv = (pll_con >> PLL145XX_SDIV_SHIFT) & PLL145XX_SDIV_MASK;
+	/* Do calculation */
+	fvco *= mdiv;
+	do_div(fvco, (pdiv << sdiv));
+
+	return (unsigned long)fvco;
+}
+
+static inline bool samsung_pll145xx_mp_check(u32 mdiv, u32 pdiv, u32 pll_con)
+{
+	return ((mdiv != ((pll_con >> PLL145XX_MDIV_SHIFT) & PLL145XX_MDIV_MASK)) ||
+		(pdiv != ((pll_con >> PLL145XX_PDIV_SHIFT) & PLL145XX_PDIV_MASK)));
+}
+
+static int samsung_pll145xx_set_rate(struct clk_hw *hw, unsigned long drate,
+					unsigned long prate)
+{
+	struct samsung_composite_pll *pll = to_comp_pll(hw);
+	const struct samsung_pll_rate_table *rate;
+	u32 pll_con;
+
+	rate = samsung_get_pll_settings(pll, drate);
+	if (!rate) {
+		pr_err("%s: Invalid rate : %lu for pll clk %s\n", __func__,
+				drate, __clk_get_name(hw->clk));
+		return -EINVAL;
+	}
+
+	pll_con = readl(pll->con_reg);
+	if (!(samsung_pll145xx_mp_check(rate->mdiv, rate->pdiv, pll_con))) {
+		if ((rate->sdiv) == ((pll_con >> PLL145XX_SDIV_SHIFT) & PLL145XX_SDIV_MASK))
+			return 0;
+		/* In the case of changing S value only */
+		pll_con &= ~(PLL145XX_SDIV_MASK << PLL145XX_SDIV_SHIFT);
+		pll_con |= rate->sdiv << PLL145XX_SDIV_SHIFT;
+		writel(pll_con, pll->con_reg);
+
+		return 0;
+	}
+
+	/* Set PLL lock time */
+	writel(rate->pdiv * PLL145XX_LOCK_FACTOR, pll->lock_reg);
+	/* Change PLL PMS values */
+	pll_con &= ~((PLL145XX_MDIV_MASK << PLL145XX_MDIV_SHIFT) |
+			(PLL145XX_PDIV_MASK << PLL145XX_PDIV_SHIFT) |
+			(PLL145XX_SDIV_MASK << PLL145XX_SDIV_SHIFT));
+	pll_con |= (rate->mdiv << PLL145XX_MDIV_SHIFT) |
+			(rate->pdiv << PLL145XX_PDIV_SHIFT) |
+			(rate->sdiv << PLL145XX_SDIV_SHIFT);
+	/* To prevent instable PLL operation, preset ENABLE bit with 0 */
+	pll_con &= ~BIT(31);
+	writel(pll_con, pll->con_reg);
+
+	/* Set enable bit */
+	pll_con |= BIT(31);
+	writel(pll_con, pll->con_reg);
+
+	do {
+		cpu_relax();
+		pll_con = readl(pll->con_reg);
+	} while (!(pll_con & (PLL145XX_LOCKED_MASK << PLL145XX_LOCKED_SHIFT)));
+
+	return 0;
+}
+
+
+static unsigned long samsung_pll1460x_recalc_rate(struct clk_hw *hw,
+				unsigned long parent_rate)
+{
+	struct samsung_composite_pll *pll = to_comp_pll(hw);
+	u32 mdiv, pdiv, sdiv, pll_con0, pll_con1;
+	s16 kdiv;
+	u64 fvco = parent_rate;
+
+	pll_con0 = readl(pll->con_reg);
+	pll_con1 = readl(pll->con_reg + 4);
+	mdiv = (pll_con0 >> PLL1460X_MDIV_SHIFT) & PLL1460X_MDIV_MASK;
+	pdiv = (pll_con0 >> PLL1460X_PDIV_SHIFT) & PLL1460X_PDIV_MASK;
+	sdiv = (pll_con0 >> PLL1460X_SDIV_SHIFT) & PLL1460X_SDIV_MASK;
+	kdiv = (s16)((pll_con1 >> PLL1460X_KDIV_SHIFT) & PLL1460X_KDIV_MASK);
+	/* Do calculation */
+	fvco *= (mdiv << 16) + kdiv;
+	do_div(fvco, (pdiv << sdiv));
+	fvco >>= 16;
+
+	return (unsigned long)fvco;
+}
+
+static inline bool samsung_pll1460x_mpk_check(u32 mdiv, u32 pdiv, u32 kdiv, u32 pll_con0, u32 pll_con1)
+{
+	return ((mdiv != ((pll_con0 >> PLL1460X_MDIV_SHIFT) & PLL1460X_MDIV_MASK)) ||
+		(pdiv != ((pll_con0 >> PLL1460X_PDIV_SHIFT) & PLL1460X_PDIV_MASK)) ||
+		(kdiv != ((pll_con1 >> PLL1460X_KDIV_SHIFT) & PLL1460X_KDIV_MASK)));
+}
+
+static int samsung_pll1460x_set_rate(struct clk_hw *hw, unsigned long drate,
+					unsigned long parent_rate)
+{
+	struct samsung_composite_pll *pll = to_comp_pll(hw);
+	u32 pll_con0, pll_con1;
+	const struct samsung_pll_rate_table *rate;
+
+	rate = samsung_get_pll_settings(pll, drate);
+	if (!rate) {
+		pr_err("%s: Invalid rate : %lu for pll clk %s\n", __func__,
+				drate, __clk_get_name(hw->clk));
+		return -EINVAL;
+	}
+
+	pll_con0 = readl(pll->con_reg);
+	pll_con1 = readl(pll->con_reg + 4);
+	if (!(samsung_pll1460x_mpk_check(rate->mdiv, rate->pdiv, rate->kdiv, pll_con0, pll_con1))) {
+		if ((rate->sdiv) == ((pll_con0 >> PLL1460X_SDIV_SHIFT) & PLL1460X_SDIV_MASK))
+			return 0;
+		/* In the case of changing S value only */
+		pll_con0 &= ~(PLL1460X_SDIV_MASK << PLL1460X_SDIV_SHIFT);
+		pll_con0 |= (rate->sdiv << PLL1460X_SDIV_SHIFT);
+		writel(pll_con0, pll->con_reg);
+
+		return 0;
+	}
+
+	/* Set PLL lock time */
+	writel(rate->pdiv * PLL1460X_LOCK_FACTOR, pll->lock_reg);
+
+	pll_con1 &= ~(PLL1460X_KDIV_MASK << PLL1460X_KDIV_SHIFT);
+	pll_con1 |= (rate->kdiv << PLL1460X_KDIV_SHIFT);
+	writel(pll_con1, pll->con_reg + 4);
+
+	pll_con0 &= ~((PLL1460X_MDIV_MASK << PLL1460X_MDIV_SHIFT) |
+			(PLL1460X_PDIV_MASK << PLL1460X_PDIV_SHIFT) |
+			(PLL1460X_SDIV_MASK << PLL1460X_SDIV_SHIFT));
+	pll_con0 |= (rate->mdiv << PLL1460X_MDIV_SHIFT) |
+			(rate->pdiv << PLL1460X_PDIV_SHIFT) |
+			(rate->sdiv << PLL1460X_SDIV_SHIFT);
+	/* To prevent instable PLL operation, preset ENABLE bit with 0 */
+	pll_con0 &= ~BIT(31);
+	writel(pll_con0, pll->con_reg);
+
+	/* Set enable bit */
+	pll_con0 |= BIT(31);
+	writel(pll_con0, pll->con_reg);
+
+	/* Wait lock time */
+	do {
+		cpu_relax();
+		pll_con0 = readl(pll->con_reg);
+	} while (!(pll_con0 & (PLL1460X_LOCKED_MASK << PLL1460X_LOCKED_SHIFT)));
+
+	return 0;
+}
+
+static const struct clk_ops samsung_pll145xx_clk_ops = {
+	.recalc_rate = samsung_pll145xx_recalc_rate,
+	.set_rate = samsung_pll145xx_set_rate,
+	.round_rate = samsung_pll_round_rate,
+	.enable = samsung_composite_pll_enable,
+	.disable = samsung_composite_pll_disable,
+	.is_enabled = samsung_composite_pll_is_enabled,
+};
+
+static const struct clk_ops samsung_pll1460x_clk_ops = {
+	.recalc_rate = samsung_pll1460x_recalc_rate,
+	.set_rate = samsung_pll1460x_set_rate,
+	.round_rate = samsung_pll_round_rate,
+	.enable = samsung_composite_pll_enable,
+	.disable = samsung_composite_pll_disable,
+	.is_enabled = samsung_composite_pll_is_enabled,
+};
+
+static int samsung_composite_pll_enable_onchange(struct clk_hw *hw)
+{
+	struct samsung_composite_pll *pll = to_comp_pll(hw);
+	int set = pll->pll_flag & PLL_BYPASS ? 0 : 1;
+	unsigned int reg;
+
+	/* Setting Enable register */
+	reg = readl(pll->enable_reg);
+	if (set)
+		reg |= (1 << pll->enable_bit);
+	else
+		reg &= ~(1 << pll->enable_bit);
+	writel(reg, pll->enable_reg);
+
+	/* setting CTRL mux register to 1 */
+	reg = readl(pll->sel_reg);
+	reg |= (1 << pll->sel_bit);
+	writel(reg, pll->sel_reg);
+
+	/* check status for mux setting */
+	do {
+		cpu_relax();
+		reg = readl(pll->stat_reg);
+	} while (((reg >> pll->stat_bit) & PLL_STAT_MASK) == PLL_STAT_CHANGE);
+
+	return 0;
+}
+
+static void samsung_composite_pll_disable_onchange(struct clk_hw *hw)
+{
+	struct samsung_composite_pll *pll = to_comp_pll(hw);
+	int set = pll->pll_flag & PLL_BYPASS ? 0 : 1;
+	unsigned int reg;
+
+	/* setting CTRL mux register to 0 */
+	reg = readl(pll->sel_reg);
+	reg &= ~(1 << pll->sel_bit);
+	writel(reg, pll->sel_reg);
+
+	/* check status for mux setting */
+	do {
+		cpu_relax();
+		reg = readl(pll->stat_reg);
+	} while (((reg >> pll->stat_bit) & PLL_STAT_MASK) == PLL_STAT_CHANGE);
+
+	/* Setting Register */
+	reg = readl(pll->enable_reg);
+	if (set)
+		reg &= ~(1 << pll->enable_bit);
+	else
+		reg |= (1 << pll->enable_bit);
+
+	writel(reg, pll->enable_reg);
+}
+
+static unsigned long samsung_pll255xx_recalc_rate(struct clk_hw *hw,
+				unsigned long parent_rate)
+{
+	struct samsung_composite_pll *pll = to_comp_pll(hw);
+	u32 mdiv, pdiv, sdiv, pll_con;
+	u64 fvco = parent_rate;
+
+	pll_con = readl(pll->con_reg);
+	mdiv = (pll_con >> PLL255XX_MDIV_SHIFT) & PLL255XX_MDIV_MASK;
+	pdiv = (pll_con >> PLL255XX_PDIV_SHIFT) & PLL255XX_PDIV_MASK;
+	sdiv = (pll_con >> PLL255XX_SDIV_SHIFT) & PLL255XX_SDIV_MASK;
+	/* Do calculation */
+	fvco *= mdiv;
+	do_div(fvco, (pdiv << sdiv));
+
+	return (unsigned long)fvco;
+}
+
+static inline bool samsung_pll255xx_mp_check(u32 mdiv, u32 pdiv, u32 pll_con)
+{
+	return ((mdiv != ((pll_con >> PLL255XX_MDIV_SHIFT) & PLL255XX_MDIV_MASK)) ||
+		(pdiv != ((pll_con >> PLL255XX_PDIV_SHIFT) & PLL255XX_PDIV_MASK)));
+}
+
+static int samsung_pll255xx_set_rate(struct clk_hw *hw, unsigned long drate,
+					unsigned long prate)
+{
+	struct samsung_composite_pll *pll = to_comp_pll(hw);
+	const struct samsung_pll_rate_table *rate;
+	u32 pll_con;
+
+	rate = samsung_get_pll_settings(pll, drate);
+	if (!rate) {
+		pr_err("%s: Invalid rate : %lu for pll clk %s\n", __func__,
+				drate, __clk_get_name(hw->clk));
+		return -EINVAL;
+	}
+
+	pll_con = readl(pll->con_reg);
+	if (!(samsung_pll255xx_mp_check(rate->mdiv, rate->pdiv, pll_con))) {
+		if ((rate->sdiv) == ((pll_con >> PLL255XX_SDIV_SHIFT) & PLL255XX_SDIV_MASK))
+			return 0;
+		/* In the case of changing S value only */
+		pll_con &= ~(PLL255XX_SDIV_MASK << PLL255XX_SDIV_SHIFT);
+		pll_con |= rate->sdiv << PLL255XX_SDIV_SHIFT;
+		writel(pll_con, pll->con_reg);
+
+		return 0;
+	}
+
+	/* Set PLL lock time */
+	writel(rate->pdiv * PLL255XX_LOCK_FACTOR, pll->lock_reg);
+	/* Change PLL PMS values */
+	pll_con &= ~((PLL255XX_MDIV_MASK << PLL255XX_MDIV_SHIFT) |
+			(PLL255XX_PDIV_MASK << PLL255XX_PDIV_SHIFT) |
+			(PLL255XX_SDIV_MASK << PLL255XX_SDIV_SHIFT));
+	pll_con |= (rate->mdiv << PLL255XX_MDIV_SHIFT) |
+			(rate->pdiv << PLL255XX_PDIV_SHIFT) |
+			(rate->sdiv << PLL255XX_SDIV_SHIFT);
+
+	/* To prevent unstable PLL operation, preset enable bit with 0 */
+	pll_con &= ~BIT(31);
+	writel(pll_con, pll->con_reg);
+
+	/* Set enable bit */
+	pll_con |= BIT(31);
+	writel(pll_con, pll->con_reg);
+
+	do {
+		cpu_relax();
+		pll_con = readl(pll->con_reg);
+	} while (!(pll_con & (PLL255XX_LOCKED_MASK << PLL255XX_LOCKED_SHIFT)));
+
+	return 0;
+}
+
+/* register function for pll clocks */
+static const struct clk_ops samsung_pll255xx_clk_ops = {
+	.recalc_rate = samsung_pll255xx_recalc_rate,
+	.set_rate = samsung_pll255xx_set_rate,
+	.round_rate = samsung_pll_round_rate,
+	.enable = samsung_composite_pll_enable_onchange,
+	.disable = samsung_composite_pll_disable_onchange,
+	.is_enabled = samsung_composite_pll_is_enabled,
+};
+
+static unsigned long samsung_pll2650x_recalc_rate(struct clk_hw *hw,
+				unsigned long parent_rate)
+{
+	struct samsung_composite_pll *pll = to_comp_pll(hw);
+	u32 mdiv, pdiv, sdiv, pll_con0, pll_con1;
+	s16 kdiv;
+	u64 fvco = parent_rate;
+
+	pll_con0 = readl(pll->con_reg);
+	pll_con1 = readl(pll->con_reg + 4);
+	mdiv = (pll_con0 >> PLL2650X_MDIV_SHIFT) & PLL2650X_MDIV_MASK;
+	pdiv = (pll_con0 >> PLL2650X_PDIV_SHIFT) & PLL2650X_PDIV_MASK;
+	sdiv = (pll_con0 >> PLL2650X_SDIV_SHIFT) & PLL2650X_SDIV_MASK;
+	kdiv = (s16)((pll_con1 >> PLL2650X_KDIV_SHIFT) & PLL2650X_KDIV_MASK);
+	/* Do calculation */
+	fvco *= (mdiv << 16) + kdiv;
+	do_div(fvco, (pdiv << sdiv));
+	fvco >>= 16;
+
+	return (unsigned long)fvco;
+}
+
+static inline bool samsung_pll2650x_mpk_check(u32 mdiv, u32 pdiv, u32 kdiv, u32 pll_con0, u32 pll_con1)
+{
+	return ((mdiv != ((pll_con0 >> PLL2650X_MDIV_SHIFT) & PLL2650X_MDIV_MASK)) ||
+		(pdiv != ((pll_con0 >> PLL2650X_PDIV_SHIFT) & PLL2650X_PDIV_MASK)) ||
+		(kdiv != ((pll_con1 >> PLL2650X_KDIV_SHIFT) & PLL2650X_KDIV_MASK)));
+}
+
+static int samsung_pll2650x_set_rate(struct clk_hw *hw, unsigned long drate,
+					unsigned long parent_rate)
+{
+	struct samsung_composite_pll *pll = to_comp_pll(hw);
+	u32 pll_con0, pll_con1;
+	const struct samsung_pll_rate_table *rate;
+
+	rate = samsung_get_pll_settings(pll, drate);
+	if (!rate) {
+		pr_err("%s: Invalid rate : %lu for pll clk %s\n", __func__,
+				drate, __clk_get_name(hw->clk));
+		return -EINVAL;
+	}
+
+	pll_con0 = readl(pll->con_reg);
+	pll_con1 = readl(pll->con_reg + 4);
+	if (!(samsung_pll2650x_mpk_check(rate->mdiv, rate->pdiv, rate->kdiv, pll_con0, pll_con1))) {
+		if ((rate->sdiv) == ((pll_con0 >> PLL2650X_SDIV_SHIFT) & PLL2650X_SDIV_MASK))
+			return 0;
+		/* In the case of changing S value only */
+		pll_con0 &= ~(PLL2650X_SDIV_MASK << PLL2650X_SDIV_SHIFT);
+		pll_con0 |= (rate->sdiv << PLL2650X_SDIV_SHIFT);
+		writel(pll_con0, pll->con_reg);
+
+		return 0;
+	}
+
+	/* Set PLL lock time */
+	writel(rate->pdiv * PLL2650X_LOCK_FACTOR, pll->lock_reg);
+
+	pll_con1 &= ~(PLL2650X_KDIV_MASK << PLL2650X_KDIV_SHIFT);
+	pll_con1 |= (rate->kdiv << PLL2650X_KDIV_SHIFT);
+	writel(pll_con1, pll->con_reg + 4);
+
+	pll_con0 &= ~((PLL2650X_MDIV_MASK << PLL2650X_MDIV_SHIFT) |
+			(PLL2650X_PDIV_MASK << PLL2650X_PDIV_SHIFT) |
+			(PLL2650X_SDIV_MASK << PLL2650X_SDIV_SHIFT));
+	pll_con0 |= (rate->mdiv << PLL2650X_MDIV_SHIFT) |
+			(rate->pdiv << PLL2650X_PDIV_SHIFT) |
+			(rate->sdiv << PLL2650X_SDIV_SHIFT);
+
+	/* To prevent unstable PLL operation, preset enable bit with 0 */
+	pll_con0 &= ~BIT(31);
+	writel(pll_con0, pll->con_reg);
+
+	/* Set enable bit */
+	pll_con0 |= BIT(31);
+	writel(pll_con0, pll->con_reg);
+
+	/*
+	 * Wait lock time
+	 * unit address translation : us to ms for mdelay
+	 */
+	mdelay(rate->pdiv * PLL2650X_LOCK_FACTOR / 1000);
+
+	return 0;
+}
+
+static const struct clk_ops samsung_pll2650x_clk_ops = {
+	.recalc_rate = samsung_pll2650x_recalc_rate,
+	.set_rate = samsung_pll2650x_set_rate,
+	.round_rate = samsung_pll_round_rate,
+	.enable = samsung_composite_pll_enable_onchange,
+	.disable = samsung_composite_pll_disable_onchange,
+	.is_enabled = samsung_composite_pll_is_enabled,
+};
+
+/* register function for pll clocks */
+static void _samsung_register_comp_pll(struct samsung_clk_provider *ctx,
+				struct samsung_composite_pll *list)
+{
+	struct clk *clk;
+	static const char *pname[1] = {"fin_pll"};
+	int len;
+	unsigned int ret = 0;
+
+	if (list->rate_table) {
+		/* find count of rates in rate_table */
+		for (len = 0; list->rate_table[len].rate != 0; )
+			len++;
+		list->rate_count = len; }
+	else
+		list->rate_count = 0;
+
+	if (list->type == pll_1450x)
+		clk = clk_register_composite(NULL, list->name, pname, 1,
+				NULL, NULL,
+				&list->hw, &samsung_pll145xx_clk_ops,
+				&list->hw, &samsung_pll145xx_clk_ops, list->flag);
+	else if (list->type == pll_1451x || list->type == pll_1452x)
+		clk = clk_register_composite(NULL, list->name, pname, 1,
+				NULL, NULL,
+				&list->hw, &samsung_pll145xx_clk_ops,
+				&list->hw, &samsung_pll145xx_clk_ops, list->flag);
+	else if (list->type == pll_1460x)
+		clk = clk_register_composite(NULL, list->name, pname, 1,
+				NULL, NULL,
+				&list->hw, &samsung_pll1460x_clk_ops,
+				&list->hw, &samsung_pll1460x_clk_ops, list->flag);
+	else if (list->type == pll_2551x || list->type == pll_2555x)
+		clk = clk_register_composite(NULL, list->name, pname, 1,
+				NULL, NULL,
+				&list->hw, &samsung_pll255xx_clk_ops,
+				&list->hw, &samsung_pll255xx_clk_ops, list->flag);
+	else if (list->type == pll_2650x)
+		clk = clk_register_composite(NULL, list->name, pname, 1,
+				NULL, NULL,
+				&list->hw, &samsung_pll2650x_clk_ops,
+				&list->hw, &samsung_pll2650x_clk_ops, list->flag);
+	else {
+		pr_err("%s: invalid pll type %d\n", __func__, list->type);
+		return;
+	}
+
+	if (IS_ERR(clk)) {
+		pr_err("%s: failed to register pll clock %s\n",
+				__func__, list->name);
+		return;
+	}
+
+	samsung_clk_add_lookup(ctx, clk, list->id);
+
+	/* register a clock lookup only if a clock alias is specified */
+	if (list->alias) {
+		ret = clk_register_clkdev(clk, list->alias, NULL);
+		if (ret)
+			pr_err("%s: failed to register lookup %s\n",
+					__func__, list->alias);
+	}
+}
+
+void samsung_register_comp_pll(struct samsung_clk_provider *ctx,
+		struct samsung_composite_pll *list, unsigned int nr_pll)
+{
+	int cnt;
+
+	for (cnt = 0; cnt < nr_pll; cnt++)
+		_samsung_register_comp_pll(ctx, &list[cnt]);
+}
+
+/* operation functions for mux clocks */
+static int samsung_mux_get_parent(struct clk_hw *hw)
+{
+	struct samsung_composite_mux *mux = to_comp_mux(hw);
+	u32 val;
+
+	val = readl(mux->sel_reg) >> mux->sel_bit;
+	val &= (BIT(mux->sel_width) - 1);
+
+	return (u8)val;
+}
+
+static int samsung_mux_set_parent(struct clk_hw *hw, u8 index)
+{
+	struct samsung_composite_mux *mux = to_comp_mux(hw);
+	u32 val;
+	unsigned long flags = 0;
+	unsigned int timeout = 1000;
+
+	if (mux->lock)
+		spin_lock_irqsave(mux->lock, flags);
+
+	val = readl(mux->sel_reg);
+	val &= ~((BIT(mux->sel_width) - 1) << mux->sel_bit);
+	val |= index << mux->sel_bit;
+	writel(val, mux->sel_reg);
+
+	if (mux->stat_reg)
+		do {
+			--timeout;
+			if (!timeout) {
+				pr_err("%s: failed to set parent %s.\n",
+						__func__, hw->clk->name);
+				pr_err("MUX_REG: %08x, MUX_STAT_REG: %08x\n",
+						readl(mux->sel_reg), readl(mux->stat_reg));
+				if (mux->lock)
+					spin_unlock_irqrestore(mux->lock, flags);
+				return -ETIMEDOUT;
+			}
+			val = readl(mux->stat_reg);
+			val &= ((BIT(mux->stat_width) - 1) << mux->stat_bit);
+		} while (val != (index << mux->stat_bit));
+
+	if (mux->lock)
+		spin_unlock_irqrestore(mux->lock, flags);
+
+	return 0;
+}
+
+static const struct clk_ops samsung_composite_mux_ops = {
+	.get_parent = samsung_mux_get_parent,
+	.set_parent = samsung_mux_set_parent,
+};
+
+/* operation functions for mux clocks checking status with "on changing" */
+
+static int samsung_mux_set_parent_onchange(struct clk_hw *hw, u8 index)
+{
+	struct samsung_composite_mux *mux = to_comp_mux(hw);
+	u32 val;
+	unsigned long flags = 0;
+	unsigned int timeout = 1000;
+
+	if (mux->lock)
+		spin_lock_irqsave(mux->lock, flags);
+
+	val = readl(mux->sel_reg);
+	val &= ~((BIT(mux->sel_width) - 1) << mux->sel_bit);
+	val |= index << mux->sel_bit;
+	writel(val, mux->sel_reg);
+
+	if (mux->stat_reg)
+		do {
+			--timeout;
+			if (!timeout) {
+				pr_err("%s: failed to set parent %s.\n",
+						__func__, hw->clk->name);
+				pr_err("MUX_REG: %08x, MUX_STAT_REG: %08x\n",
+						readl(mux->sel_reg), readl(mux->stat_reg));
+				if (mux->lock)
+					spin_unlock_irqrestore(mux->lock, flags);
+				return -ETIMEDOUT;
+			}
+			val = readl(mux->stat_reg);
+			val &= ((BIT(mux->stat_width) - 1) << mux->stat_bit);
+		} while (val == PLL_STAT_CHANGE);
+
+	if (mux->lock)
+		spin_unlock_irqrestore(mux->lock, flags);
+
+	return 0;
+}
+static const struct clk_ops samsung_composite_mux_ops_onchange = {
+	.get_parent = samsung_mux_get_parent,
+	.set_parent = samsung_mux_set_parent_onchange,
+};
+
+/* register function for mux clock */
+static void _samsung_register_comp_mux(struct samsung_clk_provider *ctx,
+				struct samsung_composite_mux *list)
+{
+	struct clk *clk;
+	unsigned int ret = 0;
+
+	list->lock = &lock;
+
+	if (!(list->flag & CLK_ON_CHANGING))
+		clk = clk_register_composite(NULL, list->name, list->parents, list->num_parents,
+				&list->hw, &samsung_composite_mux_ops,
+				NULL, NULL,
+				NULL, NULL, list->flag);
+	else
+		clk = clk_register_composite(NULL, list->name, list->parents, list->num_parents,
+				&list->hw, &samsung_composite_mux_ops_onchange,
+				NULL, NULL,
+				NULL, NULL, list->flag);
+
+	if (IS_ERR(clk)) {
+		pr_err("%s: failed to register mux clock %s\n",
+				__func__, list->name);
+		return;
+	}
+
+	samsung_clk_add_lookup(ctx, clk, list->id);
+
+	/* register a clock lookup only if a clock alias is specified */
+	if (list->alias) {
+		ret = clk_register_clkdev(clk, list->alias, NULL);
+		if (ret)
+			pr_err("%s: failed to register lookup %s\n",
+					__func__, list->alias);
+	}
+}
+
+void samsung_register_comp_mux(struct samsung_clk_provider *ctx,
+		struct samsung_composite_mux *list, unsigned int nr_mux)
+{
+	int cnt;
+
+	for (cnt = 0; cnt < nr_mux; cnt++)
+		_samsung_register_comp_mux(ctx, &list[cnt]);
+}
+
+/* operation functions for divider clocks */
+static unsigned long samsung_divider_recalc_rate(struct clk_hw *hw,
+		unsigned long parent_rate)
+{
+	struct samsung_composite_divider *divider = to_comp_divider(hw);
+	unsigned int val;
+
+	val = readl(divider->rate_reg) >> divider->rate_bit;
+	val &= (1 << divider->rate_width) - 1;
+	val += 1;
+	if (!val)
+		return parent_rate;
+
+	return parent_rate / val;
+}
+
+static int samsung_divider_bestdiv(struct clk_hw *hw, unsigned long rate,
+			unsigned long *best_parent_rate)
+{
+	struct samsung_composite_divider *divider = to_comp_divider(hw);
+	int i, bestdiv = 0;
+	unsigned long parent_rate, maxdiv, now, best = 0;
+	unsigned long parent_rate_saved = *best_parent_rate;
+
+	if (!rate)
+		rate = 1;
+
+	maxdiv = ((1 << (divider->rate_width)) - 1) + 1;
+
+	if (!(hw->clk->flags & CLK_SET_RATE_PARENT)) {
+		parent_rate = *best_parent_rate;
+		bestdiv = (parent_rate + rate - 1) / rate;
+		bestdiv = bestdiv == 0 ? 1 : bestdiv;
+		bestdiv = bestdiv > maxdiv ? maxdiv : bestdiv;
+		return bestdiv;
+	}
+
+	maxdiv = min(ULONG_MAX / rate, maxdiv);
+
+	for (i = 1; i <= maxdiv; i++) {
+		if (rate * i == parent_rate_saved) {
+			/*
+			 * It's the most ideal case if the requested rate can be
+			 * divided from parent clock without needing to change
+			 * parent rate, so return the divider immediately.
+			 */
+			*best_parent_rate = parent_rate_saved;
+			return i;
+		}
+		parent_rate = __clk_round_rate(__clk_get_parent(hw->clk),
+				((rate * i) + i - 1));
+		now = parent_rate / i;
+		if (now <= rate && now > best) {
+			bestdiv = i;
+			best = now;
+			*best_parent_rate = parent_rate;
+		}
+	}
+
+	if (!bestdiv) {
+		bestdiv = ((1 << (divider->rate_width)) - 1) + 1;
+		*best_parent_rate = __clk_round_rate(__clk_get_parent(hw->clk), 1);
+	}
+
+	return bestdiv;
+}
+
+static long samsung_divider_round_rate(struct clk_hw *hw, unsigned long rate,
+				unsigned long *prate)
+{
+	int div = 1;
+
+	div = samsung_divider_bestdiv(hw, rate, prate);
+	if (div == 0) {
+		pr_err("%s: divider value should not be %d\n", __func__, div);
+		div = 1;
+	}
+
+	return *prate / div;
+}
+
+static int samsung_divider_set_rate(struct clk_hw *hw, unsigned long rate,
+				unsigned long parent_rate)
+{
+	struct samsung_composite_divider *divider = to_comp_divider(hw);
+	unsigned int div;
+	u32 val;
+	unsigned long flags = 0;
+	unsigned int timeout = 1000;
+
+	div = (parent_rate / rate) - 1;
+
+	if (div > ((1 << divider->rate_width) - 1))
+		div = (1 << divider->rate_width) - 1;
+
+	if (divider->lock)
+		spin_lock_irqsave(divider->lock, flags);
+
+	val = readl(divider->rate_reg);
+	val &= ~(((1 << divider->rate_width) - 1) << divider->rate_bit);
+	val |= div << divider->rate_bit;
+	writel(val, divider->rate_reg);
+
+	if (divider->stat_reg)
+		do {
+			--timeout;
+			if (!timeout) {
+				pr_err("%s: faild to set rate %s.\n",
+						__func__, hw->clk->name);
+				pr_err("DIV_REG: %08x, MUX_STAT_REG: %08x\n",
+						readl(divider->rate_reg), readl(divider->stat_reg));
+				if (divider->lock)
+					spin_unlock_irqrestore(divider->lock, flags);
+				return -ETIMEDOUT;
+			}
+			val = readl(divider->stat_reg);
+			val &= BIT(divider->stat_width - 1) << divider->stat_bit;
+		} while (val);
+
+	if (divider->lock)
+		spin_unlock_irqrestore(divider->lock, flags);
+
+	return 0;
+}
+
+static const struct clk_ops samsung_composite_divider_ops = {
+	.recalc_rate = samsung_divider_recalc_rate,
+	.round_rate = samsung_divider_round_rate,
+	.set_rate = samsung_divider_set_rate,
+};
+
+/* register function for divider clocks */
+static void _samsung_register_comp_divider(struct samsung_clk_provider *ctx,
+				struct samsung_composite_divider *list)
+{
+	struct clk *clk;
+	unsigned int ret = 0;
+
+	list->lock = &lock;
+
+	clk = clk_register_composite(NULL, list->name, &list->parent_name, 1,
+			NULL, NULL,
+			&list->hw, &samsung_composite_divider_ops,
+			NULL, NULL, list->flag);
+
+	if (IS_ERR(clk)) {
+		pr_err("%s: failed to register mux clock %s\n",
+				__func__, list->name);
+		return;
+	}
+
+	samsung_clk_add_lookup(ctx, clk, list->id);
+
+	/* register a clock lookup only if a clock alias is specified */
+	if (list->alias) {
+		ret = clk_register_clkdev(clk, list->alias, NULL);
+		if (ret)
+			pr_err("%s: failed to register lookup %s\n",
+					__func__, list->alias);
+	}
+}
+
+void samsung_register_comp_divider(struct samsung_clk_provider *ctx,
+		struct samsung_composite_divider *list,	unsigned int nr_div)
+{
+	int cnt;
+
+	for (cnt = 0; cnt < nr_div; cnt++)
+		_samsung_register_comp_divider(ctx, &list[cnt]);
+}
+
+struct dummy_gate_clk {
+	unsigned long	offset;
+	u8		bit_idx;
+	struct clk	*clk;
+};
+
+static struct dummy_gate_clk **gate_clk_list;
+static unsigned int gate_clk_nr;
+
+int samsung_add_clk_gate_list(struct clk *clk, unsigned long offset, u8 bit_idx, const char *name)
+{
+	struct dummy_gate_clk *tmp_clk;
+
+	if (!clk || !offset)
+		return -EINVAL;
+
+	tmp_clk = kzalloc(sizeof(struct dummy_gate_clk), GFP_KERNEL);
+	if (!tmp_clk) {
+		pr_err("%s: fail to alloc for gate_clk\n", __func__);
+		return -ENOMEM;
+	}
+
+	tmp_clk->offset = offset;
+	tmp_clk->bit_idx = bit_idx;
+	tmp_clk->clk = clk;
+
+	gate_clk_list[gate_clk_nr] = tmp_clk;
+
+	gate_clk_nr++;
+
+	return 0;
+}
+
+struct clk *samsung_clk_get_by_reg(unsigned long offset, u8 bit_idx)
+{
+	unsigned int i;
+
+	for (i = 0; i < gate_clk_nr; i++) {
+		if (gate_clk_list[i]->offset == offset) {
+			if (gate_clk_list[i]->bit_idx == bit_idx)
+				return gate_clk_list[i]->clk;
+		}
+	}
+
+	pr_err("%s: Fail to get clk by register offset\n", __func__);
+
+	return 0;
+}
+
+/* existing register function for gate clocks */
+static struct clk * __init _samsung_register_gate(
+		struct samsung_clk_provider *ctx, struct samsung_gate *list)
+{
+	struct clk *clk;
+	unsigned int ret = 0;
+
+	clk = clk_register_gate(NULL, list->name, list->parent_name,
+			list->flag, list->reg, list->bit,
+			list->flag, &lock);
+
+	if (IS_ERR(clk)) {
+		pr_err("%s: failed to register clock %s\n", __func__,
+				list->name);
+		return 0;
+	}
+
+	samsung_clk_add_lookup(ctx, clk, list->id);
+
+	if (list->alias) {
+		ret = clk_register_clkdev(clk, list->alias, NULL);
+		if (ret)
+			pr_err("%s: failed to register lookup %s\n",
+					__func__, list->alias);
+	}
+
+	return clk;
+}
+
+void __init samsung_register_gate(struct samsung_clk_provider *ctx,
+			struct samsung_gate *list, unsigned int nr_gate)
+{
+	int cnt;
+	struct clk *clk;
+	bool gate_list_fail = false;
+	unsigned int gate_enable_nr = 0;
+	struct clk **gate_enable_list;
+
+	gate_clk_list = kzalloc(sizeof(struct dummy_gate_clk *) * nr_gate, GFP_KERNEL);
+	if (!gate_clk_list) {
+		pr_err("%s: can not alloc for gate clock list\n", __func__);
+		gate_list_fail = true;
+	}
+
+	gate_enable_list = kzalloc(sizeof(struct clk *) * nr_gate, GFP_KERNEL);
+
+	if (!gate_enable_list)
+		pr_err("%s: can not alloc for enable gate clock list\n", __func__);
+
+	for (cnt = 0; cnt < nr_gate; cnt++) {
+		clk = _samsung_register_gate(ctx, &list[cnt]);
+
+		if (((&list[cnt])->flag & CLK_GATE_ENABLE) && gate_enable_list) {
+			gate_enable_list[gate_enable_nr] = clk;
+			gate_enable_nr++;
+		}
+
+		/* Make list for gate clk to used by samsung_clk_get_by_reg */
+		if (!gate_list_fail)
+			samsung_add_clk_gate_list(clk, (unsigned long)(list[cnt].reg), list[cnt].bit, list[cnt].name);
+	}
+
+	/*
+	 * Enable for not controlling gate clocks
+	 */
+	for (cnt = 0; cnt < gate_enable_nr; cnt++)
+		clk_prepare_enable(gate_enable_list[cnt]);
+
+	if (gate_enable_list)
+		kfree(gate_enable_list);
+}
+
+/* operation functions for usermux clocks */
+static int samsung_usermux_is_enabled(struct clk_hw *hw)
+{
+	struct clk_samsung_usermux *usermux = to_usermux(hw);
+	u32 val;
+
+	val = readl(usermux->sel_reg);
+	val &= BIT(usermux->sel_bit);
+
+	return val ? 1 : 0;
+}
+
+static int samsung_usermux_enable(struct clk_hw *hw)
+{
+	struct clk_samsung_usermux *usermux = to_usermux(hw);
+	u32 val;
+	unsigned long flags = 0;
+	unsigned int timeout = 1000;
+
+	if (usermux->lock)
+		spin_lock_irqsave(usermux->lock, flags);
+
+	val = readl(usermux->sel_reg);
+	val &= ~(1 << usermux->sel_bit);
+	val |= (1 << usermux->sel_bit);
+	writel(val, usermux->sel_reg);
+
+	if (usermux->stat_reg)
+		do {
+			--timeout;
+			if (!timeout) {
+				pr_err("%s: failed to enable clock %s.\n",
+						__func__, hw->clk->name);
+				if (usermux->lock)
+					spin_unlock_irqrestore(usermux->lock, flags);
+				return -ETIMEDOUT;
+			}
+			val = readl(usermux->stat_reg);
+			val &= BIT(2) << usermux->stat_bit;
+		} while (val);
+
+	if (usermux->lock)
+		spin_unlock_irqrestore(usermux->lock, flags);
+
+	return 0;
+}
+
+static void samsung_usermux_disable(struct clk_hw *hw)
+{
+	struct clk_samsung_usermux *usermux = to_usermux(hw);
+	u32 val;
+	unsigned long flags = 0;
+	unsigned int timeout = 1000;
+
+	if (usermux->lock)
+		spin_lock_irqsave(usermux->lock, flags);
+
+	val = readl(usermux->sel_reg);
+	val &= ~(1 << usermux->sel_bit);
+	writel(val, usermux->sel_reg);
+
+	if (usermux->stat_reg)
+		do {
+			--timeout;
+			if (!timeout) {
+				pr_err("%s: failed to disable clock %s.\n",
+						__func__, hw->clk->name);
+				if (usermux->lock)
+					spin_unlock_irqrestore(usermux->lock, flags);
+				return;
+			}
+			val = readl(usermux->stat_reg);
+			val &= BIT(2) << usermux->stat_bit;
+		} while (val);
+
+	if (usermux->lock)
+		spin_unlock_irqrestore(usermux->lock, flags);
+}
+
+static const struct clk_ops samsung_usermux_ops = {
+	.enable = samsung_usermux_enable,
+	.disable = samsung_usermux_disable,
+	.is_enabled = samsung_usermux_is_enabled,
+};
+
+/* register function for usermux clocks */
+static struct clk * __init _samsung_register_comp_usermux(struct samsung_usermux *list)
+{
+	struct clk_samsung_usermux *usermux;
+	struct clk *clk;
+	struct clk_init_data init;
+
+	usermux = kzalloc(sizeof(struct clk_samsung_usermux), GFP_KERNEL);
+	if (!usermux) {
+		pr_err("%s: could not allocate usermux clk\n", __func__);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	init.name = list->name;
+	init.ops = &samsung_usermux_ops;
+	init.flags = list->flag | CLK_IS_BASIC;
+	init.parent_names = (list->parent_name ? &list->parent_name : NULL);
+	init.num_parents = (list->parent_name ? 1 : 0);
+
+	usermux->sel_reg = list->sel_reg;
+	usermux->sel_bit = list->sel_bit;
+	usermux->stat_reg = list->stat_reg;
+	usermux->stat_bit = list->stat_bit;
+	usermux->flag = 0;
+	usermux->lock = &lock;
+	usermux->hw.init = &init;
+
+	clk = clk_register(NULL, &usermux->hw);
+
+	if (IS_ERR(clk))
+		kfree(usermux);
+
+	return clk;
+}
+
+void __init samsung_register_usermux(struct samsung_clk_provider *ctx,
+		struct samsung_usermux *list, unsigned int nr_usermux)
+{
+	struct clk *clk;
+	int cnt;
+	unsigned int ret = 0;
+
+	for (cnt = 0; cnt < nr_usermux; cnt++) {
+		clk = _samsung_register_comp_usermux(&list[cnt]);
+		if (IS_ERR(clk)) {
+			pr_err("%s: failed to register clock %s\n", __func__,
+					(&list[cnt])->name);
+			return;
+		}
+
+		samsung_clk_add_lookup(ctx, clk, (&list[cnt])->id);
+
+		if ((&list[cnt])->alias) {
+			ret = clk_register_clkdev(clk, (&list[cnt])->alias, NULL);
+			if (ret)
+				pr_err("%s: failed to register lookup %s\n",
+						__func__, (&list[cnt])->alias);
+		}
+	}
+}
+
+/**
+ * Operations for virtual clock used in cal
+ * When cal is used to set clocks, following operations will be executed.
+ */
+int cal_vclk_enable(struct clk_hw *hw)
+{
+	struct samsung_vclk *vclk = to_vclk(hw);
+	unsigned long flags = 0;
+	int ret = 0;
+
+	if (vclk->lock)
+		spin_lock_irqsave(vclk->lock, flags);
+
+	/* Call cal api to enable virtual clock */
+	ret = cal_clk_enable(vclk->id);
+	if (ret) {
+		pr_err("[CAL]%s failed.\n", __func__);
+		if (vclk->lock)
+			spin_unlock_irqrestore(vclk->lock, flags);
+		return -EAGAIN;
+	}
+
+	if (vclk->lock)
+		spin_unlock_irqrestore(vclk->lock, flags);
+
+	return 0;
+}
+
+void cal_vclk_disable(struct clk_hw *hw)
+{
+	struct samsung_vclk *vclk = to_vclk(hw);
+	unsigned long flags = 0;
+	int ret = 0;
+
+	if (vclk->lock)
+		spin_lock_irqsave(vclk->lock, flags);
+
+	/* Call cal api to disable virtual clock */
+	ret = cal_clk_disable(vclk->id);
+	if (ret) {
+		pr_err("[CAL]%s failed.\n", __func__);
+		if (vclk->lock)
+			spin_unlock_irqrestore(vclk->lock, flags);
+		return;
+	}
+
+	if (vclk->lock)
+		spin_unlock_irqrestore(vclk->lock, flags);
+}
+
+int cal_vclk_is_enabled(struct clk_hw *hw)
+{
+	struct samsung_vclk *vclk = to_vclk(hw);
+	int ret = 0;
+
+	/*
+	 * Call cal api to check whether clock is enabled or not
+	 * Spinlock is not needed because only read operation will
+	 * be executed
+	 */
+	ret = cal_clk_is_enabled(vclk->id);
+
+	return ret;
+}
+
+unsigned long cal_vclk_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)
+{
+	struct samsung_vclk *vclk = to_vclk(hw);
+	unsigned long ret = 0;
+
+	/* Call cal api to recalculate rate */
+	ret = cal_clk_getrate(vclk->id);
+
+	return ret;
+}
+
+long cal_vclk_round_rate(struct clk_hw *hw, unsigned long rate,
+				unsigned long *prate)
+{
+	/* round_rate ops is not needed when using cal */
+	return (long)rate;
+}
+
+int cal_vclk_set_rate(struct clk_hw *hw, unsigned long rate, unsigned long prate)
+{
+	struct samsung_vclk *vclk = to_vclk(hw);
+	unsigned long flags = 0;
+	int ret = 0;
+
+	if (vclk->lock)
+		spin_lock_irqsave(vclk->lock, flags);
+
+	/* Call cal api to set rate of clock */
+	ret = cal_clk_setrate(vclk->id, rate);
+	if (ret) {
+		pr_err("[CAL]%s failed.\n", __func__);
+		if (vclk->lock)
+			spin_unlock_irqrestore(vclk->lock, flags);
+		return -EAGAIN;
+	}
+
+	if (vclk->lock)
+		spin_unlock_irqrestore(vclk->lock, flags);
+
+	return ret;
+}
+
+unsigned long cal_vclk_dfs_sw_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)
+{
+	struct samsung_vclk *vclk = to_vclk(hw);
+	unsigned long ret = 0;
+
+	/* Call cal api to recalculate rate */
+	ret = cal_dfs_cached_get_rate(vclk->id);
+
+	return ret;
+}
+unsigned long cal_vclk_dfs_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)
+{
+	struct samsung_vclk *vclk = to_vclk(hw);
+	unsigned long ret = 0;
+
+	/* Call cal api to recalculate rate */
+	ret = cal_dfs_get_rate(vclk->id);
+
+	return ret;
+}
+
+int cal_vclk_dfs_set_rate(struct clk_hw *hw, unsigned long rate, unsigned long prate)
+{
+	struct samsung_vclk *vclk = to_vclk(hw);
+	unsigned long flags = 0;
+	int ret = 0;
+
+	if (vclk->lock)
+		spin_lock_irqsave(vclk->lock, flags);
+
+	/* Call cal api to set rate of clock */
+	ret = cal_dfs_set_rate(vclk->id, rate);
+	if (ret) {
+		pr_err("[CAL]%s failed.\n", __func__);
+		if (vclk->lock)
+			spin_unlock_irqrestore(vclk->lock, flags);
+		return -EAGAIN;
+	}
+
+	if (vclk->lock)
+		spin_unlock_irqrestore(vclk->lock, flags);
+
+	return ret;
+}
+
+int cal_vclk_dfs_set_rate_switch(struct clk_hw *hw, unsigned long rate, unsigned long prate)
+{
+	struct samsung_vclk *vclk = to_vclk(hw);
+	unsigned long flags = 0;
+	int ret = 0;
+
+	if (vclk->lock)
+		spin_lock_irqsave(vclk->lock, flags);
+
+	/* Call cal api to set rate of clock */
+	ret = cal_dfs_set_rate_switch(vclk->id, rate);
+	if (ret) {
+		pr_err("[CAL]%s failed.\n", __func__);
+		if (vclk->lock)
+			spin_unlock_irqrestore(vclk->lock, flags);
+		return -EAGAIN;
+	}
+
+	if (vclk->lock)
+		spin_unlock_irqrestore(vclk->lock, flags);
+
+	return ret;
+}
+
+static const struct clk_ops samsung_vclk_ops = {
+	.enable = cal_vclk_enable,
+	.disable = cal_vclk_disable,
+	.is_enabled = cal_vclk_is_enabled,
+	.recalc_rate = cal_vclk_recalc_rate,
+	.round_rate = cal_vclk_round_rate,
+	.set_rate = cal_vclk_set_rate,
+};
+
+static const struct clk_ops samsung_vclk_dfs_ops = {
+	.recalc_rate = cal_vclk_dfs_recalc_rate,
+	.round_rate = cal_vclk_round_rate,
+	.set_rate = cal_vclk_dfs_set_rate,
+};
+
+static const struct clk_ops samsung_vclk_dfs_sw_ops = {
+	.recalc_rate = cal_vclk_dfs_sw_recalc_rate,
+	.round_rate = cal_vclk_round_rate,
+	.set_rate = cal_vclk_dfs_set_rate_switch,
+};
+
+static struct clk * __init _samsung_register_vclk(struct init_vclk *list)
+{
+	struct samsung_vclk *vclk;
+	struct clk *clk;
+	struct clk_init_data init;
+
+	vclk = kzalloc(sizeof(struct samsung_vclk), GFP_KERNEL);
+	if (!vclk) {
+		pr_err("%s: could not allocate struct vclk\n", __func__);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	init.name = list->name;
+	if (list->vclk_flags & VCLK_DFS)
+		init.ops = &samsung_vclk_dfs_ops;
+	else if (list->vclk_flags & VCLK_DFS_SWITCH)
+		init.ops = &samsung_vclk_dfs_sw_ops;
+	else
+		init.ops = &samsung_vclk_ops;
+	init.flags = list->flags | (CLK_IS_BASIC | CLK_IS_ROOT | CLK_GET_RATE_NOCACHE | CLK_IGNORE_UNUSED);
+	init.parent_names = NULL;
+	init.num_parents = 0;
+
+	vclk->id = list->calid;
+	/* Flags for vclk are not defined yet */
+	vclk->flags = list->vclk_flags;
+	vclk->lock = &lock;
+	vclk->hw.init = &init;
+
+	clk = clk_register(NULL, &vclk->hw);
+
+	if (IS_ERR(clk))
+		kfree(vclk);
+
+	return clk;
+}
+
+void __init samsung_register_vclk(struct samsung_clk_provider *ctx,
+			struct init_vclk *list, unsigned int nr_vclk)
+{
+	struct clk *clk;
+	int cnt;
+	unsigned int ret = 0;
+
+	for (cnt = 0; cnt < nr_vclk; cnt++) {
+		clk = _samsung_register_vclk(&list[cnt]);
+		if (IS_ERR(clk)) {
+			pr_err("%s: failed to register virtual clock %s\n",
+				__func__, (&list[cnt])->name);
+			continue;
+		}
+
+		samsung_clk_add_lookup(ctx, clk, (&list[cnt])->id);
+
+		/* Additional array of clocks for finding struct clk */
+		if ((&list[cnt])->alias) {
+			ret = clk_register_clkdev(clk, (&list[cnt])->alias, NULL);
+			if (ret)
+				pr_err("%s: failed to register lookup %s\n",
+						__func__, (&list[cnt])->alias);
+		}
+	}
+}
diff -Naur linux-3.18.14/drivers/clk/samsung/composite.h samsung/drivers/clk/samsung/composite.h
--- linux-3.18.14/drivers/clk/samsung/composite.h	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/clk/samsung/composite.h	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,501 @@
+/*
+ * Copyright (c) 2014 Samsung Electronics Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This file contains the utility functions for composite clocks.
+ */
+
+#ifndef __SAMSUNG_CLK_COMPOSITE_H
+#define __SAMSUNG_CLK_COMPOSITE_H
+
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+#include "../../soc/samsung/pwrcal/pwrcal.h"
+
+/*
+ * struct samsung_clk_provider: information about clock provider
+ * @reg_base: virtual address for the register base.
+ * @clk_data: holds clock related data like clk* and number of clocks.
+ * @lock: maintains exclusion bwtween callbacks for a given clock-provider.
+ */
+struct samsung_clk_provider {
+	void __iomem *reg_base;
+	struct clk_onecell_data clk_data;
+	spinlock_t lock;
+};
+
+/*
+ * struct samsung_clk_reg_dump: register dump of clock controller registers.
+ * @offset: clock register offset from the controller base address.
+ * @value: the value to be register at offset.
+ */
+struct samsung_clk_reg_dump {
+	unsigned long	offset;
+	u32		value;
+};
+
+/*
+ * struct samsung_fixed_rate_clock: information about fixed-rate clock
+ * @id: platform specific id of the clock.
+ * @name: name of this fixed-rate clock.
+ * @parent_name: optional parent clock name.
+ * @flags: optional fixed-rate clock flags.
+ * @fixed-rate: fixed clock rate of this clock.
+ */
+struct samsung_fixed_rate {
+	unsigned int		id;
+	char			*name;
+	const char		*parent_name;
+	unsigned long		flags;
+	unsigned long		fixed_rate;
+};
+
+#define FRATE(_id, cname, pname, f, frate)		\
+	{						\
+		.id		= _id,			\
+		.name		= cname,		\
+		.parent_name	= pname,		\
+		.flags		= f,			\
+		.fixed_rate	= frate,		\
+	}
+
+extern void __init samsung_register_fixed_rate(
+		struct samsung_clk_provider *ctx,
+		struct samsung_fixed_rate *list,
+		unsigned int nr_clk);
+/*
+ * struct samsung_fixed_factor_clock: information about fixed-factor clock
+ * @id: platform specific id of the clock.
+ * @name: name of this fixed-factor clock.
+ * @parent_name: parent clock name.
+ * @mult: fixed multiplication factor.
+ * @div: fixed division factor.
+ * @flags: optional fixed-factor clock flags.
+ */
+struct samsung_fixed_factor {
+	unsigned int		id;
+	char			*name;
+	const char		*parent_name;
+	unsigned long		mult;
+	unsigned long		div;
+	unsigned long		flags;
+};
+
+#define FFACTOR(_id, cname, pname, m, d, f)		\
+	{						\
+		.id		= _id,			\
+		.name		= cname,		\
+		.parent_name	= pname,		\
+		.mult		= m,			\
+		.div		= d,			\
+		.flags		= f,			\
+	}
+
+extern void __init samsung_register_fixed_factor(
+		struct samsung_clk_provider *ctx,
+		struct samsung_fixed_factor *list,
+		unsigned int nr_clk);
+
+/*
+ * PLL145xx Clock Type: PLL1450x, PLL1451x, PLL1452x
+ * Maximum lock time can be 150 * Pdiv cycles
+ */
+#define PLL145XX_LOCK_FACTOR		(150)
+#define PLL145XX_MDIV_MASK		(0x3FF)
+#define PLL145XX_PDIV_MASK		(0x03F)
+#define PLL145XX_SDIV_MASK		(0x007)
+#define PLL145XX_LOCKED_MASK		(0x1)
+#define PLL145XX_MDIV_SHIFT		(16)
+#define PLL145XX_PDIV_SHIFT		(8)
+#define PLL145XX_SDIV_SHIFT		(0)
+#define PLL145XX_LOCKED_SHIFT		(29)
+
+/*
+ * PLL1460X Clock Type
+ * Maximum lock time can be 3000 * Pdiv cycles
+ */
+#define PLL1460X_LOCK_FACTOR		(3000)
+#define PLL1460X_MDIV_MASK		(0x03FF)
+#define PLL1460X_PDIV_MASK		(0x003F)
+#define PLL1460X_SDIV_MASK		(0x0007)
+#define PLL1460X_KDIV_MASK		(0xFFFF)
+#define PLL1460X_LOCKED_MASK		(0x1)
+#define PLL1460X_MDIV_SHIFT		(16)
+#define PLL1460X_PDIV_SHIFT		(8)
+#define PLL1460X_SDIV_SHIFT		(0)
+#define PLL1460X_KDIV_SHIFT		(0)
+#define PLL1460X_LOCKED_SHIFT		(29)
+
+/*
+ * PLL255xx Clock Type : PLL2551x, PLL2555x
+ * Maximum lock time can be 200 * Pdiv cycles
+ */
+#define PLL255XX_LOCK_FACTOR		(200)
+#define PLL255XX_MDIV_MASK		(0x3FF)
+#define PLL255XX_PDIV_MASK		(0x3F)
+#define PLL255XX_SDIV_MASK		(0x7)
+#define PLL255XX_LOCKED_MASK		(0x1)
+#define PLL255XX_MDIV_SHIFT		(12)
+#define PLL255XX_PDIV_SHIFT		(4)
+#define PLL255XX_SDIV_SHIFT		(0)
+#define PLL255XX_LOCKED_SHIFT		(29)
+
+/*
+ * PLL2650X Clock Type
+ * Maximum lock time can be 3000 * Pdiv cycles
+ */
+#define PLL2650X_LOCK_FACTOR		(3000)
+#define PLL2650X_MDIV_MASK		(0x01FF)
+#define PLL2650X_PDIV_MASK		(0x003F)
+#define PLL2650X_SDIV_MASK		(0x0007)
+#define PLL2650X_KDIV_MASK		(0xFFFF)
+#define PLL2650X_LOCKED_MASK		(0x1)
+#define PLL2650X_MDIV_SHIFT		(12)
+#define PLL2650X_PDIV_SHIFT		(4)
+#define PLL2650X_SDIV_SHIFT		(0)
+#define PLL2650X_KDIV_SHIFT		(0)
+#define PLL2650X_LOCKED_SHIFT		(29)
+
+enum pll_type {
+	pll_1450x = 0,
+	pll_1451x,
+	pll_1452x,
+	pll_1460x,
+	pll_2551x,
+	pll_2555x,
+	pll_2650x,
+};
+
+struct samsung_pll_rate_table {
+	long rate;
+	unsigned int pdiv;
+	unsigned int mdiv;
+	unsigned int sdiv;
+	unsigned int kdiv;
+};
+
+#define PLL_BYPASS		BIT(0)
+#define CHK_ON_CHANGING		BIT(7)
+/*
+ * struct samsung_composite_pll: information about composite-pll clocks
+ * @id: id of the clock for binding with device tree.
+ * @name: name of this pll clock.
+ * @type: type of this pll clock.
+ * @lock_reg: register for locking pll.
+ * @con_reg: configuration register for pll.
+ * @enable_reg: it can be different whether pll can be gated or only bypassed.
+ * @enable_bit: bit index for en/disable pll.
+ * @sel_reg: composite-pll has ctrl-mux. when disabled, it is set by 0.
+ * @sel_bit: bit index for ctrl-mux.
+ * @stat_reg: when sel_reg is set, status register must be checked.
+ * @stat_bit: bit index for status register.
+ * @rate_table: available pll output ratio table.
+ * @alias: support alias for this clock.
+ */
+struct samsung_composite_pll {
+	struct clk_hw				hw;
+	unsigned int				id;
+	const char				*name;
+	enum pll_type				type;
+	void __iomem				*lock_reg;
+	void __iomem				*con_reg;
+	void __iomem				*enable_reg;
+	unsigned int				enable_bit;
+	void __iomem				*sel_reg;
+	unsigned int				sel_bit;
+	void __iomem 				*stat_reg;
+	unsigned int 				stat_bit;
+	const struct samsung_pll_rate_table	*rate_table;
+	unsigned int 				rate_count;
+	unsigned int				pll_flag;
+	u8					flag;
+	const char				*alias;
+};
+
+#define PLL(_id, cname, _type, lock, con, en, enbit, sel, selbit, stat, statbit, rtable, pf, f, a)	\
+	{											\
+		.id		= _id,								\
+		.name		= cname,							\
+		.type		= _type,							\
+		.lock_reg	= lock,								\
+		.con_reg	= con,								\
+		.enable_reg	= en,								\
+		.enable_bit	= enbit,							\
+		.sel_reg	= sel,								\
+		.sel_bit	= selbit,							\
+		.stat_reg	= stat,								\
+		.stat_bit	= statbit,							\
+		.rate_table	= rtable,							\
+		.rate_count	= 0,								\
+		.pll_flag	= pf,								\
+		.flag		= f,								\
+		.alias		= a,								\
+	}
+
+extern void samsung_register_comp_pll(
+		struct samsung_clk_provider *ctx,
+		struct samsung_composite_pll *pll_list,
+		unsigned int nr_pll);
+
+#define PNAME(x) static const char *x[]
+/*
+ * struct samsung_composite_mux: information about composite-mux clocks
+ * @id: id of the clock for binding with device tree.
+ * @name: name of this mux clock.
+ * @parents: array of parent clocks.
+ * @num_parents: number of parent clocks.
+ * @sel_reg: register for mux selection.
+ * @sel_bit: bit index for sel_reg.
+ * @sel_width: different by number of parent clocks.
+ * @stat_reg: status must be checked when changing parent.
+ * @stat_bit: bit index for status register.
+ * @stat_width: different by number of parent clocks.
+ * @flag: optional flag for clock.
+ * @alias: optional name. recommend no more than 15 characters.
+ */
+struct samsung_composite_mux {
+	struct clk_hw			hw;
+	unsigned int			id;
+	const char			*name;
+	const char			**parents;
+	unsigned int			num_parents;
+	void __iomem			*sel_reg;
+	unsigned int			sel_bit;
+	unsigned int			sel_width;
+	void __iomem			*stat_reg;
+	unsigned int 			stat_bit;
+	unsigned int			stat_width;
+	unsigned int			flag;
+	const char			*alias;
+	spinlock_t			*lock;
+};
+
+#define MUX(_id, cname, pnames, sel, selbit, selwid, stat, statbit, statwid, f, a)	\
+	{										\
+		.id		= _id,							\
+		.name		= cname,						\
+		.parents	= pnames,						\
+		.num_parents	= ARRAY_SIZE(pnames),					\
+		.sel_reg	= sel,							\
+		.sel_bit	= selbit,						\
+		.sel_width	= selwid,						\
+		.stat_reg	= stat,							\
+		.stat_bit	= statbit,						\
+		.stat_width	= statwid,						\
+		.flag		= f,							\
+		.alias		= a,							\
+	}
+
+extern void samsung_register_comp_mux(
+		struct samsung_clk_provider *ctx,
+		struct samsung_composite_mux *mux_list,
+		unsigned int nr_mux);
+
+/*
+ * struct samsung_composite_divider: information about composite-divider clocks
+ * @id: id of the clock for binding with device tree.
+ * @name: name of this divider clock.
+ * @parent_name: name of parent clock.
+ * @rate_reg: register for ratio selection.
+ * @rate_bit: bit index for rate_reg.
+ * @rate_width: can be different by bit index.
+ * @stat_reg: status must be checked when changing ratio.
+ * @stat_bit: bit index for status register.
+ * @stat_width: can be different by bit index.
+ * @flag: flag for clock.
+ * @alias: optional name. recommend no more than 15 characters.
+ */
+struct samsung_composite_divider {
+	struct clk_hw			hw;
+	unsigned int			id;
+	const char			*name;
+	const char			*parent_name;
+	void __iomem			*rate_reg;
+	unsigned int			rate_bit;
+	unsigned int			rate_width;
+	void __iomem			*stat_reg;
+	unsigned int			stat_bit;
+	unsigned int			stat_width;
+	unsigned int			flag;
+	const char			*alias;
+	spinlock_t			*lock;
+};
+
+#define DIV(_id, cname, pname, rate, ratebit, ratewid, stat, statbit, statwid, f, a)	\
+	{										\
+		.id		= _id,							\
+		.name		= cname,						\
+		.parent_name	= pname,						\
+		.rate_reg	= rate,							\
+		.rate_bit	= ratebit,						\
+		.rate_width	= ratewid,						\
+		.stat_reg	= stat,							\
+		.stat_bit	= statbit,						\
+		.stat_width	= statwid,						\
+		.flag		= f,							\
+		.alias		= a,							\
+	}
+
+extern void samsung_register_comp_divider(struct samsung_clk_provider *ctx,
+		struct samsung_composite_divider *div_list, unsigned int nr_div);
+
+#define CLK_GATE_ENABLE		BIT(20)
+#define CLK_ON_CHANGING		BIT(7)
+/*
+ * struct samsung_gate: information about gate clocks
+ * @id: id of the clock for binding with device tree.
+ * @name:
+ * @parent_name:
+ * @reg:
+ * @bit:
+ * @flag:
+ * @alias:
+ */
+struct samsung_gate {
+	unsigned int			id;
+	const char			*name;
+	const char			*parent_name;
+	void __iomem			*reg;
+	u8				bit;
+	unsigned int			flag;
+	const char			*alias;
+};
+
+#define GATE(_id, cname, pname, r, b, f, a)		\
+	{						\
+		.id		= _id,			\
+		.name		= cname,		\
+		.parent_name	= pname,		\
+		.reg		= r,			\
+		.bit		= b,			\
+		.flag		= f,			\
+		.alias		= a,			\
+	}
+
+extern void __init samsung_register_gate(
+		struct samsung_clk_provider *ctx,
+		struct samsung_gate *gate_list,
+		unsigned int nr_gate);
+
+struct clk_samsung_usermux {
+	struct clk_hw		hw;
+	void __iomem		*sel_reg;
+	u8			sel_bit;
+	void __iomem		*stat_reg;
+	u8	 		stat_bit;
+	u8			flag;
+	spinlock_t		*lock;
+};
+
+/*
+ * struct samsung_composite_usermux: information about usermux clocks
+ * @id: id of the clock for binding with device tree.
+ * @name: name of this usermux clock.
+ * @parent_name: name of parent clock.
+ * @sel_reg: register for usermux selection.
+ * @sel_bit: bit index for sel_reg.
+ * @stat_reg: status must be checked when changing parent.
+ * @stat_bit: bit index for status register.
+ * @flag: optional flag for clock.
+ * @alias: optional name. recommend no more than 15 characters.
+ */
+struct samsung_usermux {
+	unsigned int			id;
+	const char			*name;
+	const char			*parent_name;
+	void __iomem			*sel_reg;
+	u8				sel_bit;
+	void __iomem			*stat_reg;
+	u8	 			stat_bit;
+	u8				flag;
+	const char			*alias;
+};
+
+#define USERMUX(_id, cname, pname, sel, selbit, stat, statbit, f, a)	\
+	{								\
+		.id		= _id,					\
+		.name		= cname,				\
+		.parent_name	= pname,				\
+		.sel_reg	= sel,					\
+		.sel_bit	= selbit,				\
+		.stat_reg	= stat,					\
+		.stat_bit	= statbit,				\
+		.flag		= f,					\
+		.alias		= a,					\
+	}
+
+extern void __init samsung_register_usermux(
+		struct samsung_clk_provider *ctx,
+		struct samsung_usermux *list,
+		unsigned int nr_usermux);
+
+#define VCLK_DFS		BIT(1)
+#define VCLK_DFS_SWITCH		BIT(2)
+
+/*
+ * struct init_vclk: initial information for virtual clocks
+ * @id: id of the clock for binding with device tree.
+ * @calid: id of the clock for calling cal.
+ * @name: name of this virtual clock.
+ * @flags: optional flag for clock.
+ * @vclk_flags: optional flag for only virtual clock.
+ * @alias: optional name. recommend no more than 15 characters.
+ */
+struct init_vclk{
+	unsigned int		id;
+	unsigned int		calid;
+	const char		*name;
+	u8			flags;
+	u8			vclk_flags;
+	const char		*alias;
+};
+
+struct samsung_vclk {
+	struct clk_hw		hw;
+	unsigned int		id;
+	u8			flags;
+	spinlock_t		*lock;
+};
+
+#define VCLK(_id, _calid, _name, f, vf, a)	\
+	{					\
+		.id		= _id,		\
+		.calid		= _calid,	\
+		.name		= _name,	\
+		.flags		= f,		\
+		.vclk_flags	= vf,		\
+		.alias		= a,		\
+	}
+
+extern void __init samsung_register_vclk(struct samsung_clk_provider *ctx,
+		struct init_vclk *list, unsigned int nr_vclk);
+
+extern struct samsung_clk_provider *__init samsung_clk_init(
+			struct device_node *np, void __iomem *base,
+			unsigned long nr_clks);
+
+extern void __init samsung_clk_of_add_provider(struct device_node *np,
+		struct samsung_clk_provider *ctx);
+
+extern void __init samsung_register_of_fixed_ext(
+			struct samsung_clk_provider *ctx,
+			struct samsung_fixed_rate *fixed_rate_clk,
+			unsigned int nr_fixed_rate_clk,
+			struct of_device_id *clk_matches);
+
+extern void samsung_clk_save(void __iomem *base,
+			struct samsung_clk_reg_dump *rd,
+			unsigned int num_regs);
+extern void samsung_clk_restore(void __iomem *base,
+			const struct samsung_clk_reg_dump *rd,
+			unsigned int num_regs);
+extern struct samsung_clk_reg_dump *samsung_clk_alloc_reg_dump(
+			const unsigned long *rdump,
+			unsigned long nr_rdump);
+
+#endif /* __SAMSUNG_CLK_COMPOSITE_H */
diff -Naur linux-3.18.14/drivers/clk/samsung/Makefile samsung/drivers/clk/samsung/Makefile
--- linux-3.18.14/drivers/clk/samsung/Makefile	2015-05-20 17:04:50.000000000 +0200
+++ samsung/drivers/clk/samsung/Makefile	2018-10-29 07:24:36.000000000 +0100
@@ -2,7 +2,6 @@
 # Samsung Clock specific Makefile
 #
 
-obj-$(CONFIG_COMMON_CLK)	+= clk.o clk-pll.o
 obj-$(CONFIG_SOC_EXYNOS3250)	+= clk-exynos3250.o
 obj-$(CONFIG_ARCH_EXYNOS4)	+= clk-exynos4.o
 obj-$(CONFIG_SOC_EXYNOS5250)	+= clk-exynos5250.o
@@ -10,6 +9,19 @@
 obj-$(CONFIG_SOC_EXYNOS5410)	+= clk-exynos5410.o
 obj-$(CONFIG_SOC_EXYNOS5420)	+= clk-exynos5420.o
 obj-$(CONFIG_SOC_EXYNOS5440)	+= clk-exynos5440.o
+obj-$(CONFIG_SOC_EXYNOS7870)	+= clk-exynos7870.o
+ifeq ($(CONFIG_SOC_EXYNOS8890), y)
+ifeq ($(CONFIG_SOC_EXYNOS8890_EVT1), y)
+	obj-y				+= clk-exynos8890.o
+else
+	obj-y				+= clk-exynos8890_evt0.o
+endif
+endif
+ifeq ($(CONFIG_ARM64), y)
+	obj-y				+= composite.o
+else
+	obj-$(CONFIG_COMMON_CLK)	+= clk.o clk-pll.o
+endif
 obj-$(CONFIG_ARCH_EXYNOS)	+= clk-exynos-audss.o
 obj-$(CONFIG_ARCH_EXYNOS)	+= clk-exynos-clkout.o
 obj-$(CONFIG_S3C2410_COMMON_CLK)+= clk-s3c2410.o
@@ -18,3 +30,4 @@
 obj-$(CONFIG_S3C2443_COMMON_CLK)+= clk-s3c2443.o
 obj-$(CONFIG_ARCH_S3C64XX)	+= clk-s3c64xx.o
 obj-$(CONFIG_ARCH_S5PV210)	+= clk-s5pv210.o clk-s5pv210-audss.o
+obj-$(CONFIG_PWM_SAMSUNG)	+= clk-exynos-pwm.o
