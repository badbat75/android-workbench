diff -Naur linux-3.18.14/drivers/battery/bq24260_charger.c samsung/drivers/battery/bq24260_charger.c
--- linux-3.18.14/drivers/battery/bq24260_charger.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery/bq24260_charger.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,516 @@
+/*
+ *  bq24260_charger.c
+ *  Samsung bq24260 Charger Driver
+ *
+ *  Copyright (C) 2012 Samsung Electronics
+ *
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#define DEBUG
+
+#include <linux/battery/sec_charger.h>
+
+static int bq24260_i2c_write(struct i2c_client *client,
+				int reg, u8 *buf)
+{
+	int ret;
+	ret = i2c_smbus_write_i2c_block_data(client, reg, 1, buf);
+	if (ret < 0)
+		dev_err(&client->dev, "%s: Error(%d)\n", __func__, ret);
+	return ret;
+}
+
+static int bq24260_i2c_read(struct i2c_client *client,
+				int reg, u8 *buf)
+{
+	int ret;
+	ret = i2c_smbus_read_i2c_block_data(client, reg, 1, buf);
+	if (ret < 0)
+		dev_err(&client->dev, "%s: Error(%d)\n", __func__, ret);
+	return ret;
+}
+
+static void bq24260_i2c_write_array(struct i2c_client *client,
+				u8 *buf, int size)
+{
+	int i;
+	for (i = 0; i < size; i += 3)
+		bq24260_i2c_write(client, (u8) (*(buf + i)), (buf + i) + 1);
+}
+
+static void bq24260_set_command(struct i2c_client *client,
+				int reg, int datum)
+{
+	int val;
+	u8 data = 0;
+	val = bq24260_i2c_read(client, reg, &data);
+	if (val >= 0) {
+		dev_dbg(&client->dev, "%s : reg(0x%02x): 0x%02x(0x%02x)",
+			__func__, reg, data, datum);
+		if (data != datum) {
+			data = datum;
+			if (bq24260_i2c_write(client, reg, &data) < 0)
+				dev_err(&client->dev,
+					"%s : error!\n", __func__);
+			val = bq24260_i2c_read(client, reg, &data);
+			if (val >= 0)
+				dev_dbg(&client->dev, " => 0x%02x\n", data);
+		}
+	}
+}
+
+static void bq24260_test_read(struct i2c_client *client)
+{
+	u8 data = 0;
+	u32 addr = 0;
+	for (addr = 0; addr <= 0x06; addr++) {
+		bq24260_i2c_read(client, addr, &data);
+		dev_dbg(&client->dev,
+			"bq24260 addr : 0x%02x data : 0x%02x\n", addr, data);
+	}
+}
+
+static void bq24260_read_regs(struct i2c_client *client, char *str)
+{
+	u8 data = 0;
+	u32 addr = 0;
+
+	for (addr = 0; addr <= 0x06; addr++) {
+		bq24260_i2c_read(client, addr, &data);
+		sprintf(str+strlen(str), "0x%x, ", data);
+	}
+}
+
+
+static int bq24260_get_charging_status(struct i2c_client *client)
+{
+	int status = POWER_SUPPLY_STATUS_UNKNOWN;
+	u8 data = 0;
+
+	bq24260_i2c_read(client, BQ24260_STATUS, &data);
+	dev_info(&client->dev,
+		"%s : charger status(0x%02x)\n", __func__, data);
+
+	data = (data & 0x30);
+
+	switch (data) {
+	case 0x00:
+		status = POWER_SUPPLY_STATUS_DISCHARGING;
+		break;
+	case 0x10:
+		status = POWER_SUPPLY_STATUS_CHARGING;
+		break;
+	case 0x20:
+		status = POWER_SUPPLY_STATUS_FULL;
+		break;
+	case 0x30:
+		status = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		break;
+	}
+
+	return (int)status;
+}
+
+static int bq24260_get_charging_health(struct i2c_client *client)
+{
+	int health = POWER_SUPPLY_HEALTH_GOOD;
+	u8 data = 0;
+
+	bq24260_i2c_read(client, BQ24260_STATUS, &data);
+	dev_info(&client->dev,
+		"%s : charger status(0x%02x)\n", __func__, data);
+
+	if ((data & 0x30) == 0x30) {	/* check for fault */
+		data = (data & 0x07);
+
+		switch (data) {
+		case 0x01:
+			health = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+			break;
+		case 0x02:
+			health = POWER_SUPPLY_HEALTH_UNDERVOLTAGE;
+			break;
+		}
+	}
+
+	return (int)health;
+}
+
+static u8 bq24260_get_float_voltage_data(
+			int float_voltage)
+{
+	u8 data;
+
+	if (float_voltage < 3500)
+		float_voltage = 3500;
+
+	data = (float_voltage - 3500) / 20;
+
+	return data << 2;
+}
+
+static u8 bq24260_get_input_current_limit_data(
+			int input_current)
+{
+	u8 data = 0x00;
+
+	if (input_current <= 100)
+		data = 0x00;
+	else if (input_current <= 150)
+		data = 0x01;
+	else if (input_current <= 500)
+		data = 0x02;
+	else if (input_current <= 900)
+		data = 0x03;
+	else if (input_current <= 1000)
+		data = 0x04;
+	else if (input_current <= 2000)/* will be set as 1950mA */
+		data = 0x06;
+	else	/* No limit */
+		data = 0x07;
+
+	return data << 4;
+}
+
+static u8 bq24260_get_termination_current_limit_data(
+			int termination_current)
+{
+	u8 data;
+
+	/* default offset 50mA, max 300mA */
+	data = (termination_current - 50) / 50;
+
+	return data;
+}
+
+static u8 bq24260_get_fast_charging_current_data(
+			int fast_charging_current)
+{
+	u8 data;
+
+	/* default offset 500mA */
+	if (fast_charging_current < 500)
+		fast_charging_current = 500;
+
+	data = (fast_charging_current - 500) / 100;
+
+	return data << 3;
+}
+
+static void bq24260_charger_function_conrol(
+				struct i2c_client *client)
+{
+	struct sec_charger_info *charger = i2c_get_clientdata(client);
+	union power_supply_propval val;
+	int full_check_type;
+	u8 data;
+	if (charger->charging_current < 0) {
+		dev_dbg(&client->dev,
+			"%s : OTG is activated. Ignore command!\n", __func__);
+		return;
+	}
+
+	if (charger->cable_type ==
+		POWER_SUPPLY_TYPE_BATTERY) {
+		data = 0x00;
+		bq24260_i2c_read(client, BQ24260_CONTROL, &data);
+		data |= 0x2;
+		data &= 0x7f; /* Prevent register reset */
+		bq24260_set_command(client,
+			BQ24260_CONTROL, data);
+	} else {
+		data = 0x00;
+		bq24260_i2c_read(client, BQ24260_CONTROL, &data);
+		/* Enable charging */
+		data &= 0x7d; /*default enabled*/
+		psy_do_property("battery", get,
+			POWER_SUPPLY_PROP_CHARGE_NOW, val);
+		if (val.intval == SEC_BATTERY_CHARGING_1ST)
+			full_check_type = charger->pdata->full_check_type;
+		else
+			full_check_type = charger->pdata->full_check_type_2nd;
+		/* Termination setting */
+		switch (full_check_type) {
+		case SEC_BATTERY_FULLCHARGED_CHGGPIO:
+		case SEC_BATTERY_FULLCHARGED_CHGINT:
+		case SEC_BATTERY_FULLCHARGED_CHGPSY:
+			/* Enable Current Termination */
+			data |= 0x04;
+			break;
+		default:
+			data &= 0x7b;
+			break;
+		}
+		/* Input current limit */
+		dev_dbg(&client->dev, "%s : input current (%dmA)\n",
+			__func__, charger->pdata->charging_current
+			[charger->cable_type].input_current_limit);
+		data &= 0x0F;
+		data |= bq24260_get_input_current_limit_data(
+			charger->pdata->charging_current
+			[charger->cable_type].input_current_limit);
+		bq24260_set_command(client,
+			BQ24260_CONTROL, data);
+
+		data = 0x00;
+		/* Float voltage */
+		dev_dbg(&client->dev, "%s : float voltage (%dmV)\n",
+			__func__, charger->pdata->chg_float_voltage);
+		data |= bq24260_get_float_voltage_data(
+			charger->pdata->chg_float_voltage);
+		bq24260_set_command(client,
+			BQ24260_VOLTAGE, data);
+
+		data = 0x00;
+		/* Fast charge and Termination current */
+		dev_dbg(&client->dev, "%s : fast charging current (%dmA)\n",
+				__func__, charger->charging_current);
+		data |= bq24260_get_fast_charging_current_data(
+			charger->charging_current);
+		dev_dbg(&client->dev, "%s : termination current (%dmA)\n",
+			__func__, charger->pdata->charging_current[
+			charger->cable_type].full_check_current_1st >= 300 ?
+			300 : charger->pdata->charging_current[
+			charger->cable_type].full_check_current_1st);
+		data |= bq24260_get_termination_current_limit_data(
+			charger->pdata->charging_current[
+			charger->cable_type].full_check_current_1st);
+		bq24260_set_command(client,
+			BQ24260_CURRENT, data);
+
+		/* Special Charger Voltage
+		 * Normal charge current
+		 */
+		bq24260_i2c_read(client, BQ24260_SPECIAL, &data);
+		data &= 0xdf;
+		bq24260_set_command(client,
+			BQ24260_SPECIAL, data);
+	}
+}
+
+static void bq24260_charger_otg_conrol(
+				struct i2c_client *client)
+{
+	struct sec_charger_info *charger = i2c_get_clientdata(client);
+	u8 data;
+	if (charger->cable_type ==
+		POWER_SUPPLY_TYPE_BATTERY) {
+		dev_info(&client->dev, "%s : turn off OTG\n", __func__);
+		/* turn off OTG */
+		bq24260_i2c_read(client, BQ24260_STATUS, &data);
+		data &= 0xbf;
+		bq24260_set_command(client,
+			BQ24260_STATUS, data);
+	} else {
+		dev_info(&client->dev, "%s : turn on OTG\n", __func__);
+		/* turn on OTG */
+		bq24260_i2c_read(client, BQ24260_STATUS, &data);
+		data |= 0x40;
+		bq24260_set_command(client,
+			BQ24260_STATUS, data);
+	}
+}
+
+static int bq24260_get_charge_type(struct i2c_client *client)
+{
+	int ret;
+	u8 data;
+
+	bq24260_i2c_read(client, BQ24260_STATUS, &data);
+	data = (data & 0x30)>>4;
+
+	switch (data) {
+	case 0x01:
+		ret = POWER_SUPPLY_CHARGE_TYPE_FAST;
+		break;
+	default:
+		ret = POWER_SUPPLY_CHARGE_TYPE_NONE;
+		break;
+	}
+
+	return ret;
+}
+
+bool sec_hal_chg_init(struct i2c_client *client)
+{
+	bq24260_test_read(client);
+	return true;
+}
+
+bool sec_hal_chg_suspend(struct i2c_client *client)
+{
+	return true;
+}
+
+bool sec_hal_chg_resume(struct i2c_client *client)
+{
+	return true;
+}
+
+bool sec_hal_chg_get_property(struct i2c_client *client,
+			      enum power_supply_property psp,
+			      union power_supply_propval *val)
+{
+	struct sec_charger_info *charger = i2c_get_clientdata(client);
+	u8 data;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = bq24260_get_charging_status(client);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+		val->intval = bq24260_get_charge_type(client);
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = bq24260_get_charging_health(client);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		if (charger->charging_current) {
+			/* Rsns 0.068 Ohm */
+			bq24260_i2c_read(client, BQ24260_CURRENT, &data);
+			val->intval = (data >> 3) * 100 + 500;
+		} else
+			val->intval = 0;
+		dev_dbg(&client->dev,
+			"%s : set-current(%dmA), current now(%dmA)\n",
+			__func__, charger->charging_current, val->intval);
+		break;
+	default:
+		return false;
+	}
+	return true;
+}
+
+bool sec_hal_chg_set_property(struct i2c_client *client,
+			      enum power_supply_property psp,
+			      const union power_supply_propval *val)
+{
+	struct sec_charger_info *charger = i2c_get_clientdata(client);
+
+	switch (psp) {
+	/* val->intval : type */
+	case POWER_SUPPLY_PROP_ONLINE:
+		if (charger->pdata->chg_gpio_en) {
+			if (gpio_request(charger->pdata->chg_gpio_en,
+				"CHG_EN") < 0) {
+				dev_err(&client->dev,
+					"failed to request vbus_in gpio\n");
+				break;
+			}
+			if (charger->cable_type ==
+				POWER_SUPPLY_TYPE_BATTERY)
+				gpio_set_value_cansleep(
+					charger->pdata->chg_gpio_en,
+					charger->pdata->chg_polarity_en ?
+					0 : 1);
+			else
+				gpio_set_value_cansleep(
+					charger->pdata->chg_gpio_en,
+					charger->pdata->chg_polarity_en ?
+					1 : 0);
+			gpio_free(charger->pdata->chg_gpio_en);
+		}
+	/* val->intval : charging current */
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		if (charger->charging_current < 0)
+			bq24260_charger_otg_conrol(client);
+		else if (charger->charging_current > 0)
+			bq24260_charger_function_conrol(client);
+		else {
+			bq24260_charger_function_conrol(client);
+			bq24260_charger_otg_conrol(client);
+		}
+		bq24260_test_read(client);
+		break;
+	default:
+		return false;
+	}
+	return true;
+}
+
+ssize_t sec_hal_chg_show_attrs(struct device *dev,
+				const ptrdiff_t offset, char *buf)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct sec_charger_info *chg =
+		container_of(psy, struct sec_charger_info, psy_chg);
+	int i = 0;
+	char *str = NULL;
+
+	switch (offset) {
+	case CHG_REG:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%x\n",
+			chg->reg_addr);
+		break;
+	case CHG_DATA:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%x\n",
+			chg->reg_data);
+		break;
+	case CHG_REGS:
+		str = kzalloc(sizeof(char)*1024, GFP_KERNEL);
+		if (!str)
+			return -ENOMEM;
+
+		bq24260_read_regs(chg->client, str);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%s\n",
+			str);
+
+		kfree(str);
+		break;
+	default:
+		i = -EINVAL;
+		break;
+	}
+
+	return i;
+}
+
+ssize_t sec_hal_chg_store_attrs(struct device *dev,
+				const ptrdiff_t offset,
+				const char *buf, size_t count)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct sec_charger_info *chg =
+		container_of(psy, struct sec_charger_info, psy_chg);
+	int ret = 0;
+	int x = 0;
+	u8 data = 0;
+
+	switch (offset) {
+	case CHG_REG:
+		if (sscanf(buf, "%x\n", &x) == 1) {
+			chg->reg_addr = x;
+			bq24260_i2c_read(chg->client,
+				chg->reg_addr, &data);
+			chg->reg_data = data;
+			dev_dbg(dev, "%s: (read) addr = 0x%x, data = 0x%x\n",
+				__func__, chg->reg_addr, chg->reg_data);
+			ret = count;
+		}
+		break;
+	case CHG_DATA:
+		if (sscanf(buf, "%x\n", &x) == 1) {
+			data = (u8)x;
+			dev_dbg(dev, "%s: (write) addr = 0x%x, data = 0x%x\n",
+				__func__, chg->reg_addr, data);
+			bq24260_i2c_write(chg->client,
+				chg->reg_addr, &data);
+			ret = count;
+		}
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
diff -Naur linux-3.18.14/drivers/battery/bq51221_charger.c samsung/drivers/battery/bq51221_charger.c
--- linux-3.18.14/drivers/battery/bq51221_charger.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery/bq51221_charger.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,759 @@
+/*
+ *  bq51221_charger.c
+ *  Samsung bq51221 Charger Driver
+ *
+ *  Copyright (C) 2014 Samsung Electronics
+ * Yeongmi Ha <yeongmi86.ha@samsung.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/battery/charger/bq51221_charger.h>
+#include <linux/errno.h>
+#include <linux/version.h>
+#include <linux/device.h>
+#include <linux/pm.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/pm_runtime.h>
+#include <linux/irqdomain.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/kernel.h>
+
+#define ENABLE 1
+#define DISABLE 0
+
+static enum power_supply_property sec_charger_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_CHARGE_TYPE,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
+	POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL,
+};
+
+static int bq51221_read_device(struct i2c_client *client,
+		u8 reg, u8 bytes, void *dest)
+{
+	int ret;
+	if (bytes > 1) {
+		ret = i2c_smbus_read_i2c_block_data(client, reg, bytes, dest);
+	} else {
+		ret = i2c_smbus_read_byte_data(client, reg);
+		if (ret < 0)
+			return ret;
+		*(unsigned char *)dest = (unsigned char)ret;
+	}
+	return ret;
+}
+
+static int bq51221_reg_read(struct i2c_client *client, u8 reg)
+{
+	struct bq51221_charger_data *charger = i2c_get_clientdata(client);
+	u8 data;
+	int ret = 0;
+
+	mutex_lock(&charger->io_lock);
+	ret = bq51221_read_device(client, reg, 1, &data);
+	mutex_unlock(&charger->io_lock);
+
+	if (ret < 0) {
+		pr_err("%s: can't read reg(0x%x), ret(%d)\n", __func__, reg, ret);
+		return ret;
+	} else {
+		pr_err("%s: can read reg(0x%x), ret(%d)\n", __func__, reg, ret);
+		return (int)data;
+	}
+}
+
+static int bq51221_reg_write(struct i2c_client *client, u8 reg, u8 data)
+{
+	struct bq51221_charger_data *charger = i2c_get_clientdata(client);
+	int ret = 0;
+
+	mutex_lock(&charger->io_lock);
+	ret = i2c_smbus_write_byte_data(client, reg, data);
+	mutex_unlock(&charger->io_lock);
+
+	if (ret < 0)
+		pr_err("%s: can't write reg(0x%x), ret(%d)\n", __func__, reg, ret);
+
+	return ret;
+}
+
+static int bq51221_get_pad_mode(struct i2c_client *client)
+{
+	int ret = 0;
+	int retry_cnt =0;
+	struct bq51221_charger_data *charger = i2c_get_clientdata(client);
+
+	if(charger->pdata->pad_mode != BQ51221_PAD_MODE_NONE) {
+		/* read pad mode PMA = 1, WPC = 0 (Status bit)*/
+		ret = bq51221_reg_read(client, BQ51221_REG_INDICATOR);
+		if(ret < 0) {
+			while(retry_cnt++ < 3) {
+				msleep(50);
+				pr_info("%s retry_cnt = %d, ret =%d \n",__func__, retry_cnt, ret);
+				/* read pad mode PMA = 1, WPC = 0 (Status bit)*/
+				ret = bq51221_reg_read(client, BQ51221_REG_INDICATOR);
+				if(ret >= 0)
+					break;
+			}
+		}
+		pr_info("%s pad_mode = %d \n", __func__,ret);
+
+		if(ret >= 0) {
+			ret &= BQ51221_POWER_MODE_MASK;
+
+			if(ret == 0)
+				charger->pdata->pad_mode = BQ51221_PAD_MODE_WPC;
+			else if (ret == 1)
+				charger->pdata->pad_mode = BQ51221_PAD_MODE_PMA;
+			else
+				charger->pdata->pad_mode = BQ51221_PAD_MODE_WPC;
+		}
+		else
+			ret = 0;
+	}
+	return ret;
+}
+
+int bq51221_set_full_charge_info(struct i2c_client *client)
+{
+	int data = 0;
+	int ret = 0, i = 0;
+	int retry_cnt =0;
+
+	pr_info("%s\n", __func__);
+
+	for(i=0; i< 3; i++) {
+		/* send cs100 */
+		ret = bq51221_reg_write(client, BQ51221_REG_USER_HEADER, BQ51221_EPT_HEADER_CS100);
+		ret = bq51221_reg_write(client, BQ51221_REG_PROP_PACKET_PAYLOAD, BQ51221_CS100_VALUE);
+
+		if(ret < 0) {
+			while(retry_cnt++ < 3) {
+				msleep(50);
+				pr_info("%s retry_cnt = %d, ret =%d \n",__func__, retry_cnt, ret);
+				/* send cs100 */
+				ret = bq51221_reg_write(client, BQ51221_REG_USER_HEADER, BQ51221_EPT_HEADER_CS100);
+				ret = bq51221_reg_write(client, BQ51221_REG_PROP_PACKET_PAYLOAD, BQ51221_CS100_VALUE);
+
+				if(ret >= 0)
+					break;
+			}
+			return ret;
+		}
+
+		/* send end packet */
+		data = bq51221_reg_read(client, BQ51221_REG_MAILBOX);
+
+		data &= !BQ51221_SEND_USER_PKT_DONE_MASK;
+		ret = bq51221_reg_write(client, BQ51221_REG_MAILBOX, data);
+
+		/* check packet error */
+		data = bq51221_reg_read(client, BQ51221_REG_MAILBOX);
+		data &= BQ51221_SEND_USER_PKT_ERR_MASK;
+		data = data >> 5;
+
+		pr_info("%s error pkt = 0x%x \n",__func__, data);
+
+		if(data == BQ51221_PTK_ERR_NO_ERR) {
+			pr_err("%s sent CS100!\n",__func__);
+			ret = 1;
+		} else {
+			pr_err("%s can not send CS100! err pkt = 0x%x\n",__func__, data);
+			ret = -1;
+		}
+		msleep(300);
+	}
+	return ret;
+}
+
+int bq51221_set_voreg(struct i2c_client *client, int default_value)
+{
+	u8 data = 0;
+	int ret = 0;
+	int retry_cnt =0;
+	union power_supply_propval value;
+	struct bq51221_charger_data *charger = i2c_get_clientdata(client);
+
+#if defined(CONFIG_WIRELESS_CHARGER_INBATTERY_5V_FIX)
+	return 0;
+#endif
+
+	if (charger->pdata->pad_mode == BQ51221_PAD_MODE_PMA) {
+		pr_info("%s PMA MODE, do not set Voreg \n", __func__);
+		return 0;
+	}
+
+	psy_do_property("battery", get,
+				POWER_SUPPLY_PROP_CAPACITY, value);
+
+	if ((value.intval >= charger->pdata->wireless_cc_cv) && !default_value)
+		default_value = 1;
+
+	if (default_value) {
+		/* init VOREG with default value */
+		ret = bq51221_reg_write(client, BQ51221_REG_CURRENT_REGISTER, 0x01);
+		if(ret < 0) {
+			while(retry_cnt++ < 3) {
+				msleep(50);
+				pr_debug("%s retry_cnt = %d, ret =%d \n",__func__, retry_cnt, ret);
+				/* init VOREG with default value */
+				ret = bq51221_reg_write(client, BQ51221_REG_CURRENT_REGISTER, 0x01);
+				data = bq51221_reg_read(client, BQ51221_REG_CURRENT_REGISTER);
+				if(ret >= 0) {
+					pr_debug("%s VOREG = 0x%x \n", __func__, data);
+					break;
+				}
+			}
+		}
+		data = bq51221_reg_read(client, BQ51221_REG_CURRENT_REGISTER);
+		pr_info("%s VOREG = 0x%x 5.0V, cnt(%d)\n", __func__, data, retry_cnt);
+	} else {
+		ret = bq51221_reg_write(client, BQ51221_REG_CURRENT_REGISTER, 0x02);
+		if(ret < 0) {
+			while(retry_cnt++ < 3) {
+				msleep(50);
+				pr_debug("%s retry_cnt = %d, ret =%d \n",__func__, retry_cnt, ret);
+				/* init VOREG with default value */
+				ret = bq51221_reg_write(client, BQ51221_REG_CURRENT_REGISTER, 0x02);
+				data = bq51221_reg_read(client, BQ51221_REG_CURRENT_REGISTER);
+				if(ret >= 0) {
+					pr_debug("%s VOREG = 0x%x \n", __func__, data);
+					break;
+				}
+			}
+		}
+		data = bq51221_reg_read(client, BQ51221_REG_CURRENT_REGISTER);
+		pr_info("%s VOREG = 0x%x 5.5V, cnt(%d)\n", __func__, data, retry_cnt);
+	}
+	return ret;
+}
+
+int bq51221_set_end_power_transfer(struct i2c_client *client, int ept_mode)
+{
+
+	int pad_mode = 0;
+	int data = 0;
+	int ret = 0;
+
+	pr_info("%s\n", __func__);
+
+	switch(ept_mode)
+	{
+		case END_POWER_TRANSFER_CODE_OVER_TEMPERATURE:
+			/* read pad mode PMA = 1, WPC = 0 (Status bit)*/
+			pad_mode = bq51221_reg_read(client, BQ51221_REG_INDICATOR);
+			pr_info("%s pad_mode = %d \n", __func__,pad_mode);
+
+			if(pad_mode > 0)
+				pad_mode &= BQ51221_POWER_MODE_MASK;
+
+			if(pad_mode) {
+				pr_info("%s PMA MODE, send EOC \n", __func__);
+
+				data = bq51221_reg_read(client, BQ51221_REG_MAILBOX);
+				data |= BQ51221_SEND_EOC_MASK;
+				ret = bq51221_reg_write(client, BQ51221_REG_MAILBOX, data);
+			} else {
+				pr_info("%s WPC MODE, send EPT-OT \n", __func__);
+
+				ret = bq51221_reg_write(client, BQ51221_REG_USER_HEADER, BQ51221_EPT_HEADER_EPT);
+				ret = bq51221_reg_write(client, BQ51221_REG_PROP_PACKET_PAYLOAD, BQ51221_EPT_CODE_OVER_TEMPERATURE);
+
+				/* send end packet */
+				data = bq51221_reg_read(client, BQ51221_REG_MAILBOX);
+				data &= !BQ51221_SEND_USER_PKT_DONE_MASK;
+				ret = bq51221_reg_write(client, BQ51221_REG_MAILBOX, data);
+
+				/* check packet error */
+				data = bq51221_reg_read(client, BQ51221_REG_MAILBOX);
+				data &= BQ51221_SEND_USER_PKT_ERR_MASK;
+				data = data >> 5;
+
+				pr_info("%s error pkt = 0x%x \n",__func__, data);
+
+				if(data != BQ51221_PTK_ERR_NO_ERR) {
+					pr_err("%s can not send ept! err pkt = 0x%x\n",__func__, data);
+					ret = -1;
+				}
+			}
+			break;
+		case END_POWER_TRANSFER_CODE_RECONFIGURE:
+			pr_info("%s send EPT-Reconfigure \n", __func__);
+
+			ret = bq51221_reg_write(client, BQ51221_REG_USER_HEADER, BQ51221_EPT_HEADER_EPT);
+			ret = bq51221_reg_write(client, BQ51221_REG_PROP_PACKET_PAYLOAD, BQ51221_EPT_CODE_RECONFIGURE);
+
+			/* send end packet */
+			data = bq51221_reg_read(client, BQ51221_REG_MAILBOX);
+			data &= !BQ51221_SEND_USER_PKT_DONE_MASK;
+			ret = bq51221_reg_write(client, BQ51221_REG_MAILBOX, data);
+
+			/* check packet error */
+			data = bq51221_reg_read(client, BQ51221_REG_MAILBOX);
+			data &= BQ51221_SEND_USER_PKT_ERR_MASK;
+			data = data >> 5;
+
+			pr_info("%s error pkt = 0x%x \n",__func__, data);
+
+			if(data != BQ51221_PTK_ERR_NO_ERR) {
+				pr_err("%s can not send ept! err pkt = 0x%x\n",__func__, data);
+				ret = -1;
+			}
+			break;
+		default:
+			pr_info("%s this ept mode is not reserved \n",__func__);
+			ret = -1;
+			break;
+	}
+
+	return ret;
+}
+
+void bq51221_wireless_chg_init(struct i2c_client *client)
+{
+	int data = 0;
+	union power_supply_propval value;
+	struct bq51221_charger_data *charger = i2c_get_clientdata(client);
+
+	pr_info("%s\n", __func__);
+
+	psy_do_property("battery", get,
+				POWER_SUPPLY_PROP_CAPACITY, value);
+	/* init I limit(IOREG) */
+	bq51221_reg_write(client, BQ51221_REG_CURRENT_REGISTER2, BQ51221_IOREG_100_VALUE);
+	data = bq51221_reg_read(client, BQ51221_REG_CURRENT_REGISTER2);
+	pr_info("%s IOREG = 0x%x \n", __func__, data);
+
+	/* init CEP timing */
+
+	/* init RCVD PWR */
+
+	/* read pad mode */
+	bq51221_get_pad_mode(client);
+
+	pr_info("%s siop = %d \n" ,__func__, charger->pdata->siop_level );
+	if ((value.intval < charger->pdata->wireless_cc_cv) &&
+		(charger->pdata->pad_mode == BQ51221_PAD_MODE_WPC) &&
+		(charger->pdata->siop_level == 100) &&
+		!charger->pdata->default_voreg) {
+		/* set VOREG set 5.5V*/
+		bq51221_set_voreg(charger->client, 0);
+	} else {
+		/* init VOREG with default value */
+		bq51221_set_voreg(charger->client, 1);
+	}
+}
+
+static void bq51221_detect_work(
+		struct work_struct *work)
+{
+	struct bq51221_charger_data *charger =
+		container_of(work, struct bq51221_charger_data, wpc_work.work);
+
+	pr_info("%s\n", __func__);
+
+	bq51221_wireless_chg_init(charger->client);
+}
+
+static int bq51221_chg_get_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		union power_supply_propval *val)
+{
+	struct bq51221_charger_data *charger =
+		container_of(psy, struct bq51221_charger_data, psy_chg);
+
+	switch (psp) {
+		case POWER_SUPPLY_PROP_STATUS:
+			pr_info("%s charger->pdata->cs100_status %d \n",__func__,charger->pdata->cs100_status);
+			val->intval = charger->pdata->cs100_status;
+			break;
+		case POWER_SUPPLY_PROP_CHARGE_TYPE:
+			val->intval = bq51221_get_pad_mode(charger->client);
+			break;
+		case POWER_SUPPLY_PROP_HEALTH:
+			val->intval = 1;
+			break;
+		case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+			val->intval = charger->pdata->siop_level;
+			break;
+		case POWER_SUPPLY_PROP_ONLINE:
+		case POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL:
+			break;
+		default:
+			return -EINVAL;
+	}
+	return 0;
+}
+
+static int bq51221_chg_set_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		const union power_supply_propval *val)
+{
+	struct bq51221_charger_data *charger =
+		container_of(psy, struct bq51221_charger_data, psy_chg);
+	union power_supply_propval value;
+
+	switch (psp) {
+		case POWER_SUPPLY_PROP_STATUS:
+			if(val->intval == POWER_SUPPLY_STATUS_FULL) {
+				charger->pdata->cs100_status = bq51221_set_full_charge_info(charger->client);
+				pr_info("%s charger->pdata->cs100_status %d \n",__func__,charger->pdata->cs100_status);
+			}
+			break;
+		case POWER_SUPPLY_PROP_CHARGE_TYPE:
+			if (!charger->pdata->default_voreg &&
+				!delayed_work_pending(&charger->wpc_work))
+				bq51221_set_voreg(charger->client, val->intval);
+			break;
+		case POWER_SUPPLY_PROP_HEALTH:
+			if(val->intval == POWER_SUPPLY_HEALTH_OVERHEAT ||
+				val->intval == POWER_SUPPLY_HEALTH_OVERHEATLIMIT ||
+				val->intval == POWER_SUPPLY_HEALTH_COLD)
+				bq51221_set_end_power_transfer(charger->client, END_POWER_TRANSFER_CODE_OVER_TEMPERATURE);
+			else if(val->intval == POWER_SUPPLY_HEALTH_UNDERVOLTAGE)
+				bq51221_set_end_power_transfer(charger->client, END_POWER_TRANSFER_CODE_RECONFIGURE);
+			break;
+		case POWER_SUPPLY_PROP_ONLINE:
+			if(val->intval == POWER_SUPPLY_TYPE_WIRELESS) {
+				charger->pdata->pad_mode = BQ51221_PAD_MODE_WPC;
+				queue_delayed_work(charger->wqueue, &charger->wpc_work,
+					msecs_to_jiffies(5000));
+				wake_lock_timeout(&charger->wpc_wake_lock, HZ * 6);
+			} else if(val->intval == POWER_SUPPLY_TYPE_BATTERY) {
+				bq51221_set_voreg(charger->client, 1);
+				charger->pdata->pad_mode = BQ51221_PAD_MODE_NONE;
+				cancel_delayed_work(&charger->wpc_work);
+			}
+			break;
+		case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+			charger->pdata->siop_level = val->intval;
+			pr_info("%s siop = %d \n",__func__, charger->pdata->siop_level);
+			break;
+		case POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL:
+			if (val->intval) {
+				charger->pdata->default_voreg = true;
+				bq51221_set_voreg(charger->client, val->intval);
+			} else {
+				charger->pdata->default_voreg = false;
+				psy_do_property("battery", get,
+						POWER_SUPPLY_PROP_STATUS, value);
+				if ((value.intval == POWER_SUPPLY_STATUS_CHARGING) &&
+					(charger->pdata->pad_mode == BQ51221_PAD_MODE_WPC)) {
+					queue_delayed_work(charger->wqueue, &charger->wpc_work,
+						msecs_to_jiffies(5000));
+					wake_lock_timeout(&charger->wpc_wake_lock, HZ * 6);
+				}
+			}
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+#if 0 /* this part is for bq51221s */
+static void bq51221_chg_isr_work(struct work_struct *work)
+{
+	//struct bq51221_charger_data *charger =
+	//	container_of(work, struct bq51221_charger_data, isr_work.work);
+
+	pr_info("%s \n",__func__);
+}
+
+static irqreturn_t bq51221_chg_irq_thread(int irq, void *irq_data)
+{
+	struct bq51221_charger_data *charger = irq_data;
+
+	pr_info("%s \n",__func__);
+		schedule_delayed_work(&charger->isr_work, 0);
+
+	return IRQ_HANDLED;
+}
+#endif
+
+static int bq51221_chg_parse_dt(struct device *dev,
+		bq51221_charger_platform_data_t *pdata)
+{
+	int ret = 0;
+	struct device_node *np = dev->of_node;
+
+	if (!np) {
+		pr_info("%s: np NULL\n", __func__);
+		return 1;
+	}
+
+	np = of_find_node_by_name(NULL, "battery");
+	if (!np) {
+		pr_err("%s np NULL\n", __func__);
+	} else {
+		ret = of_property_read_u32(np,
+			"battery,wireless_cc_cv", &pdata->wireless_cc_cv);
+
+		ret = of_property_read_string(np,
+			"battery,wirelss_charger_name", (char const **)&pdata->wireless_charger_name);
+		if (ret)
+			pr_info("%s: Vendor is Empty\n", __func__);
+	}
+
+
+	return ret;
+
+#if 0 /* this part is for bq51221s */
+	ret = pdata->irq_gpio = of_get_named_gpio_flags(np, "bq51221-charger,irq-gpio",
+			0, &irq_gpio_flags);
+	if (ret < 0) {
+		dev_err(dev, "%s : can't get irq-gpio\r\n", __FUNCTION__);
+		return ret;
+	}
+	pr_info("%s irq_gpio = %d \n",__func__, pdata->irq_gpio);
+	pdata->irq_base = gpio_to_irq(pdata->irq_gpio);
+
+	return 0;
+#endif
+}
+
+static int bq51221_charger_probe(
+						struct i2c_client *client,
+						const struct i2c_device_id *id)
+{
+	struct device_node *of_node = client->dev.of_node;
+	struct bq51221_charger_data *charger;
+	bq51221_charger_platform_data_t *pdata = client->dev.platform_data;
+	int ret = 0;
+
+	dev_info(&client->dev,
+		"%s: bq51221 Charger Driver Loading\n", __func__);
+
+	if (of_node) {
+		pdata = devm_kzalloc(&client->dev, sizeof(*pdata), GFP_KERNEL);
+		if (!pdata) {
+			dev_err(&client->dev, "Failed to allocate memory\n");
+			return -ENOMEM;
+		}
+		ret = bq51221_chg_parse_dt(&client->dev, pdata);
+		if (ret < 0)
+			goto err_parse_dt;
+	} else {
+		pdata = client->dev.platform_data;
+	}
+
+	charger = kzalloc(sizeof(*charger), GFP_KERNEL);
+	if (charger == NULL) {
+		dev_err(&client->dev, "Memory is not enough.\n");
+		ret = -ENOMEM;
+		goto err_wpc_nomem;
+	}
+	charger->dev = &client->dev;
+
+	ret = i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA |
+		I2C_FUNC_SMBUS_WORD_DATA | I2C_FUNC_SMBUS_I2C_BLOCK);
+	if (!ret) {
+		ret = i2c_get_functionality(client->adapter);
+		dev_err(charger->dev, "I2C functionality is not supported.\n");
+		ret = -ENOSYS;
+		goto err_i2cfunc_not_support;
+	}
+
+	charger->client = client;
+	charger->pdata = pdata;
+
+    pr_info("%s: %s\n", __func__, charger->pdata->wireless_charger_name );
+
+	/* if board-init had already assigned irq_base (>=0) ,
+	no need to allocate it;
+	assign -1 to let this driver allocate resource by itself*/
+#if 0 /* this part is for bq51221s */
+    if (pdata->irq_base < 0)
+        pdata->irq_base = irq_alloc_descs(-1, 0, BQ51221_EVENT_IRQ, 0);
+	if (pdata->irq_base < 0) {
+		pr_err("%s: irq_alloc_descs Fail! ret(%d)\n",
+				__func__, pdata->irq_base);
+		ret = -EINVAL;
+		goto irq_base_err;
+	} else {
+		charger->irq_base = pdata->irq_base;
+		pr_info("%s: irq_base = %d\n",
+			 __func__, charger->irq_base);
+
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(3,4,0))
+		irq_domain_add_legacy(of_node, BQ51221_EVENT_IRQ, charger->irq_base, 0,
+				      &irq_domain_simple_ops, NULL);
+#endif /*(LINUX_VERSION_CODE>=KERNEL_VERSION(3,4,0))*/
+	}
+#endif
+	i2c_set_clientdata(client, charger);
+
+	charger->psy_chg.name		= pdata->wireless_charger_name;
+	charger->psy_chg.type		= POWER_SUPPLY_TYPE_UNKNOWN;
+	charger->psy_chg.get_property	= bq51221_chg_get_property;
+	charger->psy_chg.set_property	= bq51221_chg_set_property;
+	charger->psy_chg.properties	= sec_charger_props;
+	charger->psy_chg.num_properties	= ARRAY_SIZE(sec_charger_props);
+
+	mutex_init(&charger->io_lock);
+
+#if 0 /* this part is for bq51221s */
+
+	if (charger->chg_irq) {
+		INIT_DELAYED_WORK(
+			&charger->isr_work, bq51221_chg_isr_work);
+
+		ret = request_threaded_irq(charger->chg_irq,
+				NULL, bq51221_chg_irq_thread,
+				IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
+				"charger-irq", charger);
+		if (ret) {
+			dev_err(&client->dev,
+				"%s: Failed to Reqeust IRQ\n", __func__);
+			goto err_supply_unreg;
+		}
+
+		ret = enable_irq_wake(charger->chg_irq);
+		if (ret < 0)
+			dev_err(&client->dev,
+				"%s: Failed to Enable Wakeup Source(%d)\n",
+				__func__, ret);
+	}
+#endif
+	charger->pdata->cs100_status = 0;
+	charger->pdata->pad_mode = BQ51221_PAD_MODE_NONE;
+	charger->pdata->siop_level = 100;
+	charger->pdata->default_voreg = false;
+
+	ret = power_supply_register(&client->dev, &charger->psy_chg);
+	if (ret) {
+		dev_err(&client->dev,
+			"%s: Failed to Register psy_chg\n", __func__);
+		goto err_supply_unreg;
+	}
+
+	charger->wqueue = create_workqueue("bq51221_workqueue");
+	if (!charger->wqueue) {
+		pr_err("%s: Fail to Create Workqueue\n", __func__);
+		goto err_pdata_free;
+	}
+
+	wake_lock_init(&(charger->wpc_wake_lock), WAKE_LOCK_SUSPEND,
+			"wpc_wakelock");
+	INIT_DELAYED_WORK(&charger->wpc_work, bq51221_detect_work);
+
+	dev_info(&client->dev,
+		"%s: bq51221 Charger Driver Loaded\n", __func__);
+
+	return 0;
+
+err_pdata_free:
+	power_supply_unregister(&charger->psy_chg);
+err_supply_unreg:
+	mutex_destroy(&charger->io_lock);
+err_i2cfunc_not_support:
+	kfree(charger);
+err_wpc_nomem:
+err_parse_dt:
+	kfree(pdata);
+	return ret;
+}
+
+static int bq51221_charger_remove(struct i2c_client *client)
+{
+	return 0;
+}
+
+#if defined CONFIG_PM
+static int bq51221_charger_suspend(struct i2c_client *client,
+				pm_message_t state)
+{
+
+
+	return 0;
+}
+
+static int bq51221_charger_resume(struct i2c_client *client)
+{
+
+
+	return 0;
+}
+#else
+#define p9015_charger_suspend NULL
+#define p9015_charger_resume NULL
+#endif
+
+static void bq51221_charger_shutdown(struct i2c_client *client)
+{
+	struct bq51221_charger_data *charger = i2c_get_clientdata(client);
+	int data = 0;
+
+	if(charger->pdata->pad_mode != BQ51221_PAD_MODE_NONE) {
+		/* init VOREG set 5.0V*/
+		bq51221_reg_write(client, BQ51221_REG_CURRENT_REGISTER, 0x01);
+		data = bq51221_reg_read(client, BQ51221_REG_CURRENT_REGISTER);
+		pr_info("%s VOREG = 0x%x \n", __func__, data);
+	}
+}
+
+static const struct i2c_device_id bq51221_charger_id_table[] = {
+	{ "bq51221-charger", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, bq51221_id_table);
+
+#ifdef CONFIG_OF
+static struct of_device_id bq51221_charger_match_table[] = {
+	{ .compatible = "ti,bq51221-charger",},
+	{},
+};
+#else
+#define bq51221_charger_match_table NULL
+#endif
+
+static struct i2c_driver bq51221_charger_driver = {
+	.driver = {
+		.name	= "bq51221-charger",
+		.owner	= THIS_MODULE,
+		.of_match_table = bq51221_charger_match_table,
+	},
+	.shutdown	= bq51221_charger_shutdown,
+	.suspend	= bq51221_charger_suspend,
+	.resume		= bq51221_charger_resume,
+	.probe	= bq51221_charger_probe,
+	.remove	= bq51221_charger_remove,
+	.id_table	= bq51221_charger_id_table,
+};
+
+static int __init bq51221_charger_init(void)
+{
+	pr_info("%s \n",__func__);
+	return i2c_add_driver(&bq51221_charger_driver);
+}
+
+static void __exit bq51221_charger_exit(void)
+{
+	pr_info("%s \n",__func__);
+	i2c_del_driver(&bq51221_charger_driver);
+}
+
+module_init(bq51221_charger_init);
+module_exit(bq51221_charger_exit);
+
+MODULE_DESCRIPTION("Samsung bq51221 Charger Driver");
+MODULE_AUTHOR("Samsung Electronics");
+MODULE_LICENSE("GPL");
diff -Naur linux-3.18.14/drivers/battery/Kconfig samsung/drivers/battery/Kconfig
--- linux-3.18.14/drivers/battery/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery/Kconfig	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,570 @@
+
+config BATTERY_SAMSUNG
+	tristate "samsung battery driver"
+	help
+	 Say Y to include support for samsung battery driver
+	 This battery driver integrated all battery-related functions
+	 To see battery-related functions,
+	 refer to sec_charging_common.h
+
+config CHARGING_VZWCONCEPT
+	tristate "VZW concept about the charging"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support for the VZW concepts.
+
+config PREVENT_SOC_JUMP
+	tristate "prevent soc jump at full-charged"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to prevent soc jump
+
+config BATTERY_SWELLING
+	bool "prevent battery swelling"
+	help
+	  Say Y to include support for prevent battery swelling
+
+config BATTERY_SWELLING_SELF_DISCHARGING
+	bool "prevent battery swelling with self discharging"
+	help
+	  Say Y to include support for prevent battery swelling with self discharging
+
+config SW_SELF_DISCHARGING
+	bool "enable sw_self_discharging"
+	default n
+	help
+	  Say Y to enable CONFIG_SW_SELF_DISCHARGING
+
+config INBATTERY
+       bool "prevent inbattery"
+       default n
+       depends on BATTERY_SAMSUNG
+       help
+	Say Y to include support for prevent inbattery
+
+config CALC_TIME_TO_FULL
+	tristate "calculate time to full"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	Say Y to use calc time to full function.
+
+config BATTERY_AGE_FORECAST
+	tristate "battery age forecast"
+	default n
+	help
+	Say Y to use battery age forecast
+
+config BATTERY_AGE_FORECAST_DETACHABLE
+	tristate "battery age forecast for detachable"
+	default n
+	select BATTERY_AGE_FORECAST
+	help
+	Say Y to use battery age forecast for detachable
+
+config CONDITIONAL_SAFETY_TIMER
+	bool "new safety timer concept applied by charging source and current."
+	default n
+	help
+	  Say Y to include support for conditional safety timer concept.
+
+# Fuel Gauge
+
+config FUELGAUGE_DUMMY
+	tristate "dummy fuel gauge driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for dummy fuel gauge driver.
+	 This driver source code implemented
+	 skeleton source code for fuel gauge functions.
+
+config FUELGAUGE_MAX17042
+	tristate "MAX17042 fuel gauge driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for MAXIM MAX17042 fuel gauge driver.
+	 This fuel-gauge can be used in voltage-tracking mode
+	 or coulomb-counting mode.
+
+config FUELGAUGE_MAX17042_VOLTAGE_TRACKING
+	tristate "use MAX17042 fuel gauge only as voltage tracking"
+	default n
+	depends on FUELGAUGE_MAX17042
+	help
+	 Say Y to use MAX17042 fuel gauge
+	 only as voltage tracking.
+	 This mode is for target that consumes low current
+	 like smart-phone.
+
+config FUELGAUGE_MAX17042_COULOMB_COUNTING
+	tristate "use MAX17042 fuel gauge as coulomb counting (including voltage tracking)"
+	default n
+	depends on FUELGAUGE_MAX17042
+	help
+	 Say Y to use MAX17042 fuel gauge
+	 as coulomb counting (including voltage tracking).
+	 This mode is for target that consumes high current
+	 like tablet.
+
+config FUELGAUGE_MAX17048
+	tristate "MAX17048 fuel gauge driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for MAXIM MAX17048 fuel gauge driver.
+	 This fuel-gauge can be used
+	 only in voltage-tracking mode.
+
+config FUELGAUGE_MAX17050
+	tristate "MAX17050 fuel gauge driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for MAXIM MAX17047 or MAX17050 fuel gauge driver.
+	 This fuel-gauge can be used in voltage-tracking mode
+	 or coulomb-counting mode.
+
+config FUELGAUGE_MAX17050_VOLTAGE_TRACKING
+	tristate "use MAX17050 fuel gauge only as voltage tracking"
+	default n
+	depends on FUELGAUGE_MAX17050
+	help
+	 Say Y to use MAX17050 fuel gauge
+	 only as voltage tracking.
+	 This mode is for target that consumes low current
+	 like smart-phone.
+
+config FUELGAUGE_MAX17050_COULOMB_COUNTING
+	tristate "use MAX17050 fuel gauge as coulomb counting (including voltage tracking)"
+	default n
+	depends on FUELGAUGE_MAX17050
+	help
+	 Say Y to use MAX17050 fuel gauge
+	 as coulomb counting (including voltage tracking).
+	 This mode is for target that consumes high current
+	 like tablet.
+
+config FUELGAUGE_MAX77823
+	tristate "MAX77823 fuel gauge driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for MAXIM MAX17047 or MAX17050 fuel gauge driver.
+	 This fuel-gauge can be used in voltage-tracking mode
+	 or coulomb-counting mode.
+
+config FUELGAUGE_MAX77843
+	tristate "MAX77843 fuel gauge driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for MAXIM MAX17047 or MAX17050 fuel gauge driver.
+	 This fuel-gauge can be used in voltage-tracking mode
+	 or coulomb-counting mode.
+
+config FUELGAUGE_MAX77833
+	tristate "MAX77833 fuel gauge driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for MAXIM MAX77833 fuel gauge driver.
+	 This fuel-gauge can be used in coulomb-counting mode.
+
+config FUELGAUGE_MAX77823_VOLTAGE_TRACKING
+	tristate "use MAX77823 fuel gauge only as voltage tracking"
+	default n
+	depends on FUELGAUGE_MAX77823
+	help
+	 Say Y to use MAX17050 fuel gauge
+	 only as voltage tracking.
+	 This mode is for target that consumes low current
+	 like smart-phone.
+
+config FUELGAUGE_MAX77823_COULOMB_COUNTING
+	tristate "use MAX77823 fuel gauge as coulomb counting (including voltage tracking)"
+	default n
+	depends on FUELGAUGE_MAX77823
+	help
+	 Say Y to use MAX77823 fuel gauge
+	 as coulomb counting (including voltage tracking).
+	 This mode is for target that consumes high current
+	 like tablet.
+
+config FUELGAUGE_RT5033
+	tristate "RT5033 fuel gauge driver"
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for Richtek RT5033 fuel gauge driver.
+	 This driver source code implemented
+	 all functions for RT5033 fuel gauge.
+
+config FUELGAUGE_S2MU003
+        tristate "S2MU003 fuel gauge driver"
+        default n
+        depends on BATTERY_SAMSUNG
+        help
+         Say Y to include support
+         for S.LSI S2MU003 fuel gauge driver.
+
+config FUELGAUGE_S2MU005
+	tristate "S2MU005 fuel gauge driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	  Say Y to include support
+	  for S.LSI S2MU005 fuel gauge driver.
+
+config FUELGAUGE_MAX77849
+	tristate "MAX77849 fuel gauge driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 It is based on the MAX17050 fuel gauge driver.
+	 This fuel-gauge can be used in voltage-tracking mode
+	 or coulomb-counting mode.
+
+config FUELGAUGE_SM5703
+	 tristate "SM5703 fuel gauge driver"
+	 default n
+	 depends on BATTERY_SAMSUNG
+	 help
+	  Say Y to include support SM5703 FUELGAUGE.
+	  Using coulomb counting.
+
+config FUELGAUGE_SM5705
+	tristate "Siliconmitus SM5705 Fuel Gauge"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	  SM5705 is fuel-gauge systems for lithium-ion (Li+) batteries
+	  in handheld and portable equipment. The SM5705 is configured
+	  to operate with a single lithium cell
+
+config STMP_SUPPORT_FG_ALERT
+	 tristate "SM5703 fuel gauge driver"
+	 default n
+	 depends on FUELGAUGE_SM5703
+	 help
+	  Say Y to include support SM5703 FUELGAUGE alert to STMPE1801
+config PREVENT_SOC_JUMP
+        tristate "prevent soc jump at full-charged"
+        default n
+        depends on BATTERY_SAMSUNG
+        help
+         Say Y to prevent soc jump
+
+config FUELGAUGE_MAX77849_VOLTAGE_TRACKING
+	tristate "use MAX77849 fuel gauge only as voltage tracking"
+	default n
+	depends on FUELGAUGE_MAX77849
+	help
+	 Say Y to use MAX77849 fuel gauge
+	 only as voltage tracking.
+	 This mode is for target that consumes low current
+	 like smart-phone.
+
+config FUELGAUGE_MAX77849_COULOMB_COUNTING
+	tristate "use MAX77849 fuel gauge as coulomb counting (including voltage tracking)"
+	default n
+	depends on FUELGAUGE_MAX77849
+	help
+	 Say Y to use MAX77849 fuel gauge
+	 as coulomb counting (including voltage tracking).
+	 This mode is for target that consumes high current
+	 like tablet.
+
+# Charger
+
+config CHARGER_DUMMY
+	tristate "dummy charger driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for dummy charger driver.
+	 This driver source code implemented
+	 skeleton source code for charger functions.
+
+config CHARGER_MAX8903
+	tristate "MAX8903 charger driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for MAXIM MAX8903 charger driver.
+	 This driver source code implemented
+	 all functions for MAX8903 charger.
+
+config CHARGER_SMB328
+	tristate "SMB328 charger driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for Summit SMB328 charger driver.
+	 This driver source code implemented
+	 all functions for SMB328 charger.
+
+config CHARGER_SMB347
+	tristate "SMB347 charger driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for Summit SMB347 charger driver.
+	 This driver source code implemented
+	 all functions for SMB347 charger.
+
+config CHARGER_BQ24157
+	tristate "BQ24157 charger driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for TI BQ24157 charger driver.
+	 This driver source code implemented
+	 all functions for BQ24157 charger.
+
+config CHARGER_BQ24190
+	tristate "BQ24190 charger driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for TI BQ24190 charger driver.
+	 This driver source code implemented
+	 all functions for BQ24190 charger.
+
+config CHARGER_BQ24191
+	tristate "BQ24191 charger driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for TI BQ24191 charger driver.
+	 This driver source code implemented
+	 all functions for BQ24191 charger.
+
+config CHARGER_BQ24260
+	tristate "BQ24260 charger driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for TI BQ24260 charger driver.
+	 This driver source code implemented
+	 all functions for BQ24260 charger.
+
+config CHARGER_MAX77693
+	tristate "MAX77693 battery charger support"
+	depends on MFD_MAX77693 && I2C
+	help
+	  Say Y here to enable support for the MAX77693 charger
+	  MAX77693 incluse muic, pmic, haptic, led,
+	  flash driver.
+	  You have to define MFD_MAX77693
+
+config CHARGER_MAX77823
+	tristate "MAX77823 battery charger support"
+	depends on BATTERY_SAMSUNG
+	help
+	  Say Y here to enable support for the MAX77823 charger
+
+config CHARGER_MAX77843
+	tristate "MAX77843 battery charger support"
+	depends on BATTERY_SAMSUNG
+	help
+	  Say Y here to enable support for the MAX77843 charger
+
+config CHARGER_MAX77833
+	tristate "MAX77833 battery charger support"
+	depends on BATTERY_SAMSUNG
+	help
+	  Say Y here to enable support for the MAX77833 charger
+
+config CHARGER_MAX77804
+	tristate "MAX77804 battery charger support"
+	depends on (MFD_MAX77804 || MFD_MAX77804K) && I2C
+	help
+	  Say Y here to enable support for the MAX77804 charger
+	  MAX77804 incluse muic, pmic, haptic, led,
+	  flash driver.
+	  You have to define MFD_MAX77804
+
+config CHARGER_MAX77888
+	tristate "MAX77888 battery charger support"
+	depends on (MFD_MAX77888) && I2C
+	help
+	  Say Y here to enable support for the MAX77888 charger
+	  MAX77888 incluse muic, pmic, haptic, led,
+	  flash driver.
+	  You have to define MFD_MAX77888
+
+config CHARGER_MAX77849
+	tristate "MAX77849 battery charger support"
+	depends on MFD_MAX77849 && I2C
+	help
+	  Say Y here to enable support for the MAX77849 charger
+	  MAX77849 incluse muic, pmic, haptic, led,
+	  flash driver.
+	  You have to define MFD_MAX7784
+
+config CHARGER_SM5703
+	tristate "SM5703 battery charger support"
+	depends on MFD_SM5703 && I2C
+	help
+	  Say Y here to enable support for the SM5703 charger
+	  SM5703 incluse led, flash driver.
+	  You have to define MFD_SM5703
+
+config CHARGER_SM5705
+	tristate "SM5705 battery charger support"
+	depends on MFD_SM5705 && I2C
+	help
+	  Say Y here to enable support for the SM5705 charger
+
+config CHARGER_SM5703_SOFT_START_CHARGING
+	bool "SM5703 soft step charging"
+	default n
+	depends on CHARGER_SM5703
+	help
+	 Say Y here to enable support for SM5703 soft step charging
+	 You have to define CHARGER_SM5703
+
+config CHARGER_SM5703_DUALPATH
+	bool "SM5703 dual path"
+	default n
+	depends on CHARGER_SM5703
+	help
+	  Say Y here to enable support for SM5703 dual path setting for suspending the charger in battery removal/VF open test scenario
+	  You have to define CHARGER_SM5703
+
+config CHARGER_S2MU003
+        tristate "S2MU003 charger support"
+        depends on (MFD_S2MU003) && I2C
+        help
+          Say Y here to enable support for the S2MU003 charger
+          S2MU003 incluse pmic, led driver.
+          You have to define MFD_S2MU003
+
+config CHARGER_S2MU005
+	tristate "S2MU005 charger support"
+	depends on (MFD_S2MU005) && I2C
+	help
+	  Say Y here to enable support for the S2MU005 charger
+	  S2MU005 incluse pmic, led driver.
+	  You have to define MFD_S2MU005
+
+config WIRELESS_CHARGER_INBATTERY
+        tristate "wireless charger in battery support"
+        depends on BATTERY_SAMSUNG && I2C
+        help
+          Say Y here to enable support for the wireless charger charger
+          driver.
+
+config WIRELESS_CHARGER_INBATTERY_CS100
+        tristate "wireless charger in battery cs100 command support"
+        depends on BATTERY_SAMSUNG && I2C
+        help
+          Say Y here to enable support for the wireless charger charger
+          driver.
+
+config WIRELESS_CHARGER_INBATTERY_5V_FIX
+        tristate "wireless charger in battery had 5.0V voreg"
+        depends on BATTERY_SAMSUNG && I2C
+        help
+          Say Y here to enable support for the wireless charger charger
+          driver.
+
+config WIRELESS_CHARGER_HIGH_VOLTAGE
+        tristate "high voltage wireless charger"
+        depends on BATTERY_SAMSUNG && I2C
+        help
+          Say Y here to enable support for the wireless charger charger
+          driver.
+
+config WIRELESS_CHARGER_BQ51221
+        tristate "bq51221 battery charger support"
+        depends on BATTERY_SAMSUNG && I2C
+        help
+          Say Y here to enable support for the bq51221 charger
+          bq51221 wireless charger driver.
+
+config WIRELESS_CHARGER_P9027S
+        tristate "p9027s battery charger support"
+        depends on BATTERY_SAMSUNG && I2C
+        help
+          Say Y here to enable support for the p9027s charger
+          p9027s wireless charger driver.
+
+config WIRELESS_CHARGER_P9220S
+        tristate "p9220s battery charger support"
+        depends on BATTERY_SAMSUNG && I2C
+        help
+          Say Y here to enable support for the p9220s charger
+          p9220s wireless charger driver.
+
+config WIRELESS_CHARGER_MAX77900
+        tristate "max77900 battery charger support"
+        depends on BATTERY_SAMSUNG && I2C
+        help
+          Say Y here to enable support for the max77900 charger
+          max77900 wireless charger driver.
+
+config AFC_CHARGER_MODE
+	bool "afc charging support in sec battery driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	  Say Y to include support for sec afc charging support
+
+config SAMSUNG_LPM_MODE
+	bool "Off charging mode support in sec battery driver"
+	default n
+	help
+	  Say Y to include support for sec off charging support
+	  This value defined at bootloader.
+	  Before enable this feature,
+	  implemet power off charging in the bootloader.
+
+config EN_OOPS
+	bool "enable oops filter"
+	default n
+	help
+	  Say Y to enable oops filter
+
+config DISABLE_SAVE_CAPACITY_MAX
+	bool "Disable to save capacity max in efs"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	  Say Y to include support to disable it
+	  capacity_max is saved in /efs/FactoryApp/batt_capacity_max
+	  capacity_max is restored after boot up
+	  You can find the code in healthd
+
+config FIX_CHG_FQ_4MHZ
+	bool "fix charging frequency 4MHz"
+	default n
+	depends on CHARGER_MAX77843
+	help
+	  Say Y to fix charging frequency 4MHz
+
+config STORE_MODE
+       bool "enable store mode"
+       default n
+       help
+	 Say Y to enable CONFIG_STORE_MODE
diff -Naur linux-3.18.14/drivers/battery/Makefile samsung/drivers/battery/Makefile
--- linux-3.18.14/drivers/battery/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery/Makefile	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,31 @@
+obj-$(CONFIG_BATTERY_SAMSUNG)	+= sec_battery.o
+obj-$(CONFIG_OF)		+= sec_adc.o
+obj-$(CONFIG_FUELGAUGE_MAX17042)	+= max17042_fuelgauge.o sec_fuelgauge.o
+obj-$(CONFIG_FUELGAUGE_MAX17048)	+= max17048_fuelgauge.o sec_fuelgauge.o
+obj-$(CONFIG_FUELGAUGE_MAX17050)	+= max17050_fuelgauge.o sec_fuelgauge.o
+obj-$(CONFIG_FUELGAUGE_MAX77823)	+= max77823_fuelgauge.o
+obj-$(CONFIG_FUELGAUGE_MAX77843)	+= max77843_fuelgauge.o
+obj-$(CONFIG_FUELGAUGE_MAX77833)	+= max77833_fuelgauge.o
+obj-$(CONFIG_FUELGAUGE_S2MU003)	+= s2mu003_fuelgauge.o
+obj-$(CONFIG_FUELGAUGE_S2MU005)        += s2mu005_fuelgauge.o
+obj-$(CONFIG_FUELGAUGE_SM5703)		+= sm5703_fuelgauge.o
+obj-$(CONFIG_FUELGAUGE_SM5705)		+= sm5705_fuelgauge.o
+
+obj-$(CONFIG_CHARGER_MAX8903)	+= max8903_charger.o
+obj-$(CONFIG_CHARGER_SMB328)	+= smb328_charger.o
+obj-$(CONFIG_CHARGER_SMB347)	+= smb347_charger.o sec_charger.o
+obj-$(CONFIG_CHARGER_BQ24157)	+= bq24157_charger.o sec_charger.o
+obj-$(CONFIG_CHARGER_BQ24190)	+= bq24190_charger.o
+obj-$(CONFIG_CHARGER_BQ24191)	+= bq24190_charger.o
+obj-$(CONFIG_CHARGER_BQ24260)	+= bq24260_charger.o sec_charger.o
+obj-$(CONFIG_CHARGER_MAX77804)  += max77804_charger.o
+obj-$(CONFIG_CHARGER_MAX77693)	+= max77693_charger.o
+obj-$(CONFIG_CHARGER_MAX77823)	+= max77823_charger.o
+obj-$(CONFIG_CHARGER_MAX77843)	+= max77843_charger.o
+obj-$(CONFIG_CHARGER_MAX77888)	+= max77888_charger.o
+obj-$(CONFIG_CHARGER_MAX77833)	+= max77833_charger.o
+obj-$(CONFIG_CHARGER_S2MU003)   += s2mu003_charger.o
+obj-$(CONFIG_WIRELESS_CHARGER_BQ51221)	+= bq51221_charger.o
+obj-$(CONFIG_CHARGER_S2MU005)   += s2mu005_charger.o
+obj-$(CONFIG_CHARGER_SM5703)	+= sm5703_charger.o
+obj-$(CONFIG_CHARGER_SM5705)	+= sm5705_charger.o sm5705_charger_oper.o
diff -Naur linux-3.18.14/drivers/battery/max17048_fuelgauge.c samsung/drivers/battery/max17048_fuelgauge.c
--- linux-3.18.14/drivers/battery/max17048_fuelgauge.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery/max17048_fuelgauge.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,671 @@
+/*
+ *  max17048_fuelgauge.c
+ *  Samsung MAX17048 Fuel Gauge Driver
+ *
+ *  Copyright (C) 2012 Samsung Electronics
+ *
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/battery/sec_fuelgauge.h>
+#include <linux/sec_batt.h>
+
+#if 0
+static int max17048_write_reg(struct i2c_client *client, int reg, u8 value)
+{
+	int ret;
+
+	ret = i2c_smbus_write_byte_data(client, reg, value);
+
+	if (ret < 0)
+		dev_err(&client->dev, "%s: err %d\n", __func__, ret);
+
+	return ret;
+}
+#endif
+
+static int max17048_read_reg(struct i2c_client *client, int reg)
+{
+	int ret;
+
+	ret = i2c_smbus_read_byte_data(client, reg);
+
+	if (ret < 0)
+		dev_err(&client->dev, "%s: err %d\n", __func__, ret);
+
+	return ret;
+}
+
+static int max17048_read_word(struct i2c_client *client, int reg)
+{
+	int ret;
+
+	ret = i2c_smbus_read_word_data(client, reg);
+	if (ret < 0)
+		dev_err(&client->dev, "%s: err %d\n", __func__, ret);
+
+	return ret;
+}
+
+static int max17048_write_word(struct i2c_client *client, int reg, u16 buf)
+{
+	int ret;
+
+	ret = i2c_smbus_write_word_data(client, reg, buf);
+	if (ret < 0)
+		dev_err(&client->dev, "%s: err %d\n", __func__, ret);
+
+	return ret;
+}
+
+static void max17048_reset(struct i2c_client *client)
+{
+	u16 mode, reset_cmd;
+
+	mode = max17048_read_word(client, MAX17048_MODE_MSB);
+
+	mode = swab16(mode);
+	reset_cmd = swab16(mode | 0x4000);
+
+	i2c_smbus_write_word_data(client, MAX17048_MODE_MSB, reset_cmd);
+
+	msleep(300);
+}
+
+static int max17048_get_vcell(struct i2c_client *client)
+{
+	u32 vcell;
+	u16 w_data;
+	u32 temp;
+
+	temp = max17048_read_word(client, MAX17048_VCELL_MSB);
+
+	w_data = swab16(temp);
+
+	temp = ((w_data & 0xFFF0) >> 4) * 1250;
+	vcell = temp / 1000;
+
+	dev_dbg(&client->dev,
+		"%s : vcell (%d)\n", __func__, vcell);
+
+	return vcell;
+}
+
+static int max17048_get_avg_vcell(struct i2c_client *client)
+{
+	u32 vcell_data = 0;
+	u32 vcell_max = 0;
+	u32 vcell_min = 0;
+	u32 vcell_total = 0;
+	u32 i;
+
+	for (i = 0; i < AVER_SAMPLE_CNT; i++) {
+		vcell_data = max17048_get_vcell(client);
+
+		if (i != 0) {
+			if (vcell_data > vcell_max)
+				vcell_max = vcell_data;
+			else if (vcell_data < vcell_min)
+				vcell_min = vcell_data;
+		} else {
+			vcell_max = vcell_data;
+			vcell_min = vcell_data;
+		}
+		vcell_total += vcell_data;
+	}
+
+	return (vcell_total - vcell_max - vcell_min) / (AVER_SAMPLE_CNT-2);
+}
+
+static int max17048_get_ocv(struct i2c_client *client)
+{
+	u32 ocv;
+	u16 w_data;
+	u32 temp;
+	u16 cmd;
+
+	cmd = swab16(0x4A57);
+	max17048_write_word(client, 0x3E, cmd);
+
+	temp = max17048_read_word(client, MAX17048_OCV_MSB);
+
+	w_data = swab16(temp);
+
+	temp = ((w_data & 0xFFF0) >> 4) * 1250;
+	ocv = temp / 1000;
+
+	cmd = swab16(0x0000);
+	max17048_write_word(client, 0x3E, cmd);
+
+	dev_dbg(&client->dev,
+		"%s : ocv (%d)\n", __func__, ocv);
+
+	return ocv;
+}
+
+/* soc should be 0.01% unit */
+static int max17048_get_soc(struct i2c_client *client)
+{
+	struct sec_fuelgauge_info *fuelgauge =
+				i2c_get_clientdata(client);
+	u8 data[2] = {0, 0};
+	int temp, soc;
+	u64 psoc64 = 0;
+	u64 temp64;
+	u32 divisor = 10000000;
+
+	temp = max17048_read_word(client, MAX17048_SOC_MSB);
+
+	if (get_battery_data(fuelgauge).is_using_model_data) {
+		/* [ TempSOC = ((SOC1 * 256) + SOC2) * 0.001953125 ] */
+		temp64 = swab16(temp);
+		psoc64 = temp64 * 1953125;
+		psoc64 = div_u64(psoc64, divisor);
+		soc = psoc64 & 0xffff;
+	} else {
+		data[0] = temp & 0xff;
+		data[1] = (temp & 0xff00) >> 8;
+
+		soc = (data[0] * 100) + (data[1] * 100 / 256);
+	}
+
+	dev_dbg(&client->dev,
+		"%s : raw capacity (%d), data(0x%04x)\n",
+		__func__, soc, (data[0]<<8) | data[1]);
+
+	return soc;
+}
+
+static int max17048_get_current(struct i2c_client *client)
+{
+	union power_supply_propval value;
+
+	psy_do_property("sec-charger", get,
+		POWER_SUPPLY_PROP_CURRENT_NOW, value);
+
+	return value.intval;
+}
+
+#define DISCHARGE_SAMPLE_CNT 5
+static int discharge_cnt=0;
+static int all_vcell[5] = {0,};
+
+/* if ret < 0, discharge */
+static int sec_bat_check_discharge(int vcell)
+{
+	int i, cnt, ret = 0;
+
+	all_vcell[discharge_cnt++] = vcell;
+	if (discharge_cnt >= DISCHARGE_SAMPLE_CNT)
+		discharge_cnt = 0;
+
+	cnt = discharge_cnt;
+
+	/* check after last value is set */
+	if (all_vcell[cnt] == 0)
+		return 0;
+
+	for (i = 0; i < DISCHARGE_SAMPLE_CNT; i++) {
+		if (cnt == i)
+			continue;
+		if (all_vcell[cnt] > all_vcell[i])
+			ret--;
+		else
+			ret++;
+	}
+	return ret;
+}
+
+/* judge power off or not by current_avg */
+static int max17048_get_current_average(struct i2c_client *client)
+{
+	union power_supply_propval value_bat;
+	union power_supply_propval value_chg;
+	int vcell, soc, curr_avg;
+	int check_discharge;
+
+	psy_do_property("sec-charger", get,
+		POWER_SUPPLY_PROP_CURRENT_NOW, value_chg);
+	psy_do_property("battery", get,
+		POWER_SUPPLY_PROP_HEALTH, value_bat);
+	vcell = max17048_get_vcell(client);
+	soc = max17048_get_soc(client) / 100;
+	check_discharge = sec_bat_check_discharge(vcell);
+
+	/* if 0% && under 3.4v && low power charging(1000mA), power off */
+	if (!lpcharge && (soc <= 0) && (vcell < 3400) &&
+	    (check_discharge < 0) &&
+	    (((value_bat.intval == POWER_SUPPLY_HEALTH_OVERHEAT) ||
+	      (value_bat.intval == POWER_SUPPLY_HEALTH_COLD)))) {
+		pr_info("%s: SOC(%d), Vnow(%d), Inow(%d)\n",
+			__func__, soc, vcell, value_chg.intval);
+		curr_avg = -1;
+	} else {
+		curr_avg = value_chg.intval;
+	}
+
+	return curr_avg;
+}
+
+void sec_bat_reset_discharge(struct i2c_client *client)
+{
+	int i;
+
+	for (i = 0; i < DISCHARGE_SAMPLE_CNT ; i++)
+		all_vcell[i] = 0;
+	discharge_cnt = 0;
+}
+
+static void max17048_get_version(struct i2c_client *client)
+{
+	u16 w_data;
+	int temp;
+
+	temp = max17048_read_word(client, MAX17048_VER_MSB);
+
+	w_data = swab16(temp);
+
+	dev_info(&client->dev,
+		"MAX17048 Fuel-Gauge Ver 0x%04x\n", w_data);
+}
+
+static u16 max17048_get_rcomp(struct i2c_client *client)
+{
+	u16 w_data;
+	int temp;
+
+	temp = max17048_read_word(client, MAX17048_RCOMP_MSB);
+
+	w_data = swab16(temp);
+
+	dev_dbg(&client->dev,
+		"%s : current rcomp = 0x%04x\n",
+		__func__, w_data);
+
+	return w_data;
+}
+
+static void max17048_set_rcomp(struct i2c_client *client, u16 new_rcomp)
+{
+	i2c_smbus_write_word_data(client,
+		MAX17048_RCOMP_MSB, swab16(new_rcomp));
+}
+
+static void max17048_rcomp_update(struct i2c_client *client, int temp)
+{
+	struct sec_fuelgauge_info *fuelgauge =
+				i2c_get_clientdata(client);
+	union power_supply_propval value;
+
+	int starting_rcomp = 0;
+	int new_rcomp = 0;
+	int rcomp_current = 0;
+
+	rcomp_current = max17048_get_rcomp(client);
+
+	psy_do_property("battery", get,
+		POWER_SUPPLY_PROP_STATUS, value);
+
+	if (value.intval == POWER_SUPPLY_STATUS_CHARGING) /* in charging */
+		starting_rcomp = get_battery_data(fuelgauge).RCOMP_charging;
+	else
+		starting_rcomp = get_battery_data(fuelgauge).RCOMP0;
+
+	if (temp > RCOMP0_TEMP)
+		new_rcomp = starting_rcomp + ((temp - RCOMP0_TEMP) *
+			get_battery_data(fuelgauge).temp_cohot / 1000);
+	else if (temp < RCOMP0_TEMP)
+		new_rcomp = starting_rcomp + ((temp - RCOMP0_TEMP) *
+			get_battery_data(fuelgauge).temp_cocold / 1000);
+	else
+		new_rcomp = starting_rcomp;
+
+	if (new_rcomp > 255)
+		new_rcomp = 255;
+	else if (new_rcomp < 0)
+		new_rcomp = 0;
+
+	new_rcomp <<= 8;
+	new_rcomp &= 0xff00;
+	/* not related to RCOMP */
+	new_rcomp |= (rcomp_current & 0xff);
+
+	if (rcomp_current != new_rcomp) {
+		dev_dbg(&client->dev,
+			"%s : RCOMP 0x%04x -> 0x%04x (0x%02x)\n",
+			__func__, rcomp_current, new_rcomp,
+			new_rcomp >> 8);
+		max17048_set_rcomp(client, new_rcomp);
+	}
+}
+
+#ifdef CONFIG_OF
+static int max17048_parse_dt(struct device *dev,
+			     struct sec_fuelgauge_info *fuelgauge)
+{
+	struct device_node *np = dev->of_node;
+	int ret;
+	int value;
+
+	if (np == NULL) {
+		pr_err("%s np NULL\n", __func__);
+	} else {
+		ret = of_property_read_u32(np, "fuelgauge,rcomp0",
+					   &value);
+		pr_err("%s value %d\n",
+		       __func__, value);
+		get_battery_data(fuelgauge).RCOMP0 = (u8)value;
+		if (ret < 0)
+			pr_err("%s error reading rcomp0 %d\n",
+			       __func__, ret);
+		ret = of_property_read_u32(np, "fuelgauge,rcomp_charging",
+					   &value);
+		pr_err("%s value %d\n",
+		       __func__, value);
+		get_battery_data(fuelgauge).RCOMP_charging = (u8)value;
+		if (ret < 0)
+			pr_err("%s error reading rcomp_charging %d\n",
+			       __func__, ret);
+		ret = of_property_read_u32(np, "fuelgauge,temp_cohot",
+				   &get_battery_data(fuelgauge).temp_cohot);
+		if (ret < 0)
+			pr_err("%s error reading temp_cohot %d\n",
+			       __func__, ret);
+		ret = of_property_read_u32(np, "fuelgauge,temp_cocold",
+				   &get_battery_data(fuelgauge).temp_cocold);
+		if (ret < 0)
+			pr_err("%s error reading temp_cocold %d\n",
+			       __func__, ret);
+		get_battery_data(fuelgauge).is_using_model_data = of_property_read_bool(np,
+				"fuelgauge,is_using_model_data");
+		ret = of_property_read_string(np, "fuelgauge,type_str",
+				(const char **)&get_battery_data(fuelgauge).type_str);
+		if (ret < 0)
+			pr_err("%s error reading temp_cocold %d\n",
+			       __func__, ret);
+
+		pr_info("%s RCOMP0: 0x%x, RCOMP_charging: 0x%x, temp_cohot: %d,"
+			"temp_cocold: %d, is_using_model_data: %d, "
+			"type_str: %s,\n", __func__,
+			get_battery_data(fuelgauge).RCOMP0,
+			get_battery_data(fuelgauge).RCOMP_charging,
+			get_battery_data(fuelgauge).temp_cohot,
+			get_battery_data(fuelgauge).temp_cocold,
+			get_battery_data(fuelgauge).is_using_model_data,
+			get_battery_data(fuelgauge).type_str
+			);
+	}
+
+	return 0;
+}
+#endif
+
+static void fg_read_regs(struct i2c_client *client, char *str)
+{
+	int data = 0;
+	u32 addr = 0;
+
+	for (addr = 0x02; addr <= 0x04; addr += 2) {
+		data = max17048_read_word(client, addr);
+		sprintf(str + strlen(str), "0x%04x, ", data);
+	}
+
+	/* "#" considered as new line in application */
+	sprintf(str+strlen(str), "#");
+
+	for (addr = 0x08; addr <= 0x1a; addr += 2) {
+		data = max17048_read_word(client, addr);
+		sprintf(str + strlen(str), "0x%04x, ", data);
+	}
+}
+
+bool sec_hal_fg_init(struct i2c_client *client)
+{
+#ifdef CONFIG_OF
+	struct sec_fuelgauge_info *fuelgauge =
+		i2c_get_clientdata(client);
+	int error;
+
+	error = max17048_parse_dt(&client->dev, fuelgauge);
+
+	if (error) {
+		dev_err(&client->dev,
+			"%s : Failed to get max17048 fuel_init\n", __func__);
+		return false;
+	}
+#endif
+	pr_info("%s\n", __func__);
+
+	max17048_get_version(client);
+
+	return true;
+}
+
+bool sec_hal_fg_suspend(struct i2c_client *client)
+{
+	return true;
+}
+
+bool sec_hal_fg_resume(struct i2c_client *client)
+{
+	return true;
+}
+
+bool sec_hal_fg_fuelalert_init(struct i2c_client *client, int soc)
+{
+	u16 temp;
+	u8 data;
+
+	temp = max17048_get_rcomp(client);
+	data = 32 - soc; /* set soc for fuel alert */
+	temp &= 0xff00;
+	temp += data;
+
+	dev_dbg(&client->dev,
+		"%s : new rcomp = 0x%04x\n",
+		__func__, temp);
+
+	max17048_set_rcomp(client, temp);
+
+	return true;
+}
+
+bool sec_hal_fg_is_fuelalerted(struct i2c_client *client)
+{
+	u16 temp;
+
+	temp = max17048_get_rcomp(client);
+
+	if (temp & 0x20)	/* ALRT is asserted */
+		return true;
+
+	return false;
+}
+
+bool sec_hal_fg_fuelalert_process(void *irq_data, bool is_fuel_alerted)
+{
+	return true;
+}
+
+bool sec_hal_fg_full_charged(struct i2c_client *client)
+{
+	return true;
+}
+
+bool sec_hal_fg_reset(struct i2c_client *client)
+{
+	max17048_reset(client);
+	return true;
+}
+
+bool sec_hal_fg_get_property(struct i2c_client *client,
+			     enum power_supply_property psp,
+			     union power_supply_propval *val)
+{
+	int i, pr_cnt = 1;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = 0;
+		break;
+		/* Cell voltage (VCELL, mV) */
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = max17048_get_vcell(client);
+		break;
+		/* Additional Voltage Information (mV) */
+	case POWER_SUPPLY_PROP_VOLTAGE_AVG:
+		switch (val->intval) {
+		case SEC_BATTEY_VOLTAGE_AVERAGE:
+			val->intval = max17048_get_avg_vcell(client);
+			break;
+		case SEC_BATTEY_VOLTAGE_OCV:
+			val->intval = max17048_get_ocv(client);
+			break;
+		}
+		break;
+		/* Current (mA) */
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = max17048_get_current(client);
+		break;
+		/* Average Current (mA) */
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+		val->intval = max17048_get_current_average(client);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+		break;
+	case POWER_SUPPLY_PROP_ENERGY_NOW:
+		break;
+		/* SOC (%) */
+	case POWER_SUPPLY_PROP_CAPACITY:
+		if (val->intval == SEC_FUELGAUGE_CAPACITY_TYPE_RAW) {
+                        val->intval = max17048_get_soc(client);
+                } else {
+                        val->intval = max17048_get_soc(client) / 10;
+			if (!(pr_cnt++ % 10)) {
+				pr_cnt = 1;
+				for (i = 0x02; i < 0x1C; i++)
+					printk("0x%02x(0x%02x), ",
+					i, max17048_read_reg(client, i));
+				printk("\n");
+			}
+                }
+		break;
+		/* Battery Temperature */
+	case POWER_SUPPLY_PROP_TEMP:
+		/* Target Temperature */
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		break;
+	default:
+		return false;
+	}
+	return true;
+}
+
+bool sec_hal_fg_set_property(struct i2c_client *client,
+			     enum power_supply_property psp,
+			     const union power_supply_propval *val)
+{
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		sec_bat_reset_discharge(client);
+		break;
+		/* Battery Temperature */
+	case POWER_SUPPLY_PROP_TEMP:
+		/* Target Temperature */
+		/* temperature is 0.1 degree, should be divide by 10 */
+		max17048_rcomp_update(client, val->intval / 10);
+		break;
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:		
+		break;
+	default:
+		return false;
+	}
+	return true;
+}
+
+ssize_t sec_hal_fg_show_attrs(struct device *dev,
+				const ptrdiff_t offset, char *buf)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct sec_fuelgauge_info *fg =
+		container_of(psy, struct sec_fuelgauge_info, psy_fg);
+	int i = 0;
+	char *str = NULL;
+
+	switch (offset) {
+	case FG_DATA:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%02x%02x\n",
+			fg->reg_data[1], fg->reg_data[0]);
+		break;
+	case FG_REGS:
+		str = kzalloc(sizeof(char)*1024, GFP_KERNEL);
+		if (!str)
+			return -ENOMEM;
+
+		fg_read_regs(fg->client, str);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%s\n",
+			str);
+
+		kfree(str);
+		break;
+	default:
+		i = -EINVAL;
+		break;
+	}
+
+	return i;
+}
+
+ssize_t sec_hal_fg_store_attrs(struct device *dev,
+				const ptrdiff_t offset,
+				const char *buf, size_t count)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct sec_fuelgauge_info *fg =
+		container_of(psy, struct sec_fuelgauge_info, psy_fg);
+	int ret = 0;
+	int x = 0;
+	u16 data;
+
+	switch (offset) {
+	case FG_REG:
+		if (sscanf(buf, "%x\n", &x) == 1) {
+			fg->reg_addr = x;
+			data = max17048_read_word(
+				fg->client, fg->reg_addr);
+			fg->reg_data[0] = (data & 0xff00) >> 8;
+			fg->reg_data[1] = (data & 0x00ff);
+
+			dev_dbg(&fg->client->dev,
+				"%s: (read) addr = 0x%x, data = 0x%02x%02x\n",
+				 __func__, fg->reg_addr,
+				 fg->reg_data[1], fg->reg_data[0]);
+			ret = count;
+		}
+		break;
+	case FG_DATA:
+		if (sscanf(buf, "%x\n", &x) == 1) {
+			dev_dbg(&fg->client->dev,
+				"%s: (write) addr = 0x%x, data = 0x%04x\n",
+				__func__, fg->reg_addr, x);
+			i2c_smbus_write_word_data(fg->client,
+				fg->reg_addr, swab16(x));
+			ret = count;
+		}
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
diff -Naur linux-3.18.14/drivers/battery/max17050_fuelgauge.c samsung/drivers/battery/max17050_fuelgauge.c
--- linux-3.18.14/drivers/battery/max17050_fuelgauge.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery/max17050_fuelgauge.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,2451 @@
+/*
+ *  max17050_fuelgauge.c
+ *  Samsung MAX17050 Fuel Gauge Driver
+ *
+ *  Copyright (C) 2012 Samsung Electronics
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#define DEBUG
+
+#include <linux/battery/sec_fuelgauge.h>
+
+#ifdef CONFIG_FUELGAUGE_MAX17050_VOLTAGE_TRACKING
+static int max17050_write_reg(struct i2c_client *client, int reg, u8 *buf)
+{
+	int ret;
+
+	ret = i2c_smbus_write_i2c_block_data(client, reg, 2, buf);
+
+	if (ret < 0)
+		dev_err(&client->dev, "%s: Error(%d)\n", __func__, ret);
+
+	return ret;
+}
+
+static int max17050_read_reg(struct i2c_client *client, int reg, u8 *buf)
+{
+	int ret;
+
+	ret = i2c_smbus_read_i2c_block_data(client, reg, 2, buf);
+
+	if (ret < 0)
+		dev_err(&client->dev, "%s: Error(%d)\n", __func__, ret);
+
+	return ret;
+}
+
+static void max17050_write_reg_array(struct i2c_client *client,
+				     u8 *buf, int size)
+{
+	int i;
+
+	for (i = 0; i < size; i += 3)
+		max17050_write_reg(client, (u8) (*(buf + i)), (buf + i) + 1);
+}
+
+static void max17050_init_regs(struct i2c_client *client)
+{
+	u8 data[2];
+
+	if (max17050_read_reg(client, MAX17050_REG_FILTERCFG, data) < 0)
+		return;
+
+	/* Clear average vcell (12 sec) */
+	data[0] &= 0x8f;
+
+	max17050_write_reg(client, MAX17050_REG_FILTERCFG, data);
+}
+
+static void max17050_get_version(struct i2c_client *client)
+{
+	u8 data[2];
+
+	if (max17050_read_reg(client, MAX17050_REG_VERSION, data) < 0)
+		return;
+
+	dev_dbg(&client->dev, "MAX17050 Fuel-Gauge Ver %d%d\n",
+		data[0], data[1]);
+}
+
+static void max17050_alert_init(struct i2c_client *client)
+{
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+	u8 data[2];
+
+	/* SALRT Threshold setting */
+	data[0] = fuelgauge->pdata->fuel_alert_soc;
+	data[1] = 0xff;
+	max17050_write_reg(client, MAX17050_REG_SALRT_TH, data);
+
+	/* VALRT Threshold setting */
+	data[0] = 0x00;
+	data[1] = 0xff;
+	max17050_write_reg(client, MAX17050_REG_VALRT_TH, data);
+
+	/* TALRT Threshold setting */
+	data[0] = 0x80;
+	data[1] = 0x7f;
+	max17050_write_reg(client, MAX17050_REG_TALRT_TH, data);
+}
+
+static bool max17050_check_status(struct i2c_client *client)
+{
+	u8 data[2];
+	bool ret = false;
+
+	/* check if Smn was generated */
+	if (max17050_read_reg(client, MAX17050_REG_STATUS, data) < 0)
+		return ret;
+
+	dev_info(&client->dev, "%s: status_reg(%02x%02x)\n",
+		__func__, data[1], data[0]);
+
+	/* minimum SOC threshold exceeded. */
+	if (data[1] & (0x1 << 2))
+		ret = true;
+
+	/* clear status reg */
+	if (!ret) {
+		data[1] = 0;
+		max17050_write_reg(client, MAX17050_REG_STATUS, data);
+		msleep(200);
+	}
+
+	return ret;
+}
+
+static int max17050_set_temperature(struct i2c_client *client, int temperature)
+{
+	u8 data[2];
+
+	data[0] = 0;
+	data[1] = temperature;
+	max17050_write_reg(client, MAX17050_REG_TEMPERATURE, data);
+
+	dev_dbg(&client->dev, "%s: temperature to (%d)\n",
+		__func__, temperature);
+
+	return temperature;
+}
+
+static int max17050_get_temperature(struct i2c_client *client)
+{
+	u8 data[2];
+	s32 temperature = 0;
+
+	if (max17050_read_reg(client, MAX17050_REG_TEMPERATURE, data) < 0)
+		return -ERANGE;
+
+	/* data[] store 2's compliment format number */
+	if (data[1] & (0x1 << 7)) {
+		/* Negative */
+		temperature = ((~(data[1])) & 0xFF) + 1;
+		temperature *= (-1000);
+	} else {
+		temperature = data[1] & 0x7F;
+		temperature *= 1000;
+		temperature += data[0] * 39 / 10;
+	}
+
+	dev_dbg(&client->dev, "%s: temperature (%d)\n",
+		__func__, temperature);
+
+	return temperature;
+}
+
+/* soc should be 0.01% unit */
+static int max17050_get_soc(struct i2c_client *client)
+{
+	u8 data[2];
+	int soc;
+
+	if (max17050_read_reg(client, MAX17050_REG_SOC_VF, data) < 0)
+		return -EINVAL;
+
+	soc = ((data[1] * 100) + (data[0] * 100 / 256));
+
+	dev_dbg(&client->dev, "%s: raw capacity (%d)\n", __func__, soc);
+
+	return min(soc, 10000);
+}
+
+static int max17050_get_vfocv(struct i2c_client *client)
+{
+	u8 data[2];
+	u32 vfocv = 0;
+
+	if (max17050_read_reg(client, MAX17050_REG_VFOCV, data) < 0)
+		return -EINVAL;
+
+	vfocv = ((data[0] >> 3) + (data[1] << 5)) * 625 / 1000;
+
+	dev_dbg(&client->dev, "%s: vfocv (%d)\n", __func__, vfocv);
+
+	return vfocv;
+}
+
+static int max17050_get_vcell(struct i2c_client *client)
+{
+	u8 data[2];
+	u32 vcell = 0;
+
+	if (max17050_read_reg(client, MAX17050_REG_VCELL, data) < 0)
+		return -EINVAL;
+
+	vcell = ((data[0] >> 3) + (data[1] << 5)) * 625 / 1000;
+
+	dev_dbg(&client->dev, "%s: vcell (%d)\n", __func__, vcell);
+
+	return vcell;
+}
+
+static int max17050_get_avgvcell(struct i2c_client *client)
+{
+	u8 data[2];
+	u32 avgvcell = 0;
+
+	if (max17050_read_reg(client, MAX17050_REG_AVGVCELL, data) < 0)
+		return -EINVAL;
+
+	avgvcell = ((data[0] >> 3) + (data[1] << 5)) * 625 / 1000;
+
+	dev_dbg(&client->dev, "%s: avgvcell (%d)\n", __func__, avgvcell);
+
+	return avgvcell;
+}
+
+bool sec_hal_fg_init(struct i2c_client *client)
+{
+	/* initialize fuel gauge registers */
+	max17050_init_regs(client);
+
+	max17050_get_version(client);
+
+	return true;
+}
+
+bool sec_hal_fg_suspend(struct i2c_client *client)
+{
+	return true;
+}
+
+bool sec_hal_fg_resume(struct i2c_client *client)
+{
+	return true;
+}
+
+bool sec_hal_fg_fuelalert_init(struct i2c_client *client, int soc)
+{
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+	u8 data[2];
+
+	/* 1. Set max17050 alert configuration. */
+	max17050_alert_init(client);
+
+	if (max17050_read_reg(client, MAX17050_REG_CONFIG, data)
+	    < 0)
+		return -1;
+
+	/*Enable Alert (Aen = 1) */
+	data[0] |= (0x1 << 2);
+
+	max17050_write_reg(client, MAX17050_REG_CONFIG, data);
+
+	dev_dbg(&client->dev, "%s: config_reg(%02x%02x) irq(%d)\n",
+		 __func__, data[1], data[0], fuelgauge->pdata->fg_irq);
+
+	return true;
+}
+
+bool sec_hal_fg_is_fuelalerted(struct i2c_client *client)
+{
+	return max17050_check_status(client);
+}
+
+bool sec_hal_fg_fuelalert_process(void *irq_data, bool is_fuel_alerted)
+{
+	struct sec_fuelgauge_info *fuelgauge = irq_data;
+	u8 data[2];
+
+	/* update SOC */
+	/* max17050_get_soc(fuelgauge->client); */
+
+	if (is_fuel_alerted) {
+		if (max17050_read_reg(fuelgauge->client,
+				      MAX17050_REG_CONFIG, data) < 0)
+			return false;
+
+		data[1] |= (0x1 << 3);
+
+		max17050_write_reg(fuelgauge->client,
+				   MAX17050_REG_CONFIG, data);
+
+		dev_info(&fuelgauge->client->dev,
+			"%s: Fuel-alert Alerted!! (%02x%02x)\n",
+			__func__, data[1], data[0]);
+	} else {
+		if (max17050_read_reg(fuelgauge->client,
+				      MAX17050_REG_CONFIG, data)
+		    < 0)
+			return false;
+
+		data[1] &= (~(0x1 << 3));
+
+		max17050_write_reg(fuelgauge->client,
+				   MAX17050_REG_CONFIG, data);
+
+		dev_info(&fuelgauge->client->dev,
+			"%s: Fuel-alert Released!! (%02x%02x)\n",
+			__func__, data[1], data[0]);
+	}
+
+	max17050_read_reg(fuelgauge->client, MAX17050_REG_VCELL, data);
+	dev_dbg(&fuelgauge->client->dev,
+		"%s: MAX17050_REG_VCELL(%02x%02x)\n",
+		 __func__, data[1], data[0]);
+
+	max17050_read_reg(fuelgauge->client, MAX17050_REG_TEMPERATURE, data);
+	dev_dbg(&fuelgauge->client->dev,
+		"%s: MAX17050_REG_TEMPERATURE(%02x%02x)\n",
+		 __func__, data[1], data[0]);
+
+	max17050_read_reg(fuelgauge->client, MAX17050_REG_CONFIG, data);
+	dev_dbg(&fuelgauge->client->dev,
+		"%s: MAX17050_REG_CONFIG(%02x%02x)\n",
+		 __func__, data[1], data[0]);
+
+	max17050_read_reg(fuelgauge->client, MAX17050_REG_VFOCV, data);
+	dev_dbg(&fuelgauge->client->dev,
+		"%s: MAX17050_REG_VFOCV(%02x%02x)\n",
+		 __func__, data[1], data[0]);
+
+	max17050_read_reg(fuelgauge->client, MAX17050_REG_SOC_VF, data);
+	dev_dbg(&fuelgauge->client->dev,
+		"%s: MAX17050_REG_SOC_VF(%02x%02x)\n",
+		 __func__, data[1], data[0]);
+
+	dev_dbg(&fuelgauge->client->dev,
+		"%s: FUEL GAUGE IRQ (%d)\n",
+		 __func__,
+		 gpio_get_value(fuelgauge->pdata->fg_irq));
+
+#if 0
+	max17050_read_reg(fuelgauge->client, MAX17050_REG_STATUS, data);
+	dev_dbg(&fuelgauge->client->dev,
+		"%s: MAX17050_REG_STATUS(%02x%02x)\n",
+		 __func__, data[1], data[0]);
+
+	max17050_read_reg(fuelgauge->client, MAX17050_REG_VALRT_TH, data);
+	dev_dbg(&fuelgauge->client->dev,
+		"%s: MAX17050_REG_VALRT_TH(%02x%02x)\n",
+		 __func__, data[1], data[0]);
+
+	max17050_read_reg(fuelgauge->client, MAX17050_REG_TALRT_TH, data);
+	dev_dbg(&fuelgauge->client->dev,
+		"%s: MAX17050_REG_TALRT_TH(%02x%02x)\n",
+		 __func__, data[1], data[0]);
+
+	max17050_read_reg(fuelgauge->client, MAX17050_REG_SALRT_TH, data);
+	dev_dbg(&fuelgauge->client->dev,
+		"%s: MAX17050_REG_SALRT_TH(%02x%02x)\n",
+		 __func__, data[1], data[0]);
+
+	max17050_read_reg(fuelgauge->client, MAX17050_REG_AVGVCELL, data);
+	dev_dbg(&fuelgauge->client->dev,
+		"%s: MAX17050_REG_AVGVCELL(%02x%02x)\n",
+		 __func__, data[1], data[0]);
+
+	max17050_read_reg(fuelgauge->client, MAX17050_REG_VERSION, data);
+	dev_dbg(&fuelgauge->client->dev,
+		"%s: MAX17050_REG_VERSION(%02x%02x)\n",
+		 __func__, data[1], data[0]);
+
+	max17050_read_reg(fuelgauge->client, MAX17050_REG_LEARNCFG, data);
+	dev_dbg(&fuelgauge->client->dev,
+		"%s: MAX17050_REG_LEARNCFG(%02x%02x)\n",
+		 __func__, data[1], data[0]);
+
+	max17050_read_reg(fuelgauge->client, MAX17050_REG_MISCCFG, data);
+	dev_dbg(&fuelgauge->client->dev,
+		"%s: MAX17050_REG_MISCCFG(%02x%02x)\n",
+		 __func__, data[1], data[0]);
+
+	max17050_read_reg(fuelgauge->client, MAX17050_REG_CGAIN, data);
+	dev_dbg(&fuelgauge->client->dev,
+		"%s: MAX17050_REG_CGAIN(%02x%02x)\n",
+		 __func__, data[1], data[0]);
+
+	max17050_read_reg(fuelgauge->client, MAX17050_REG_RCOMP, data);
+	dev_dbg(&fuelgauge->client->dev,
+		"%s: MAX17050_REG_RCOMP(%02x%02x)\n",
+		 __func__, data[1], data[0]);
+#endif
+
+	return true;
+}
+
+bool sec_hal_fg_full_charged(struct i2c_client *client)
+{
+	return true;
+}
+
+bool sec_hal_fg_get_property(struct i2c_client *client,
+			     enum power_supply_property psp,
+			     union power_supply_propval *val)
+{
+	switch (psp) {
+		/* Cell voltage (VCELL, mV) */
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = max17050_get_vcell(client);
+		break;
+		/* Additional Voltage Information (mV) */
+	case POWER_SUPPLY_PROP_VOLTAGE_AVG:
+		switch (val->intval) {
+		case SEC_BATTEY_VOLTAGE_AVERAGE:
+			val->intval = max17050_get_avgvcell(client);
+			break;
+		case SEC_BATTEY_VOLTAGE_OCV:
+			val->intval = max17050_get_vfocv(client);
+			break;
+		}
+		break;
+		/* Current (mA) */
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = 0;
+		break;
+		/* Average Current (mA) */
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+		val->intval = 0;
+		break;
+		/* SOC (%) */
+	case POWER_SUPPLY_PROP_CAPACITY:
+		if (val->intval == SEC_FUELGAUGE_CAPACITY_TYPE_RAW)
+			val->intval = max17050_get_soc(client);
+		else
+			val->intval = max17050_get_soc(client) / 10;
+		break;
+		/* Battery Temperature */
+	case POWER_SUPPLY_PROP_TEMP:
+		/* Target Temperature */
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		val->intval = max17050_get_temperature(client);
+		break;
+	default:
+		return false;
+	}
+	return true;
+}
+
+bool sec_hal_fg_set_property(struct i2c_client *client,
+			     enum power_supply_property psp,
+			     const union power_supply_propval *val)
+{
+	switch (psp) {
+		/* Battery Temperature */
+	case POWER_SUPPLY_PROP_TEMP:
+		/* Target Temperature */
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		max17050_set_temperature(client, val->intval);
+		break;
+	default:
+		return false;
+	}
+	return true;
+}
+
+ssize_t sec_hal_fg_show_attrs(struct device *dev,
+				const ptrdiff_t offset, char *buf)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct sec_fuelgauge_info *fg =
+		container_of(psy, struct sec_fuelgauge_info, psy_fg);
+	int i = 0;
+
+	switch (offset) {
+/*	case FG_REG: */
+/*		break; */
+	case FG_DATA:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%02x%02x\n",
+			fg->reg_data[1], fg->reg_data[0]);
+		break;
+	default:
+		i = -EINVAL;
+		break;
+	}
+
+	return i;
+}
+
+ssize_t sec_hal_fg_store_attrs(struct device *dev,
+				const ptrdiff_t offset,
+				const char *buf, size_t count)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct sec_fuelgauge_info *fg =
+		container_of(psy, struct sec_fuelgauge_info, psy_fg);
+	int ret = 0;
+	int x = 0;
+	u8 data[2];
+
+	switch (offset) {
+	case FG_REG:
+		if (sscanf(buf, "%x\n", &x) == 1) {
+			fg->reg_addr = x;
+			max17050_read_reg(fg->client,
+				fg->reg_addr, fg->reg_data);
+			dev_dbg(&fg->client->dev,
+				"%s: (read) addr = 0x%x, data = 0x%02x%02x\n",
+				 __func__, fg->reg_addr,
+				 fg->reg_data[1], fg->reg_data[0]);
+			ret = count;
+		}
+		break;
+	case FG_DATA:
+		if (sscanf(buf, "%x\n", &x) == 1) {
+			data[0] = (x & 0xFF00) >> 8;
+			data[1] = (x & 0x00FF);
+			dev_dbg(&fg->client->dev,
+				"%s: (write) addr = 0x%x, data = 0x%02x%02x\n",
+				__func__, fg->reg_addr, data[1], data[0]);
+			max17050_write_reg(fg->client,
+				fg->reg_addr, data);
+			ret = count;
+		}
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+#endif
+
+#ifdef CONFIG_FUELGAUGE_MAX17050_COULOMB_COUNTING
+static int fg_i2c_read(struct i2c_client *client,
+				u8 reg, u8 *data, u8 length)
+{
+	s32 value;
+
+	value = i2c_smbus_read_i2c_block_data(client, reg, length, data);
+	if (value < 0 || value != length) {
+		dev_err(&client->dev, "%s: Error(%d)\n",
+			__func__, value);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int fg_i2c_write(struct i2c_client *client,
+				u8 reg, u8 *data, u8 length)
+{
+	s32 value;
+
+	value = i2c_smbus_write_i2c_block_data(client, reg, length, data);
+	if (value < 0) {
+		dev_err(&client->dev, "%s: Error(%d)\n",
+			__func__, value);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int fg_read_register(struct i2c_client *client,
+				u8 addr)
+{
+	u8 data[2];
+
+	if (fg_i2c_read(client, addr, data, 2) < 0) {
+		dev_err(&client->dev, "%s: Failed to read addr(0x%x)\n",
+			__func__, addr);
+		return -1;
+	}
+
+	return (data[1] << 8) | data[0];
+}
+
+static int fg_write_register(struct i2c_client *client,
+				u8 addr, u16 w_data)
+{
+	u8 data[2];
+
+	data[0] = w_data & 0xFF;
+	data[1] = w_data >> 8;
+
+	if (fg_i2c_write(client, addr, data, 2) < 0) {
+		dev_err(&client->dev, "%s: Failed to write addr(0x%x)\n",
+			__func__, addr);
+		return -1;
+	}
+
+	return 0;
+}
+
+#if 0
+static int fg_read_16register(struct i2c_client *client,
+				u8 addr, u16 *r_data)
+{
+	u8 data[32];
+	int i = 0;
+
+	if (fg_i2c_read(client, addr, data, 32) < 0) {
+		dev_err(&client->dev, "%s: Failed to read addr(0x%x)\n",
+			__func__, addr);
+		return -1;
+	}
+
+	for (i = 0; i < 16; i++)
+		r_data[i] = (data[2 * i + 1] << 8) | data[2 * i];
+
+	return 0;
+}
+#endif
+
+static void fg_write_and_verify_register(struct i2c_client *client,
+				u8 addr, u16 w_data)
+{
+	u16 r_data;
+	u8 retry_cnt = 2;
+
+	while (retry_cnt) {
+		fg_write_register(client, addr, w_data);
+		r_data = fg_read_register(client, addr);
+
+		if (r_data != w_data) {
+			dev_err(&client->dev,
+				"%s: verification failed (addr: 0x%x, w_data: 0x%x, r_data: 0x%x)\n",
+				__func__, addr, w_data, r_data);
+			retry_cnt--;
+		} else
+			break;
+	}
+}
+
+static void fg_test_print(struct i2c_client *client)
+{
+	u8 data[2];
+	u32 average_vcell;
+	u16 w_data;
+	u32 temp;
+	u32 temp2;
+	u16 reg_data;
+
+	if (fg_i2c_read(client, AVR_VCELL_REG, data, 2) < 0) {
+		dev_err(&client->dev, "%s: Failed to read VCELL\n", __func__);
+		return;
+	}
+
+	w_data = (data[1]<<8) | data[0];
+
+	temp = (w_data & 0xFFF) * 78125;
+	average_vcell = temp / 1000000;
+
+	temp = ((w_data & 0xF000) >> 4) * 78125;
+	temp2 = temp / 1000000;
+	average_vcell += (temp2 << 4);
+
+	dev_info(&client->dev, "%s: AVG_VCELL(%d), data(0x%04x)\n", __func__,
+		average_vcell, (data[1]<<8) | data[0]);
+
+	reg_data = fg_read_register(client, FULLCAP_REG);
+	dev_info(&client->dev, "%s: FULLCAP(%d), data(0x%04x)\n", __func__,
+		reg_data/2, reg_data);
+
+	reg_data = fg_read_register(client, REMCAP_REP_REG);
+	dev_info(&client->dev, "%s: REMCAP_REP(%d), data(0x%04x)\n", __func__,
+		reg_data/2, reg_data);
+
+	reg_data = fg_read_register(client, REMCAP_MIX_REG);
+	dev_info(&client->dev, "%s: REMCAP_MIX(%d), data(0x%04x)\n", __func__,
+		reg_data/2, reg_data);
+
+	reg_data = fg_read_register(client, REMCAP_AV_REG);
+	dev_info(&client->dev, "%s: REMCAP_AV(%d), data(0x%04x)\n", __func__,
+		reg_data/2, reg_data);
+}
+
+static void fg_periodic_read(struct i2c_client *client)
+{
+	u8 reg;
+	int i;
+	int data[0x10];
+	char *str = NULL;
+
+	str = kzalloc(sizeof(char)*1024, GFP_KERNEL);
+	if (!str)
+		return;
+
+	for (i = 0; i < 16; i++) {
+		for (reg = 0; reg < 0x10; reg++)
+			data[reg] = fg_read_register(client, reg + i * 0x10);
+
+		sprintf(str+strlen(str),
+			"%04xh,%04xh,%04xh,%04xh,%04xh,%04xh,%04xh,%04xh,",
+			data[0x00], data[0x01], data[0x02], data[0x03],
+			data[0x04], data[0x05], data[0x06], data[0x07]);
+		sprintf(str+strlen(str),
+			"%04xh,%04xh,%04xh,%04xh,%04xh,%04xh,%04xh,%04xh,",
+			data[0x08], data[0x09], data[0x0a], data[0x0b],
+			data[0x0c], data[0x0d], data[0x0e], data[0x0f]);
+		if (i == 4)
+			i = 13;
+	}
+
+	dev_info(&client->dev, "%s", str);
+
+	kfree(str);
+}
+
+static void fg_read_regs(struct i2c_client *client, char *str)
+{
+	int data = 0;
+	u32 addr = 0;
+
+	for (addr = 0; addr <= 0x4f; addr++) {
+		data = fg_read_register(client, addr);
+		sprintf(str+strlen(str), "0x%04x, ", data);
+	}
+
+	/* "#" considered as new line in application */
+	sprintf(str+strlen(str), "#");
+
+	for (addr = 0xe0; addr <= 0xff; addr++) {
+		data = fg_read_register(client, addr);
+		sprintf(str+strlen(str), "0x%04x, ", data);
+	}
+}
+
+static int fg_read_vcell(struct i2c_client *client)
+{
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+	u8 data[2];
+	u32 vcell;
+	u16 w_data;
+	u32 temp;
+	u32 temp2;
+
+	if (fg_i2c_read(client, VCELL_REG, data, 2) < 0) {
+		dev_err(&client->dev, "%s: Failed to read VCELL\n", __func__);
+		return -1;
+	}
+
+	w_data = (data[1]<<8) | data[0];
+
+	temp = (w_data & 0xFFF) * 78125;
+	vcell = temp / 1000000;
+
+	temp = ((w_data & 0xF000) >> 4) * 78125;
+	temp2 = temp / 1000000;
+	vcell += (temp2 << 4);
+
+	if (!(fuelgauge->info.pr_cnt % PRINT_COUNT))
+		dev_info(&client->dev, "%s: VCELL(%d), data(0x%04x)\n",
+			__func__, vcell, (data[1]<<8) | data[0]);
+
+	return vcell;
+}
+
+static int fg_read_vfocv(struct i2c_client *client)
+{
+	u8 data[2];
+	u32 vfocv = 0;
+	u16 w_data;
+	u32 temp;
+	u32 temp2;
+
+	if (fg_i2c_read(client, VFOCV_REG, data, 2) < 0) {
+		dev_err(&client->dev, "%s: Failed to read VFOCV\n", __func__);
+		return -1;
+	}
+
+	w_data = (data[1]<<8) | data[0];
+
+	temp = (w_data & 0xFFF) * 78125;
+	vfocv = temp / 1000000;
+
+	temp = ((w_data & 0xF000) >> 4) * 78125;
+	temp2 = temp / 1000000;
+	vfocv += (temp2 << 4);
+
+	return vfocv;
+}
+
+static int fg_read_avg_vcell(struct i2c_client *client)
+{
+	u8 data[2];
+	u32 avg_vcell = 0;
+	u16 w_data;
+	u32 temp;
+	u32 temp2;
+
+	if (fg_i2c_read(client, AVR_VCELL_REG, data, 2) < 0) {
+		dev_err(&client->dev,
+			"%s: Failed to read AVG_VCELL\n", __func__);
+		return -1;
+	}
+
+	w_data = (data[1]<<8) | data[0];
+
+	temp = (w_data & 0xFFF) * 78125;
+	avg_vcell = temp / 1000000;
+
+	temp = ((w_data & 0xF000) >> 4) * 78125;
+	temp2 = temp / 1000000;
+	avg_vcell += (temp2 << 4);
+
+	return avg_vcell;
+}
+
+static int fg_check_battery_present(struct i2c_client *client)
+{
+	u8 status_data[2];
+	int ret = 1;
+
+	/* 1. Check Bst bit */
+	if (fg_i2c_read(client, STATUS_REG, status_data, 2) < 0) {
+		dev_err(&client->dev,
+			"%s: Failed to read STATUS_REG\n", __func__);
+		return 0;
+	}
+
+	if (status_data[0] & (0x1 << 3)) {
+		dev_info(&client->dev,
+			"%s: addr(0x01), data(0x%04x)\n", __func__,
+			(status_data[1]<<8) | status_data[0]);
+		dev_info(&client->dev, "%s: battery is absent!!\n", __func__);
+		ret = 0;
+	}
+
+	return ret;
+}
+
+static int fg_write_temp(struct i2c_client *client, int temperature)
+{
+	u8 data[2];
+
+	data[0] = (temperature%10) * 1000 / 39;
+	data[1] = temperature / 10;
+	fg_i2c_write(client, TEMPERATURE_REG, data, 2);
+
+	dev_dbg(&client->dev, "%s: temperature to (%d, 0x%02x%02x)\n",
+		__func__, temperature, data[1], data[0]);
+
+	return temperature;
+}
+
+static int fg_read_temp(struct i2c_client *client)
+{
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+	u8 data[2] = {0, 0};
+	int temper = 0;
+	int i;
+
+	if (fg_check_battery_present(client)) {
+		if (fg_i2c_read(client, TEMPERATURE_REG, data, 2) < 0) {
+			dev_err(&client->dev,
+				"%s: Failed to read TEMPERATURE_REG\n",
+				__func__);
+			return -1;
+		}
+
+		if (data[1]&(0x1 << 7)) {
+			temper = ((~(data[1]))&0xFF)+1;
+			temper *= (-1000);
+			temper -= ((~((int)data[0]))+1) * 39 / 10;
+		} else {
+			temper = data[1] & 0x7f;
+			temper *= 1000;
+			temper += data[0] * 39 / 10;
+#if 0
+			/* Adjust temperature */
+			for (i = 0; i < TEMP_RANGE_MAX_NUM-1; i++) {
+				if ((temper >= get_battery_data(fuelgauge).
+					temp_adjust_table[i][RANGE]) &&
+					(temper < get_battery_data(fuelgauge).
+					temp_adjust_table[i+1][RANGE])) {
+					temper = (temper *
+						get_battery_data(fuelgauge).
+						temp_adjust_table[i][SLOPE] /
+						100) -
+						get_battery_data(fuelgauge).
+						temp_adjust_table[i][OFFSET];
+				}
+			}
+			if (i == TEMP_RANGE_MAX_NUM-1)
+				dev_dbg(&client->dev,
+					"%s : No adjustment for temperature\n",
+					__func__);
+#endif
+		}
+	} else
+		temper = 20000;
+
+	if (!(fuelgauge->info.pr_cnt % PRINT_COUNT))
+		dev_info(&client->dev, "%s: TEMPERATURE(%d), data(0x%04x)\n",
+			__func__, temper, (data[1]<<8) | data[0]);
+
+	return temper/100;
+}
+
+/* soc should be 0.1% unit */
+static int fg_read_vfsoc(struct i2c_client *client)
+{
+	u8 data[2];
+	int soc;
+
+	if (fg_i2c_read(client, VFSOC_REG, data, 2) < 0) {
+		dev_err(&client->dev, "%s: Failed to read VFSOC\n", __func__);
+		return -1;
+	}
+
+	soc = ((data[1] * 100) + (data[0] * 100 / 256)) / 10;
+
+	return min(soc, 1000);
+}
+
+/* soc should be 0.1% unit */
+static int fg_read_avsoc(struct i2c_client *client)
+{
+	u8 data[2];
+	int soc;
+
+	if (fg_i2c_read(client, SOCAV_REG, data, 2) < 0) {
+		dev_err(&client->dev, "%s: Failed to read AVSOC\n", __func__);
+		return -1;
+	}
+
+	soc = ((data[1] * 100) + (data[0] * 100 / 256)) / 10;
+
+	return min(soc, 1000);
+}
+
+/* soc should be 0.1% unit */
+static int fg_read_soc(struct i2c_client *client)
+{
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+	u8 data[2];
+	int soc;
+
+	if (fg_i2c_read(client, SOCREP_REG, data, 2) < 0) {
+		dev_err(&client->dev, "%s: Failed to read SOCREP\n", __func__);
+		return -1;
+	}
+
+	soc = ((data[1] * 100) + (data[0] * 100 / 256)) / 10;
+
+	dev_dbg(&client->dev, "%s: raw capacity (%d)\n", __func__, soc);
+
+	if (!(fuelgauge->info.pr_cnt % PRINT_COUNT))
+		dev_dbg(&client->dev, "%s: raw capacity (%d), data(0x%04x)\n",
+			__func__, soc, (data[1]<<8) | data[0]);
+
+	return min(soc, 1000);
+}
+
+/* soc should be 0.01% unit */
+static int fg_read_rawsoc(struct i2c_client *client)
+{
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+	u8 data[2];
+	int soc;
+
+	if (fg_i2c_read(client, SOCREP_REG, data, 2) < 0) {
+		dev_err(&client->dev, "%s: Failed to read SOCREP\n", __func__);
+		return -1;
+	}
+
+	soc = (data[1] * 100) + (data[0] * 100 / 256);
+
+	dev_dbg(&client->dev, "%s: raw capacity (0.01%%) (%d)\n",
+		__func__, soc);
+
+	if (!(fuelgauge->info.pr_cnt % PRINT_COUNT))
+		dev_dbg(&client->dev, "%s: raw capacity (%d), data(0x%04x)\n",
+			__func__, soc, (data[1]<<8) | data[0]);
+
+	return min(soc, 10000);
+}
+
+static int fg_read_fullcap(struct i2c_client *client)
+{
+	u8 data[2];
+	int ret;
+
+	if (fg_i2c_read(client, FULLCAP_REG, data, 2) < 0) {
+		dev_err(&client->dev, "%s: Failed to read FULLCAP\n", __func__);
+		return -1;
+	}
+
+	ret = (data[1] << 8) + data[0];
+
+	return ret;
+}
+
+static int fg_read_mixcap(struct i2c_client *client)
+{
+	u8 data[2];
+	int ret;
+
+	if (fg_i2c_read(client, REMCAP_MIX_REG, data, 2) < 0) {
+		dev_err(&client->dev, "%s: Failed to read REMCAP_MIX_REG\n",
+			__func__);
+		return -1;
+	}
+
+	ret = (data[1] << 8) + data[0];
+
+	return ret;
+}
+
+static int fg_read_avcap(struct i2c_client *client)
+{
+	u8 data[2];
+	int ret;
+
+	if (fg_i2c_read(client, REMCAP_AV_REG, data, 2) < 0) {
+		dev_err(&client->dev, "%s: Failed to read REMCAP_AV_REG\n",
+			__func__);
+		return -1;
+	}
+
+	ret = (data[1] << 8) + data[0];
+
+	return ret;
+}
+
+static int fg_read_repcap(struct i2c_client *client)
+{
+	u8 data[2];
+	int ret;
+
+	if (fg_i2c_read(client, REMCAP_REP_REG, data, 2) < 0) {
+		dev_err(&client->dev, "%s: Failed to read REMCAP_REP_REG\n",
+			__func__);
+		return -1;
+	}
+
+	ret = (data[1] << 8) + data[0];
+
+	return ret;
+}
+
+static int fg_read_current(struct i2c_client *client, int unit)
+{
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+	u8 data1[2], data2[2];
+	u32 temp, sign;
+	s32 i_current;
+	s32 avg_current;
+
+	if (fg_i2c_read(client, CURRENT_REG, data1, 2) < 0) {
+		dev_err(&client->dev, "%s: Failed to read CURRENT\n",
+			__func__);
+		return -1;
+	}
+
+	if (fg_i2c_read(client, AVG_CURRENT_REG, data2, 2) < 0) {
+		dev_err(&client->dev, "%s: Failed to read AVERAGE CURRENT\n",
+			__func__);
+		return -1;
+	}
+
+	temp = ((data1[1]<<8) | data1[0]) & 0xFFFF;
+	if (temp & (0x1 << 15)) {
+		sign = NEGATIVE;
+		temp = (~temp & 0xFFFF) + 1;
+	} else
+		sign = POSITIVE;
+
+	/* 1.5625uV/0.01Ohm(Rsense) = 156.25uA */
+	switch (unit) {
+	case SEC_BATTEY_CURRENT_UA:
+		i_current = temp * 15625 / 100;
+		break;
+	case SEC_BATTEY_CURRENT_MA:
+	default:
+		i_current = temp * 15625 / 100000;
+	}
+
+	if (sign)
+		i_current *= -1;
+
+	temp = ((data2[1]<<8) | data2[0]) & 0xFFFF;
+	if (temp & (0x1 << 15)) {
+		sign = NEGATIVE;
+		temp = (~temp & 0xFFFF) + 1;
+	} else
+		sign = POSITIVE;
+
+	/* 1.5625uV/0.01Ohm(Rsense) = 156.25uA */
+	avg_current = temp * 15625 / 100000;
+	if (sign)
+		avg_current *= -1;
+
+	if (!(fuelgauge->info.pr_cnt++ % PRINT_COUNT)) {
+		fg_test_print(client);
+		dev_info(&client->dev, "%s: CURRENT(%dmA), AVG_CURRENT(%dmA)\n",
+			__func__, i_current, avg_current);
+		fuelgauge->info.pr_cnt = 1;
+		/* Read max17050's all registers every 5 minute. */
+		fg_periodic_read(client);
+	}
+
+	return i_current;
+}
+
+static int fg_read_avg_current(struct i2c_client *client, int unit)
+{
+	u8  data2[2];
+	u32 temp, sign;
+	s32 avg_current;
+
+	if (fg_i2c_read(client, AVG_CURRENT_REG, data2, 2) < 0) {
+		dev_err(&client->dev, "%s: Failed to read AVERAGE CURRENT\n",
+			__func__);
+		return -1;
+	}
+
+	temp = ((data2[1]<<8) | data2[0]) & 0xFFFF;
+	if (temp & (0x1 << 15)) {
+		sign = NEGATIVE;
+		temp = (~temp & 0xFFFF) + 1;
+	} else
+		sign = POSITIVE;
+
+	/* 1.5625uV/0.01Ohm(Rsense) = 156.25uA */
+	switch (unit) {
+	case SEC_BATTEY_CURRENT_UA:
+		avg_current = temp * 15625 / 100;
+		break;
+	case SEC_BATTEY_CURRENT_MA:
+	default:
+		avg_current = temp * 15625 / 100000;
+	}
+
+	if (sign)
+		avg_current *= -1;
+
+	return avg_current;
+}
+
+int fg_reset_soc(struct i2c_client *client)
+{
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+	u8 data[2];
+	int vfocv, fullcap;
+
+	/* delay for current stablization */
+	msleep(500);
+
+	dev_info(&client->dev,
+		"%s: Before quick-start - VCELL(%d), VFOCV(%d), VfSOC(%d), RepSOC(%d)\n",
+		__func__, fg_read_vcell(client), fg_read_vfocv(client),
+		fg_read_vfsoc(client), fg_read_soc(client));
+	dev_info(&client->dev,
+		"%s: Before quick-start - current(%d), avg current(%d)\n",
+		__func__, fg_read_current(client, SEC_BATTEY_CURRENT_MA),
+		fg_read_avg_current(client, SEC_BATTEY_CURRENT_MA));
+
+	if (!fuelgauge->pdata->check_jig_status()) {
+		dev_info(&client->dev,
+			"%s : Return by No JIG_ON signal\n", __func__);
+		return 0;
+	}
+
+	fg_write_register(client, CYCLES_REG, 0);
+
+	if (fg_i2c_read(client, MISCCFG_REG, data, 2) < 0) {
+		dev_err(&client->dev, "%s: Failed to read MiscCFG\n", __func__);
+		return -1;
+	}
+
+	data[1] |= (0x1 << 2);
+	if (fg_i2c_write(client, MISCCFG_REG, data, 2) < 0) {
+		dev_err(&client->dev,
+			"%s: Failed to write MiscCFG\n", __func__);
+		return -1;
+	}
+
+	msleep(250);
+	fg_write_register(client, FULLCAP_REG,
+		get_battery_data(fuelgauge).Capacity);
+	msleep(500);
+
+	dev_info(&client->dev,
+		"%s: After quick-start - VCELL(%d), VFOCV(%d), VfSOC(%d), RepSOC(%d)\n",
+		__func__, fg_read_vcell(client), fg_read_vfocv(client),
+		fg_read_vfsoc(client), fg_read_soc(client));
+	dev_info(&client->dev,
+		"%s: After quick-start - current(%d), avg current(%d)\n",
+		__func__, fg_read_current(client, SEC_BATTEY_CURRENT_MA),
+		fg_read_avg_current(client, SEC_BATTEY_CURRENT_MA));
+	fg_write_register(client, CYCLES_REG, 0x00a0);
+
+/* P8 is not turned off by Quickstart @3.4V
+ * (It's not a problem, depend on mode data)
+ * Power off for factory test(File system, etc..) */
+	vfocv = fg_read_vfocv(client);
+	if (vfocv < POWER_OFF_VOLTAGE_LOW_MARGIN) {
+		dev_info(&client->dev, "%s: Power off condition(%d)\n",
+			__func__, vfocv);
+
+		fullcap = fg_read_register(client, FULLCAP_REG);
+		/* FullCAP * 0.009 */
+		fg_write_register(client, REMCAP_REP_REG,
+			(u16)(fullcap * 9 / 1000));
+		msleep(200);
+		dev_info(&client->dev, "%s: new soc=%d, vfocv=%d\n", __func__,
+			fg_read_soc(client), vfocv);
+	}
+
+	dev_info(&client->dev,
+		"%s: Additional step - VfOCV(%d), VfSOC(%d), RepSOC(%d)\n",
+		__func__, fg_read_vfocv(client),
+		fg_read_vfsoc(client), fg_read_soc(client));
+
+	return 0;
+}
+
+
+int fg_reset_capacity_by_jig_connection(struct i2c_client *client)
+{
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+
+	dev_info(&client->dev,
+		"%s: DesignCap = Capacity - 1 (Jig Connection)\n", __func__);
+
+	return fg_write_register(client, DESIGNCAP_REG,
+		get_battery_data(fuelgauge).Capacity-1);
+}
+
+int fg_adjust_capacity(struct i2c_client *client)
+{
+	u8 data[2];
+
+	data[0] = 0;
+	data[1] = 0;
+
+	/* 1. Write RemCapREP(05h)=0; */
+	if (fg_i2c_write(client, REMCAP_REP_REG, data, 2) < 0) {
+		dev_err(&client->dev, "%s: Failed to write RemCap_REP\n",
+			__func__);
+		return -1;
+	}
+	msleep(200);
+
+	dev_info(&client->dev, "%s: After adjust - RepSOC(%d)\n", __func__,
+		fg_read_soc(client));
+
+	return 0;
+}
+
+void fg_low_batt_compensation(struct i2c_client *client, u32 level)
+{
+	int read_val;
+	u32 temp;
+
+	dev_info(&client->dev, "%s: Adjust SOCrep to %d!!\n",
+		__func__, level);
+
+	read_val = fg_read_register(client, FULLCAP_REG);
+	/* RemCapREP (05h) = FullCap(10h) x 0.0090 */
+	temp = read_val * (level*90) / 10000;
+	fg_write_register(client, REMCAP_REP_REG, (u16)temp);
+}
+
+#if 0
+static void fg_read_model_data(struct i2c_client *client)
+{
+	u16 data0[16], data1[16], data2[16];
+	int i;
+	int relock_check;
+
+	dev_info(&client->dev, "[FG_Model] ");
+
+	/* Unlock model access */
+	fg_write_register(client, 0x62, 0x0059);
+	fg_write_register(client, 0x63, 0x00C4);
+
+	/* Read model data */
+	fg_read_16register(client, 0x80, data0);
+	fg_read_16register(client, 0x90, data1);
+	fg_read_16register(client, 0xa0, data2);
+
+	/* Print model data */
+	for (i = 0; i < 16; i++)
+		dev_info(&client->dev, "0x%04x, ", data0[i]);
+
+	for (i = 0; i < 16; i++)
+		dev_info(&client->dev, "0x%04x, ", data1[i]);
+
+	for (i = 0; i < 16; i++) {
+		if (i == 15)
+			dev_info(&client->dev, "0x%04x", data2[i]);
+		else
+			dev_info(&client->dev, "0x%04x, ", data2[i]);
+	}
+
+	do {
+		relock_check = 0;
+		/* Lock model access */
+		fg_write_register(client, 0x62, 0x0000);
+		fg_write_register(client, 0x63, 0x0000);
+
+		/* Read model data again */
+		fg_read_16register(client, 0x80, data0);
+		fg_read_16register(client, 0x90, data1);
+		fg_read_16register(client, 0xa0, data2);
+
+		for (i = 0; i < 16; i++) {
+			if (data0[i] || data1[i] || data2[i]) {
+				dev_dbg(&client->dev,
+					"%s: data is non-zero, lock again!!\n",
+					__func__);
+				relock_check = 1;
+			}
+		}
+	} while (relock_check);
+}
+#endif
+
+static int fg_check_status_reg(struct i2c_client *client)
+{
+	u8 status_data[2];
+	int ret = 0;
+
+	/* 1. Check Smn was generatedread */
+	if (fg_i2c_read(client, STATUS_REG, status_data, 2) < 0) {
+		dev_err(&client->dev, "%s: Failed to read STATUS_REG\n",
+			__func__);
+		return -1;
+	}
+	dev_info(&client->dev, "%s: addr(0x00), data(0x%04x)\n", __func__,
+		(status_data[1]<<8) | status_data[0]);
+
+	if (status_data[1] & (0x1 << 2))
+		ret = 1;
+
+	/* 2. clear Status reg */
+	status_data[1] = 0;
+	if (fg_i2c_write(client, STATUS_REG, status_data, 2) < 0) {
+		dev_info(&client->dev, "%s: Failed to write STATUS_REG\n",
+			__func__);
+		return -1;
+	}
+
+	return ret;
+}
+
+int get_fuelgauge_value(struct i2c_client *client, int data)
+{
+	int ret;
+
+	switch (data) {
+	case FG_LEVEL:
+		ret = fg_read_soc(client);
+		break;
+
+	case FG_TEMPERATURE:
+		ret = fg_read_temp(client);
+		break;
+
+	case FG_VOLTAGE:
+		ret = fg_read_vcell(client);
+		break;
+
+	case FG_CURRENT:
+		ret = fg_read_current(client, SEC_BATTEY_CURRENT_MA);
+		break;
+
+	case FG_CURRENT_AVG:
+		ret = fg_read_avg_current(client, SEC_BATTEY_CURRENT_MA);
+		break;
+
+	case FG_CHECK_STATUS:
+		ret = fg_check_status_reg(client);
+		break;
+
+	case FG_RAW_SOC:
+		ret = fg_read_rawsoc(client);
+		break;
+
+	case FG_VF_SOC:
+		ret = fg_read_vfsoc(client);
+		break;
+
+	case FG_AV_SOC:
+		ret = fg_read_avsoc(client);
+		break;
+
+	case FG_FULLCAP:
+		ret = fg_read_fullcap(client);
+		break;
+
+	case FG_MIXCAP:
+		ret = fg_read_mixcap(client);
+		break;
+
+	case FG_AVCAP:
+		ret = fg_read_avcap(client);
+		break;
+
+	case FG_REPCAP:
+		ret = fg_read_repcap(client);
+		break;
+
+	default:
+		ret = -1;
+		break;
+	}
+
+	return ret;
+}
+
+int fg_alert_init(struct i2c_client *client, int soc)
+{
+	u8 misccgf_data[2];
+	u8 salrt_data[2];
+	u8 config_data[2];
+	u8 valrt_data[2];
+	u8 talrt_data[2];
+	u16 read_data = 0;
+
+	/* Using RepSOC */
+	if (fg_i2c_read(client, MISCCFG_REG, misccgf_data, 2) < 0) {
+		dev_err(&client->dev,
+			"%s: Failed to read MISCCFG_REG\n", __func__);
+		return -1;
+	}
+	misccgf_data[0] = misccgf_data[0] & ~(0x03);
+
+	if (fg_i2c_write(client, MISCCFG_REG, misccgf_data, 2) < 0) {
+		dev_info(&client->dev,
+			"%s: Failed to write MISCCFG_REG\n", __func__);
+		return -1;
+	}
+
+	/* SALRT Threshold setting */
+	salrt_data[1] = 0xff;
+	salrt_data[0] = soc;
+	if (fg_i2c_write(client, SALRT_THRESHOLD_REG, salrt_data, 2) < 0) {
+		dev_info(&client->dev,
+			"%s: Failed to write SALRT_THRESHOLD_REG\n", __func__);
+		return -1;
+	}
+
+	/* Reset VALRT Threshold setting (disable) */
+	valrt_data[1] = 0xFF;
+	valrt_data[0] = 0x00;
+	if (fg_i2c_write(client, VALRT_THRESHOLD_REG, valrt_data, 2) < 0) {
+		dev_info(&client->dev,
+			"%s: Failed to write VALRT_THRESHOLD_REG\n", __func__);
+		return -1;
+	}
+
+	read_data = fg_read_register(client, (u8)VALRT_THRESHOLD_REG);
+	if (read_data != 0xff00)
+		dev_err(&client->dev,
+			"%s: VALRT_THRESHOLD_REG is not valid (0x%x)\n",
+			__func__, read_data);
+
+	/* Reset TALRT Threshold setting (disable) */
+	talrt_data[1] = 0x7F;
+	talrt_data[0] = 0x80;
+	if (fg_i2c_write(client, TALRT_THRESHOLD_REG, talrt_data, 2) < 0) {
+		dev_info(&client->dev,
+			"%s: Failed to write TALRT_THRESHOLD_REG\n", __func__);
+		return -1;
+	}
+
+	read_data = fg_read_register(client, (u8)TALRT_THRESHOLD_REG);
+	if (read_data != 0x7f80)
+		dev_err(&client->dev,
+			"%s: TALRT_THRESHOLD_REG is not valid (0x%x)\n",
+			__func__, read_data);
+
+	/*mdelay(100);*/
+
+	/* Enable SOC alerts */
+	if (fg_i2c_read(client, CONFIG_REG, config_data, 2) < 0) {
+		dev_err(&client->dev,
+			"%s: Failed to read CONFIG_REG\n", __func__);
+		return -1;
+	}
+	config_data[0] = config_data[0] | (0x1 << 2);
+
+	if (fg_i2c_write(client, CONFIG_REG, config_data, 2) < 0) {
+		dev_info(&client->dev,
+			"%s: Failed to write CONFIG_REG\n", __func__);
+		return -1;
+	}
+
+	return 1;
+}
+
+void fg_fullcharged_compensation(struct i2c_client *client,
+		u32 is_recharging, bool pre_update)
+{
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+	static int new_fullcap_data;
+
+	dev_info(&client->dev, "%s: is_recharging(%d), pre_update(%d)\n",
+		__func__, is_recharging, pre_update);
+
+	new_fullcap_data =
+		fg_read_register(client, FULLCAP_REG);
+	if (new_fullcap_data < 0)
+		new_fullcap_data = get_battery_data(fuelgauge).Capacity;
+
+	/* compare with initial capacity */
+	if (new_fullcap_data >
+		(get_battery_data(fuelgauge).Capacity * 110 / 100)) {
+		dev_info(&client->dev,
+			"%s: [Case 1] capacity = 0x%04x, NewFullCap = 0x%04x\n",
+			__func__, get_battery_data(fuelgauge).Capacity,
+			new_fullcap_data);
+
+		new_fullcap_data =
+			(get_battery_data(fuelgauge).Capacity * 110) / 100;
+
+		fg_write_register(client, REMCAP_REP_REG,
+			(u16)(new_fullcap_data));
+		fg_write_register(client, FULLCAP_REG,
+			(u16)(new_fullcap_data));
+	} else if (new_fullcap_data <
+		(get_battery_data(fuelgauge).Capacity * 50 / 100)) {
+		dev_info(&client->dev,
+			"%s: [Case 5] capacity = 0x%04x, NewFullCap = 0x%04x\n",
+			__func__, get_battery_data(fuelgauge).Capacity,
+			new_fullcap_data);
+
+		new_fullcap_data =
+			(get_battery_data(fuelgauge).Capacity * 50) / 100;
+
+		fg_write_register(client, REMCAP_REP_REG,
+			(u16)(new_fullcap_data));
+		fg_write_register(client, FULLCAP_REG,
+			(u16)(new_fullcap_data));
+	} else {
+	/* compare with previous capacity */
+		if (new_fullcap_data >
+			(fuelgauge->info.previous_fullcap * 110 / 100)) {
+			dev_info(&client->dev,
+				"%s: [Case 2] previous_fullcap = 0x%04x, NewFullCap = 0x%04x\n",
+				__func__, fuelgauge->info.previous_fullcap,
+				new_fullcap_data);
+
+			new_fullcap_data =
+				(fuelgauge->info.previous_fullcap * 110) / 100;
+
+			fg_write_register(client, REMCAP_REP_REG,
+				(u16)(new_fullcap_data));
+			fg_write_register(client, FULLCAP_REG,
+				(u16)(new_fullcap_data));
+		} else if (new_fullcap_data <
+			(fuelgauge->info.previous_fullcap * 90 / 100)) {
+			dev_info(&client->dev,
+				"%s: [Case 3] previous_fullcap = 0x%04x, NewFullCap = 0x%04x\n",
+				__func__, fuelgauge->info.previous_fullcap,
+				new_fullcap_data);
+
+			new_fullcap_data =
+				(fuelgauge->info.previous_fullcap * 90) / 100;
+
+			fg_write_register(client, REMCAP_REP_REG,
+				(u16)(new_fullcap_data));
+			fg_write_register(client, FULLCAP_REG,
+				(u16)(new_fullcap_data));
+		} else {
+			dev_info(&client->dev,
+				"%s: [Case 4] previous_fullcap = 0x%04x, NewFullCap = 0x%04x\n",
+				__func__, fuelgauge->info.previous_fullcap,
+				new_fullcap_data);
+		}
+	}
+
+	/* 4. Write RepSOC(06h)=100%; */
+	fg_write_register(client, SOCREP_REG, (u16)(0x64 << 8));
+
+	/* 5. Write MixSOC(0Dh)=100%; */
+	fg_write_register(client, SOCMIX_REG, (u16)(0x64 << 8));
+
+	/* 6. Write AVSOC(0Eh)=100%; */
+	fg_write_register(client, SOCAV_REG, (u16)(0x64 << 8));
+
+	/* if pre_update case, skip updating PrevFullCAP value. */
+	if (!pre_update)
+		fuelgauge->info.previous_fullcap =
+			fg_read_register(client, FULLCAP_REG);
+
+	dev_info(&client->dev,
+		"%s: (A) FullCap = 0x%04x, RemCap = 0x%04x\n", __func__,
+		fg_read_register(client, FULLCAP_REG),
+		fg_read_register(client, REMCAP_REP_REG));
+
+	fg_periodic_read(client);
+}
+
+void fg_check_vf_fullcap_range(struct i2c_client *client)
+{
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+	static int new_vffullcap;
+	bool is_vffullcap_changed = true;
+
+	if (fuelgauge->pdata->check_jig_status())
+		fg_reset_capacity_by_jig_connection(client);
+
+	new_vffullcap = fg_read_register(client, FULLCAP_NOM_REG);
+	if (new_vffullcap < 0)
+		new_vffullcap = get_battery_data(fuelgauge).Capacity;
+
+	/* compare with initial capacity */
+	if (new_vffullcap >
+		(get_battery_data(fuelgauge).Capacity * 110 / 100)) {
+		dev_info(&client->dev,
+			"%s: [Case 1] capacity = 0x%04x, NewVfFullCap = 0x%04x\n",
+			__func__, get_battery_data(fuelgauge).Capacity,
+			new_vffullcap);
+
+		new_vffullcap =
+			(get_battery_data(fuelgauge).Capacity * 110) / 100;
+
+		fg_write_register(client, DQACC_REG,
+			(u16)(new_vffullcap / 4));
+		fg_write_register(client, DPACC_REG, (u16)0x3200);
+	} else if (new_vffullcap <
+		(get_battery_data(fuelgauge).Capacity * 50 / 100)) {
+		dev_info(&client->dev,
+			"%s: [Case 5] capacity = 0x%04x, NewVfFullCap = 0x%04x\n",
+			__func__, get_battery_data(fuelgauge).Capacity,
+			new_vffullcap);
+
+		new_vffullcap =
+			(get_battery_data(fuelgauge).Capacity * 50) / 100;
+
+		fg_write_register(client, DQACC_REG,
+			(u16)(new_vffullcap / 4));
+		fg_write_register(client, DPACC_REG, (u16)0x3200);
+	} else {
+	/* compare with previous capacity */
+		if (new_vffullcap >
+			(fuelgauge->info.previous_vffullcap * 110 / 100)) {
+			dev_info(&client->dev,
+				"%s: [Case 2] previous_vffullcap = 0x%04x, NewVfFullCap = 0x%04x\n",
+				__func__, fuelgauge->info.previous_vffullcap,
+				new_vffullcap);
+
+			new_vffullcap =
+				(fuelgauge->info.previous_vffullcap * 110) /
+				100;
+
+			fg_write_register(client, DQACC_REG,
+				(u16)(new_vffullcap / 4));
+			fg_write_register(client, DPACC_REG, (u16)0x3200);
+		} else if (new_vffullcap <
+			(fuelgauge->info.previous_vffullcap * 90 / 100)) {
+			dev_info(&client->dev,
+				"%s: [Case 3] previous_vffullcap = 0x%04x, NewVfFullCap = 0x%04x\n",
+				__func__, fuelgauge->info.previous_vffullcap,
+				new_vffullcap);
+
+			new_vffullcap =
+				(fuelgauge->info.previous_vffullcap * 90) / 100;
+
+			fg_write_register(client, DQACC_REG,
+				(u16)(new_vffullcap / 4));
+			fg_write_register(client, DPACC_REG, (u16)0x3200);
+		} else {
+			dev_info(&client->dev,
+				"%s: [Case 4] previous_vffullcap = 0x%04x, NewVfFullCap = 0x%04x\n",
+				__func__, fuelgauge->info.previous_vffullcap,
+				new_vffullcap);
+			is_vffullcap_changed = false;
+		}
+	}
+
+	/* delay for register setting (dQacc, dPacc) */
+	if (is_vffullcap_changed)
+		msleep(300);
+
+	fuelgauge->info.previous_vffullcap =
+		fg_read_register(client, FULLCAP_NOM_REG);
+
+	if (is_vffullcap_changed)
+		dev_info(&client->dev,
+			"%s : VfFullCap(0x%04x), dQacc(0x%04x), dPacc(0x%04x)\n",
+			__func__,
+			fg_read_register(client, FULLCAP_NOM_REG),
+			fg_read_register(client, DQACC_REG),
+			fg_read_register(client, DPACC_REG));
+
+}
+
+void fg_set_full_charged(struct i2c_client *client)
+{
+	dev_info(&client->dev, "[FG_Set_Full] (B) FullCAP(%d), RemCAP(%d)\n",
+		(fg_read_register(client, FULLCAP_REG)/2),
+		(fg_read_register(client, REMCAP_REP_REG)/2));
+
+	fg_write_register(client, FULLCAP_REG,
+		(u16)fg_read_register(client, REMCAP_REP_REG));
+
+	dev_info(&client->dev, "[FG_Set_Full] (A) FullCAP(%d), RemCAP(%d)\n",
+		(fg_read_register(client, FULLCAP_REG)/2),
+		(fg_read_register(client, REMCAP_REP_REG)/2));
+}
+
+static void display_low_batt_comp_cnt(struct i2c_client *client)
+{
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+
+	pr_info("Check Array(%s): [%d, %d], [%d, %d], ",
+			get_battery_data(fuelgauge).type_str,
+			fuelgauge->info.low_batt_comp_cnt[0][0],
+			fuelgauge->info.low_batt_comp_cnt[0][1],
+			fuelgauge->info.low_batt_comp_cnt[1][0],
+			fuelgauge->info.low_batt_comp_cnt[1][1]);
+	pr_info("[%d, %d], [%d, %d], [%d, %d]\n",
+			fuelgauge->info.low_batt_comp_cnt[2][0],
+			fuelgauge->info.low_batt_comp_cnt[2][1],
+			fuelgauge->info.low_batt_comp_cnt[3][0],
+			fuelgauge->info.low_batt_comp_cnt[3][1],
+			fuelgauge->info.low_batt_comp_cnt[4][0],
+			fuelgauge->info.low_batt_comp_cnt[4][1]);
+}
+
+static void add_low_batt_comp_cnt(struct i2c_client *client,
+				int range, int level)
+{
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+	int i;
+	int j;
+
+	/* Increase the requested count value, and reset others. */
+	fuelgauge->info.low_batt_comp_cnt[range-1][level/2]++;
+
+	for (i = 0; i < LOW_BATT_COMP_RANGE_NUM; i++) {
+		for (j = 0; j < LOW_BATT_COMP_LEVEL_NUM; j++) {
+			if (i == range-1 && j == level/2)
+				continue;
+			else
+				fuelgauge->info.low_batt_comp_cnt[i][j] = 0;
+		}
+	}
+}
+
+void prevent_early_poweroff(struct i2c_client *client,
+	int vcell, int *fg_soc)
+{
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+	int soc = 0;
+	int read_val;
+
+	soc = fg_read_soc(client);
+
+	/* No need to write REMCAP_REP in below normal cases */
+	if (soc > POWER_OFF_SOC_HIGH_MARGIN || vcell > get_battery_data(fuelgauge).low_battery_comp_voltage)
+		return;
+
+	dev_info(&client->dev, "%s: soc=%d, vcell=%d\n", __func__,
+		soc, vcell);
+
+	if (vcell > POWER_OFF_VOLTAGE_HIGH_MARGIN) {
+		read_val = fg_read_register(client, FULLCAP_REG);
+		/* FullCAP * 0.013 */
+		fg_write_register(client, REMCAP_REP_REG,
+		(u16)(read_val * 13 / 1000));
+		msleep(200);
+		*fg_soc = fg_read_soc(client);
+		dev_info(&client->dev, "%s: new soc=%d, vcell=%d\n",
+			__func__, *fg_soc, vcell);
+	}
+}
+
+void reset_low_batt_comp_cnt(struct i2c_client *client)
+{
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+
+	memset(fuelgauge->info.low_batt_comp_cnt, 0,
+		sizeof(fuelgauge->info.low_batt_comp_cnt));
+}
+
+static int check_low_batt_comp_condition(
+				struct i2c_client *client, int *nLevel)
+{
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+	int i;
+	int j;
+	int ret = 0;
+
+	for (i = 0; i < LOW_BATT_COMP_RANGE_NUM; i++) {
+		for (j = 0; j < LOW_BATT_COMP_LEVEL_NUM; j++) {
+			if (fuelgauge->info.low_batt_comp_cnt[i][j] >=
+				MAX_LOW_BATT_CHECK_CNT) {
+				display_low_batt_comp_cnt(client);
+				ret = 1;
+				*nLevel = j*2 + 1;
+				break;
+			}
+		}
+	}
+
+	return ret;
+}
+
+static int get_low_batt_threshold(struct i2c_client *client,
+				int range, int nCurrent, int level)
+{
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+	int ret = 0;
+
+	ret = get_battery_data(fuelgauge).low_battery_table[range][OFFSET] +
+		((nCurrent *
+		get_battery_data(fuelgauge).low_battery_table[range][SLOPE]) /
+		1000);
+
+	return ret;
+}
+
+int low_batt_compensation(struct i2c_client *client,
+		int fg_soc, int fg_vcell, int fg_current)
+{
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+	int fg_avg_current = 0;
+	int fg_min_current = 0;
+	int new_level = 0;
+	int i, table_size;
+
+	/* Not charging, Under low battery comp voltage */
+	if (fg_vcell <= get_battery_data(fuelgauge).low_battery_comp_voltage) {
+		fg_avg_current = fg_read_avg_current(client,
+			SEC_BATTEY_CURRENT_MA);
+		fg_min_current = min(fg_avg_current, fg_current);
+
+		table_size =
+			sizeof(get_battery_data(fuelgauge).low_battery_table) /
+			(sizeof(s16)*TABLE_MAX);
+
+		for (i = 1; i < CURRENT_RANGE_MAX_NUM; i++) {
+			if ((fg_min_current >= get_battery_data(fuelgauge).
+				low_battery_table[i-1][RANGE]) &&
+				(fg_min_current < get_battery_data(fuelgauge).
+				low_battery_table[i][RANGE])) {
+				if (fg_soc >= 10 && fg_vcell <
+					get_low_batt_threshold(client,
+					i, fg_min_current, 1)) {
+					add_low_batt_comp_cnt(
+						client, i, 1);
+				} else {
+					reset_low_batt_comp_cnt(client);
+				}
+			}
+		}
+
+		if (check_low_batt_comp_condition(client, &new_level)) {
+			fg_low_batt_compensation(client, new_level);
+			reset_low_batt_comp_cnt(client);
+
+			/* Do not update soc right after
+			 * low battery compensation
+			 * to prevent from powering-off suddenly
+			 */
+			dev_info(&client->dev,
+				"%s: SOC is set to %d by low compensation!!\n",
+				__func__, fg_read_soc(client));
+		}
+	}
+
+	/* Prevent power off over 3500mV */
+	prevent_early_poweroff(client, fg_vcell, &fg_soc);
+
+	return fg_soc;
+}
+
+static bool is_booted_in_low_battery(struct i2c_client *client)
+{
+	int fg_vcell = get_fuelgauge_value(client, FG_VOLTAGE);
+	int fg_current = get_fuelgauge_value(client, FG_CURRENT);
+	int threshold = 0;
+
+	threshold = 3300 + ((fg_current * 17) / 100);
+
+	if (fg_vcell <= threshold)
+		return true;
+	else
+		return false;
+}
+
+static bool fuelgauge_recovery_handler(struct i2c_client *client)
+{
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+	int current_soc;
+	int avsoc;
+	int temperature;
+
+	if (fuelgauge->info.soc >= LOW_BATTERY_SOC_REDUCE_UNIT) {
+		dev_err(&client->dev,
+			"%s: Reduce the Reported SOC by 1%%\n",
+			__func__);
+		current_soc =
+			get_fuelgauge_value(client, FG_LEVEL) / 10;
+
+		if (current_soc) {
+			dev_info(&client->dev,
+				"%s: Returning to Normal discharge path\n",
+				__func__);
+			dev_info(&client->dev,
+				"%s: Actual SOC(%d) non-zero\n",
+				__func__, current_soc);
+			fuelgauge->info.is_low_batt_alarm = false;
+		} else {
+			temperature =
+				get_fuelgauge_value(client, FG_TEMPERATURE);
+			avsoc =
+				get_fuelgauge_value(client, FG_AV_SOC);
+
+			if ((fuelgauge->info.soc > avsoc) ||
+				(temperature < 0)) {
+				fuelgauge->info.soc -=
+					LOW_BATTERY_SOC_REDUCE_UNIT;
+				dev_err(&client->dev,
+					"%s: New Reduced RepSOC (%d)\n",
+					__func__, fuelgauge->info.soc);
+			} else
+				dev_info(&client->dev,
+					"%s: Waiting for recovery (AvSOC:%d)\n",
+					__func__, avsoc);
+		}
+	}
+
+	return fuelgauge->info.is_low_batt_alarm;
+}
+
+static int get_fuelgauge_soc(struct i2c_client *client)
+{
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+	union power_supply_propval value;
+	int fg_soc = 0;
+	int fg_vfsoc;
+	int fg_vcell;
+	int fg_current;
+	int avg_current;
+	ktime_t	current_time;
+	struct timespec ts;
+	int fullcap_check_interval;
+
+	if (fuelgauge->info.is_low_batt_alarm)
+		if (fuelgauge_recovery_handler(client)) {
+			fg_soc = fuelgauge->info.soc;
+			goto return_soc;
+		}
+
+#if defined(ANDROID_ALARM_ACTIVATED)
+	current_time = alarm_get_elapsed_realtime();
+	ts = ktime_to_timespec(current_time);
+#else
+	current_time = ktime_get_boottime();
+	ts = ktime_to_timespec(current_time);
+#endif
+
+	/* check fullcap range */
+	fullcap_check_interval =
+		(ts.tv_sec - fuelgauge->info.fullcap_check_interval);
+	if (fullcap_check_interval >
+		VFFULLCAP_CHECK_INTERVAL) {
+		dev_info(&client->dev,
+			"%s: check fullcap range (interval:%d)\n",
+			__func__, fullcap_check_interval);
+		fg_check_vf_fullcap_range(client);
+		fuelgauge->info.fullcap_check_interval = ts.tv_sec;
+	}
+
+	fg_soc = get_fuelgauge_value(client, FG_LEVEL);
+	if (fg_soc < 0) {
+		dev_info(&client->dev, "Can't read soc!!!");
+		fg_soc = fuelgauge->info.soc;
+	}
+
+	if (fuelgauge->info.low_batt_boot_flag) {
+		fg_soc = 0;
+
+		if (fuelgauge->pdata->check_cable_callback() !=
+			POWER_SUPPLY_TYPE_BATTERY &&
+			!is_booted_in_low_battery(client)) {
+			fg_adjust_capacity(client);
+			fuelgauge->info.low_batt_boot_flag = 0;
+		}
+
+		if (fuelgauge->pdata->check_cable_callback() ==
+			POWER_SUPPLY_TYPE_BATTERY)
+			fuelgauge->info.low_batt_boot_flag = 0;
+	}
+
+	fg_vcell = get_fuelgauge_value(client, FG_VOLTAGE);
+	fg_current = get_fuelgauge_value(client, FG_CURRENT);
+	avg_current = get_fuelgauge_value(client, FG_CURRENT_AVG);
+	fg_vfsoc = get_fuelgauge_value(client, FG_VF_SOC);
+
+	psy_do_property("battery", get,
+		POWER_SUPPLY_PROP_STATUS, value);
+
+	/* Algorithm for reducing time to fully charged (from MAXIM) */
+	if (value.intval != POWER_SUPPLY_STATUS_DISCHARGING &&
+		value.intval != POWER_SUPPLY_STATUS_FULL &&
+		fuelgauge->cable_type != POWER_SUPPLY_TYPE_USB &&
+		/* Skip when first check after boot up */
+		!fuelgauge->info.is_first_check &&
+		(fg_vfsoc > VFSOC_FOR_FULLCAP_LEARNING &&
+		(fg_current > LOW_CURRENT_FOR_FULLCAP_LEARNING &&
+		fg_current < HIGH_CURRENT_FOR_FULLCAP_LEARNING) &&
+		(avg_current > LOW_AVGCURRENT_FOR_FULLCAP_LEARNING &&
+		avg_current < HIGH_AVGCURRENT_FOR_FULLCAP_LEARNING))) {
+
+		if (fuelgauge->info.full_check_flag == 2) {
+			dev_info(&client->dev,
+				"%s: force fully charged SOC !! (%d)",
+				__func__, fuelgauge->info.full_check_flag);
+			fg_set_full_charged(client);
+			fg_soc = get_fuelgauge_value(client, FG_LEVEL);
+		} else if (fuelgauge->info.full_check_flag < 2)
+			dev_info(&client->dev,
+				"%s: full_check_flag (%d)",
+				__func__, fuelgauge->info.full_check_flag);
+
+		/* prevent overflow */
+		if (fuelgauge->info.full_check_flag++ > 10000)
+			fuelgauge->info.full_check_flag = 3;
+	} else
+		fuelgauge->info.full_check_flag = 0;
+
+	/*  Checks vcell level and tries to compensate SOC if needed.*/
+	/*  If jig cable is connected, then skip low batt compensation check. */
+	if (!fuelgauge->pdata->check_jig_status() &&
+		value.intval == POWER_SUPPLY_STATUS_DISCHARGING)
+		fg_soc = low_batt_compensation(
+			client, fg_soc, fg_vcell, fg_current);
+
+	if (fuelgauge->info.is_first_check)
+		fuelgauge->info.is_first_check = false;
+
+	fuelgauge->info.soc = fg_soc;
+
+return_soc:
+	dev_dbg(&client->dev, "%s: soc(%d), low_batt_alarm(%d)\n",
+		__func__, fuelgauge->info.soc,
+		fuelgauge->info.is_low_batt_alarm);
+
+	return fg_soc;
+}
+
+static void full_comp_work_handler(struct work_struct *work)
+{
+	struct sec_fg_info *fg_info =
+		container_of(work, struct sec_fg_info, full_comp_work.work);
+	struct sec_fuelgauge_info *fuelgauge =
+		container_of(fg_info, struct sec_fuelgauge_info, info);
+	int avg_current;
+	union power_supply_propval value;
+
+	avg_current = get_fuelgauge_value(fuelgauge->client, FG_CURRENT_AVG);
+	psy_do_property("battery", get,
+		POWER_SUPPLY_PROP_STATUS, value);
+
+	if (avg_current >= 25) {
+		cancel_delayed_work(&fuelgauge->info.full_comp_work);
+		schedule_delayed_work(&fuelgauge->info.full_comp_work, 100);
+	} else {
+		dev_info(&fuelgauge->client->dev,
+			"%s: full charge compensation start (avg_current %d)\n",
+			__func__, avg_current);
+		fg_fullcharged_compensation(fuelgauge->client,
+			(int)(value.intval ==
+			POWER_SUPPLY_STATUS_FULL), false);
+	}
+}
+
+static irqreturn_t sec_jig_irq_thread(int irq, void *irq_data)
+{
+	struct sec_fuelgauge_info *fuelgauge = irq_data;
+
+	if (fuelgauge->pdata->check_jig_status())
+		fg_reset_capacity_by_jig_connection(fuelgauge->client);
+	else
+		dev_info(&fuelgauge->client->dev,
+				"%s: jig removed\n", __func__);
+	return IRQ_HANDLED;
+}
+
+bool sec_hal_fg_init(struct i2c_client *client)
+{
+	struct sec_fuelgauge_info *fuelgauge =
+				i2c_get_clientdata(client);
+	ktime_t	current_time;
+	struct timespec ts;
+	u8 data[2] = {0, 0};
+
+#if defined(ANDROID_ALARM_ACTIVATED)
+	current_time = alarm_get_elapsed_realtime();
+	ts = ktime_to_timespec(current_time);
+#else
+	current_time = ktime_get_boottime();
+	ts = ktime_to_timespec(current_time);
+#endif
+
+	fuelgauge->info.fullcap_check_interval = ts.tv_sec;
+
+	fuelgauge->info.is_low_batt_alarm = false;
+	fuelgauge->info.is_first_check = true;
+
+	/* Init parameters to prevent wrong compensation. */
+	fuelgauge->info.previous_fullcap =
+		fg_read_register(client, FULLCAP_REG);
+	fuelgauge->info.previous_vffullcap =
+		fg_read_register(client, FULLCAP_NOM_REG);
+
+	/* To reduce booting time, skip reading regs
+	* fg_read_model_data(client);
+	* fg_periodic_read(client);
+	*/
+
+	if (fuelgauge->pdata->check_cable_callback() !=
+		POWER_SUPPLY_TYPE_BATTERY &&
+		is_booted_in_low_battery(client))
+		fuelgauge->info.low_batt_boot_flag = 1;
+
+	if (fuelgauge->pdata->check_jig_status())
+		fg_reset_capacity_by_jig_connection(client);
+	else {
+		if (fuelgauge->pdata->jig_irq) {
+			int ret;
+			ret = request_threaded_irq(fuelgauge->pdata->jig_irq,
+					NULL, sec_jig_irq_thread,
+					fuelgauge->pdata->jig_irq_attr,
+					"jig-irq", fuelgauge);
+			if (ret) {
+				dev_info(&fuelgauge->client->dev,
+					"%s: Failed to Reqeust IRQ\n",
+					__func__);
+			}
+		}
+	}
+
+	INIT_DELAYED_WORK(&fuelgauge->info.full_comp_work,
+		full_comp_work_handler);
+
+	/* NOT using FG for temperature */
+	if (fuelgauge->pdata->thermal_source != SEC_BATTERY_THERMAL_SOURCE_FG) {
+		data[0] = 0x00;
+		data[1] = 0x21;
+		fg_i2c_write(client, CONFIG_REG, data, 2);
+	}
+
+	return true;
+}
+
+bool sec_hal_fg_suspend(struct i2c_client *client)
+{
+	return true;
+}
+
+bool sec_hal_fg_resume(struct i2c_client *client)
+{
+	return true;
+}
+
+bool sec_hal_fg_fuelalert_init(struct i2c_client *client, int soc)
+{
+	if (fg_alert_init(client, soc) > 0)
+		return true;
+	else
+		return false;
+}
+
+bool sec_hal_fg_is_fuelalerted(struct i2c_client *client)
+{
+	if (get_fuelgauge_value(client, FG_CHECK_STATUS) > 0)
+		return true;
+	else
+		return false;
+}
+
+bool sec_hal_fg_fuelalert_process(void *irq_data, bool is_fuel_alerted)
+{
+	struct sec_fuelgauge_info *fuelgauge =
+		(struct sec_fuelgauge_info *)irq_data;
+	union power_supply_propval value;
+	int overcurrent_limit_in_soc;
+	int current_soc =
+		get_fuelgauge_value(fuelgauge->client, FG_LEVEL);
+
+	psy_do_property("battery", get,
+		POWER_SUPPLY_PROP_STATUS, value);
+	if (value.intval == POWER_SUPPLY_STATUS_CHARGING)
+		return true;
+
+	if (fuelgauge->info.soc <= STABLE_LOW_BATTERY_DIFF)
+		overcurrent_limit_in_soc = STABLE_LOW_BATTERY_DIFF_LOWBATT;
+	else
+		overcurrent_limit_in_soc = STABLE_LOW_BATTERY_DIFF;
+
+	if (((int)fuelgauge->info.soc - current_soc) >
+		overcurrent_limit_in_soc) {
+		dev_info(&fuelgauge->client->dev,
+			"%s: Abnormal Current Consumption jump by %d units\n",
+			__func__, (((int)fuelgauge->info.soc - current_soc)));
+		dev_info(&fuelgauge->client->dev,
+			"%s: Last Reported SOC (%d).\n",
+			__func__, fuelgauge->info.soc);
+
+		fuelgauge->info.is_low_batt_alarm = true;
+
+		if (fuelgauge->info.soc >=
+			LOW_BATTERY_SOC_REDUCE_UNIT)
+			return true;
+	}
+
+	if (value.intval ==
+			POWER_SUPPLY_STATUS_DISCHARGING) {
+		dev_err(&fuelgauge->client->dev,
+			"Set battery level as 0, power off.\n");
+		fuelgauge->info.soc = 0;
+		value.intval = 0;
+		psy_do_property("battery", set,
+			POWER_SUPPLY_PROP_CAPACITY, value);
+	}
+
+	return true;
+}
+
+bool sec_hal_fg_full_charged(struct i2c_client *client)
+{
+	struct sec_fuelgauge_info *fuelgauge =
+				i2c_get_clientdata(client);
+	union power_supply_propval value;
+
+	psy_do_property("battery", get,
+		POWER_SUPPLY_PROP_STATUS, value);
+
+	/* full charge compensation algorithm by MAXIM */
+	fg_fullcharged_compensation(client,
+		(int)(value.intval == POWER_SUPPLY_STATUS_FULL), true);
+
+	cancel_delayed_work(&fuelgauge->info.full_comp_work);
+	schedule_delayed_work(&fuelgauge->info.full_comp_work, 100);
+
+	return false;
+}
+
+bool sec_hal_fg_reset(struct i2c_client *client)
+{
+	if (!fg_reset_soc(client))
+		return true;
+	else
+		return false;
+}
+
+bool sec_hal_fg_get_property(struct i2c_client *client,
+			     enum power_supply_property psp,
+			     union power_supply_propval *val)
+{
+	switch (psp) {
+		/* Cell voltage (VCELL, mV) */
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = get_fuelgauge_value(client, FG_VOLTAGE);
+		break;
+		/* Additional Voltage Information (mV) */
+	case POWER_SUPPLY_PROP_VOLTAGE_AVG:
+		switch (val->intval) {
+		case SEC_BATTEY_VOLTAGE_OCV:
+			val->intval = fg_read_vfocv(client);
+			break;
+		case SEC_BATTEY_VOLTAGE_AVERAGE:
+		default:
+			val->intval = fg_read_avg_vcell(client);
+			break;
+		}
+		break;
+		/* Current */
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		switch (val->intval) {
+		case SEC_BATTEY_CURRENT_UA:
+			val->intval =
+				fg_read_current(client, SEC_BATTEY_CURRENT_UA);
+			break;
+		case SEC_BATTEY_CURRENT_MA:
+		default:
+			val->intval = get_fuelgauge_value(client, FG_CURRENT);
+			break;
+		}
+		break;
+		/* Average Current */
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+		switch (val->intval) {
+		case SEC_BATTEY_CURRENT_UA:
+			val->intval =
+				fg_read_avg_current(client,
+				SEC_BATTEY_CURRENT_UA);
+			break;
+		case SEC_BATTEY_CURRENT_MA:
+		default:
+			val->intval =
+				get_fuelgauge_value(client, FG_CURRENT_AVG);
+			break;
+		}
+		break;
+		/* Full Capacity */
+	case POWER_SUPPLY_PROP_ENERGY_NOW:
+		switch (val->intval) {
+		case SEC_BATTEY_CAPACITY_DESIGNED:
+			val->intval = get_fuelgauge_value(client, FG_FULLCAP);
+			break;
+		case SEC_BATTEY_CAPACITY_ABSOLUTE:
+			val->intval = get_fuelgauge_value(client, FG_MIXCAP);
+			break;
+		case SEC_BATTEY_CAPACITY_TEMPERARY:
+			val->intval = get_fuelgauge_value(client, FG_AVCAP);
+			break;
+		case SEC_BATTEY_CAPACITY_CURRENT:
+			val->intval = get_fuelgauge_value(client, FG_REPCAP);
+			break;
+		}
+		break;
+		/* SOC (%) */
+	case POWER_SUPPLY_PROP_CAPACITY:
+		if (val->intval == SEC_FUELGAUGE_CAPACITY_TYPE_RAW)
+			val->intval = get_fuelgauge_value(client, FG_RAW_SOC);
+		else
+			val->intval = get_fuelgauge_soc(client);
+		break;
+		/* Battery Temperature */
+	case POWER_SUPPLY_PROP_TEMP:
+		/* Target Temperature */
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		val->intval = get_fuelgauge_value(client, FG_TEMPERATURE);
+		break;
+	default:
+		return false;
+	}
+	return true;
+}
+
+bool sec_hal_fg_set_property(struct i2c_client *client,
+			     enum power_supply_property psp,
+			     const union power_supply_propval *val)
+{
+	struct sec_fuelgauge_info *fuelgauge =
+				i2c_get_clientdata(client);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		if (val->intval != POWER_SUPPLY_TYPE_BATTERY) {
+			if (fuelgauge->info.is_low_batt_alarm) {
+				dev_info(&client->dev,
+					"%s: Reset low_batt_alarm\n",
+					__func__);
+				fuelgauge->info.is_low_batt_alarm = false;
+			}
+
+			reset_low_batt_comp_cnt(client);
+		}
+		break;
+		/* Battery Temperature */
+	case POWER_SUPPLY_PROP_TEMP:
+		/* Target Temperature */
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		fg_write_temp(client, val->intval);
+		break;
+	case POWER_SUPPLY_PROP_ENERGY_NOW:
+		fg_reset_capacity_by_jig_connection(client);
+		break;
+	default:
+		return false;
+	}
+	return true;
+}
+
+ssize_t sec_hal_fg_show_attrs(struct device *dev,
+				const ptrdiff_t offset, char *buf)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct sec_fuelgauge_info *fg =
+		container_of(psy, struct sec_fuelgauge_info, psy_fg);
+	int i = 0;
+	char *str = NULL;
+
+	switch (offset) {
+/*	case FG_REG: */
+/*		break; */
+	case FG_DATA:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%02x%02x\n",
+			fg->reg_data[1], fg->reg_data[0]);
+		break;
+	case FG_REGS:
+		str = kzalloc(sizeof(char)*1024, GFP_KERNEL);
+		if (!str)
+			return -ENOMEM;
+
+		fg_read_regs(fg->client, str);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%s\n",
+			str);
+
+		kfree(str);
+		break;
+	default:
+		i = -EINVAL;
+		break;
+	}
+
+	return i;
+}
+
+ssize_t sec_hal_fg_store_attrs(struct device *dev,
+				const ptrdiff_t offset,
+				const char *buf, size_t count)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct sec_fuelgauge_info *fg =
+		container_of(psy, struct sec_fuelgauge_info, psy_fg);
+	int ret = 0;
+	int x = 0;
+
+	switch (offset) {
+	case FG_REG:
+		if (sscanf(buf, "%x\n", &x) == 1) {
+			fg->reg_addr = x;
+			if (fg_i2c_read(fg->client,
+				fg->reg_addr, fg->reg_data, 2) < 0) {
+				dev_err(dev, "%s: Error in read\n", __func__);
+				break;
+			}
+			dev_dbg(dev,
+				"%s: (read) addr = 0x%x, data = 0x%02x%02x\n",
+				__func__, fg->reg_addr,
+				fg->reg_data[1], fg->reg_data[0]);
+			ret = count;
+		}
+		break;
+	case FG_DATA:
+		if (sscanf(buf, "%x\n", &x) == 1) {
+			dev_dbg(dev, "%s: (write) addr = 0x%x, data = 0x%04x\n",
+				__func__, fg->reg_addr, x);
+			fg_write_and_verify_register(fg->client,
+				fg->reg_addr, (u16)x);
+			ret = count;
+		}
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+#endif
+
diff -Naur linux-3.18.14/drivers/battery/max77693_charger.c samsung/drivers/battery/max77693_charger.c
--- linux-3.18.14/drivers/battery/max77693_charger.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery/max77693_charger.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,1302 @@
+/*
+ *  max77693_charger.c
+ *  Samsung max77693 Charger Driver
+ *
+ *  Copyright (C) 2012 Samsung Electronics
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/mfd/max77693.h>
+#include <linux/mfd/max77693-private.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+
+#define DEBUG
+
+#define ENABLE 1
+#define DISABLE 0
+
+static struct dentry    *max77693_dentry;
+
+struct max77693_charger_data {
+	struct max77693_dev	*max77693;
+
+	struct power_supply	psy_chg;
+
+	struct workqueue_struct *wqueue;
+	struct work_struct	chgin_work;
+	struct delayed_work	isr_work;
+
+	/* mutex */
+	struct mutex irq_lock;
+	struct mutex ops_lock;
+
+	/* wakelock */
+	struct wake_lock update_wake_lock;
+
+	unsigned int	is_charging;
+	unsigned int	charging_type;
+	unsigned int	battery_state;
+	unsigned int	battery_present;
+	unsigned int	cable_type;
+	unsigned int	charging_current_max;
+	unsigned int	charging_current;
+	unsigned int	input_current_limit;
+	unsigned int	vbus_state;
+	int		status;
+	bool		aicl_on;
+	int		siop_level;
+
+	int		irq_bypass;
+	int		irq_therm;
+	int		irq_battery;
+	int		irq_chg;
+	int		irq_chgin;
+
+	/* software regulation */
+	bool		soft_reg_state;
+	int		soft_reg_current;
+
+	/* unsufficient power */
+	bool		reg_loop_deted;
+
+#if defined(CONFIG_WIRELESS_CHARGING)
+	/* wireless charge, w(wpc), v(vbus) */
+	int		wc_w_gpio;
+	int		wc_w_irq;
+	int		wc_w_state;
+	int		wc_v_gpio;
+	int		wc_v_irq;
+	int		wc_v_state;
+	bool		wc_pwr_det;
+#endif
+
+	sec_battery_platform_data_t	*pdata;
+};
+
+static enum power_supply_property sec_charger_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_CHARGE_TYPE,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_CURRENT_MAX,
+	POWER_SUPPLY_PROP_CURRENT_AVG,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+};
+
+/* static void MAX77693_charger_initialize(struct max77693_charger_data *charger); */
+static int max77693_get_vbus_state(struct max77693_charger_data *charger);
+
+static void max77693_dump_reg(struct max77693_charger_data *charger)
+{
+	u8 reg_data;
+	u32 reg_addr;
+	pr_info("%s\n", __func__);
+
+	for (reg_addr = 0xB0; reg_addr <= 0xC5; reg_addr++) {
+		max77693_read_reg(charger->max77693->i2c, reg_addr, &reg_data);
+		pr_info("max77693: c: 0x%02x(0x%02x)\n", reg_addr, reg_data);
+	}
+}
+
+static int max77693_get_battery_present(struct max77693_charger_data *charger)
+{
+	u8 reg_data;
+
+	if (max77693_read_reg(charger->max77693->i2c,
+			MAX77693_CHG_REG_CHG_INT_OK, &reg_data) < 0) {
+		/* Eventhough there is an error,
+		   don't do power-off */
+		return 1;
+	}
+
+	pr_debug("%s: CHG_INT_OK(0x%02x)\n", __func__, reg_data);
+
+	reg_data = ((reg_data & MAX77693_BATP_OK) >> MAX77693_BATP_OK_SHIFT);
+
+	return reg_data;
+}
+
+static void max77693_set_charger_state(struct max77693_charger_data *charger,
+		int enable)
+{
+	u8 reg_data;
+
+	max77693_read_reg(charger->max77693->i2c,
+			MAX77693_CHG_REG_CHG_CNFG_00, &reg_data);
+
+	if (enable)
+		reg_data |= MAX77693_MODE_CHGR;
+	else
+		reg_data &= ~MAX77693_MODE_CHGR;
+
+	pr_info("%s: CHG_CNFG_00(0x%02x)\n", __func__, reg_data);
+	max77693_write_reg(charger->max77693->i2c,
+			MAX77693_CHG_REG_CHG_CNFG_00, reg_data);
+}
+
+static void max77693_set_buck(struct max77693_charger_data *charger,
+		int enable)
+{
+	u8 reg_data;
+
+	max77693_read_reg(charger->max77693->i2c,
+		MAX77693_CHG_REG_CHG_CNFG_00, &reg_data);
+
+	if (enable)
+		reg_data |= MAX77693_MODE_BUCK;
+	else
+		reg_data &= ~MAX77693_MODE_BUCK;
+
+	pr_debug("%s: CHG_CNFG_00(0x%02x)\n", __func__, reg_data);
+	max77693_write_reg(charger->max77693->i2c,
+		MAX77693_CHG_REG_CHG_CNFG_00, reg_data);
+}
+
+static void max77693_set_input_current(struct max77693_charger_data *charger,
+		int cur)
+{
+	int set_current_reg, now_current_reg;
+	int vbus_state, curr_step, delay;
+	u8 set_reg, reg_data;
+
+	mutex_lock(&charger->ops_lock);
+	disable_irq(charger->irq_chgin);
+
+	if (charger->cable_type == POWER_SUPPLY_TYPE_WPC)
+		set_reg = MAX77693_CHG_REG_CHG_CNFG_10;
+	else
+		set_reg = MAX77693_CHG_REG_CHG_CNFG_09;
+
+
+	if (cur <= 0) {
+		max77693_write_reg(charger->max77693->i2c,
+			set_reg, 0);
+//		max77693_set_buck(charger, DISABLE);
+		enable_irq(charger->irq_chgin);
+		mutex_unlock(&charger->ops_lock);
+		return;
+	} else
+		max77693_set_buck(charger, ENABLE);
+
+	set_current_reg = cur / 20;
+	max77693_read_reg(charger->max77693->i2c,
+		set_reg, &reg_data);
+	if (reg_data == set_current_reg) {
+		/* check uvlo  */
+		while(1) {
+			vbus_state = max77693_get_vbus_state(charger);
+			if (((vbus_state == 0x00) || (vbus_state == 0x01)) &&
+				(charger->cable_type != POWER_SUPPLY_TYPE_WPC)) {
+				/* UVLO */
+				set_current_reg -= 5;
+				if (set_current_reg <= 0)
+					break;
+				max77693_write_reg(charger->max77693->i2c,
+						set_reg, set_current_reg);
+				pr_info("%s: reg_data(0x%02x)\n", __func__, set_current_reg);
+				/* under 1.3A, slow rate */
+				if (set_current_reg < (1300 / 20) &&
+					(charger->cable_type == POWER_SUPPLY_TYPE_MAINS))
+					charger->aicl_on = true;
+				msleep(50);
+			} else
+				break;
+		}
+		enable_irq(charger->irq_chgin);
+		mutex_unlock(&charger->ops_lock);
+		return;
+	}
+
+	if (reg_data == 0) {
+		now_current_reg = SOFT_CHG_START_CURR / 20;
+		max77693_write_reg(charger->max77693->i2c,
+			set_reg, now_current_reg);
+		msleep(SOFT_CHG_START_DUR);
+	} else
+		now_current_reg = reg_data;
+
+	if (cur < 500) {
+		curr_step = 1;
+		delay = 50;
+	} else {
+		curr_step = SOFT_CHG_CURR_STEP / 20;
+		delay = SOFT_CHG_STEP_DUR;
+	}
+	now_current_reg += (curr_step);
+
+	while (now_current_reg < set_current_reg &&
+			charger->cable_type != POWER_SUPPLY_TYPE_BATTERY)
+	{
+		now_current_reg = min(now_current_reg, set_current_reg);
+		max77693_write_reg(charger->max77693->i2c,
+			set_reg, now_current_reg);
+		msleep(delay);
+
+		vbus_state = max77693_get_vbus_state(charger);
+		if (((vbus_state == 0x00) || (vbus_state == 0x01)) &&
+			!(charger->cable_type == POWER_SUPPLY_TYPE_WPC)) {
+			/* UVLO */
+			now_current_reg -= (curr_step * 3);
+			curr_step /= 2;
+			max77693_write_reg(charger->max77693->i2c,
+					set_reg, now_current_reg);
+			pr_info("%s: reg_data(0x%02x)\n", __func__, now_current_reg);
+			if (curr_step < 5) {
+				/* under 1.3A, slow rate */
+				if (now_current_reg < (1300 / 20) &&
+					(charger->cable_type == POWER_SUPPLY_TYPE_MAINS))
+					charger->aicl_on = true;
+				enable_irq(charger->irq_chgin);
+				mutex_unlock(&charger->ops_lock);
+				return;
+			}
+			msleep(50);
+		} else
+			now_current_reg += (curr_step);
+	}
+
+	pr_info("%s: reg_data(0x%02x)\n", __func__, set_current_reg);
+	max77693_write_reg(charger->max77693->i2c,
+		set_reg, set_current_reg);
+	enable_irq(charger->irq_chgin);
+	mutex_unlock(&charger->ops_lock);
+}
+
+static int max77693_get_input_current(struct max77693_charger_data *charger)
+{
+	u8 reg_data;
+	int get_current = 0;
+
+	if (charger->cable_type == POWER_SUPPLY_TYPE_WPC) {
+		max77693_read_reg(charger->max77693->i2c,
+			MAX77693_CHG_REG_CHG_CNFG_10, &reg_data);
+		pr_info("%s: CHG_CNFG_10(0x%02x)\n", __func__, reg_data);
+	} else {
+		max77693_read_reg(charger->max77693->i2c,
+			MAX77693_CHG_REG_CHG_CNFG_09, &reg_data);
+		pr_info("%s: CHG_CNFG_09(0x%02x)\n", __func__, reg_data);
+	}
+
+	get_current = reg_data * 20;
+
+	pr_debug("%s: get input current: %dmA\n", __func__, get_current);
+	return get_current;
+}
+
+static void max77693_set_topoff_current(struct max77693_charger_data *charger,
+		int cur, int timeout)
+{
+	u8 reg_data;
+
+	if (cur >= 350)
+		reg_data = 0x07;
+	else if (cur >= 300)
+		reg_data = 0x06;
+	else if (cur >= 250)
+		reg_data = 0x05;
+	else if (cur >= 200)
+		reg_data = 0x04;
+	else if (cur >= 175)
+		reg_data = 0x03;
+	else if (cur >= 150)
+		reg_data = 0x02;
+	else if (cur >= 125)
+		reg_data = 0x01;
+	else
+		reg_data = 0x00;
+
+	/* the unit of timeout is second*/
+	timeout = timeout / 60;
+	reg_data |= ((timeout / 10) << 3);
+	pr_info("%s: reg_data(0x%02x), topoff(%d)\n", __func__, reg_data, cur);
+
+	max77693_write_reg(charger->max77693->i2c,
+		MAX77693_CHG_REG_CHG_CNFG_03, reg_data);
+}
+
+static void max77693_set_charge_current(struct max77693_charger_data *charger,
+		int cur)
+{
+	u8 reg_data = 0;
+
+	pr_info("%s: set current value : %d\n", __func__, cur);
+
+	if (!cur) {
+		/* No charger */
+		max77693_write_reg(charger->max77693->i2c,
+			MAX77693_CHG_REG_CHG_CNFG_02, 0x0);
+	} else {
+		reg_data &= ~MAX77693_CHG_CC;
+		reg_data |= ((cur * 3 / 100) << 0);
+//		reg_data |= MAX77693_OTG_ILIM;
+
+		pr_info("%s: charge current %d mA, reg_data(0x%02x)\n",
+				__func__, cur, reg_data);
+
+		max77693_write_reg(charger->max77693->i2c,
+			MAX77693_CHG_REG_CHG_CNFG_02, reg_data);
+	}
+}
+
+static int max77693_get_charge_current(struct max77693_charger_data *charger)
+{
+	u8 reg_data;
+	int get_current = 0;
+
+	max77693_read_reg(charger->max77693->i2c,
+		MAX77693_CHG_REG_CHG_CNFG_02, &reg_data);
+	pr_debug("%s: CHG_CNFG_02(0x%02x)\n", __func__, reg_data);
+
+	reg_data &= MAX77693_CHG_CC;
+	get_current = reg_data * 333 / 10;
+
+	pr_debug("%s: get charge current: %dmA\n", __func__, get_current);
+	return get_current;
+}
+
+static void reduce_input_current(struct max77693_charger_data *charger, int cur)
+{
+	u8 set_reg;
+	u8 set_value;
+
+	if ((!charger->is_charging) || mutex_is_locked(&charger->ops_lock) ||
+			(charger->cable_type == POWER_SUPPLY_TYPE_WPC))
+		return;
+	set_reg = MAX77693_CHG_REG_CHG_CNFG_09;
+	if (!max77693_read_reg(charger->max77693->i2c,
+				set_reg, &set_value)) {
+		if (set_value == 0)
+			return;
+		set_value -= (cur / 20);
+		set_value = (set_value < 10) ? 10 : set_value;
+		max77693_write_reg(charger->max77693->i2c,
+				set_reg, set_value);
+		pr_info("%s: set current: reg:(0x%x), val:(0x%x)\n",
+				__func__, set_reg, set_value);
+		/* under 1.3A, slow rate */
+		if (set_value < (1300 / 20) &&
+			(charger->cable_type == POWER_SUPPLY_TYPE_MAINS))
+			charger->aicl_on = true;
+	}
+}
+
+static int max77693_get_vbus_state(struct max77693_charger_data *charger)
+{
+	u8 reg_data;
+
+	max77693_read_reg(charger->max77693->i2c,
+		MAX77693_CHG_REG_CHG_DTLS_00, &reg_data);
+	if (charger->cable_type == POWER_SUPPLY_TYPE_WPC)
+		reg_data = ((reg_data & MAX77693_WCIN_DTLS) >>
+			MAX77693_WCIN_DTLS_SHIFT);
+	else
+		reg_data = ((reg_data & MAX77693_CHGIN_DTLS) >>
+			MAX77693_CHGIN_DTLS_SHIFT);
+
+	switch (reg_data) {
+	case 0x00:
+		pr_info("%s: VBUS is invalid. CHGIN < CHGIN_UVLO\n",
+			__func__);
+		break;
+	case 0x01:
+		pr_info("%s: VBUS is invalid. CHGIN < MBAT+CHGIN2SYS" \
+			"and CHGIN > CHGIN_UVLO\n", __func__);
+		break;
+	case 0x02:
+		pr_info("%s: VBUS is invalid. CHGIN > CHGIN_OVLO",
+			__func__);
+		break;
+	case 0x03:
+		pr_info("%s: VBUS is valid. CHGIN < CHGIN_OVLO", __func__);
+		break;
+	default:
+		break;
+	}
+
+	return reg_data;
+}
+
+static int max77693_get_charger_state(struct max77693_charger_data *charger)
+{
+	int state;
+	u8 reg_data;
+
+	max77693_read_reg(charger->max77693->i2c,
+		MAX77693_CHG_REG_CHG_DTLS_01, &reg_data);
+	reg_data = ((reg_data & MAX77693_CHG_DTLS) >> MAX77693_CHG_DTLS_SHIFT);
+	pr_info("%s: CHG_DTLS : 0x%2x\n", __func__, reg_data);
+
+	switch (reg_data) {
+	case 0x0:
+	case 0x1:
+	case 0x2:
+		state = POWER_SUPPLY_STATUS_CHARGING;
+		break;
+	case 0x3:
+	case 0x4:
+		state = POWER_SUPPLY_STATUS_FULL;
+		break;
+	case 0x5:
+	case 0x6:
+	case 0x7:
+		state = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		break;
+	case 0x8:
+	case 0xA:
+	case 0xB:
+		state = POWER_SUPPLY_STATUS_DISCHARGING;
+		break;
+	default:
+		state = POWER_SUPPLY_STATUS_UNKNOWN;
+		break;
+	}
+
+	return state;
+}
+
+static int max77693_get_health_state(struct max77693_charger_data *charger)
+{
+	int state;
+	int vbus_state;
+	int chg_state;
+	u8 reg_data;
+
+	max77693_read_reg(charger->max77693->i2c,
+		MAX77693_CHG_REG_CHG_DTLS_01, &reg_data);
+	reg_data = ((reg_data & MAX77693_BAT_DTLS) >> MAX77693_BAT_DTLS_SHIFT);
+
+	switch (reg_data) {
+	case 0x00:
+		pr_info("%s: No battery and the charger is suspended\n",
+			__func__);
+		state = POWER_SUPPLY_HEALTH_UNKNOWN;
+		break;
+	case 0x01:
+		pr_info("%s: battery unspec failure\n",
+			__func__);
+		state = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;
+		break;
+	case 0x02:
+		pr_info("%s: battery dead\n", __func__);
+		state = POWER_SUPPLY_HEALTH_DEAD;
+		break;
+	case 0x03:
+		pr_info("%s: battery good\n", __func__);
+		state = POWER_SUPPLY_HEALTH_GOOD;
+		break;
+	case 0x04:
+		pr_info("%s: battery is okay" \
+			"but its voltage is low\n", __func__);
+		state = POWER_SUPPLY_HEALTH_GOOD;
+		break;
+	case 0x05:
+		pr_info("%s: battery ovp\n", __func__);
+		state = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+		break;
+	default:
+		pr_info("%s: battery unknown : 0x%d\n", __func__, reg_data);
+		state = POWER_SUPPLY_HEALTH_UNKNOWN;
+		break;
+	}
+
+	if (state == POWER_SUPPLY_HEALTH_GOOD) {
+		/* VBUS OVP state return battery OVP state */
+		vbus_state = max77693_get_vbus_state(charger);
+		if ((vbus_state == 0x00) || (vbus_state == 0x01))
+			reduce_input_current(charger, 20);
+		/* read CHG_DTLS and detecting battery terminal error */
+		chg_state = max77693_get_charger_state(charger);
+		/* OVP is higher priority */
+		if (vbus_state == 0x02) { /* CHGIN_OVLO */
+			pr_info("%s: vbus ovp\n", __func__);
+			state = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+		} else if (reg_data == 0x04 &&
+				chg_state == POWER_SUPPLY_STATUS_FULL) {
+			pr_info("%s: battery terminal error\n", __func__);
+			state = POWER_SUPPLY_HEALTH_UNDERVOLTAGE;
+		}
+	}
+
+	return state;
+}
+
+static bool max77693_charger_unlock(struct max77693_charger_data *chg_data)
+{
+	struct i2c_client *i2c = chg_data->max77693->i2c;
+	u8 reg_data;
+	u8 chgprot;
+	int retry_cnt = 0;
+	bool need_init = false;
+	pr_debug("%s\n", __func__);
+	pr_info("%s: charger unlock enable \n", __func__);
+
+	max77693_read_reg(i2c, MAX77693_CHG_REG_CHG_CNFG_06, &reg_data);
+	chgprot = ((reg_data & 0x0C) >> 2);
+
+	if (chgprot == 0x03) {
+		pr_info("%s: unlocked state, return\n", __func__);
+		need_init = false;
+		goto unlock_finish;
+	}
+
+	do {
+		max77693_write_reg(i2c, MAX77693_CHG_REG_CHG_CNFG_06,
+					(0x03 << 2));
+
+		max77693_read_reg(i2c, MAX77693_CHG_REG_CHG_CNFG_06, &reg_data);
+		chgprot = ((reg_data & 0x0C) >> 2);
+
+		if (chgprot != 0x03) {
+			pr_err("%s: unlock err, chgprot(0x%x), retry(%d)\n",
+					__func__, chgprot, retry_cnt);
+			msleep(100);
+		} else {
+			pr_info("%s: unlock success, chgprot(0x%x)\n",
+							__func__, chgprot);
+			need_init = true;
+			break;
+		}
+	} while ((chgprot != 0x03) && (++retry_cnt < 10));
+
+unlock_finish:
+	return need_init;
+}
+
+static void max77693_charger_initialize(struct max77693_charger_data *charger)
+{
+	u8 reg_data, float_voltage = 0x1D;
+	pr_debug("%s\n", __func__);
+
+	max77693_set_buck(charger, ENABLE);
+
+	/* unlock charger setting protect */
+	reg_data = (0x03 << 2);
+	max77693_write_reg(charger->max77693->i2c,
+		MAX77693_CHG_REG_CHG_CNFG_06, reg_data);
+
+	/*
+	 * fast charge timer disable
+	 * restart threshold disable
+	 * pre-qual charge enable(default)
+	 */
+	reg_data = (0x0 << 0) | (0x03 << 4);
+	max77693_write_reg(charger->max77693->i2c,
+		MAX77693_CHG_REG_CHG_CNFG_01, reg_data);
+
+	/*
+	 * confirm whether TA is connected or NOT
+	 */
+	if (max77693_read_reg(charger->max77693->i2c,
+		MAX77693_CHG_REG_CHG_INT_OK, &reg_data) == 0) {
+		/* Check the charging status*/
+		if ((reg_data & (MAX77693_CHGIN_OK|MAX77693_WCIN_OK)) == 0) {
+			max77693_read_reg(charger->max77693->i2c,
+				MAX77693_CHG_REG_CHG_CNFG_00, &reg_data);
+			reg_data &= ~(CHG_CNFG_00_CHG_MASK
+					| CHG_CNFG_00_BUCK_MASK);
+			max77693_write_reg(charger->max77693->i2c,
+				MAX77693_CHG_REG_CHG_CNFG_00, reg_data);
+		}
+	}
+	/*
+	 * charge current 466mA(default)
+	 * otg current limit 900mA
+	 */
+	max77693_read_reg(charger->max77693->i2c,
+			MAX77693_CHG_REG_CHG_CNFG_02, &reg_data);
+	reg_data |= (1 << 7);
+	max77693_write_reg(charger->max77693->i2c,
+		MAX77693_CHG_REG_CHG_CNFG_02, reg_data);
+
+	/*
+	 * top off current 100mA
+	 * top off timer 40min
+	 */
+	reg_data = (0x04 << 3);
+	max77693_write_reg(charger->max77693->i2c,
+		MAX77693_CHG_REG_CHG_CNFG_03, reg_data);
+
+	/*
+	 * cv voltage 4.2V or 4.35V
+	 * MINVSYS 3.6V(default)
+	 */
+	max77693_read_reg(charger->max77693->i2c,
+			MAX77693_CHG_REG_CHG_CNFG_04, &reg_data);
+
+	reg_data &= ~0x1F;
+	if (charger->pdata->chg_float_voltage) {
+		float_voltage = charger->pdata->chg_float_voltage <= 4325 ?
+			(charger->pdata->chg_float_voltage - 3650) / 25 :
+			(charger->pdata->chg_float_voltage - 3650) / 25 + 1;
+	}
+
+	reg_data |= float_voltage;
+
+	/*
+	pr_info("%s: battery cv voltage %s, (sysrev %d)\n", __func__,
+		(((reg_data & max77693_CHG_PRM_MASK) == \
+		(0x1D << max77693_CHG_PRM_SHIFT)) ? "4.35V" : "4.2V"),
+		system_rev);
+	*/
+	max77693_write_reg(charger->max77693->i2c,
+		MAX77693_CHG_REG_CHG_CNFG_04, reg_data);
+
+	/* VBYPSET Default set 3V */
+	reg_data = 0x00;
+	max77693_write_reg(charger->max77693->i2c,
+		MAX77693_CHG_REG_CHG_CNFG_11, reg_data);
+
+	max77693_dump_reg(charger);
+}
+
+static void check_charger_unlock_state(struct max77693_charger_data *chg_data)
+{
+	bool need_reg_init = false;
+	pr_debug("%s\n", __func__);
+
+	pr_info("%s: unlock state enable\n", __func__);
+	need_reg_init = max77693_charger_unlock(chg_data);
+	if (need_reg_init) {
+		pr_err("%s: charger locked state, reg init\n", __func__);
+		max77693_charger_initialize(chg_data);
+	}
+}
+
+static int sec_chg_get_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		union power_supply_propval *val)
+{
+	struct max77693_charger_data *charger =
+		container_of(psy, struct max77693_charger_data, psy_chg);
+	u8 reg_data;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = POWER_SUPPLY_TYPE_BATTERY;
+		if (max77693_read_reg(charger->max77693->i2c,
+			MAX77693_CHG_REG_CHG_INT_OK, &reg_data) == 0) {
+			if (reg_data & MAX77693_CHGIN_OK)
+				val->intval = POWER_SUPPLY_TYPE_MAINS;
+			else if (reg_data & MAX77693_WCIN_OK)
+				val->intval = POWER_SUPPLY_TYPE_WPC;
+		}
+		break;
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = max77693_get_charger_state(charger);
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = max77693_get_health_state(charger);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		val->intval = charger->charging_current_max;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+		val->intval = charger->charging_current;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = min(max77693_get_input_current(charger),
+			max77693_get_charge_current(charger));
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+		if (!charger->is_charging)
+		val->intval = POWER_SUPPLY_CHARGE_TYPE_NONE;
+		else if (charger->aicl_on)
+			val->intval = POWER_SUPPLY_CHARGE_TYPE_SLOW;
+		else
+			val->intval = POWER_SUPPLY_CHARGE_TYPE_FAST;
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = max77693_get_battery_present(charger);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sec_chg_set_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		const union power_supply_propval *val)
+{
+	struct max77693_charger_data *charger =
+		container_of(psy, struct max77693_charger_data, psy_chg);
+	union power_supply_propval value;
+	int set_charging_current, set_charging_current_max;
+	const int usb_charging_current = charger->pdata->charging_current[
+		POWER_SUPPLY_TYPE_USB].fast_charging_current;
+	const int wpc_charging_current = charger->pdata->charging_current[
+		POWER_SUPPLY_TYPE_WPC].input_current_limit;
+
+	/* check and unlock */
+	check_charger_unlock_state(charger);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		charger->status = val->intval;
+		break;
+	/* val->intval : type */
+	case POWER_SUPPLY_PROP_ONLINE:
+		charger->cable_type = val->intval;
+		psy_do_property("battery", get,
+				POWER_SUPPLY_PROP_HEALTH, value);
+		if (val->intval == POWER_SUPPLY_TYPE_BATTERY) {
+			charger->is_charging = false;
+			charger->aicl_on = false;
+			set_charging_current = 0;
+			set_charging_current_max = 0;
+		} else {
+			charger->is_charging = true;
+			/* decrease the charging current according to siop level */
+			set_charging_current =
+				charger->charging_current * charger->siop_level / 100;
+			if (set_charging_current > 0 &&
+					set_charging_current < usb_charging_current)
+				set_charging_current = usb_charging_current;
+			if (val->intval == POWER_SUPPLY_TYPE_WPC)
+				set_charging_current_max = wpc_charging_current;
+			else
+				set_charging_current_max =
+					charger->charging_current_max;
+		}
+
+		max77693_set_charger_state(charger, charger->is_charging);
+		/* if battery full, only disable charging  */
+		if ((charger->status == POWER_SUPPLY_STATUS_CHARGING) ||
+				(charger->status == POWER_SUPPLY_STATUS_DISCHARGING) ||
+				(value.intval == POWER_SUPPLY_HEALTH_UNSPEC_FAILURE)) {
+
+			/* current setting */
+			max77693_set_charge_current(charger,
+				set_charging_current);
+			max77693_set_input_current(charger,
+				set_charging_current_max);
+			max77693_set_topoff_current(charger,
+				charger->pdata->charging_current[
+				val->intval].full_check_current_1st,
+				charger->pdata->charging_current[
+				val->intval].full_check_current_2nd);
+		}
+		break;
+	/* val->intval : input charging current */
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		charger->charging_current_max = val->intval;
+		break;
+	/*  val->intval : charging current */
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+		charger->charging_current = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		charger->siop_level = val->intval;
+		if (charger->is_charging) {
+			/* decrease the charging current according to siop level */
+			int current_now =
+				charger->charging_current * val->intval / 100;
+			if (current_now > 0 &&
+					current_now < usb_charging_current)
+				current_now = usb_charging_current;
+			max77693_set_charge_current(charger, current_now);
+		}
+		break;
+	case POWER_SUPPLY_PROP_POWER_NOW:
+		max77693_set_charge_current(charger,
+				val->intval);
+		max77693_set_input_current(charger,
+				val->intval);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void sec_chg_isr_work(struct work_struct *work)
+{
+	struct max77693_charger_data *charger =
+		container_of(work, struct max77693_charger_data, isr_work.work);
+
+	union power_supply_propval val;
+
+	if (charger->pdata->full_check_type ==
+			SEC_BATTERY_FULLCHARGED_CHGINT) {
+
+		val.intval = max77693_get_charger_state(charger);
+
+		switch (val.intval) {
+		case POWER_SUPPLY_STATUS_DISCHARGING:
+			pr_err("%s: Interrupted but Discharging\n", __func__);
+			break;
+
+		case POWER_SUPPLY_STATUS_NOT_CHARGING:
+			pr_err("%s: Interrupted but NOT Charging\n", __func__);
+			break;
+
+		case POWER_SUPPLY_STATUS_FULL:
+			pr_info("%s: Interrupted by Full\n", __func__);
+			psy_do_property("battery", set,
+				POWER_SUPPLY_PROP_STATUS, val);
+			break;
+
+		case POWER_SUPPLY_STATUS_CHARGING:
+			pr_err("%s: Interrupted but Charging\n", __func__);
+			break;
+
+		case POWER_SUPPLY_STATUS_UNKNOWN:
+		default:
+			pr_err("%s: Invalid Charger Status\n", __func__);
+			break;
+		}
+	}
+
+	if (charger->pdata->ovp_uvlo_check_type ==
+			SEC_BATTERY_OVP_UVLO_CHGINT) {
+
+		val.intval = max77693_get_health_state(charger);
+
+		switch (val.intval) {
+		case POWER_SUPPLY_HEALTH_OVERHEAT:
+		case POWER_SUPPLY_HEALTH_COLD:
+			pr_err("%s: Interrupted but Hot/Cold\n", __func__);
+			break;
+
+		case POWER_SUPPLY_HEALTH_DEAD:
+			pr_err("%s: Interrupted but Dead\n", __func__);
+			break;
+
+		case POWER_SUPPLY_HEALTH_OVERVOLTAGE:
+		case POWER_SUPPLY_HEALTH_UNDERVOLTAGE:
+			pr_info("%s: Interrupted by OVP/UVLO\n", __func__);
+			psy_do_property("battery", set,
+				POWER_SUPPLY_PROP_HEALTH, val);
+			break;
+
+		case POWER_SUPPLY_HEALTH_UNSPEC_FAILURE:
+			pr_err("%s: Interrupted but Unspec\n", __func__);
+			break;
+
+		case POWER_SUPPLY_HEALTH_GOOD:
+			pr_err("%s: Interrupted but Good\n", __func__);
+			break;
+
+		case POWER_SUPPLY_HEALTH_UNKNOWN:
+		default:
+			pr_err("%s: Invalid Charger Health\n", __func__);
+			break;
+		}
+	}
+}
+
+static int max77693_debugfs_show(struct seq_file *s, void *data)
+{
+	struct max77693_charger_data *charger = s->private;
+	u8 reg;
+	u8 reg_data;
+
+	seq_printf(s, "MAX77693 CHARGER IC :\n");
+	seq_printf(s, "==================\n");
+	for (reg = 0xB0; reg <= 0xC5; reg++) {
+		max77693_read_reg(charger->max77693->i2c, reg, &reg_data);
+		seq_printf(s, "0x%02x:\t0x%02x\n", reg, reg_data);
+	}
+
+	seq_printf(s, "\n");
+
+	return 0;
+}
+
+static int max77693_debugfs_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, max77693_debugfs_show, inode->i_private);
+}
+
+static const struct file_operations max77693_debugfs_fops = {
+	.open           = max77693_debugfs_open,
+	.read           = seq_read,
+	.llseek         = seq_lseek,
+	.release        = single_release,
+};
+
+static irqreturn_t sec_chg_irq_thread(int irq, void *irq_data)
+{
+	struct max77693_charger_data *charger = irq_data;
+
+	pr_info("%s: Charger interrupt occured\n", __func__);
+
+	if ((charger->pdata->full_check_type ==
+				SEC_BATTERY_FULLCHARGED_CHGINT) ||
+			(charger->pdata->ovp_uvlo_check_type ==
+			 SEC_BATTERY_OVP_UVLO_CHGINT))
+		schedule_delayed_work(&charger->isr_work, 0);
+
+	return IRQ_HANDLED;
+}
+
+#if defined(CONFIG_WIRELESS_CHARGING)
+static irqreturn_t wpc_charger_irq(int irq, void *data)
+{
+	struct max77693_charger_data *chg_data = data;
+	int wc_w_state;
+	union power_supply_propval value;
+	pr_info("%s: irq(%d)\n", __func__, irq);
+
+	/* check and unlock */
+	check_charger_unlock_state(chg_data);
+
+	wc_w_state = 0;
+
+	wc_w_state = !gpio_get_value(chg_data->wc_w_gpio);
+	if ((chg_data->wc_w_state == 0) && (wc_w_state == 1)) {
+		value.intval = POWER_SUPPLY_TYPE_WPC<<ONLINE_TYPE_MAIN_SHIFT;
+		psy_do_property("battery", set,
+				POWER_SUPPLY_PROP_ONLINE, value);
+		pr_info("%s: wpc activated, set V_INT as PN\n",
+				__func__);
+	} else if ((chg_data->wc_w_state == 1) && (wc_w_state == 0)) {
+		value.intval =
+			POWER_SUPPLY_TYPE_BATTERY<<ONLINE_TYPE_MAIN_SHIFT;
+		psy_do_property("battery", set,
+				POWER_SUPPLY_PROP_ONLINE, value);
+		pr_info("%s: wpc deactivated, set V_INT as PD\n",
+				__func__);
+	}
+	pr_info("%s: w(%d to %d)\n", __func__,
+			chg_data->wc_w_state, wc_w_state);
+
+	chg_data->wc_w_state = wc_w_state;
+
+	return IRQ_HANDLED;
+}
+#endif
+
+static irqreturn_t max77693_bypass_irq(int irq, void *data)
+{
+	struct max77693_charger_data *chg_data = data;
+	u8 dtls_02;
+	u8 byp_dtls;
+	u8 chg_cnfg_00;
+
+	pr_info("%s: irq(%d)\n", __func__, irq);
+
+	/* check and unlock */
+	check_charger_unlock_state(chg_data);
+
+	max77693_read_reg(chg_data->max77693->i2c,
+				MAX77693_CHG_REG_CHG_DTLS_02,
+				&dtls_02);
+
+	byp_dtls = ((dtls_02 & MAX77693_BYP_DTLS) >>
+				MAX77693_BYP_DTLS_SHIFT);
+	pr_info("%s: BYP_DTLS(0x%02x)\n", __func__, byp_dtls);
+
+	if (byp_dtls & 0x1) {
+		pr_info("%s: bypass overcurrent limit\n", __func__);
+#ifdef CONFIG_USB_HOST_NOTIFY
+		/* max77693_muic_host_notify_cb(0); */
+#endif
+		/* disable the register values just related to OTG and
+		   keep the values about the charging */
+		max77693_read_reg(chg_data->max77693->i2c,
+			MAX77693_CHG_REG_CHG_CNFG_00, &chg_cnfg_00);
+		chg_cnfg_00 &= ~(CHG_CNFG_00_OTG_MASK
+				| CHG_CNFG_00_BOOST_MASK
+				| CHG_CNFG_00_DIS_MUIC_CTRL_MASK);
+		max77693_write_reg(chg_data->max77693->i2c,
+					MAX77693_CHG_REG_CHG_CNFG_00,
+					chg_cnfg_00);
+	}
+	if (byp_dtls & 0x8)
+		reduce_input_current(chg_data, 100);
+
+	return IRQ_HANDLED;
+}
+
+static void max77693_chgin_isr_work(struct work_struct *work)
+{
+	struct max77693_charger_data *charger = container_of(work,
+				struct max77693_charger_data, chgin_work);
+	u8 chgin_dtls;
+	u8 prev_chgin_dtls = 0xff;
+	int battery_health;
+	union power_supply_propval value;
+	int stable_count = 0;
+
+	disable_irq(charger->irq_chgin);
+
+	while (1) {
+		psy_do_property("battery", get,
+				POWER_SUPPLY_PROP_HEALTH, value);
+		battery_health = value.intval;
+
+		max77693_read_reg(charger->max77693->i2c,
+				MAX77693_CHG_REG_CHG_DTLS_00,
+				&chgin_dtls);
+		chgin_dtls = ((chgin_dtls & MAX77693_CHGIN_DTLS) >>
+				MAX77693_CHGIN_DTLS_SHIFT);
+		if (prev_chgin_dtls == chgin_dtls)
+			stable_count++;
+		else
+			stable_count = 0;
+		if (stable_count > 10) {
+			pr_info("%s: irq(%d), chgin(0x%x), prev 0x%x\n",
+					__func__, charger->irq_chgin,
+					chgin_dtls, prev_chgin_dtls);
+			break;
+		}
+
+		if (charger->is_charging) {
+			if ((chgin_dtls == 0x02) && \
+				(battery_health == POWER_SUPPLY_HEALTH_GOOD)) {
+				pr_info("%s: charger is over voltage\n",
+						__func__);
+				value.intval = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+				psy_do_property("battery", set,
+					POWER_SUPPLY_PROP_HEALTH, value);
+			} else if (battery_health == \
+					POWER_SUPPLY_HEALTH_OVERVOLTAGE) {
+				pr_info("%s: charger is good\n", __func__);
+				value.intval = POWER_SUPPLY_HEALTH_GOOD;
+				psy_do_property("battery", set,
+					POWER_SUPPLY_PROP_HEALTH, value);
+			}
+			if ((chgin_dtls == 0x0) || (chgin_dtls == 0x01))
+				reduce_input_current(charger, 20);
+		}
+		prev_chgin_dtls = chgin_dtls;
+		msleep(100);
+	}
+	enable_irq(charger->irq_chgin);
+}
+
+static irqreturn_t max77693_chgin_irq(int irq, void *data)
+{
+	struct max77693_charger_data *charger = data;
+	queue_work(charger->wqueue, &charger->chgin_work);
+
+	return IRQ_HANDLED;
+}
+
+static __devinit int max77693_charger_probe(struct platform_device *pdev)
+{
+	struct max77693_dev *iodev = dev_get_drvdata(pdev->dev.parent);
+	struct max77693_platform_data *pdata = dev_get_platdata(iodev->dev);
+	struct max77693_charger_data *charger;
+	int ret = 0;
+
+	pr_info("%s: max77693 Charger driver probe\n", __func__);
+
+	charger = kzalloc(sizeof(*charger), GFP_KERNEL);
+	if (!charger)
+		return -ENOMEM;
+
+	charger->max77693 = iodev;
+	charger->pdata = pdata->charger_data;
+	charger->aicl_on = false;
+	charger->siop_level = 100;
+
+	platform_set_drvdata(pdev, charger);
+
+	charger->psy_chg.name           = "sec-charger";
+	charger->psy_chg.type           = POWER_SUPPLY_TYPE_UNKNOWN;
+	charger->psy_chg.get_property   = sec_chg_get_property;
+	charger->psy_chg.set_property   = sec_chg_set_property;
+	charger->psy_chg.properties     = sec_charger_props;
+	charger->psy_chg.num_properties = ARRAY_SIZE(sec_charger_props);
+
+	mutex_init(&charger->ops_lock);
+
+	if (charger->pdata->chg_gpio_init) {
+		if (!charger->pdata->chg_gpio_init()) {
+			pr_err("%s: Failed to Initialize GPIO\n", __func__);
+			goto err_free;
+		}
+	}
+
+	max77693_charger_initialize(charger);
+
+	ret = power_supply_register(&pdev->dev, &charger->psy_chg);
+	if (ret) {
+		pr_err("%s: Failed to Register psy_chg\n", __func__);
+		goto err_free;
+	}
+
+	if (charger->pdata->chg_irq) {
+		INIT_DELAYED_WORK_DEFERRABLE(
+				&charger->isr_work, sec_chg_isr_work);
+		ret = request_threaded_irq(charger->pdata->chg_irq,
+				NULL, sec_chg_irq_thread,
+				charger->pdata->chg_irq_attr,
+				"charger-irq", charger);
+		if (ret) {
+			pr_err("%s: Failed to Reqeust IRQ\n", __func__);
+			goto err_irq;
+		}
+	}
+
+#if defined(CONFIG_WIRELESS_CHARGING)
+	charger->wc_w_gpio = pdata->wc_irq_gpio;
+	if (charger->wc_w_gpio) {
+		charger->wc_w_irq = gpio_to_irq(charger->wc_w_gpio);
+		ret = gpio_request(charger->wc_w_gpio, "wpc_charger-irq");
+		if (ret < 0) {
+			pr_err("%s: failed requesting gpio %d\n", __func__,
+				charger->wc_w_gpio);
+			goto err_wc_irq;
+		}
+		ret = request_threaded_irq(charger->wc_w_irq,
+				NULL, wpc_charger_irq,
+				IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING |
+				IRQF_ONESHOT,
+				"wpc-int", charger);
+		if (ret) {
+			pr_err("%s: Failed to Reqeust IRQ\n", __func__);
+			goto err_wc_irq;
+		}
+		enable_irq_wake(charger->wc_w_irq);
+		charger->wc_w_state = !gpio_get_value(charger->wc_w_gpio);
+	}
+#endif
+
+	charger->wqueue =
+	    create_singlethread_workqueue(dev_name(&pdev->dev));
+	INIT_WORK(&charger->chgin_work, max77693_chgin_isr_work);
+	if (!charger->wqueue) {
+		pr_err("%s: Fail to Create Workqueue\n", __func__);
+		goto err_workqueue;
+	}
+
+	charger->irq_chgin = pdata->irq_base + MAX77693_CHG_IRQ_CHGIN_I;
+	ret = request_threaded_irq(charger->irq_chgin, NULL,
+			max77693_chgin_irq, 0, "chgin-irq", charger);
+	if (ret < 0) {
+		pr_err("%s: fail to request chgin IRQ: %d: %d\n",
+				__func__, charger->irq_chgin, ret);
+		goto err_chgin_irq;
+	}
+
+	charger->irq_bypass = pdata->irq_base + MAX77693_CHG_IRQ_BYP_I;
+	ret = request_threaded_irq(charger->irq_bypass, NULL,
+			max77693_bypass_irq, 0, "bypass-irq", charger);
+	if (ret < 0)
+		pr_err("%s: fail to request bypass IRQ: %d: %d\n",
+				__func__, charger->irq_bypass, ret);
+
+	max77693_dentry = debugfs_create_file("max77693-regs",
+			S_IRUSR, NULL, charger, &max77693_debugfs_fops);
+	return 0;
+
+err_chgin_irq:
+	destroy_workqueue(charger->wqueue);
+err_workqueue:
+#if defined(CONFIG_WIRELESS_CHARGING)
+	if (charger->wc_w_irq)
+		free_irq(charger->wc_w_irq, NULL);
+err_wc_irq:
+#endif
+	if (charger->pdata->chg_irq)
+		free_irq(charger->pdata->chg_irq, NULL);
+err_irq:
+	power_supply_unregister(&charger->psy_chg);
+err_free:
+	kfree(charger);
+
+	return ret;
+
+}
+
+static int __devexit max77693_charger_remove(struct platform_device *pdev)
+{
+	struct max77693_charger_data *charger =
+				platform_get_drvdata(pdev);
+
+	if (!IS_ERR_OR_NULL(max77693_dentry))
+		debugfs_remove(max77693_dentry);
+
+	destroy_workqueue(charger->wqueue);
+#if defined(CONFIG_WIRELESS_CHARGING)
+	if (charger->wc_w_irq)
+		free_irq(charger->wc_w_irq, NULL);
+#endif
+	if (charger->pdata->chg_irq)
+		free_irq(charger->pdata->chg_irq, NULL);
+
+	power_supply_unregister(&charger->psy_chg);
+	kfree(charger);
+
+	return 0;
+}
+
+#if defined CONFIG_PM
+static int max77693_charger_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int max77693_charger_resume(struct device *dev)
+{
+	return 0;
+}
+#else
+#define max77693_charger_suspend NULL
+#define max77693_charger_resume NULL
+#endif
+
+static SIMPLE_DEV_PM_OPS(max77693_charger_pm_ops, max77693_charger_suspend,
+		max77693_charger_resume);
+
+void max77693_charger_shutdown(struct device *dev)
+{
+	struct max77693_charger_data *charger =
+				dev_get_drvdata(dev);
+	u8 reg_data;
+
+	if (!charger->max77693->i2c) {
+		pr_err("%s: no max77693 i2c client\n", __func__);
+		return;
+	}
+	reg_data = 0x04;
+	max77693_write_reg(charger->max77693->i2c,
+		MAX77693_CHG_REG_CHG_CNFG_00, reg_data);
+	reg_data = 0x19;
+	max77693_write_reg(charger->max77693->i2c,
+		MAX77693_CHG_REG_CHG_CNFG_09, reg_data);
+	reg_data = 0x19;
+	max77693_write_reg(charger->max77693->i2c,
+		MAX77693_CHG_REG_CHG_CNFG_10, reg_data);
+	pr_info("func:%s \n", __func__);
+}
+
+static struct platform_driver max77693_charger_driver = {
+	.driver = {
+		.name = "max77693-charger",
+		.owner = THIS_MODULE,
+		.pm = &max77693_charger_pm_ops,
+		.shutdown = max77693_charger_shutdown,
+	},
+	.probe = max77693_charger_probe,
+	.remove = __devexit_p(max77693_charger_remove),
+};
+
+static int __init max77693_charger_init(void)
+{
+	pr_info("func:%s\n", __func__);
+	return platform_driver_register(&max77693_charger_driver);
+}
+module_init(max77693_charger_init);
+
+static void __exit max77693_charger_exit(void)
+{
+	platform_driver_register(&max77693_charger_driver);
+}
+
+module_exit(max77693_charger_exit);
+
+MODULE_DESCRIPTION("max77693 charger driver");
+MODULE_AUTHOR("Samsung Electronics");
+MODULE_LICENSE("GPL");
+
diff -Naur linux-3.18.14/drivers/battery/max77804_charger.c samsung/drivers/battery/max77804_charger.c
--- linux-3.18.14/drivers/battery/max77804_charger.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery/max77804_charger.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,1876 @@
+/*
+ *  max77804_charger.c
+ *  Samsung max77804 Charger Driver
+ *
+ *  Copyright (C) 2012 Samsung Electronics
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/mfd/max77804.h>
+#include <linux/mfd/max77804-private.h>
+#ifdef CONFIG_USB_HOST_NOTIFY
+#include <linux/usb_notify.h>
+#endif
+
+#define ENABLE 1
+#define DISABLE 0
+
+#define RECOVERY_DELAY		3000
+#define RECOVERY_CNT		5
+#define REDUCE_CURRENT_STEP	100
+#define MINIMUM_INPUT_CURRENT	300
+
+#define SIOP_INPUT_LIMIT_CURRENT 1200
+#define SIOP_CHARGING_LIMIT_CURRENT 1000
+#define SIOP_WIRELESS_INPUT_LIMIT_CURRENT 620
+#define SIOP_WIRELESS_CHARGING_LIMIT_CURRENT 680
+#define SLOW_CHARGING_CURRENT_STANDARD 400
+
+struct max77804_charger_data {
+	struct max77804_dev	*max77804;
+
+	struct power_supply	psy_chg;
+
+	struct workqueue_struct *wqueue;
+	struct work_struct	chgin_work;
+	struct delayed_work	isr_work;
+	struct delayed_work	recovery_work;	/*  softreg recovery work */
+	struct delayed_work	wpc_work;	/*  wpc detect work */
+	struct delayed_work	chgin_init_work;	/*  chgin init work */
+
+	/* mutex */
+	struct mutex irq_lock;
+	struct mutex ops_lock;
+
+	/* wakelock */
+	struct wake_lock recovery_wake_lock;
+	struct wake_lock wpc_wake_lock;
+	struct wake_lock chgin_wake_lock;
+
+	unsigned int	is_charging;
+	unsigned int	charging_type;
+	unsigned int	battery_state;
+	unsigned int	battery_present;
+	unsigned int	cable_type;
+	unsigned int	charging_current_max;
+	unsigned int	charging_current;
+	unsigned int	input_current_limit;
+	unsigned int	vbus_state;
+	int		aicl_on;
+	int		status;
+	int		siop_level;
+	int uvlo_attach_flag;
+	int uvlo_attach_cable_type;
+
+	int		irq_bypass;
+#if defined(CONFIG_CHARGER_MAX77804)
+	int		irq_batp;
+#else
+	int		irq_therm;
+#endif
+	int		irq_battery;
+	int		irq_chg;
+#if defined(CONFIG_CHARGER_MAX77804)
+	int		irq_wcin;
+#endif
+	int		irq_chgin;
+
+	/* software regulation */
+	bool		soft_reg_state;
+	int		soft_reg_current;
+
+	/* unsufficient power */
+	bool		reg_loop_deted;
+
+	/* wireless charge, w(wpc), v(vbus) */
+	int		wc_w_gpio;
+	int		wc_w_irq;
+	int		wc_w_state;
+	int		wc_v_gpio;
+	int		wc_v_irq;
+	int		wc_v_state;
+	bool		wc_pwr_det;
+	int		soft_reg_recovery_cnt;
+
+	int pmic_ver;
+	int input_curr_limit_step;
+	int wpc_input_curr_limit_step;
+	int charging_curr_step;
+
+	sec_battery_platform_data_t	*pdata;
+};
+
+static enum power_supply_property sec_charger_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_CHARGE_TYPE,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_CURRENT_MAX,
+	POWER_SUPPLY_PROP_CURRENT_AVG,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
+	POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL,
+#ifdef WPC_CHECK_CVPRM_FEATURE
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+#endif
+};
+
+static void max77804_charger_initialize(struct max77804_charger_data *charger);
+static int max77804_get_vbus_state(struct max77804_charger_data *charger);
+static int max77804_get_charger_state(struct max77804_charger_data *charger);
+
+#if 0
+static void max77804_dump_reg(struct max77804_charger_data *charger)
+{
+	u8 reg_data;
+	u32 reg_addr;
+	pr_info("%s\n", __func__);
+
+	for (reg_addr = 0xB0; reg_addr <= 0xC5; reg_addr++) {
+		max77804_read_reg(charger->max77804->i2c, reg_addr, &reg_data);
+		pr_info("max77804: c: 0x%02x(0x%02x)\n", reg_addr, reg_data);
+	}
+}
+#endif
+
+static bool max77804_charger_unlock(struct max77804_charger_data *chg_data)
+{
+	struct i2c_client *i2c = chg_data->max77804->i2c;
+	u8 reg_data;
+	u8 chgprot;
+	int retry_cnt = 0;
+	bool need_init = false;
+
+	do {
+		max77804_read_reg(i2c, MAX77804_CHG_REG_CHG_CNFG_06, &reg_data);
+		chgprot = ((reg_data & 0x0C) >> 2);
+		if (chgprot != 0x03) {
+			pr_err("%s: unlock err, chgprot(0x%x), retry(%d)\n",
+					__func__, chgprot, retry_cnt);
+			max77804_write_reg(i2c, MAX77804_CHG_REG_CHG_CNFG_06,
+				(0x03 << 2));
+			need_init = true;
+			msleep(20);
+		} else {
+			pr_debug("%s: unlock success, chgprot(0x%x)\n",
+				__func__, chgprot);
+			break;
+		}
+	} while ((chgprot != 0x03) && (++retry_cnt < 10));
+
+	return need_init;
+}
+
+static void check_charger_unlock_state(struct max77804_charger_data *chg_data)
+{
+	bool need_reg_init;
+	pr_debug("%s\n", __func__);
+
+	need_reg_init = max77804_charger_unlock(chg_data);
+	if (need_reg_init) {
+		pr_err("%s: charger locked state, reg init\n", __func__);
+		max77804_charger_initialize(chg_data);
+	}
+}
+
+static int max77804_get_battery_present(struct max77804_charger_data *charger)
+{
+	u8 reg_data;
+
+	if (max77804_read_reg(charger->max77804->i2c,
+			MAX77804_CHG_REG_CHG_INT_OK, &reg_data) < 0) {
+		/* Eventhough there is an error,
+		   don't do power-off */
+		return 1;
+	}
+
+	pr_debug("%s: CHG_INT_OK(0x%02x)\n", __func__, reg_data);
+
+	reg_data = ((reg_data & MAX77804_DETBAT) >> MAX77804_DETBAT_SHIFT);
+
+	return reg_data;
+}
+
+static void max77804_set_charger_state(struct max77804_charger_data *charger,
+		int enable)
+{
+	u8 reg_data;
+
+	max77804_read_reg(charger->max77804->i2c,
+			MAX77804_CHG_REG_CHG_CNFG_00, &reg_data);
+
+	if (enable)
+		reg_data |= MAX77804_MODE_CHGR;
+	else
+		reg_data &= ~MAX77804_MODE_CHGR;
+
+	pr_debug("%s: CHG_CNFG_00(0x%02x)\n", __func__, reg_data);
+	max77804_write_reg(charger->max77804->i2c,
+			MAX77804_CHG_REG_CHG_CNFG_00, reg_data);
+}
+
+static void max77804_set_buck(struct max77804_charger_data *charger,
+		int enable)
+{
+	u8 reg_data;
+
+	max77804_read_reg(charger->max77804->i2c,
+		MAX77804_CHG_REG_CHG_CNFG_00, &reg_data);
+
+	if (enable)
+		reg_data |= MAX77804_MODE_BUCK;
+	else
+		reg_data &= ~MAX77804_MODE_BUCK;
+
+	pr_debug("%s: CHG_CNFG_00(0x%02x)\n", __func__, reg_data);
+	max77804_write_reg(charger->max77804->i2c,
+		MAX77804_CHG_REG_CHG_CNFG_00, reg_data);
+}
+
+#ifdef WPC_CHECK_CVPRM_FEATURE
+static void max77804_check_cvprm(struct max77804_charger_data *charger, u8 data)
+{
+	u8 reg_data;
+
+	max77804_read_reg(charger->max77804->i2c,
+			MAX77804_CHG_REG_CHG_CNFG_04, &reg_data);
+	if ((reg_data & 0x1f) != data) {
+		reg_data &= ~(0x1f << 0);
+		reg_data |= (data << 0);
+		max77804_write_reg(charger->max77804->i2c,
+				MAX77804_CHG_REG_CHG_CNFG_04, reg_data);
+	}
+}
+
+static int max77804_get_charge_votage(struct max77804_charger_data *charger)
+{
+	u8 reg_data;
+	int charge_voltage;
+
+	max77804_read_reg(charger->max77804->i2c,
+			MAX77804_CHG_REG_CHG_CNFG_04, &reg_data);
+
+	reg_data &= 0x1f;
+	if (reg_data == 0x1c) {
+		charge_voltage = 4340;
+	} else {
+		if (reg_data > 0x1c) {
+			reg_data -= 1;
+		}
+		charge_voltage = (reg_data * 25) + 3650;
+	}
+
+	return charge_voltage;
+}
+#endif
+
+#if 0
+static void max77804_check_slow_charging(struct max77804_charger_data *charger, int set_current_reg)
+{
+	/* under 500mA, slow rate */
+	if (set_current_reg <= (SLOW_CHARGING_CURRENT_STANDARD / charger->input_curr_limit_step) &&
+			(charger->cable_type != POWER_SUPPLY_TYPE_BATTERY)) {
+		charger->aicl_on = true;
+		pr_info("%s: slow charging on : set_current_reg(0x%02x), cable type(%d)\n", __func__, set_current_reg, charger->cable_type);
+	}
+	else
+		charger->aicl_on = false;
+}
+
+static void max77804_change_charge_path(struct max77804_charger_data *charger,
+		int path)
+{
+	u8 cnfg12, ctrl3;
+
+	if (path == POWER_SUPPLY_TYPE_WIRELESS) {
+		cnfg12 = (0 << CHG_CNFG_12_CHGINSEL_SHIFT);
+		ctrl3 = (1 << CTRL3_JIGSET_SHIFT);
+	} else {
+		cnfg12 = (1 << CHG_CNFG_12_CHGINSEL_SHIFT);
+		ctrl3 = (0 << CTRL3_JIGSET_SHIFT);
+	}
+
+	if (charger->pmic_ver == 0x04)
+		max77804_update_reg(charger->max77804->muic, MAX77804_MUIC_REG_CTRL3,
+				ctrl3,	CTRL3_JIGSET_MASK);
+	max77804_update_reg(charger->max77804->i2c, MAX77804_CHG_REG_CHG_CNFG_12,
+			cnfg12,	CHG_CNFG_12_CHGINSEL_MASK);
+}
+#endif
+
+static void max77804_set_input_current(struct max77804_charger_data *charger,
+		int cur)
+{
+	int set_current_reg, now_current_reg;
+	int vbus_state, curr_step, delay;
+	u8 set_reg, reg_data;
+	int chg_state;
+
+	mutex_lock(&charger->ops_lock);
+	max77804_read_reg(charger->max77804->i2c,
+		MAX77804_CHG_REG_CHG_INT_MASK, &reg_data);
+	reg_data |= (0x1 << 6);
+	max77804_write_reg(charger->max77804->i2c,
+		MAX77804_CHG_REG_CHG_INT_MASK, reg_data);
+
+	if (charger->cable_type == POWER_SUPPLY_TYPE_WIRELESS) {
+		set_reg = MAX77804_CHG_REG_CHG_CNFG_10;
+		charger->input_curr_limit_step = 20;
+	} else {
+		set_reg = MAX77804_CHG_REG_CHG_CNFG_09;
+		charger->input_curr_limit_step = 25;
+	}
+
+	if (cur <= 0) {
+		max77804_write_reg(charger->max77804->i2c,
+			set_reg, 0);
+		max77804_set_buck(charger, DISABLE);
+		goto exit;
+	} else
+		max77804_set_buck(charger, ENABLE);
+
+	set_current_reg = cur / charger->input_curr_limit_step;
+	if (charger->cable_type == POWER_SUPPLY_TYPE_BATTERY)
+		goto set_input_current;
+
+	max77804_read_reg(charger->max77804->i2c,
+		set_reg, &reg_data);
+	if (reg_data == set_current_reg) {
+		/* check uvlo  */
+		while((set_current_reg > (MINIMUM_INPUT_CURRENT / charger->input_curr_limit_step)) && (set_current_reg < 255)) {
+			vbus_state = max77804_get_vbus_state(charger);
+			if (((vbus_state == 0x00) || (vbus_state == 0x01)) &&
+				(charger->cable_type != POWER_SUPPLY_TYPE_WIRELESS)) {
+				/* UVLO */
+				set_current_reg -= 5;
+				if (set_current_reg < (MINIMUM_INPUT_CURRENT / charger->input_curr_limit_step))
+					set_current_reg = (MINIMUM_INPUT_CURRENT / charger->input_curr_limit_step);
+				max77804_write_reg(charger->max77804->i2c,
+						set_reg, set_current_reg);
+				pr_info("%s: set_current_reg(0x%02x)\n", __func__, set_current_reg);
+				chg_state = max77804_get_charger_state(charger);
+				if ((chg_state != POWER_SUPPLY_STATUS_CHARGING) &&
+						(chg_state != POWER_SUPPLY_STATUS_FULL))
+					break;
+				msleep(50);
+			} else
+				break;
+		}
+		goto exit;
+	}
+
+	if (reg_data == 0) {
+		now_current_reg = SOFT_CHG_START_CURR / charger->input_curr_limit_step;
+		max77804_write_reg(charger->max77804->i2c,
+			set_reg, now_current_reg);
+		msleep(SOFT_CHG_START_DUR);
+	} else
+		now_current_reg = reg_data;
+
+	if (cur <= 1000) {
+		curr_step = 1;
+		delay = 50;
+	} else {
+		curr_step = SOFT_CHG_CURR_STEP / charger->input_curr_limit_step;
+		delay = SOFT_CHG_STEP_DUR;
+	}
+	now_current_reg += (curr_step);
+
+	while (now_current_reg < set_current_reg &&
+			charger->cable_type != POWER_SUPPLY_TYPE_BATTERY)
+	{
+		now_current_reg = min(now_current_reg, set_current_reg);
+		max77804_write_reg(charger->max77804->i2c,
+			set_reg, now_current_reg);
+		msleep(delay);
+
+		vbus_state = max77804_get_vbus_state(charger);
+		if (((vbus_state == 0x00) || (vbus_state == 0x01)) &&
+				(charger->cable_type != POWER_SUPPLY_TYPE_WIRELESS)) {
+			/* UVLO */
+			if (now_current_reg > (curr_step * 3))
+				now_current_reg -= (curr_step * 3);
+			/* current limit 300mA */
+			if (now_current_reg < (MINIMUM_INPUT_CURRENT / charger->input_curr_limit_step))
+				now_current_reg = (MINIMUM_INPUT_CURRENT / charger->input_curr_limit_step);
+			curr_step /= 2;
+			max77804_write_reg(charger->max77804->i2c,
+					set_reg, now_current_reg);
+			pr_info("%s: now_current_reg(0x%02x)\n", __func__, now_current_reg);
+			chg_state = max77804_get_charger_state(charger);
+			if ((chg_state != POWER_SUPPLY_STATUS_CHARGING) &&
+					(chg_state != POWER_SUPPLY_STATUS_FULL))
+				goto exit;
+			if (curr_step < 2)
+				goto exit;
+			msleep(50);
+		} else
+			now_current_reg += (curr_step);
+	}
+
+set_input_current:
+	pr_info("%s: reg_data(0x%02x), input(%d)\n",
+		__func__, set_current_reg, cur);
+	max77804_write_reg(charger->max77804->i2c,
+		set_reg, set_current_reg);
+exit:
+	max77804_read_reg(charger->max77804->i2c,
+		MAX77804_CHG_REG_CHG_INT_MASK, &reg_data);
+	reg_data &= ~(0x1 << 6);
+	max77804_write_reg(charger->max77804->i2c,
+		MAX77804_CHG_REG_CHG_INT_MASK, reg_data);
+	mutex_unlock(&charger->ops_lock);
+}
+
+static int max77804_get_input_current(struct max77804_charger_data *charger)
+{
+	u8 reg_data;
+	int get_current = 0;
+
+	if (charger->cable_type == POWER_SUPPLY_TYPE_WIRELESS) {
+		max77804_read_reg(charger->max77804->i2c,
+			MAX77804_CHG_REG_CHG_CNFG_10, &reg_data);
+		pr_info("%s: CHG_CNFG_10(0x%02x)\n", __func__, reg_data);
+		charger->input_curr_limit_step = 20;
+	} else {
+		max77804_read_reg(charger->max77804->i2c,
+			MAX77804_CHG_REG_CHG_CNFG_09, &reg_data);
+		charger->input_curr_limit_step = 25;
+		get_current = reg_data * charger->input_curr_limit_step;
+		pr_info("%s: CHG_CNFG_09(0x%02x)\n", __func__, reg_data);
+	}
+get_current = reg_data * charger->input_curr_limit_step;
+
+	pr_debug("%s: get input current: %dmA\n", __func__, get_current);
+	return get_current;
+}
+
+static void max77804_set_topoff_current(struct max77804_charger_data *charger,
+		int cur, int timeout)
+{
+	u8 reg_data;
+
+	if (cur >= 350)
+		reg_data = 0x07;
+	else if (cur >= 300)
+		reg_data = 0x06;
+	else if (cur >= 250)
+		reg_data = 0x05;
+	else if (cur >= 200)
+		reg_data = 0x04;
+	else if (cur >= 175)
+		reg_data = 0x03;
+	else if (cur >= 150)
+		reg_data = 0x02;
+	else if (cur >= 125)
+		reg_data = 0x01;
+	else
+		reg_data = 0x00;
+
+	/* the unit of timeout is second*/
+	timeout = timeout / 60;
+	reg_data |= ((timeout / 10) << 3);
+	pr_info("%s: reg_data(0x%02x), topoff(%d)\n", __func__, reg_data, cur);
+
+	max77804_write_reg(charger->max77804->i2c,
+		MAX77804_CHG_REG_CHG_CNFG_03, reg_data);
+}
+
+static void max77804_set_charge_current(struct max77804_charger_data *charger,
+		int cur)
+{
+	u8 reg_data = 0;
+
+	max77804_read_reg(charger->max77804->i2c,
+		MAX77804_CHG_REG_CHG_CNFG_02, &reg_data);
+	reg_data &= ~MAX77804_CHG_CC;
+
+	if (!cur) {
+		/* No charger */
+		max77804_write_reg(charger->max77804->i2c,
+			MAX77804_CHG_REG_CHG_CNFG_02, reg_data);
+	} else {
+		reg_data |= ((cur * 10 / charger->charging_curr_step) << 0);
+
+		max77804_write_reg(charger->max77804->i2c,
+				MAX77804_CHG_REG_CHG_CNFG_02, reg_data);
+	}
+	pr_info("%s: reg_data(0x%02x), charge(%d)\n",
+		__func__, reg_data, cur);
+}
+
+/*
+static int max77804_get_charge_current(struct max77804_charger_data *charger)
+{
+	u8 reg_data;
+	int get_current = 0;
+
+	max77804_read_reg(charger->max77804->i2c,
+		MAX77804_CHG_REG_CHG_CNFG_02, &reg_data);
+	pr_debug("%s: CHG_CNFG_02(0x%02x)\n", __func__, reg_data);
+
+	reg_data &= MAX77804_CHG_CC;
+	get_current = reg_data * charger->charging_curr_step / 10;
+
+	pr_debug("%s: get charge current: %dmA\n", __func__, get_current);
+	return get_current;
+}
+*/
+
+/* in soft regulation, current recovery operation */
+static void max77804_recovery_work(struct work_struct *work)
+{
+	struct max77804_charger_data *charger = container_of(work,
+						struct max77804_charger_data,
+						recovery_work.work);
+	u8 dtls_00, chgin_dtls;
+	u8 dtls_01, chg_dtls;
+	u8 dtls_02, byp_dtls;
+	pr_debug("%s\n", __func__);
+
+	wake_unlock(&charger->recovery_wake_lock);
+	if ((!charger->is_charging) || mutex_is_locked(&charger->ops_lock) ||
+			(charger->cable_type != POWER_SUPPLY_TYPE_MAINS))
+		return;
+	max77804_read_reg(charger->max77804->i2c,
+				MAX77804_CHG_REG_CHG_DTLS_00, &dtls_00);
+	max77804_read_reg(charger->max77804->i2c,
+				MAX77804_CHG_REG_CHG_DTLS_01, &dtls_01);
+	max77804_read_reg(charger->max77804->i2c,
+				MAX77804_CHG_REG_CHG_DTLS_02, &dtls_02);
+
+	chgin_dtls = ((dtls_00 & MAX77804_CHGIN_DTLS) >>
+				MAX77804_CHGIN_DTLS_SHIFT);
+	chg_dtls = ((dtls_01 & MAX77804_CHG_DTLS) >>
+				MAX77804_CHG_DTLS_SHIFT);
+	byp_dtls = ((dtls_02 & MAX77804_BYP_DTLS) >>
+				MAX77804_BYP_DTLS_SHIFT);
+
+	if ((charger->soft_reg_recovery_cnt < RECOVERY_CNT) && (
+		(chgin_dtls == 0x3) && (chg_dtls != 0x8) && (byp_dtls == 0x0))) {
+		pr_info("%s: try to recovery, cnt(%d)\n", __func__,
+				(charger->soft_reg_recovery_cnt + 1));
+
+		if (charger->siop_level < 100 &&
+			charger->cable_type == POWER_SUPPLY_TYPE_MAINS) {
+			pr_info("%s : LCD on status and revocer current\n", __func__);
+			max77804_set_input_current(charger,
+					SIOP_INPUT_LIMIT_CURRENT);
+		} else {
+			max77804_set_input_current(charger,
+				charger->charging_current_max);
+		}
+	} else {
+		pr_info("%s: fail to recovery, cnt(%d)\n", __func__,
+				(charger->soft_reg_recovery_cnt + 1));
+
+		pr_info("%s:  CHGIN(0x%x), CHG(0x%x), BYP(0x%x)\n",
+				__func__, chgin_dtls, chg_dtls, byp_dtls);
+
+		/* schedule softreg recovery wq */
+		if (charger->soft_reg_recovery_cnt < RECOVERY_CNT) {
+			wake_lock(&charger->recovery_wake_lock);
+			queue_delayed_work(charger->wqueue, &charger->recovery_work,
+				msecs_to_jiffies(RECOVERY_DELAY));
+		} else {
+			pr_info("%s: recovery cnt(%d) is over\n",
+				__func__, RECOVERY_CNT);
+		}
+	}
+
+	/* add recovery try count */
+	charger->soft_reg_recovery_cnt++;
+}
+
+static void reduce_input_current(struct max77804_charger_data *charger, int cur)
+{
+	u8 set_reg;
+	u8 set_value;
+	unsigned int min_input_current = 0;
+
+	if ((!charger->is_charging) || mutex_is_locked(&charger->ops_lock) ||
+		(charger->cable_type == POWER_SUPPLY_TYPE_WIRELESS))
+		return;
+	set_reg = MAX77804_CHG_REG_CHG_CNFG_09;
+	min_input_current = MINIMUM_INPUT_CURRENT;
+	charger->input_curr_limit_step = 25;
+
+	if (!max77804_read_reg(charger->max77804->i2c,
+				set_reg, &set_value)) {
+		if ((set_value <= (min_input_current / charger->input_curr_limit_step)) ||
+		    (set_value <= (cur / charger->input_curr_limit_step)))
+			return;
+		set_value -= (cur / charger->input_curr_limit_step);
+		set_value = (set_value < (min_input_current / charger->input_curr_limit_step)) ?
+			(min_input_current / charger->input_curr_limit_step) : set_value;
+		max77804_write_reg(charger->max77804->i2c,
+				set_reg, set_value);
+		pr_info("%s: set current: reg:(0x%x), val:(0x%x)\n",
+				__func__, set_reg, set_value);
+	}
+	if(charger->cable_type == POWER_SUPPLY_TYPE_MAINS) {
+		/* schedule softreg recovery wq */
+		cancel_delayed_work_sync(&charger->recovery_work);
+		wake_lock(&charger->recovery_wake_lock);
+		queue_delayed_work(charger->wqueue, &charger->recovery_work,
+				msecs_to_jiffies(RECOVERY_DELAY));
+	}
+}
+
+static int max77804_get_vbus_state(struct max77804_charger_data *charger)
+{
+	u8 reg_data;
+
+	max77804_read_reg(charger->max77804->i2c,
+		MAX77804_CHG_REG_CHG_DTLS_00, &reg_data);
+	if (charger->cable_type == POWER_SUPPLY_TYPE_WIRELESS)
+		reg_data = ((reg_data & MAX77804_WCIN_DTLS) >>
+			MAX77804_WCIN_DTLS_SHIFT);
+	else
+		reg_data = ((reg_data & MAX77804_CHGIN_DTLS) >>
+			MAX77804_CHGIN_DTLS_SHIFT);
+
+	switch (reg_data) {
+	case 0x00:
+		pr_info("%s: VBUS is invalid. CHGIN < CHGIN_UVLO\n",
+			__func__);
+		break;
+	case 0x01:
+		pr_info("%s: VBUS is invalid. CHGIN < MBAT+CHGIN2SYS" \
+			"and CHGIN > CHGIN_UVLO\n", __func__);
+		break;
+	case 0x02:
+		pr_info("%s: VBUS is invalid. CHGIN > CHGIN_OVLO",
+			__func__);
+		break;
+	case 0x03:
+		pr_info("%s: VBUS is valid. CHGIN < CHGIN_OVLO", __func__);
+		break;
+	default:
+		break;
+	}
+
+	return reg_data;
+}
+
+static int max77804_get_charger_state(struct max77804_charger_data *charger)
+{
+	int state;
+	u8 reg_data;
+
+	max77804_read_reg(charger->max77804->i2c,
+		MAX77804_CHG_REG_CHG_DTLS_01, &reg_data);
+	reg_data = ((reg_data & MAX77804_CHG_DTLS) >> MAX77804_CHG_DTLS_SHIFT);
+	pr_info("%s: CHG_DTLS : 0x%2x\n", __func__, reg_data);
+
+	switch (reg_data) {
+	case 0x0:
+	case 0x1:
+	case 0x2:
+		state = POWER_SUPPLY_STATUS_CHARGING;
+		break;
+	case 0x3:
+	case 0x4:
+		state = POWER_SUPPLY_STATUS_FULL;
+		break;
+	case 0x5:
+	case 0x6:
+	case 0x7:
+		state = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		break;
+	case 0x8:
+	case 0xA:
+	case 0xB:
+		state = POWER_SUPPLY_STATUS_DISCHARGING;
+		break;
+	default:
+		state = POWER_SUPPLY_STATUS_UNKNOWN;
+		break;
+	}
+
+	return state;
+}
+
+static int max77804_get_health_state(struct max77804_charger_data *charger)
+{
+	int state;
+	int vbus_state;
+	int retry_cnt;
+	u8 chg_dtls_00, chg_dtls, reg_data;
+	u8 chg_cnfg_00, chg_cnfg_01 ,chg_cnfg_02, chg_cnfg_04, chg_cnfg_09, chg_cnfg_12;
+
+	max77804_read_reg(charger->max77804->i2c,
+		MAX77804_CHG_REG_CHG_DTLS_01, &reg_data);
+	reg_data = ((reg_data & MAX77804_BAT_DTLS) >> MAX77804_BAT_DTLS_SHIFT);
+
+	pr_info("%s: reg_data(0x%x)\n", __func__, reg_data);
+	switch (reg_data) {
+	case 0x00:
+		pr_info("%s: No battery and the charger is suspended\n",
+			__func__);
+		state = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;
+		break;
+	case 0x01:
+		pr_info("%s: battery is okay "
+			"but its voltage is low(~VPQLB)\n", __func__);
+		state = POWER_SUPPLY_HEALTH_GOOD;
+		break;
+	case 0x02:
+		pr_info("%s: battery dead\n", __func__);
+		state = POWER_SUPPLY_HEALTH_DEAD;
+		break;
+	case 0x03:
+		state = POWER_SUPPLY_HEALTH_GOOD;
+		break;
+	case 0x04:
+		pr_info("%s: battery is okay" \
+			"but its voltage is low\n", __func__);
+		state = POWER_SUPPLY_HEALTH_GOOD;
+		break;
+	case 0x05:
+		pr_info("%s: battery ovp\n", __func__);
+		state = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+		break;
+	default:
+		pr_info("%s: battery unknown : 0x%d\n", __func__, reg_data);
+		state = POWER_SUPPLY_HEALTH_UNKNOWN;
+		break;
+	}
+
+	if (state == POWER_SUPPLY_HEALTH_GOOD) {
+		union power_supply_propval value;
+		psy_do_property("battery", get,
+				POWER_SUPPLY_PROP_HEALTH, value);
+		/* VBUS OVP state return battery OVP state */
+		vbus_state = max77804_get_vbus_state(charger);
+		/* read CHG_DTLS and detecting battery terminal error */
+		max77804_read_reg(charger->max77804->i2c,
+				MAX77804_CHG_REG_CHG_DTLS_01, &chg_dtls);
+		chg_dtls = ((chg_dtls & MAX77804_CHG_DTLS) >>
+				MAX77804_CHG_DTLS_SHIFT);
+		max77804_read_reg(charger->max77804->i2c,
+				MAX77804_CHG_REG_CHG_CNFG_00, &chg_cnfg_00);
+
+		/* print the log at the abnormal case */
+		if((charger->is_charging == 1) && (chg_dtls & 0x08)) {
+			max77804_read_reg(charger->max77804->i2c,
+				MAX77804_CHG_REG_CHG_DTLS_00, &chg_dtls_00);
+			max77804_read_reg(charger->max77804->i2c,
+				MAX77804_CHG_REG_CHG_CNFG_01, &chg_cnfg_01);
+			max77804_read_reg(charger->max77804->i2c,
+				MAX77804_CHG_REG_CHG_CNFG_02, &chg_cnfg_02);
+		max77804_read_reg(charger->max77804->i2c,
+				MAX77804_CHG_REG_CHG_CNFG_04, &chg_cnfg_04);
+			max77804_read_reg(charger->max77804->i2c,
+					MAX77804_CHG_REG_CHG_CNFG_09, &chg_cnfg_09);
+			max77804_read_reg(charger->max77804->i2c,
+					MAX77804_CHG_REG_CHG_CNFG_12, &chg_cnfg_12);
+
+			pr_info("%s: CHG_DTLS_00(0x%x), CHG_DTLS_01(0x%x), CHG_CNFG_00(0x%x)\n",
+					__func__, chg_dtls_00, chg_dtls, chg_cnfg_00);
+			pr_info("%s:  CHG_CNFG_01(0x%x), CHG_CNFG_02(0x%x), CHG_CNFG_04(0x%x)\n",
+					__func__, chg_cnfg_01, chg_cnfg_02, chg_cnfg_04);
+			pr_info("%s:  CHG_CNFG_09(0x%x), CHG_CNFG_12(0x%x)\n",
+					__func__, chg_cnfg_09, chg_cnfg_12);
+		}
+
+		pr_info("%s: vbus_state : 0x%d, chg_dtls : 0x%d\n", __func__, vbus_state, chg_dtls);
+		/*  OVP is higher priority */
+		if (vbus_state == 0x02) { /*  CHGIN_OVLO */
+			pr_info("%s: vbus ovp\n", __func__);
+			state = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+			if (charger->cable_type == POWER_SUPPLY_TYPE_WIRELESS) {
+				retry_cnt = 0;
+				do {
+					msleep(50);
+					vbus_state = max77804_get_vbus_state(charger);
+				} while((retry_cnt++ < 2) && (vbus_state == 0x02));
+				if (vbus_state == 0x02) {
+					state = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+					panic("wpc and ovp");
+				} else
+					state = POWER_SUPPLY_HEALTH_GOOD;
+			}
+		} else if (((vbus_state == 0x0) || (vbus_state == 0x01)) &&(chg_dtls & 0x08) && \
+				(chg_cnfg_00 & MAX77804_MODE_BUCK) && \
+				(chg_cnfg_00 & MAX77804_MODE_CHGR) && \
+				(charger->cable_type != POWER_SUPPLY_TYPE_WIRELESS)) {
+			pr_info("%s: vbus is under\n", __func__);
+			state = POWER_SUPPLY_HEALTH_UNDERVOLTAGE;
+		} else if((value.intval == POWER_SUPPLY_HEALTH_UNDERVOLTAGE) && \
+				!((vbus_state == 0x0) || (vbus_state == 0x01))){
+			max77804_set_input_current(charger,
+					charger->charging_current_max);
+		}
+	}
+
+	return state;
+}
+
+static int sec_chg_get_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		union power_supply_propval *val)
+{
+	struct max77804_charger_data *charger =
+		container_of(psy, struct max77804_charger_data, psy_chg);
+	u8 reg_data;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = POWER_SUPPLY_TYPE_BATTERY;
+		if (max77804_read_reg(charger->max77804->i2c,
+			MAX77804_CHG_REG_CHG_INT_OK, &reg_data) == 0) {
+			if (reg_data & MAX77804_WCIN_OK) {
+				val->intval = POWER_SUPPLY_TYPE_WIRELESS;
+				charger->wc_w_state = 1;
+			} else if (reg_data & MAX77804_CHGIN_OK) {
+				val->intval = POWER_SUPPLY_TYPE_MAINS;
+			}
+		}
+		break;
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = max77804_get_charger_state(charger);
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = max77804_get_health_state(charger);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		val->intval = charger->charging_current_max;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+		val->intval = charger->charging_current;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = max77804_get_input_current(charger);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+		if (!charger->is_charging)
+			val->intval = POWER_SUPPLY_CHARGE_TYPE_NONE;
+		else if (charger->aicl_on)
+		{
+			val->intval = POWER_SUPPLY_CHARGE_TYPE_SLOW;
+			pr_info("%s: slow-charging mode\n", __func__);
+		}
+		else
+			val->intval = POWER_SUPPLY_CHARGE_TYPE_FAST;
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = max77804_get_battery_present(charger);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+		break;
+#ifdef WPC_CHECK_CVPRM_FEATURE
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = max77804_get_charge_votage(charger);
+		break;
+#endif
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sec_chg_set_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		const union power_supply_propval *val)
+{
+	struct max77804_charger_data *charger =
+		container_of(psy, struct max77804_charger_data, psy_chg);
+	union power_supply_propval value;
+	int set_charging_current, set_charging_current_max;
+	const int usb_charging_current = charger->pdata->charging_current[
+		POWER_SUPPLY_TYPE_USB].fast_charging_current;
+	u8 chg_cnfg_00 = 0;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		charger->status = val->intval;
+		break;
+	/* val->intval : type */
+	case POWER_SUPPLY_PROP_ONLINE:
+		/* check and unlock */
+		check_charger_unlock_state(charger);
+
+		if (val->intval == POWER_SUPPLY_TYPE_POWER_SHARING) {
+			psy_do_property("ps", get,
+				POWER_SUPPLY_PROP_STATUS, value);
+			chg_cnfg_00 = CHG_CNFG_00_OTG_MASK
+				| CHG_CNFG_00_BOOST_MASK
+				| CHG_CNFG_00_DIS_MUIC_CTRL_MASK;
+
+			if (value.intval) {
+				max77804_update_reg(charger->max77804->i2c, MAX77804_CHG_REG_CHG_CNFG_00,
+					chg_cnfg_00, chg_cnfg_00);
+				pr_info("%s: ps enable\n", __func__);
+			} else {
+				max77804_update_reg(charger->max77804->i2c, MAX77804_CHG_REG_CHG_CNFG_00,
+					0, chg_cnfg_00);
+				pr_info("%s: ps disable\n", __func__);
+			}
+			break;
+		}
+
+		charger->cable_type = val->intval;
+		psy_do_property("battery", get,
+				POWER_SUPPLY_PROP_HEALTH, value);
+		if (val->intval == POWER_SUPPLY_TYPE_BATTERY) {
+			charger->is_charging = false;
+			charger->aicl_on = false;
+			charger->soft_reg_recovery_cnt = 0;
+			set_charging_current = 0;
+			set_charging_current_max =
+				charger->pdata->charging_current[
+				POWER_SUPPLY_TYPE_USB].input_current_limit;
+
+			chg_cnfg_00 &= ~(CHG_CNFG_00_CHG_MASK
+				| CHG_CNFG_00_OTG_MASK
+				| CHG_CNFG_00_BOOST_MASK
+				| CHG_CNFG_00_DIS_MUIC_CTRL_MASK);
+
+			set_charging_current_max =
+				charger->pdata->charging_current[
+					POWER_SUPPLY_TYPE_USB].input_current_limit;
+
+			max77804_update_reg(charger->max77804->i2c,
+					    MAX77804_CHG_REG_CHG_CNFG_00,
+					    chg_cnfg_00,
+					    (CHG_CNFG_00_CHG_MASK
+					     | CHG_CNFG_00_OTG_MASK
+					     | CHG_CNFG_00_BOOST_MASK
+					     | CHG_CNFG_00_DIS_MUIC_CTRL_MASK));
+		} else {
+			charger->is_charging = true;
+			charger->charging_current_max =
+					charger->pdata->charging_current
+					[charger->cable_type].input_current_limit;
+			charger->charging_current =
+					charger->pdata->charging_current
+					[charger->cable_type].fast_charging_current;
+			/* decrease the charging current according to siop level */
+			set_charging_current =
+				charger->charging_current * charger->siop_level / 100;
+			if (set_charging_current > 0 &&
+					set_charging_current < usb_charging_current)
+				set_charging_current = usb_charging_current;
+
+				set_charging_current_max =
+						charger->charging_current_max;
+#ifdef WPC_CHECK_CVPRM_FEATURE
+			if (val->intval == POWER_SUPPLY_TYPE_WIRELESS)
+				max77804_check_cvprm(charger, 0x1C);
+			else
+				max77804_check_cvprm(charger, 0x1D);
+#endif
+
+			if (charger->siop_level < 100) {
+				if (val->intval == POWER_SUPPLY_TYPE_WIRELESS) {
+					if (set_charging_current_max > SIOP_WIRELESS_INPUT_LIMIT_CURRENT) {
+						set_charging_current_max = SIOP_WIRELESS_INPUT_LIMIT_CURRENT;
+						if (set_charging_current > SIOP_WIRELESS_CHARGING_LIMIT_CURRENT)
+							set_charging_current = SIOP_WIRELESS_CHARGING_LIMIT_CURRENT;
+					}
+				} else {
+					if (set_charging_current_max > SIOP_INPUT_LIMIT_CURRENT) {
+						set_charging_current_max = SIOP_INPUT_LIMIT_CURRENT;
+						if (set_charging_current > SIOP_CHARGING_LIMIT_CURRENT)
+							set_charging_current = SIOP_CHARGING_LIMIT_CURRENT;
+					}
+				}
+			}
+		}
+		max77804_set_charger_state(charger, charger->is_charging);
+		/* if battery full, only disable charging  */
+		if ((charger->status == POWER_SUPPLY_STATUS_CHARGING) ||
+		    (charger->status == POWER_SUPPLY_STATUS_DISCHARGING) ||
+		    (charger->status == POWER_SUPPLY_STATUS_FULL) ||
+		    (value.intval == POWER_SUPPLY_HEALTH_UNSPEC_FAILURE) ||
+		    (value.intval == POWER_SUPPLY_HEALTH_OVERHEATLIMIT)) {
+			/* current setting */
+			max77804_set_charge_current(charger,
+				set_charging_current);
+			/* if battery is removed, disable input current and reenable input current
+			  *  to enable buck always */
+			if ((value.intval == POWER_SUPPLY_HEALTH_UNSPEC_FAILURE) ||
+			    (value.intval == POWER_SUPPLY_HEALTH_OVERHEATLIMIT))
+				max77804_set_input_current(charger, 0);
+			else
+				max77804_set_input_current(charger,
+					set_charging_current_max);
+			max77804_set_topoff_current(charger,
+				charger->pdata->charging_current[
+				val->intval].full_check_current_1st,
+				charger->pdata->charging_current[
+				val->intval].full_check_current_2nd);
+		}
+		break;
+	/* val->intval : input charging current */
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		charger->charging_current_max = val->intval;
+		break;
+	/*  val->intval : charging current */
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+		charger->charging_current = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		max77804_set_charge_current(charger,
+				val->intval);
+		max77804_set_input_current(charger,
+				val->intval);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+		charger->siop_level = val->intval;
+		if (charger->is_charging) {
+			/* decrease the charging current according to siop level */
+			int current_now =
+				charger->charging_current * val->intval / 100;
+
+			/* do forced set charging current */
+			if (current_now > 0 &&
+					current_now < usb_charging_current)
+				current_now = usb_charging_current;
+
+			if (charger->cable_type == POWER_SUPPLY_TYPE_MAINS) {
+				if (charger->siop_level < 100 ) {
+					set_charging_current_max = SIOP_INPUT_LIMIT_CURRENT;
+				} else {
+					set_charging_current_max =
+						charger->charging_current_max;
+				}
+
+				if (charger->siop_level < 100 &&
+						current_now > SIOP_CHARGING_LIMIT_CURRENT)
+					current_now = SIOP_CHARGING_LIMIT_CURRENT;
+				max77804_set_input_current(charger,
+					set_charging_current_max);
+			} else if (charger->cable_type == POWER_SUPPLY_TYPE_WIRELESS) {
+				if (charger->siop_level < 100 ) {
+					set_charging_current_max = SIOP_WIRELESS_INPUT_LIMIT_CURRENT;
+				} else {
+					set_charging_current_max =
+						charger->charging_current_max;
+				}
+
+				if (charger->siop_level < 100 &&
+				    current_now > SIOP_WIRELESS_CHARGING_LIMIT_CURRENT)
+					current_now = SIOP_WIRELESS_CHARGING_LIMIT_CURRENT;
+				max77804_set_input_current(charger,
+					set_charging_current_max);
+			}
+
+			max77804_set_charge_current(charger, current_now);
+
+		}
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL:
+		if (val->intval) {
+			chg_cnfg_00 &= ~(CHG_CNFG_00_CHG_MASK
+					 | CHG_CNFG_00_BUCK_MASK);
+			chg_cnfg_00 |= (CHG_CNFG_00_OTG_MASK
+					| CHG_CNFG_00_BOOST_MASK
+					| CHG_CNFG_00_DIS_MUIC_CTRL_MASK);
+			max77804_update_reg(charger->max77804->i2c,
+					    MAX77804_CHG_REG_CHG_CNFG_00,
+					    chg_cnfg_00,
+					    (CHG_CNFG_00_CHG_MASK
+					     | CHG_CNFG_00_OTG_MASK
+					     | CHG_CNFG_00_BUCK_MASK
+					     | CHG_CNFG_00_BOOST_MASK
+					     | CHG_CNFG_00_DIS_MUIC_CTRL_MASK));
+		} else {
+			chg_cnfg_00 = ~(CHG_CNFG_00_OTG_MASK
+					| CHG_CNFG_00_BOOST_MASK
+					| CHG_CNFG_00_DIS_MUIC_CTRL_MASK);
+			chg_cnfg_00 |= CHG_CNFG_00_BUCK_MASK;
+			max77804_update_reg(charger->max77804->i2c,
+					    MAX77804_CHG_REG_CHG_CNFG_00,
+					    chg_cnfg_00,
+					    (CHG_CNFG_00_OTG_MASK
+					     | CHG_CNFG_00_BUCK_MASK
+					     | CHG_CNFG_00_BOOST_MASK
+					     | CHG_CNFG_00_DIS_MUIC_CTRL_MASK));
+		}
+		break;
+#if defined(CONFIG_SAMSUNG_BATTERY_ENG_TEST)
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+	{
+		u8 ctrl3, cnfg12;
+		if(val->intval == POWER_SUPPLY_TYPE_WIRELESS) {
+			cnfg12 = (0 << CHG_CNFG_12_CHGINSEL_SHIFT);
+			ctrl3 = (1 << CTRL3_JIGSET_SHIFT);
+			if (charger->cable_type == POWER_SUPPLY_TYPE_WIRELESS) {
+				charger->charging_current_max = 650;
+				charger->charging_current = 750;
+				max77804_set_input_current(charger,
+						charger->charging_current_max);
+				max77804_set_charge_current(charger, charger->charging_current);
+			}
+		}
+		else {
+			cnfg12 = (1 << CHG_CNFG_12_CHGINSEL_SHIFT);
+			ctrl3 = (0 << CTRL3_JIGSET_SHIFT);
+		}
+
+		max77804_update_reg(charger->max77804->muic, MAX77804_MUIC_REG_CTRL3, ctrl3,
+				CTRL3_JIGSET_MASK);
+		max77804_update_reg(charger->max77804->i2c, MAX77804_CHG_REG_CHG_CNFG_12, cnfg12,
+				CHG_CNFG_12_CHGINSEL_MASK);
+
+		pr_info("%s: ctrl3 : (0x%02x)\n", __func__, ctrl3);
+		pr_info("%s: set CNFG_12: 0x%x\n", __func__, cnfg12);
+		break;
+	}
+#endif
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static u8 max77804_get_float_voltage_data(
+					int float_voltage)
+{
+	u8 data = 0x16;
+
+	if (float_voltage >= 4400)
+		data = 0x1f;
+	else if (float_voltage >= 4375)
+		data = 0x1e;
+	else if (float_voltage >= 4350)
+		data = 0x1d;
+	else if (float_voltage >= 4340)
+		data = 0x1c;
+	else
+		data = (float_voltage - 3650) / 25;
+	return data;
+}
+
+static void max77804_charger_initialize(struct max77804_charger_data *charger)
+{
+	u8 reg_data;
+	pr_debug("%s\n", __func__);
+
+	/* unmasked: CHGIN_I, WCIN_I, BATP_I, BYP_I	*/
+	max77804_write_reg(charger->max77804->i2c,
+		MAX77804_CHG_REG_CHG_INT_MASK, 0x9a);
+
+	/* unlock charger setting protect */
+	reg_data = (0x03 << 2);
+	max77804_write_reg(charger->max77804->i2c,
+		MAX77804_CHG_REG_CHG_CNFG_06, reg_data);
+
+	/*
+	 * fast charge timer disable
+	 * restart threshold disable
+	 * pre-qual charge enable(default)
+	 */
+	reg_data = (0x0 << 0) | (0x03 << 4);
+	max77804_write_reg(charger->max77804->i2c,
+		MAX77804_CHG_REG_CHG_CNFG_01, reg_data);
+
+	/*
+	 * charge current 466mA(default)
+	 * otg current limit 900mA
+	 */
+	max77804_read_reg(charger->max77804->i2c,
+			MAX77804_CHG_REG_CHG_CNFG_02, &reg_data);
+	reg_data |= (1 << 7);
+	max77804_write_reg(charger->max77804->i2c,
+		MAX77804_CHG_REG_CHG_CNFG_02, reg_data);
+
+	/*
+	 * top off current 100mA
+	 * top off timer 40min
+	 */
+	reg_data = (0x04 << 3);
+	max77804_write_reg(charger->max77804->i2c,
+		MAX77804_CHG_REG_CHG_CNFG_03, reg_data);
+
+	/*
+	 * cv voltage 4.2V or 4.35V
+	 * MINVSYS 3.6V(default)
+	 */
+	reg_data = max77804_get_float_voltage_data(charger->pdata->chg_float_voltage);
+	max77804_update_reg(charger->max77804->i2c, MAX77804_CHG_REG_CHG_CNFG_04,
+			(reg_data << CHG_CNFG_04_CHG_CV_PRM_SHIFT),
+			CHG_CNFG_04_CHG_CV_PRM_MASK);
+	max77804_read_reg(charger->max77804->i2c,
+			MAX77804_CHG_REG_CHG_CNFG_04, &reg_data);
+	pr_info("%s: battery cv voltage 0x%x\n", __func__, reg_data);
+}
+
+static void sec_chg_isr_work(struct work_struct *work)
+{
+	struct max77804_charger_data *charger =
+		container_of(work, struct max77804_charger_data, isr_work.work);
+
+	union power_supply_propval val;
+
+	if (charger->pdata->full_check_type ==
+			SEC_BATTERY_FULLCHARGED_CHGINT) {
+
+		val.intval = max77804_get_charger_state(charger);
+
+		switch (val.intval) {
+		case POWER_SUPPLY_STATUS_DISCHARGING:
+			pr_err("%s: Interrupted but Discharging\n", __func__);
+			break;
+
+		case POWER_SUPPLY_STATUS_NOT_CHARGING:
+			pr_err("%s: Interrupted but NOT Charging\n", __func__);
+			break;
+
+		case POWER_SUPPLY_STATUS_FULL:
+			pr_info("%s: Interrupted by Full\n", __func__);
+			psy_do_property("battery", set,
+				POWER_SUPPLY_PROP_STATUS, val);
+			break;
+
+		case POWER_SUPPLY_STATUS_CHARGING:
+			pr_err("%s: Interrupted but Charging\n", __func__);
+			break;
+
+		case POWER_SUPPLY_STATUS_UNKNOWN:
+		default:
+			pr_err("%s: Invalid Charger Status\n", __func__);
+			break;
+		}
+	}
+
+	if (charger->pdata->ovp_uvlo_check_type ==
+			SEC_BATTERY_OVP_UVLO_CHGINT) {
+
+		val.intval = max77804_get_health_state(charger);
+
+		switch (val.intval) {
+		case POWER_SUPPLY_HEALTH_OVERHEAT:
+		case POWER_SUPPLY_HEALTH_COLD:
+			pr_err("%s: Interrupted but Hot/Cold\n", __func__);
+			break;
+
+		case POWER_SUPPLY_HEALTH_DEAD:
+			pr_err("%s: Interrupted but Dead\n", __func__);
+			break;
+
+		case POWER_SUPPLY_HEALTH_OVERVOLTAGE:
+		case POWER_SUPPLY_HEALTH_UNDERVOLTAGE:
+			pr_info("%s: Interrupted by OVP/UVLO\n", __func__);
+			psy_do_property("battery", set,
+				POWER_SUPPLY_PROP_HEALTH, val);
+			break;
+
+		case POWER_SUPPLY_HEALTH_UNSPEC_FAILURE:
+			pr_err("%s: Interrupted but Unspec\n", __func__);
+			break;
+
+		case POWER_SUPPLY_HEALTH_GOOD:
+			pr_err("%s: Interrupted but Good\n", __func__);
+			break;
+
+		case POWER_SUPPLY_HEALTH_UNKNOWN:
+		default:
+			pr_err("%s: Invalid Charger Health\n", __func__);
+			break;
+		}
+	}
+}
+
+static irqreturn_t sec_chg_irq_thread(int irq, void *irq_data)
+{
+	struct max77804_charger_data *charger = irq_data;
+
+	pr_info("%s: Charger interrupt occured\n", __func__);
+
+	if ((charger->pdata->full_check_type ==
+				SEC_BATTERY_FULLCHARGED_CHGINT) ||
+			(charger->pdata->ovp_uvlo_check_type ==
+			 SEC_BATTERY_OVP_UVLO_CHGINT))
+		schedule_delayed_work(&charger->isr_work, 0);
+
+	return IRQ_HANDLED;
+}
+
+static void wpc_detect_work(struct work_struct *work)
+{
+	struct max77804_charger_data *chg_data = container_of(work,
+						struct max77804_charger_data,
+						wpc_work.work);
+	int wc_w_state;
+	int retry_cnt;
+	union power_supply_propval value;
+	u8 reg_data;
+	pr_debug("%s\n", __func__);
+
+	max77804_read_reg(chg_data->max77804->i2c,
+		MAX77804_CHG_REG_CHG_INT_MASK, &reg_data);
+	reg_data &= ~(1 << 5);
+	max77804_write_reg(chg_data->max77804->i2c,
+		MAX77804_CHG_REG_CHG_INT_MASK, reg_data);
+
+	/* check and unlock */
+	check_charger_unlock_state(chg_data);
+
+	retry_cnt = 0;
+	do {
+		max77804_read_reg(chg_data->max77804->i2c,
+				MAX77804_CHG_REG_CHG_INT_OK, &reg_data);
+		wc_w_state = (reg_data & MAX77804_WCIN_OK)
+					>> MAX77804_WCIN_OK_SHIFT;
+		msleep(50);
+	} while((retry_cnt++ < 2) && (wc_w_state == 0));
+
+	if ((chg_data->wc_w_state == 0) && (wc_w_state == 1)) {
+		value.intval = 1;
+		psy_do_property("wireless", set,
+				POWER_SUPPLY_PROP_ONLINE, value);
+		pr_info("%s: wpc activated, set V_INT as PN\n",
+				__func__);
+	} else if ((chg_data->wc_w_state == 1) && (wc_w_state == 0)) {
+		if (!chg_data->is_charging)
+			max77804_set_charger_state(chg_data, true);
+
+		retry_cnt = 0;
+		do {
+			max77804_read_reg(chg_data->max77804->i2c,
+					MAX77804_CHG_REG_CHG_DTLS_01, &reg_data);
+			reg_data = ((reg_data & MAX77804_CHG_DTLS)
+					>> MAX77804_CHG_DTLS_SHIFT);
+			msleep(50);
+		} while((retry_cnt++ < 2) && (reg_data == 0x8));
+		pr_info("%s: reg_data: 0x%x, charging: %d\n", __func__,
+			reg_data, chg_data->is_charging);
+		if (!chg_data->is_charging)
+			max77804_set_charger_state(chg_data, false);
+		if ((reg_data != 0x08)
+				&& (chg_data->cable_type == POWER_SUPPLY_TYPE_WIRELESS)) {
+			pr_info("%s: wpc uvlo, but charging\n", __func__);
+			queue_delayed_work(chg_data->wqueue, &chg_data->wpc_work,
+					msecs_to_jiffies(500));
+			return;
+		} else {
+			value.intval = 0;
+			psy_do_property("wireless", set,
+					POWER_SUPPLY_PROP_ONLINE, value);
+			pr_info("%s: wpc deactivated, set V_INT as PD\n",
+					__func__);
+		}
+	}
+	pr_info("%s: w(%d to %d)\n", __func__,
+			chg_data->wc_w_state, wc_w_state);
+
+	chg_data->wc_w_state = wc_w_state;
+
+	wake_unlock(&chg_data->wpc_wake_lock);
+}
+
+static irqreturn_t wpc_charger_irq(int irq, void *data)
+{
+	struct max77804_charger_data *chg_data = data;
+	unsigned long delay;
+	u8 reg_data;
+
+	max77804_read_reg(chg_data->max77804->i2c,
+		MAX77804_CHG_REG_CHG_INT_MASK, &reg_data);
+	reg_data |= (1 << 5);
+	max77804_write_reg(chg_data->max77804->i2c,
+		MAX77804_CHG_REG_CHG_INT_MASK, reg_data);
+
+	wake_lock(&chg_data->wpc_wake_lock);
+#ifdef CONFIG_SAMSUNG_BATTERY_FACTORY
+	delay = msecs_to_jiffies(0);
+#else
+	if (chg_data->wc_w_state)
+		delay = msecs_to_jiffies(500);
+	else
+		delay = msecs_to_jiffies(0);
+#endif
+	queue_delayed_work(chg_data->wqueue, &chg_data->wpc_work,
+			delay);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t max77804_batp_irq(int irq, void *data)
+{
+	struct max77804_charger_data *chg_data = data;
+	u8 batp_ok, bat_dtls;
+	union power_supply_propval value;
+
+	pr_info("%s: battery present interrupt occured\n", __func__);
+	max77804_read_reg(chg_data->max77804->i2c,
+			MAX77804_CHG_REG_CHG_INT_OK, &batp_ok);
+
+	max77804_read_reg(chg_data->max77804->i2c,
+			MAX77804_CHG_REG_CHG_DTLS_00, &bat_dtls);
+	pr_info("%s : CHG_INT_OK : 0x%x, CHG_DTLS_00: 0x%x\n",
+			__func__, batp_ok, bat_dtls);
+
+	batp_ok &= 0x4;
+	bat_dtls &= 0x1;
+
+	if (batp_ok == 0x0 || bat_dtls == 0x1)
+		psy_do_property("battery", set,
+				POWER_SUPPLY_PROP_PRESENT, value);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t max77804_bypass_irq(int irq, void *data)
+{
+	struct max77804_charger_data *chg_data = data;
+	u8 dtls_02;
+	u8 byp_dtls;
+	u8 chg_cnfg_00;
+	u8 vbus_state;
+#ifdef CONFIG_USB_HOST_NOTIFY
+	struct otg_notify *o_notify;
+
+	o_notify = get_otg_notify();
+#endif
+
+	pr_info("%s: irq(%d)\n", __func__, irq);
+
+	/* check and unlock */
+	check_charger_unlock_state(chg_data);
+
+	max77804_read_reg(chg_data->max77804->i2c,
+				MAX77804_CHG_REG_CHG_DTLS_02,
+				&dtls_02);
+
+	byp_dtls = ((dtls_02 & MAX77804_BYP_DTLS) >>
+				MAX77804_BYP_DTLS_SHIFT);
+	pr_info("%s: BYP_DTLS(0x%02x)\n", __func__, byp_dtls);
+	vbus_state = max77804_get_vbus_state(chg_data);
+
+	if (byp_dtls & 0x1) {
+		pr_info("%s: bypass overcurrent limit\n", __func__);
+#ifdef CONFIG_USB_HOST_NOTIFY
+		send_otg_notify(o_notify, NOTIFY_EVENT_OVERCURRENT, 0);
+#endif
+		/* disable the register values just related to OTG and
+		   keep the values about the charging */
+		max77804_read_reg(chg_data->max77804->i2c,
+			MAX77804_CHG_REG_CHG_CNFG_00, &chg_cnfg_00);
+		chg_cnfg_00 &= ~(CHG_CNFG_00_OTG_MASK
+				| CHG_CNFG_00_BOOST_MASK
+				| CHG_CNFG_00_DIS_MUIC_CTRL_MASK);
+		max77804_write_reg(chg_data->max77804->i2c,
+					MAX77804_CHG_REG_CHG_CNFG_00,
+					chg_cnfg_00);
+	}
+	if (byp_dtls & 0x8) {
+		reduce_input_current(chg_data, REDUCE_CURRENT_STEP);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static void max77804_chgin_isr_work(struct work_struct *work)
+{
+	struct max77804_charger_data *charger = container_of(work,
+				struct max77804_charger_data, chgin_work);
+	u8 chgin_dtls, chg_dtls, chg_cnfg_00, reg_data;
+	u8 prev_chgin_dtls = 0xff;
+	int battery_health;
+	union power_supply_propval value;
+	int stable_count = 0;
+
+	wake_lock(&charger->chgin_wake_lock);
+
+	max77804_read_reg(charger->max77804->i2c,
+		MAX77804_CHG_REG_CHG_INT_MASK, &reg_data);
+	reg_data |= (1 << 6);
+	max77804_write_reg(charger->max77804->i2c,
+		MAX77804_CHG_REG_CHG_INT_MASK, reg_data);
+
+	while (1) {
+		psy_do_property("battery", get,
+				POWER_SUPPLY_PROP_HEALTH, value);
+		battery_health = value.intval;
+
+		max77804_read_reg(charger->max77804->i2c,
+				MAX77804_CHG_REG_CHG_DTLS_00,
+				&chgin_dtls);
+		chgin_dtls = ((chgin_dtls & MAX77804_CHGIN_DTLS) >>
+				MAX77804_CHGIN_DTLS_SHIFT);
+		max77804_read_reg(charger->max77804->i2c,
+				MAX77804_CHG_REG_CHG_DTLS_01, &chg_dtls);
+		chg_dtls = ((chg_dtls & MAX77804_CHG_DTLS) >>
+				MAX77804_CHG_DTLS_SHIFT);
+		max77804_read_reg(charger->max77804->i2c,
+			MAX77804_CHG_REG_CHG_CNFG_00, &chg_cnfg_00);
+
+		if (prev_chgin_dtls == chgin_dtls)
+			stable_count++;
+		else
+			stable_count = 0;
+		if (stable_count > 10) {
+			pr_info("%s: irq(%d), chgin(0x%x), chg_dtls(0x%x) prev 0x%x\n",
+					__func__, charger->irq_chgin,
+					chgin_dtls, chg_dtls, prev_chgin_dtls);
+			if (charger->is_charging) {
+				if ((chgin_dtls == 0x02) && \
+					(battery_health != POWER_SUPPLY_HEALTH_OVERVOLTAGE)) {
+					pr_info("%s: charger is over voltage\n",
+							__func__);
+					value.intval = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+					psy_do_property("battery", set,
+						POWER_SUPPLY_PROP_HEALTH, value);
+				} else if (((chgin_dtls == 0x0) || (chgin_dtls == 0x01)) &&(chg_dtls & 0x08) && \
+						(chg_cnfg_00 & MAX77804_MODE_BUCK) && \
+						(chg_cnfg_00 & MAX77804_MODE_CHGR) && \
+						(battery_health != POWER_SUPPLY_HEALTH_UNDERVOLTAGE) && \
+						(charger->cable_type != POWER_SUPPLY_TYPE_WIRELESS)) {
+					pr_info("%s, vbus_state : 0x%d, chg_state : 0x%d\n", __func__, chgin_dtls, chg_dtls);
+					pr_info("%s: vBus is undervoltage\n", __func__);
+					value.intval = POWER_SUPPLY_HEALTH_UNDERVOLTAGE;
+					psy_do_property("battery", set,
+							POWER_SUPPLY_PROP_HEALTH, value);
+				} else if ((battery_health == \
+							POWER_SUPPLY_HEALTH_OVERVOLTAGE) &&
+						(chgin_dtls != 0x02)) {
+					pr_info("%s: vbus_state : 0x%d, chg_state : 0x%d\n", __func__, chgin_dtls, chg_dtls);
+					pr_info("%s: overvoltage->normal\n", __func__);
+					value.intval = POWER_SUPPLY_HEALTH_GOOD;
+					psy_do_property("battery", set,
+							POWER_SUPPLY_PROP_HEALTH, value);
+				} else if ((battery_health == \
+							POWER_SUPPLY_HEALTH_UNDERVOLTAGE) &&
+						!((chgin_dtls == 0x0) || (chgin_dtls == 0x01))){
+					pr_info("%s: vbus_state : 0x%d, chg_state : 0x%d\n", __func__, chgin_dtls, chg_dtls);
+					pr_info("%s: undervoltage->normal\n", __func__);
+					value.intval = POWER_SUPPLY_HEALTH_GOOD;
+					psy_do_property("battery", set,
+							POWER_SUPPLY_PROP_HEALTH, value);
+					max77804_set_input_current(charger,
+							charger->charging_current_max);
+				}
+			}
+			break;
+		}
+
+		if (charger->is_charging) {
+			/* reduce only at CC MODE */
+			if (((chgin_dtls == 0x0) || (chgin_dtls == 0x01)) &&
+					(chg_dtls == 0x01) && (stable_count > 2))
+				reduce_input_current(charger, REDUCE_CURRENT_STEP);
+		}
+		prev_chgin_dtls = chgin_dtls;
+		msleep(100);
+	}
+	max77804_read_reg(charger->max77804->i2c,
+		MAX77804_CHG_REG_CHG_INT_MASK, &reg_data);
+	reg_data &= ~(1 << 6);
+	max77804_write_reg(charger->max77804->i2c,
+		MAX77804_CHG_REG_CHG_INT_MASK, reg_data);
+
+	wake_unlock(&charger->chgin_wake_lock);
+}
+
+static irqreturn_t max77804_chgin_irq(int irq, void *data)
+{
+	struct max77804_charger_data *charger = data;
+	queue_work(charger->wqueue, &charger->chgin_work);
+
+	return IRQ_HANDLED;
+}
+
+/* register chgin isr after sec_battery_probe */
+static void max77804_chgin_init_work(struct work_struct *work)
+{
+	struct max77804_charger_data *charger = container_of(work,
+						struct max77804_charger_data,
+						chgin_init_work.work);
+	int ret;
+
+	pr_info("%s \n", __func__);
+	ret = request_threaded_irq(charger->irq_chgin, NULL,
+			max77804_chgin_irq, 0, "chgin-irq", charger);
+	if (ret < 0) {
+		pr_err("%s: fail to request chgin IRQ: %d: %d\n",
+				__func__, charger->irq_chgin, ret);
+	}
+}
+
+#ifdef CONFIG_OF
+static int sec_charger_parse_dt(struct max77804_charger_data *charger)
+{
+	struct device_node *np = of_find_node_by_name(NULL, "charger");
+	sec_battery_platform_data_t *pdata = charger->pdata;
+	int ret = 0;
+	int i, len;
+	const u32 *p;
+
+	if (np == NULL) {
+		pr_err("%s np NULL\n", __func__);
+	} else {
+		ret = of_property_read_u32(np, "battery,chg_float_voltage",
+					   &pdata->chg_float_voltage);
+	}
+
+	np = of_find_node_by_name(NULL, "battery");
+	if (!np) {
+		pr_err("%s np NULL\n", __func__);
+	} else {
+		p = of_get_property(np, "battery,input_current_limit", &len);
+
+		len = len / sizeof(u32);
+
+		pdata->charging_current = kzalloc(sizeof(sec_charging_current_t) * len,
+						  GFP_KERNEL);
+
+		for(i = 0; i < len; i++) {
+			ret = of_property_read_u32_index(np,
+				 "battery,input_current_limit", i,
+				 &pdata->charging_current[i].input_current_limit);
+			ret = of_property_read_u32_index(np,
+				 "battery,fast_charging_current", i,
+				 &pdata->charging_current[i].fast_charging_current);
+			ret = of_property_read_u32_index(np,
+				 "battery,full_check_current_1st", i,
+				 &pdata->charging_current[i].full_check_current_1st);
+			ret = of_property_read_u32_index(np,
+				 "battery,full_check_current_2nd", i,
+				 &pdata->charging_current[i].full_check_current_2nd);
+		}
+	}
+	return ret;
+}
+#endif
+
+static __devinit int max77804_charger_probe(struct platform_device *pdev)
+{
+	struct max77804_dev *iodev = dev_get_drvdata(pdev->dev.parent);
+	struct max77804_platform_data *pdata = dev_get_platdata(iodev->dev);
+	struct max77804_charger_data *charger;
+	int ret = 0;
+	u8 reg_data;
+
+	pr_info("%s: MAX77804 Charger driver probe\n", __func__);
+
+	charger = kzalloc(sizeof(*charger), GFP_KERNEL);
+	if (!charger)
+		return -ENOMEM;
+
+	pdata->charger_data = kzalloc(sizeof(sec_battery_platform_data_t), GFP_KERNEL);
+	if (!pdata->charger_data) {
+		ret = -ENOMEM;
+		goto err_free;
+	}
+
+	charger->max77804 = iodev;
+	charger->pdata = pdata->charger_data;
+	charger->aicl_on = false;
+	charger->siop_level = 100;
+
+#ifdef CONFIG_OF
+	if (sec_charger_parse_dt(charger))
+		dev_err(&pdev->dev,
+			"%s : Failed to get charger int\n", __func__);
+#endif
+
+	platform_set_drvdata(pdev, charger);
+
+	charger->psy_chg.name           = "sec-charger";
+	charger->psy_chg.type           = POWER_SUPPLY_TYPE_UNKNOWN;
+	charger->psy_chg.get_property   = sec_chg_get_property;
+	charger->psy_chg.set_property   = sec_chg_set_property;
+	charger->psy_chg.properties     = sec_charger_props;
+	charger->psy_chg.num_properties = ARRAY_SIZE(sec_charger_props);
+
+	mutex_init(&charger->ops_lock);
+/*
+	if (charger->pdata->chg_gpio_init) {
+		if (!charger->pdata->chg_gpio_init()) {
+			pr_err("%s: Failed to Initialize GPIO\n", __func__);
+			goto err_free;
+		}
+	}
+*/
+	max77804_charger_initialize(charger);
+
+	if (max77804_read_reg(charger->max77804->i2c, MAX77804_PMIC_REG_PMIC_ID1, &reg_data) < 0) {
+		pr_err("device not found on this channel (this is not an error)\n");
+		ret = -ENODEV;
+		goto err_free;
+	} else {
+		charger->pmic_ver = (reg_data & 0xf);
+		pr_info("%s: device found: ver.0x%x\n", __func__,
+				charger->pmic_ver);
+	}
+
+	charger->input_curr_limit_step = 25;
+	charger->wpc_input_curr_limit_step = 20;
+	charger->charging_curr_step= 400;  // 0.1mA unit
+
+	charger->wqueue =
+	    create_singlethread_workqueue(dev_name(&pdev->dev));
+	if (!charger->wqueue) {
+		pr_err("%s: Fail to Create Workqueue\n", __func__);
+		goto err_free;
+	}
+	wake_lock_init(&charger->chgin_wake_lock, WAKE_LOCK_SUSPEND,
+		       "charger->chgin");
+	INIT_WORK(&charger->chgin_work, max77804_chgin_isr_work);
+	INIT_DELAYED_WORK(&charger->chgin_init_work, max77804_chgin_init_work);
+	wake_lock_init(&charger->recovery_wake_lock, WAKE_LOCK_SUSPEND,
+					       "charger-recovery");
+	INIT_DELAYED_WORK(&charger->recovery_work, max77804_recovery_work);
+	wake_lock_init(&charger->wpc_wake_lock, WAKE_LOCK_SUSPEND,
+					       "charger-wpc");
+	INIT_DELAYED_WORK(&charger->wpc_work, wpc_detect_work);
+	ret = power_supply_register(&pdev->dev, &charger->psy_chg);
+	if (ret) {
+		pr_err("%s: Failed to Register psy_chg\n", __func__);
+		goto err_power_supply_register;
+	}
+
+	if (charger->pdata->chg_irq) {
+		INIT_DELAYED_WORK(
+			&charger->isr_work, sec_chg_isr_work);
+		ret = request_threaded_irq(charger->pdata->chg_irq,
+				NULL, sec_chg_irq_thread,
+				charger->pdata->chg_irq_attr,
+				"charger-irq", charger);
+		if (ret) {
+			pr_err("%s: Failed to Reqeust IRQ\n", __func__);
+			goto err_irq;
+		}
+	}
+
+	charger->wc_w_irq = pdata->irq_base + MAX77804_CHG_IRQ_WCIN_I;
+	ret = request_threaded_irq(charger->wc_w_irq,
+			NULL, wpc_charger_irq,
+			IRQF_TRIGGER_FALLING,
+			"wpc-int", charger);
+	if (ret) {
+		pr_err("%s: Failed to Reqeust IRQ\n", __func__);
+		goto err_wc_irq;
+	}
+	max77804_read_reg(charger->max77804->i2c,
+			MAX77804_CHG_REG_CHG_INT_OK, &reg_data);
+	charger->wc_w_state = (reg_data & MAX77804_WCIN_OK)
+				>> MAX77804_WCIN_OK_SHIFT;
+
+	charger->irq_chgin = pdata->irq_base + MAX77804_CHG_IRQ_CHGIN_I;
+	/* enable chgin irq after sec_battery_probe */
+	queue_delayed_work(charger->wqueue, &charger->chgin_init_work,
+			msecs_to_jiffies(3000));
+
+	charger->irq_bypass = pdata->irq_base + MAX77804_CHG_IRQ_BYP_I;
+	ret = request_threaded_irq(charger->irq_bypass, NULL,
+			max77804_bypass_irq, 0, "bypass-irq", charger);
+	if (ret < 0)
+		pr_err("%s: fail to request bypass IRQ: %d: %d\n",
+				__func__, charger->irq_bypass, ret);
+
+	charger->irq_batp = pdata->irq_base + MAX77804_CHG_IRQ_BATP_I;
+	ret = request_threaded_irq(charger->irq_batp, NULL,
+			max77804_batp_irq, 0, "batp_irq", charger);
+	if (ret < 0)
+		pr_err("%s: fail to request batp irq : %d, %d\n",
+				__func__, charger->irq_batp, ret);
+
+	return 0;
+err_wc_irq:
+	free_irq(charger->pdata->chg_irq, NULL);
+err_irq:
+	power_supply_unregister(&charger->psy_chg);
+err_power_supply_register:
+	destroy_workqueue(charger->wqueue);
+err_free:
+	kfree(charger);
+
+	return ret;
+
+}
+
+static int __devexit max77804_charger_remove(struct platform_device *pdev)
+{
+	struct max77804_charger_data *charger =
+				platform_get_drvdata(pdev);
+
+	destroy_workqueue(charger->wqueue);
+	free_irq(charger->wc_w_irq, NULL);
+	free_irq(charger->pdata->chg_irq, NULL);
+	power_supply_unregister(&charger->psy_chg);
+	kfree(charger);
+
+	return 0;
+}
+
+#if defined CONFIG_PM
+static int max77804_charger_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int max77804_charger_resume(struct device *dev)
+{
+	return 0;
+}
+#else
+#define max77804_charger_suspend NULL
+#define max77804_charger_resume NULL
+#endif
+
+static void max77804_charger_shutdown(struct device *dev)
+{
+	struct max77804_charger_data *charger =
+				dev_get_drvdata(dev);
+	u8 reg_data;
+
+	pr_info("%s: MAX77804 Charger driver shutdown\n", __func__);
+	if (!charger->max77804->i2c) {
+		pr_err("%s: no max77804 i2c client\n", __func__);
+		return;
+	}
+	reg_data = 0x04;
+	max77804_write_reg(charger->max77804->i2c,
+		MAX77804_CHG_REG_CHG_CNFG_00, reg_data);
+
+	reg_data = 0x19;
+
+	max77804_write_reg(charger->max77804->i2c,
+		MAX77804_CHG_REG_CHG_CNFG_09, reg_data);
+	reg_data = 0x19;
+	max77804_write_reg(charger->max77804->i2c,
+		MAX77804_CHG_REG_CHG_CNFG_10, reg_data);
+	pr_info("func:%s \n", __func__);
+}
+
+static SIMPLE_DEV_PM_OPS(max77804_charger_pm_ops, max77804_charger_suspend,
+		max77804_charger_resume);
+
+static struct platform_driver max77804_charger_driver = {
+	.driver = {
+		.name = "max77804-charger",
+		.owner = THIS_MODULE,
+		.pm = &max77804_charger_pm_ops,
+		.shutdown = max77804_charger_shutdown,
+	},
+	.probe = max77804_charger_probe,
+	.remove = __devexit_p(max77804_charger_remove),
+};
+
+static int __init max77804_charger_init(void)
+{
+	pr_info("func:%s\n", __func__);
+	return platform_driver_register(&max77804_charger_driver);
+}
+module_init(max77804_charger_init);
+
+static void __exit max77804_charger_exit(void)
+{
+	platform_driver_register(&max77804_charger_driver);
+}
+
+module_exit(max77804_charger_exit);
+
+MODULE_DESCRIPTION("max77804 charger driver");
+MODULE_AUTHOR("Samsung Electronics");
+MODULE_LICENSE("GPL");
diff -Naur linux-3.18.14/drivers/battery/max77823_charger.c samsung/drivers/battery/max77823_charger.c
--- linux-3.18.14/drivers/battery/max77823_charger.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery/max77823_charger.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,1535 @@
+/*
+ *  max77823_charger.c
+ *  Samsung MAX77823 Charger Driver
+ *
+ *  Copyright (C) 2012 Samsung Electronics
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#define DEBUG
+
+#include <linux/mfd/max77823-private.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#ifdef CONFIG_USB_HOST_NOTIFY
+#include <linux/usb_notify.h>
+#endif
+
+#define ENABLE 1
+#define DISABLE 0
+
+static enum power_supply_property max77823_charger_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_CHARGE_TYPE,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_CURRENT_MAX,
+	POWER_SUPPLY_PROP_CURRENT_AVG,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
+	POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL,
+};
+
+static void max77823_charger_initialize(struct max77823_charger_data *charger);
+static int max77823_get_vbus_state(struct max77823_charger_data *charger);
+static int max77823_get_charger_state(struct max77823_charger_data *charger);
+
+static bool max77823_charger_unlock(struct max77823_charger_data *charger)
+{
+	struct i2c_client *i2c = charger->i2c;
+	u8 reg_data;
+	u8 chgprot;
+	int retry_cnt = 0;
+	bool need_init = false;
+
+	do {
+		max77823_read_reg(i2c, MAX77823_CHG_CNFG_06, &reg_data);
+		chgprot = ((reg_data & 0x0C) >> 2);
+		if (chgprot != 0x03) {
+			pr_err("%s: unlock err, chgprot(0x%x), retry(%d)\n",
+					__func__, chgprot, retry_cnt);
+			max77823_write_reg(i2c, MAX77823_CHG_CNFG_06,
+					   (0x03 << 2));
+			need_init = true;
+			msleep(20);
+		} else {
+			pr_debug("%s: unlock success, chgprot(0x%x)\n",
+				__func__, chgprot);
+			break;
+		}
+	} while ((chgprot != 0x03) && (++retry_cnt < 10));
+
+	return need_init;
+}
+
+static void check_charger_unlock_state(struct max77823_charger_data *charger)
+{
+	bool need_reg_init;
+	pr_debug("%s\n", __func__);
+
+	need_reg_init = max77823_charger_unlock(charger);
+	if (need_reg_init) {
+		pr_err("%s: charger locked state, reg init\n", __func__);
+		max77823_charger_initialize(charger);
+	}
+}
+
+static void max77823_test_read(struct max77823_charger_data *charger)
+{
+	u8 data = 0;
+	u32 addr = 0;
+	for (addr = 0xB0; addr <= 0xC3; addr++) {
+		max77823_read_reg(charger->i2c, addr, &data);
+		pr_debug("MAX7823 addr : 0x%02x data : 0x%02x\n", addr, data);
+	}
+}
+
+static int max77823_get_vbus_state(struct max77823_charger_data *charger)
+{
+	u8 reg_data;
+
+	max77823_read_reg(charger->i2c,
+			  MAX77823_CHG_DETAILS_00, &reg_data);
+
+	if (charger->cable_type == POWER_SUPPLY_TYPE_WIRELESS)
+		reg_data = ((reg_data & MAX77823_WCIN_DTLS) >>
+			    MAX77823_WCIN_DTLS_SHIFT);
+	else
+		reg_data = ((reg_data & MAX77823_CHGIN_DTLS) >>
+			    MAX77823_CHGIN_DTLS_SHIFT);
+
+	switch (reg_data) {
+	case 0x00:
+		pr_info("%s: VBUS is invalid. CHGIN < CHGIN_UVLO\n",
+			__func__);
+		break;
+	case 0x01:
+		pr_info("%s: VBUS is invalid. CHGIN < MBAT+CHGIN2SYS" \
+			"and CHGIN > CHGIN_UVLO\n", __func__);
+		break;
+	case 0x02:
+		pr_info("%s: VBUS is invalid. CHGIN > CHGIN_OVLO",
+			__func__);
+		break;
+	case 0x03:
+		pr_info("%s: VBUS is valid. CHGIN < CHGIN_OVLO", __func__);
+		break;
+	default:
+		break;
+	}
+
+	return reg_data;
+}
+
+static int max77823_get_charger_state(struct max77823_charger_data *charger)
+{
+	int status = POWER_SUPPLY_STATUS_UNKNOWN;
+	u8 reg_data;
+
+	max77823_read_reg(charger->i2c,
+			  MAX77823_CHG_DETAILS_01, &reg_data);
+
+	pr_info("%s : charger status (0x%02x)\n", __func__, reg_data);
+
+	reg_data &= 0x0f;
+
+	switch (reg_data)
+	{
+	case 0x00:
+	case 0x01:
+	case 0x02:
+		status = POWER_SUPPLY_STATUS_CHARGING;
+		break;
+	case 0x03:
+	case 0x04:
+		status = POWER_SUPPLY_STATUS_FULL;
+		break;
+	case 0x05:
+	case 0x06:
+	case 0x07:
+		status = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		break;
+	case 0x08:
+	case 0xA:
+	case 0xB:
+		status = POWER_SUPPLY_STATUS_DISCHARGING;
+	default:
+		status = POWER_SUPPLY_STATUS_UNKNOWN;
+		break;
+	}
+
+	return (int)status;
+}
+
+static int max77823_get_charging_health(struct max77823_charger_data *charger)
+{
+	int state;
+	int vbus_state;
+	int retry_cnt;
+	u8 chg_dtls_00, chg_dtls, reg_data;
+	u8 chg_cnfg_00, chg_cnfg_01 ,chg_cnfg_02, chg_cnfg_04, chg_cnfg_09, chg_cnfg_12;
+
+	max77823_read_reg(charger->i2c,
+			  MAX77823_CHG_DETAILS_01, &reg_data);
+	reg_data = ((reg_data & MAX77823_BAT_DTLS) >> MAX77823_BAT_DTLS_SHIFT);
+
+	pr_info("%s: reg_data(0x%x)\n", __func__, reg_data);
+	switch (reg_data) {
+	case 0x00:
+		pr_info("%s: No battery and the charger is suspended\n",
+			__func__);
+		state = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;
+		break;
+	case 0x01:
+		pr_info("%s: battery is okay "
+			"but its voltage is low(~VPQLB)\n", __func__);
+		state = POWER_SUPPLY_HEALTH_GOOD;
+		break;
+	case 0x02:
+		pr_info("%s: battery dead\n", __func__);
+		state = POWER_SUPPLY_HEALTH_DEAD;
+		break;
+	case 0x03:
+		state = POWER_SUPPLY_HEALTH_GOOD;
+		break;
+	case 0x04:
+		pr_info("%s: battery is okay" \
+			"but its voltage is low\n", __func__);
+		state = POWER_SUPPLY_HEALTH_GOOD;
+		break;
+	case 0x05:
+		pr_info("%s: battery ovp\n", __func__);
+		state = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+		break;
+	default:
+		pr_info("%s: battery unknown : 0x%d\n", __func__, reg_data);
+		state = POWER_SUPPLY_HEALTH_UNKNOWN;
+		break;
+	}
+
+	if (state == POWER_SUPPLY_HEALTH_GOOD) {
+		union power_supply_propval value;
+		psy_do_property("battery", get,
+				POWER_SUPPLY_PROP_HEALTH, value);
+		/* VBUS OVP state return battery OVP state */
+		vbus_state = max77823_get_vbus_state(charger);
+		/* read CHG_DTLS and detecting battery terminal error */
+		max77823_read_reg(charger->i2c,
+				  MAX77823_CHG_DETAILS_01, &chg_dtls);
+		chg_dtls = ((chg_dtls & MAX77823_CHG_DTLS) >>
+			    MAX77823_CHG_DTLS_SHIFT);
+		max77823_read_reg(charger->i2c,
+				  MAX77823_CHG_CNFG_00, &chg_cnfg_00);
+
+		/* print the log at the abnormal case */
+		if((charger->is_charging == 1) && (chg_dtls & 0x08)) {
+			max77823_read_reg(charger->i2c,
+				MAX77823_CHG_DETAILS_00, &chg_dtls_00);
+			max77823_read_reg(charger->i2c,
+				MAX77823_CHG_CNFG_01, &chg_cnfg_01);
+			max77823_read_reg(charger->i2c,
+				MAX77823_CHG_CNFG_02, &chg_cnfg_02);
+			max77823_read_reg(charger->i2c,
+				MAX77823_CHG_CNFG_04, &chg_cnfg_04);
+			max77823_read_reg(charger->i2c,
+					MAX77823_CHG_CNFG_09, &chg_cnfg_09);
+			max77823_read_reg(charger->i2c,
+					MAX77823_CHG_CNFG_12, &chg_cnfg_12);
+
+			pr_info("%s: CHG_DTLS_00(0x%x), CHG_DTLS_01(0x%x), CHG_CNFG_00(0x%x)\n",
+				__func__, chg_dtls_00, chg_dtls, chg_cnfg_00);
+			pr_info("%s:  CHG_CNFG_01(0x%x), CHG_CNFG_02(0x%x), CHG_CNFG_04(0x%x)\n",
+				__func__, chg_cnfg_01, chg_cnfg_02, chg_cnfg_04);
+			pr_info("%s:  CHG_CNFG_09(0x%x), CHG_CNFG_12(0x%x)\n",
+				__func__, chg_cnfg_09, chg_cnfg_12);
+		}
+
+		pr_info("%s: vbus_state : 0x%d, chg_dtls : 0x%d\n", __func__, vbus_state, chg_dtls);
+		/*  OVP is higher priority */
+		if (vbus_state == 0x02) { /*  CHGIN_OVLO */
+			pr_info("%s: vbus ovp\n", __func__);
+			state = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+			if (charger->cable_type == POWER_SUPPLY_TYPE_WIRELESS) {
+				retry_cnt = 0;
+				do {
+					msleep(50);
+					vbus_state = max77823_get_vbus_state(charger);
+				} while((retry_cnt++ < 2) && (vbus_state == 0x02));
+				if (vbus_state == 0x02) {
+					state = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+					panic("wpc and ovp");
+				} else
+					state = POWER_SUPPLY_HEALTH_GOOD;
+			}
+		} else if (((vbus_state == 0x0) || (vbus_state == 0x01)) &&(chg_dtls & 0x08) && \
+				(chg_cnfg_00 & MAX77823_MODE_BUCK) && \
+				(chg_cnfg_00 & MAX77823_MODE_CHGR) && \
+				(charger->cable_type != POWER_SUPPLY_TYPE_WIRELESS)) {
+			pr_info("%s: vbus is under\n", __func__);
+			state = POWER_SUPPLY_HEALTH_UNDERVOLTAGE;
+		}
+	}
+
+	return (int)state;
+}
+
+static u8 max77823_get_float_voltage_data(int float_voltage)
+{
+	int voltage = 3650;
+	int i;
+
+	for (i = 0; voltage <= 4700; i++) {
+		if (float_voltage <= voltage)
+			break;
+		voltage += 25;
+	}
+
+	if (float_voltage <= 4340)
+		return i;
+	else
+		return (i+1);
+}
+
+static int max77823_get_input_current(struct max77823_charger_data *charger)
+{
+	u8 reg_data;
+	int get_current = 0;
+	int quotient, remainder;
+
+	if (charger->cable_type == POWER_SUPPLY_TYPE_WIRELESS) {
+		max77823_read_reg(charger->i2c,
+				  MAX77823_CHG_CNFG_10, &reg_data);
+
+		if (reg_data <= 3)
+			get_current = 60;
+		else
+			get_current = 60 + (reg_data - 3) * 20;
+	} else {
+		max77823_read_reg(charger->i2c,
+				  MAX77823_CHG_CNFG_09, &reg_data);
+
+		if (reg_data <= 0x03) {
+			get_current = 100;
+		} else if (reg_data >= 0x78) {
+			get_current = 4000;
+		} else {
+			quotient = reg_data / 3;
+			remainder = reg_data % 3;
+
+			if (remainder == 0)
+				get_current = quotient * 100;
+			else if (remainder == 1)
+				get_current = (quotient * 100) + 33;
+			else if (remainder == 2)
+				get_current = (quotient * 100) + 67;
+		}
+	}
+	return get_current;
+}
+
+static bool max77823_check_battery(struct max77823_charger_data *charger)
+{
+	u8 reg_data;
+	u8 reg_data2;
+
+	max77823_read_reg(charger->i2c,
+			  MAX77823_CHG_INT_OK, &reg_data);
+
+	pr_info("%s : CHG_INT_OK(0x%x)\n", __func__, reg_data);
+
+	max77823_read_reg(charger->i2c,
+			  MAX77823_CHG_DETAILS_00, &reg_data2);
+
+	pr_info("%s : CHG_DETAILS00(0x%x)\n", __func__, reg_data2);
+
+	if ((reg_data & MAX77823_BATP_OK) ||
+	    !(reg_data2 & MAX77823_BATP_DTLS))
+		return true;
+	else
+		return false;
+}
+
+static void max77823_set_buck(struct max77823_charger_data *charger,
+		int enable)
+{
+	u8 reg_data;
+
+	max77823_read_reg(charger->i2c          ,
+		MAX77823_CHG_CNFG_00, &reg_data);
+
+	if (enable)
+		reg_data |= MAX77823_MODE_BUCK;
+	else
+		reg_data &= ~MAX77823_MODE_BUCK;
+
+	pr_info("%s: CHG_CNFG_00(0x%02x)\n", __func__, reg_data);
+	max77823_write_reg(charger->i2c,
+			   MAX77823_CHG_CNFG_00, reg_data);
+}
+
+static void max77823_set_input_current(struct max77823_charger_data *charger,
+				       int input_current)
+{
+	int quotient, remainder;
+	u8 reg_data;
+
+	max77823_read_reg(charger->i2c,
+			  MAX77823_CHG_CNFG_09, &reg_data);
+	reg_data &= ~MAX77823_CHG_CHGIN_LIM;
+
+	if (input_current <= 0)
+		max77823_set_buck(charger, DISABLE);
+	else
+		max77823_set_buck(charger, ENABLE);
+
+	if (!input_current) {
+		max77823_write_reg(charger->i2c,
+				   MAX77823_CHG_CNFG_09, reg_data);
+	} else {
+		quotient = input_current / 100;
+		remainder = input_current % 100;
+
+		if (remainder >= 67)
+			reg_data |= (quotient * 3) + 2;
+		else if (remainder >= 33)
+			reg_data |= (quotient * 3) + 1;
+		else if (remainder < 33)
+			reg_data |= quotient * 3;
+
+		max77823_write_reg(charger->i2c,
+				   MAX77823_CHG_CNFG_09, reg_data);
+	}
+}
+
+static void max77823_set_charge_current(struct max77823_charger_data *charger,
+					int fast_charging_current)
+{
+	int curr_step = 50;
+	u8 reg_data;
+
+	max77823_read_reg(charger->i2c,
+			  MAX77823_CHG_CNFG_02, &reg_data);
+	reg_data &= ~MAX77823_CHG_CC;
+
+	if (!fast_charging_current) {
+		max77823_write_reg(charger->i2c,
+				   MAX77823_CHG_CNFG_02, reg_data);
+	} else {
+		reg_data |= (fast_charging_current / curr_step);
+
+		max77823_write_reg(charger->i2c,MAX77823_CHG_CNFG_02, reg_data);
+	}
+
+}
+
+static void max77823_set_topoff_current(struct max77823_charger_data *charger,
+					int termination_current,
+					int termination_time)
+{
+	u8 reg_data;
+
+	if (termination_current >= 350)
+		reg_data = 0x07;
+	else if (termination_current >= 300)
+		reg_data = 0x06;
+	else if (termination_current >= 250)
+		reg_data = 0x05;
+	else if (termination_current >= 200)
+		reg_data = 0x04;
+	else if (termination_current >= 175)
+		reg_data = 0x03;
+	else if (termination_current >= 150)
+		reg_data = 0x02;
+	else if (termination_current >= 125)
+		reg_data = 0x01;
+	else
+		reg_data = 0x00;
+
+	/* the unit of timeout is second*/
+	termination_time = termination_time / 60;
+	reg_data |= ((termination_time / 10) << 3);
+	pr_info("%s: reg_data(0x%02x), topoff(%d)\n",
+		__func__, reg_data, termination_current);
+
+	max77823_write_reg(charger->i2c,
+			   MAX77823_CHG_CNFG_03, reg_data);
+
+}
+
+static void max77823_set_charger_state(struct max77823_charger_data *charger,
+	int enable)
+{
+	u8 reg_data;
+
+	max77823_read_reg(charger->i2c, MAX77823_CHG_CNFG_00, &reg_data);
+
+	if (enable)
+		reg_data |= MAX77823_MODE_CHGR;
+	else
+		reg_data &= ~MAX77823_MODE_CHGR;
+
+	pr_debug("%s : CHG_CNFG_00(0x%02x)\n", __func__, reg_data);
+
+	max77823_write_reg(charger->i2c,MAX77823_CHG_CNFG_00, reg_data);
+}
+
+static void max77823_charger_function_control(
+				struct max77823_charger_data *charger)
+{
+	const int usb_charging_current = charger->pdata->charging_current[
+		POWER_SUPPLY_TYPE_USB].fast_charging_current;
+	int set_charging_current, set_charging_current_max;
+	u8 chg_cnfg_00 = 0;
+
+	pr_info("####%s####\n", __func__);
+
+	if (charger->cable_type == POWER_SUPPLY_TYPE_BATTERY ||
+	    charger->cable_type == POWER_SUPPLY_TYPE_OTG) {
+		charger->is_charging = false;
+		charger->aicl_on = false;
+		set_charging_current = 0;
+		set_charging_current_max =
+			charger->pdata->charging_current[
+				POWER_SUPPLY_TYPE_USB].input_current_limit;
+
+		if (charger->cable_type == POWER_SUPPLY_TYPE_OTG) {
+			chg_cnfg_00 |= (CHG_CNFG_00_OTG_MASK
+					| CHG_CNFG_00_BOOST_MASK
+					| CHG_CNFG_00_DIS_MUIC_CTRL_MASK);
+
+			chg_cnfg_00 &= ~(CHG_CNFG_00_BUCK_MASK);
+
+			max77823_update_reg(charger->i2c,
+					    MAX77823_CHG_CNFG_00,
+					    chg_cnfg_00,
+					    (CHG_CNFG_00_OTG_MASK |
+					     CHG_CNFG_00_BOOST_MASK |
+					     CHG_CNFG_00_DIS_MUIC_CTRL_MASK |
+					     CHG_CNFG_00_BUCK_MASK));
+		} else {
+			chg_cnfg_00 &= ~(CHG_CNFG_00_CHG_MASK
+					 | CHG_CNFG_00_OTG_MASK
+					 | CHG_CNFG_00_BOOST_MASK
+					 | CHG_CNFG_00_DIS_MUIC_CTRL_MASK);
+
+			max77823_update_reg(charger->i2c,
+					    MAX77823_CHG_CNFG_00,
+					    chg_cnfg_00,
+					    (CHG_CNFG_00_CHG_MASK |
+					     CHG_CNFG_00_OTG_MASK |
+					     CHG_CNFG_00_BOOST_MASK |
+					     CHG_CNFG_00_DIS_MUIC_CTRL_MASK));
+
+			set_charging_current_max =
+				charger->pdata->charging_current[
+					POWER_SUPPLY_TYPE_USB].input_current_limit;
+		}
+	} else {
+		charger->is_charging = true;
+		charger->charging_current_max =
+			charger->pdata->charging_current
+			[charger->cable_type].input_current_limit;
+		charger->charging_current =
+			charger->pdata->charging_current
+			[charger->cable_type].fast_charging_current;
+		/* decrease the charging current according to siop level */
+		set_charging_current =
+			charger->charging_current * charger->siop_level / 100;
+		if (set_charging_current > 0 &&
+		    set_charging_current < usb_charging_current)
+			set_charging_current = usb_charging_current;
+
+		set_charging_current_max =
+			charger->charging_current_max;
+
+		if (charger->siop_level < 100 &&
+		    set_charging_current_max > SIOP_INPUT_LIMIT_CURRENT) {
+			set_charging_current_max = SIOP_INPUT_LIMIT_CURRENT;
+			if (set_charging_current > SIOP_CHARGING_LIMIT_CURRENT)
+				set_charging_current = SIOP_CHARGING_LIMIT_CURRENT;
+		}
+	}
+
+	max77823_set_charger_state(charger, charger->is_charging);
+
+	/* if battery full, only disable charging  */
+	if ((charger->status == POWER_SUPPLY_STATUS_CHARGING) ||
+	    (charger->status == POWER_SUPPLY_STATUS_FULL) ||
+	    (charger->status == POWER_SUPPLY_STATUS_DISCHARGING)) {
+		/* current setting */
+		max77823_set_charge_current(charger,
+					    set_charging_current);
+		/* if battery is removed, disable input current and reenable input current
+		 *  to enable buck always */
+		max77823_set_input_current(charger,
+					   set_charging_current_max);
+		max77823_set_topoff_current(charger,
+					    charger->pdata->charging_current[
+						    charger->cable_type].full_check_current_1st,
+					    charger->pdata->charging_current[
+						    charger->cable_type].full_check_current_2nd);
+	}
+
+	pr_info("charging = %d, fc = %d, il = %d, t1 = %d, t2 = %d, cable = %d\n",
+		charger->is_charging,
+		charger->charging_current,
+		charger->charging_current_max,
+		charger->pdata->charging_current[charger->cable_type].full_check_current_1st,
+		charger->pdata->charging_current[charger->cable_type].full_check_current_2nd,
+		charger->cable_type);
+
+	max77823_test_read(charger);
+
+}
+
+
+static void max77823_charger_initialize(struct max77823_charger_data *charger)
+{
+	u8 reg_data;
+	pr_info("%s\n", __func__);
+
+	/* unmasked: CHGIN_I, WCIN_I, BATP_I, BYP_I	*/
+	max77823_write_reg(charger->i2c, MAX77823_CHG_INT_MASK, 0x9a);
+
+	/* unlock charger setting protect */
+	reg_data = (0x03 << 2);
+	max77823_write_reg(charger->i2c, MAX77823_CHG_CNFG_06, reg_data);
+
+	/*
+	 * fast charge timer disable
+	 * restart threshold disable
+	 * pre-qual charge enable(default)
+	 */
+	reg_data = (0x08 << 0) | (0x03 << 4);
+	max77823_write_reg(charger->i2c, MAX77823_CHG_CNFG_01, reg_data);
+
+	/*
+	 * charge current 466mA(default)
+	 * otg current limit 900mA
+	 */
+	max77823_read_reg(charger->i2c, MAX77823_CHG_CNFG_02, &reg_data);
+	reg_data |= (1 << 7);
+	max77823_write_reg(charger->i2c, MAX77823_CHG_CNFG_02, reg_data);
+
+	/*
+	 * top off current 100mA
+	 * top off timer 40min
+	 */
+	reg_data = 0x36;
+	max77823_write_reg(charger->i2c, MAX77823_CHG_CNFG_03, reg_data);
+
+	/*
+	 * cv voltage 4.2V or 4.35V
+	 * MINVSYS 3.6V(default)
+	 */
+	reg_data = max77823_get_float_voltage_data(charger->pdata->chg_float_voltage);
+	max77823_update_reg(charger->i2c, MAX77823_CHG_CNFG_04,
+			(reg_data << CHG_CNFG_04_CHG_CV_PRM_SHIFT),
+			CHG_CNFG_04_CHG_CV_PRM_MASK);
+	max77823_read_reg(charger->i2c, MAX77823_CHG_CNFG_04, &reg_data);
+	pr_info("%s: battery cv voltage 0x%x\n", __func__, reg_data);
+
+	max77823_test_read(charger);
+
+}
+
+static int max77823_chg_get_property(struct power_supply *psy,
+			      enum power_supply_property psp,
+			      union power_supply_propval *val)
+{
+	struct max77823_charger_data *charger =
+		container_of(psy, struct max77823_charger_data, psy_chg);
+	u8 reg_data;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = POWER_SUPPLY_TYPE_BATTERY;
+		if (max77823_read_reg(charger->i2c,
+			MAX77823_CHG_INT_OK, &reg_data) == 0) {
+			if (reg_data & MAX77823_WCIN_OK) {
+				val->intval = POWER_SUPPLY_TYPE_WIRELESS;
+				charger->wc_w_state = 1;
+			} else if (reg_data & MAX77823_CHGIN_OK) {
+				val->intval = POWER_SUPPLY_TYPE_MAINS;
+			}
+		}
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = max77823_check_battery(charger);
+		break;
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = max77823_get_charger_state(charger);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+		if (!charger->is_charging)
+			val->intval = POWER_SUPPLY_CHARGE_TYPE_NONE;
+		else if (charger->aicl_on)
+		{
+			val->intval = POWER_SUPPLY_CHARGE_TYPE_SLOW;
+			pr_info("%s: slow-charging mode\n", __func__);
+		}
+		else
+			val->intval = POWER_SUPPLY_CHARGE_TYPE_FAST;
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = max77823_get_charging_health(charger);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		val->intval = charger->charging_current_max;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+		val->intval = max77823_get_input_current(charger);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = max77823_get_input_current(charger);
+		pr_debug("%s : set-current(%dmA), current now(%dmA)\n",
+			__func__, charger->charging_current, val->intval);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int max77823_chg_set_property(struct power_supply *psy,
+			  enum power_supply_property psp,
+			  const union power_supply_propval *val)
+{
+	struct max77823_charger_data *charger =
+		container_of(psy, struct max77823_charger_data, psy_chg);
+	int set_charging_current_max;
+	const int usb_charging_current = charger->pdata->charging_current[
+		POWER_SUPPLY_TYPE_USB].fast_charging_current;
+	u8 chg_cnfg_00 = 0;
+
+	switch (psp) {
+	/* val->intval : type */
+	case POWER_SUPPLY_PROP_STATUS:
+		charger->status = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		charger->cable_type = val->intval;
+		max77823_charger_function_control(charger);
+		break;
+	/* val->intval : input charging current */
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		charger->charging_current_max = val->intval;
+		break;
+	/*  val->intval : charging current */
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+		charger->charging_current = val->intval;
+		break;
+	/* val->intval : charging current */
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		charger->charging_current = val->intval;
+		max77823_set_charge_current(charger,
+					    charger->charging_current);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+		charger->siop_level = val->intval;
+		if (charger->is_charging) {
+			/* decrease the charging current according to siop level */
+			int current_now =
+				charger->charging_current * val->intval / 100;
+
+			/* do forced set charging current */
+			if (current_now > 0 &&
+					current_now < usb_charging_current)
+				current_now = usb_charging_current;
+
+			if (charger->cable_type == POWER_SUPPLY_TYPE_MAINS) {
+				if (charger->siop_level < 100 ) {
+					set_charging_current_max = SIOP_INPUT_LIMIT_CURRENT;
+				} else {
+					set_charging_current_max =
+						charger->charging_current_max;
+				}
+
+				if (charger->siop_level < 100 &&
+				    current_now > SIOP_CHARGING_LIMIT_CURRENT)
+					current_now = SIOP_CHARGING_LIMIT_CURRENT;
+				max77823_set_input_current(charger,
+						   set_charging_current_max);
+			}
+
+			max77823_set_charge_current(charger, current_now);
+
+		}
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL:
+		if (val->intval) {
+			chg_cnfg_00 &= ~(CHG_CNFG_00_CHG_MASK
+					 | CHG_CNFG_00_BUCK_MASK);
+			chg_cnfg_00 |= (CHG_CNFG_00_OTG_MASK
+					| CHG_CNFG_00_BOOST_MASK
+					| CHG_CNFG_00_DIS_MUIC_CTRL_MASK);
+			max77823_update_reg(charger->i2c,
+					    MAX77823_CHG_CNFG_00,
+					    chg_cnfg_00,
+					    (CHG_CNFG_00_CHG_MASK
+					     | CHG_CNFG_00_OTG_MASK
+					     | CHG_CNFG_00_BUCK_MASK
+					     | CHG_CNFG_00_BOOST_MASK
+					     | CHG_CNFG_00_DIS_MUIC_CTRL_MASK));
+		} else {
+			chg_cnfg_00 = ~(CHG_CNFG_00_OTG_MASK
+					| CHG_CNFG_00_BOOST_MASK
+					| CHG_CNFG_00_DIS_MUIC_CTRL_MASK);
+			chg_cnfg_00 |= CHG_CNFG_00_BUCK_MASK;
+			max77823_update_reg(charger->i2c,
+					    MAX77823_CHG_CNFG_00,
+					    chg_cnfg_00,
+					    (CHG_CNFG_00_OTG_MASK
+					     | CHG_CNFG_00_BUCK_MASK
+					     | CHG_CNFG_00_BOOST_MASK
+					     | CHG_CNFG_00_DIS_MUIC_CTRL_MASK));
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+
+static int max77823_debugfs_show(struct seq_file *s, void *data)
+{
+	struct max77823_charger_data *charger = s->private;
+	u8 reg;
+	u8 reg_data;
+
+	seq_printf(s, "MAX77823 CHARGER IC :\n");
+	seq_printf(s, "===================\n");
+	for (reg = 0xB0; reg <= 0xC3; reg++) {
+		max77823_read_reg(charger->i2c, reg, &reg_data);
+		seq_printf(s, "0x%02x:\t0x%02x\n", reg, reg_data);
+	}
+
+	seq_printf(s, "\n");
+	return 0;
+}
+
+static int max77823_debugfs_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, max77823_debugfs_show, inode->i_private);
+}
+
+static const struct file_operations max77823_debugfs_fops = {
+	.open           = max77823_debugfs_open,
+	.read           = seq_read,
+	.llseek         = seq_lseek,
+	.release        = single_release,
+};
+
+static void max77823_chg_isr_work(struct work_struct *work)
+{
+	struct max77823_charger_data *charger =
+		container_of(work, struct max77823_charger_data, isr_work.work);
+
+	union power_supply_propval val;
+
+	if (charger->pdata->full_check_type ==
+	    SEC_BATTERY_FULLCHARGED_CHGINT) {
+
+		val.intval = max77823_get_charger_state(charger);
+
+		switch (val.intval) {
+		case POWER_SUPPLY_STATUS_DISCHARGING:
+			pr_err("%s: Interrupted but Discharging\n", __func__);
+			break;
+
+		case POWER_SUPPLY_STATUS_NOT_CHARGING:
+			pr_err("%s: Interrupted but NOT Charging\n", __func__);
+			break;
+
+		case POWER_SUPPLY_STATUS_FULL:
+			pr_info("%s: Interrupted by Full\n", __func__);
+			psy_do_property("battery", set,
+				POWER_SUPPLY_PROP_STATUS, val);
+			break;
+
+		case POWER_SUPPLY_STATUS_CHARGING:
+			pr_err("%s: Interrupted but Charging\n", __func__);
+			break;
+
+		case POWER_SUPPLY_STATUS_UNKNOWN:
+		default:
+			pr_err("%s: Invalid Charger Status\n", __func__);
+			break;
+		}
+	}
+
+	if (charger->pdata->ovp_uvlo_check_type ==
+		SEC_BATTERY_OVP_UVLO_CHGINT) {
+		val.intval = max77823_get_charging_health(charger);
+		switch (val.intval) {
+		case POWER_SUPPLY_HEALTH_OVERHEAT:
+		case POWER_SUPPLY_HEALTH_COLD:
+			pr_err("%s: Interrupted but Hot/Cold\n", __func__);
+			break;
+
+		case POWER_SUPPLY_HEALTH_DEAD:
+			pr_err("%s: Interrupted but Dead\n", __func__);
+			break;
+
+		case POWER_SUPPLY_HEALTH_OVERVOLTAGE:
+		case POWER_SUPPLY_HEALTH_UNDERVOLTAGE:
+			pr_info("%s: Interrupted by OVP/UVLO\n", __func__);
+			psy_do_property("battery", set,
+				POWER_SUPPLY_PROP_HEALTH, val);
+			break;
+
+		case POWER_SUPPLY_HEALTH_UNSPEC_FAILURE:
+			pr_err("%s: Interrupted but Unspec\n", __func__);
+			break;
+
+		case POWER_SUPPLY_HEALTH_GOOD:
+			pr_err("%s: Interrupted but Good\n", __func__);
+			break;
+
+		case POWER_SUPPLY_HEALTH_UNKNOWN:
+		default:
+			pr_err("%s: Invalid Charger Health\n", __func__);
+			break;
+		}
+	}
+}
+
+static irqreturn_t max77823_chg_irq_thread(int irq, void *irq_data)
+{
+	struct max77823_charger_data *charger = irq_data;
+
+	pr_info("%s : Charger interrup occured\n",
+		__func__);
+
+	if ((charger->pdata->full_check_type ==
+	     SEC_BATTERY_FULLCHARGED_CHGINT) ||
+	    (charger->pdata->ovp_uvlo_check_type ==
+	     SEC_BATTERY_OVP_UVLO_CHGINT))
+		schedule_delayed_work(&charger->isr_work, 0);
+
+	return IRQ_HANDLED;
+}
+
+static int cp_usb_enable;
+
+void cp_usb_power_control(int enable)
+{
+	struct power_supply *psy = power_supply_get_by_name("max77823-charger");
+	u8 reg_data = 0;
+
+	cp_usb_enable = enable;
+
+	if (psy) {
+		struct max77823_charger_data *charger =
+			container_of(psy, struct max77823_charger_data, psy_chg);
+
+		if (enable) {
+			max77823_read_reg(charger->pmic_i2c, MAX77823_PMIC_SAFEOUT_LDO_Control,
+					  &reg_data);
+			reg_data |= MAX77823_SAFEOUT2;
+			max77823_write_reg(charger->pmic_i2c, MAX77823_PMIC_SAFEOUT_LDO_Control,
+					   reg_data);
+		} else {
+			max77823_read_reg(charger->pmic_i2c, MAX77823_PMIC_SAFEOUT_LDO_Control,
+					  &reg_data);
+			reg_data &= ~MAX77823_SAFEOUT2;
+			max77823_write_reg(charger->pmic_i2c, MAX77823_PMIC_SAFEOUT_LDO_Control,
+					   reg_data);
+		}
+	}
+
+	pr_info("[%s]CP_USB(%d) REG(0x%x) DATA(0x%x)\n", __func__,
+		enable, MAX77823_PMIC_SAFEOUT_LDO_Control, reg_data);
+}
+
+static void wpc_detect_work(struct work_struct *work)
+{
+	struct max77823_charger_data *charger = container_of(work,
+						struct max77823_charger_data,
+						wpc_work.work);
+	int wc_w_state;
+	int retry_cnt;
+	union power_supply_propval value;
+	u8 reg_data;
+
+	pr_info("%s\n", __func__);
+
+	max77823_read_reg(charger->i2c,
+			  MAX77823_CHG_INT_MASK, &reg_data);
+	reg_data &= ~(1 << 5);
+	max77823_write_reg(charger->i2c,
+		MAX77823_CHG_INT_MASK, reg_data);
+
+	/* check and unlock */
+	check_charger_unlock_state(charger);
+
+	retry_cnt = 0;
+	do {
+		max77823_read_reg(charger->i2c,
+				  MAX77823_CHG_INT_OK, &reg_data);
+		wc_w_state = (reg_data & MAX77823_WCIN_OK)
+			>> MAX77823_WCIN_OK_SHIFT;
+		msleep(50);
+	} while((retry_cnt++ < 2) && (wc_w_state == 0));
+
+	if ((charger->wc_w_state == 0) && (wc_w_state == 1)) {
+		value.intval = 1;
+		psy_do_property("wireless", set,
+				POWER_SUPPLY_PROP_ONLINE, value);
+		pr_info("%s: wpc activated, set V_INT as PN\n",
+				__func__);
+	} else if ((charger->wc_w_state == 1) && (wc_w_state == 0)) {
+		if (!charger->is_charging)
+			max77823_set_charger_state(charger, true);
+
+		retry_cnt = 0;
+		do {
+			max77823_read_reg(charger->i2c,
+					  MAX77823_CHG_DETAILS_01, &reg_data);
+			reg_data = ((reg_data & MAX77823_CHG_DTLS)
+				    >> MAX77823_CHG_DTLS_SHIFT);
+			msleep(50);
+		} while((retry_cnt++ < 2) && (reg_data == 0x8));
+		pr_info("%s: reg_data: 0x%x, charging: %d\n", __func__,
+			reg_data, charger->is_charging);
+		if (!charger->is_charging)
+			max77823_set_charger_state(charger, false);
+		if ((reg_data != 0x08)
+		    && (charger->cable_type == POWER_SUPPLY_TYPE_WIRELESS)) {
+			pr_info("%s: wpc uvlo, but charging\n", __func__);
+			queue_delayed_work(charger->wqueue, &charger->wpc_work,
+					   msecs_to_jiffies(500));
+			return;
+		} else {
+			value.intval = 0;
+			psy_do_property("wireless", set,
+					POWER_SUPPLY_PROP_ONLINE, value);
+			pr_info("%s: wpc deactivated, set V_INT as PD\n",
+					__func__);
+		}
+	}
+	pr_info("%s: w(%d to %d)\n", __func__,
+		charger->wc_w_state, wc_w_state);
+
+	charger->wc_w_state = wc_w_state;
+
+	wake_unlock(&charger->wpc_wake_lock);
+}
+
+static irqreturn_t wpc_charger_irq(int irq, void *data)
+{
+	struct max77823_charger_data *charger = data;
+	unsigned long delay;
+	u8 reg_data;
+
+	max77823_read_reg(charger->i2c,
+		MAX77823_CHG_INT_MASK, &reg_data);
+	reg_data |= (1 << 5);
+	max77823_write_reg(charger->i2c,
+		MAX77823_CHG_INT_MASK, reg_data);
+
+	wake_lock(&charger->wpc_wake_lock);
+#ifdef CONFIG_SAMSUNG_BATTERY_FACTORY
+	delay = msecs_to_jiffies(0);
+#else
+	if (charger->wc_w_state)
+		delay = msecs_to_jiffies(500);
+	else
+		delay = msecs_to_jiffies(0);
+#endif
+	queue_delayed_work(charger->wqueue, &charger->wpc_work,
+			delay);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t max77823_batp_irq(int irq, void *data)
+{
+	struct max77823_charger_data *charger = data;
+	union power_supply_propval value;
+	u8 reg_data;
+
+	pr_info("%s : irq(%d)\n", __func__, irq);
+
+	max77823_read_reg(charger->i2c,
+			  MAX77823_CHG_INT_MASK, &reg_data);
+	reg_data |= (1 << 2);
+	max77823_write_reg(charger->i2c,
+		MAX77823_CHG_INT_MASK, reg_data);
+
+	check_charger_unlock_state(charger);
+
+	max77823_read_reg(charger->i2c,
+			  MAX77823_CHG_INT_OK,
+			  &reg_data);
+
+	if (!(reg_data & MAX77823_BATP_OK))
+		psy_do_property("battery", set, POWER_SUPPLY_PROP_PRESENT, value);
+
+	max77823_read_reg(charger->i2c,
+		MAX77823_CHG_INT_MASK, &reg_data);
+	reg_data &= ~(1 << 2);
+	max77823_write_reg(charger->i2c,
+		MAX77823_CHG_INT_MASK, reg_data);
+
+	return IRQ_HANDLED;
+}
+
+
+static irqreturn_t max77823_bypass_irq(int irq, void *data)
+{
+	struct max77823_charger_data *charger = data;
+	u8 dtls_02;
+	u8 byp_dtls;
+	u8 chg_cnfg_00;
+	u8 vbus_state;
+#ifdef CONFIG_USB_HOST_NOTIFY
+	struct otg_notify *o_notify;
+
+	o_notify = get_otg_notify();
+#endif
+
+	pr_info("%s: irq(%d)\n", __func__, irq);
+
+	/* check and unlock */
+	check_charger_unlock_state(charger);
+
+	max77823_read_reg(charger->i2c,
+			  MAX77823_CHG_DETAILS_02,
+			  &dtls_02);
+
+	byp_dtls = ((dtls_02 & MAX77823_BYP_DTLS) >>
+				MAX77823_BYP_DTLS_SHIFT);
+	pr_info("%s: BYP_DTLS(0x%02x)\n", __func__, byp_dtls);
+	vbus_state = max77823_get_vbus_state(charger);
+
+	if (byp_dtls & 0x1) {
+		pr_info("%s: bypass overcurrent limit\n", __func__);
+#ifdef CONFIG_USB_HOST_NOTIFY
+		send_otg_notify(o_notify, NOTIFY_EVENT_OVERCURRENT, 0);
+#endif
+		/* disable the register values just related to OTG and
+		   keep the values about the charging */
+		max77823_read_reg(charger->i2c,
+			MAX77823_CHG_CNFG_00, &chg_cnfg_00);
+		chg_cnfg_00 &= ~(CHG_CNFG_00_OTG_MASK
+				| CHG_CNFG_00_BOOST_MASK
+				| CHG_CNFG_00_DIS_MUIC_CTRL_MASK);
+		max77823_write_reg(charger->i2c,
+					MAX77823_CHG_CNFG_00,
+					chg_cnfg_00);
+	}
+	return IRQ_HANDLED;
+}
+
+static void max77823_chgin_isr_work(struct work_struct *work)
+{
+	struct max77823_charger_data *charger = container_of(work,
+				struct max77823_charger_data, chgin_work);
+	u8 chgin_dtls, chg_dtls, chg_cnfg_00, reg_data;
+	u8 prev_chgin_dtls = 0xff;
+	int battery_health;
+	union power_supply_propval value;
+	int stable_count = 0;
+
+	wake_lock(&charger->chgin_wake_lock);
+
+	max77823_read_reg(charger->i2c,
+			  MAX77823_CHG_INT_MASK, &reg_data);
+	reg_data |= (1 << 6);
+	max77823_write_reg(charger->i2c,
+		MAX77823_CHG_INT_MASK, reg_data);
+
+	while (1) {
+		psy_do_property("battery", get,
+				POWER_SUPPLY_PROP_HEALTH, value);
+		battery_health = value.intval;
+
+		max77823_read_reg(charger->i2c,
+				MAX77823_CHG_DETAILS_00,
+				&chgin_dtls);
+		chgin_dtls = ((chgin_dtls & MAX77823_CHGIN_DTLS) >>
+				MAX77823_CHGIN_DTLS_SHIFT);
+		max77823_read_reg(charger->i2c,
+				MAX77823_CHG_DETAILS_01, &chg_dtls);
+		chg_dtls = ((chg_dtls & MAX77823_CHG_DTLS) >>
+				MAX77823_CHG_DTLS_SHIFT);
+		max77823_read_reg(charger->i2c,
+			MAX77823_CHG_CNFG_00, &chg_cnfg_00);
+
+		if (prev_chgin_dtls == chgin_dtls)
+			stable_count++;
+		else
+			stable_count = 0;
+		if (stable_count > 10) {
+			pr_info("%s: irq(%d), chgin(0x%x), chg_dtls(0x%x) prev 0x%x\n",
+					__func__, charger->irq_chgin,
+					chgin_dtls, chg_dtls, prev_chgin_dtls);
+			if (charger->is_charging) {
+				if ((chgin_dtls == 0x02) && \
+					(battery_health != POWER_SUPPLY_HEALTH_OVERVOLTAGE)) {
+					pr_info("%s: charger is over voltage\n",
+							__func__);
+					value.intval = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+					psy_do_property("battery", set,
+						POWER_SUPPLY_PROP_HEALTH, value);
+				} else if (((chgin_dtls == 0x0) || (chgin_dtls == 0x01)) &&(chg_dtls & 0x08) && \
+						(chg_cnfg_00 & MAX77823_MODE_BUCK) && \
+						(chg_cnfg_00 & MAX77823_MODE_CHGR) && \
+						(battery_health != POWER_SUPPLY_HEALTH_UNDERVOLTAGE) && \
+						(charger->cable_type != POWER_SUPPLY_TYPE_WIRELESS)) {
+					pr_info("%s, vbus_state : 0x%d, chg_state : 0x%d\n", __func__, chgin_dtls, chg_dtls);
+					pr_info("%s: vBus is undervoltage\n", __func__);
+					value.intval = POWER_SUPPLY_HEALTH_UNDERVOLTAGE;
+					psy_do_property("battery", set,
+							POWER_SUPPLY_PROP_HEALTH, value);
+				} else if ((battery_health == \
+							POWER_SUPPLY_HEALTH_OVERVOLTAGE) &&
+						(chgin_dtls != 0x02)) {
+					pr_info("%s: vbus_state : 0x%d, chg_state : 0x%d\n", __func__, chgin_dtls, chg_dtls);
+					pr_info("%s: overvoltage->normal\n", __func__);
+					value.intval = POWER_SUPPLY_HEALTH_GOOD;
+					psy_do_property("battery", set,
+							POWER_SUPPLY_PROP_HEALTH, value);
+				} else if ((battery_health == \
+							POWER_SUPPLY_HEALTH_UNDERVOLTAGE) &&
+						!((chgin_dtls == 0x0) || (chgin_dtls == 0x01))){
+					pr_info("%s: vbus_state : 0x%d, chg_state : 0x%d\n", __func__, chgin_dtls, chg_dtls);
+					pr_info("%s: undervoltage->normal\n", __func__);
+					value.intval = POWER_SUPPLY_HEALTH_GOOD;
+					psy_do_property("battery", set,
+							POWER_SUPPLY_PROP_HEALTH, value);
+					max77823_set_input_current(charger,
+							charger->charging_current_max);
+				}
+			}
+			break;
+		}
+
+		prev_chgin_dtls = chgin_dtls;
+		msleep(100);
+	}
+	max77823_read_reg(charger->i2c,
+		MAX77823_CHG_INT_MASK, &reg_data);
+	reg_data &= ~(1 << 6);
+	max77823_write_reg(charger->i2c,
+		MAX77823_CHG_INT_MASK, reg_data);
+
+	wake_unlock(&charger->chgin_wake_lock);
+}
+
+static irqreturn_t max77823_chgin_irq(int irq, void *data)
+{
+	struct max77823_charger_data *charger = data;
+	queue_work(charger->wqueue, &charger->chgin_work);
+
+	return IRQ_HANDLED;
+}
+
+/* register chgin isr after sec_battery_probe */
+static void max77823_chgin_init_work(struct work_struct *work)
+{
+	struct max77823_charger_data *charger = container_of(work,
+						struct max77823_charger_data,
+						chgin_init_work.work);
+	int ret;
+
+	pr_info("%s \n", __func__);
+	ret = request_threaded_irq(charger->irq_chgin, NULL,
+			max77823_chgin_irq, 0, "chgin-irq", charger);
+	if (ret < 0) {
+		pr_err("%s: fail to request chgin IRQ: %d: %d\n",
+				__func__, charger->irq_chgin, ret);
+	}
+}
+
+#ifdef CONFIG_OF
+static int max77823_charger_parse_dt(struct max77823_charger_data *charger)
+{
+	struct device_node *np = of_find_node_by_name(NULL, "max77823-charger");
+	sec_battery_platform_data_t *pdata = charger->pdata;
+	int ret = 0;
+	int i, len;
+	const u32 *p;
+
+	if (np == NULL) {
+		pr_err("%s np NULL\n", __func__);
+	} else {
+		ret = of_property_read_u32(np, "battery,chg_float_voltage",
+					   &pdata->chg_float_voltage);
+	}
+
+	np = of_find_node_by_name(NULL, "battery");
+	if (!np) {
+		pr_err("%s np NULL\n", __func__);
+	} else {
+		p = of_get_property(np, "battery,input_current_limit", &len);
+
+		len = len / sizeof(u32);
+
+		pdata->charging_current = kzalloc(sizeof(sec_charging_current_t) * len,
+						  GFP_KERNEL);
+
+		for(i = 0; i < len; i++) {
+			ret = of_property_read_u32_index(np,
+				 "battery,input_current_limit", i,
+				 &pdata->charging_current[i].input_current_limit);
+			ret = of_property_read_u32_index(np,
+				 "battery,fast_charging_current", i,
+				 &pdata->charging_current[i].fast_charging_current);
+			ret = of_property_read_u32_index(np,
+				 "battery,full_check_current_1st", i,
+				 &pdata->charging_current[i].full_check_current_1st);
+			ret = of_property_read_u32_index(np,
+				 "battery,full_check_current_2nd", i,
+				 &pdata->charging_current[i].full_check_current_2nd);
+		}
+	}
+	return ret;
+}
+#endif
+
+static int __devinit max77823_charger_probe(struct platform_device *pdev)
+{
+	struct max77823_dev *max77823 = dev_get_drvdata(pdev->dev.parent);
+	struct max77823_platform_data *pdata = dev_get_platdata(max77823->dev);
+	struct max77823_charger_data *charger;
+	int ret = 0;
+	u8 reg_data;
+
+	pr_info("%s: Max77823 Charger Driver Loading\n", __func__);
+
+	charger = kzalloc(sizeof(*charger), GFP_KERNEL);
+	if (!charger)
+		return -ENOMEM;
+
+	pdata->charger_data = kzalloc(sizeof(sec_battery_platform_data_t), GFP_KERNEL);
+	if (!pdata->charger_data)
+		return -ENOMEM;
+
+	mutex_init(&charger->charger_mutex);
+
+	charger->dev = &pdev->dev;
+	charger->i2c = max77823->charger;
+	charger->pmic_i2c = max77823->i2c;
+	charger->pdata = pdata->charger_data;
+	charger->aicl_on = false;
+	charger->siop_level = 100;
+	charger->max77823_pdata = pdata;
+
+#if defined(CONFIG_OF)
+	ret = max77823_charger_parse_dt(charger);
+	if (ret < 0) {
+		pr_err("%s not found charger dt! ret[%d]\n",
+		       __func__, ret);
+	}
+#endif
+
+	platform_set_drvdata(pdev, charger);
+
+	charger->psy_chg.name		= "max77823-charger";
+	charger->psy_chg.type		= POWER_SUPPLY_TYPE_UNKNOWN;
+	charger->psy_chg.get_property	= max77823_chg_get_property;
+	charger->psy_chg.set_property	= max77823_chg_set_property;
+	charger->psy_chg.properties	= max77823_charger_props;
+	charger->psy_chg.num_properties	= ARRAY_SIZE(max77823_charger_props);
+
+	max77823_charger_initialize(charger);
+
+	(void) debugfs_create_file("max77823-regs",
+		S_IRUGO, NULL, (void *)charger, &max77823_debugfs_fops);
+
+	charger->wqueue =
+	    create_singlethread_workqueue(dev_name(&pdev->dev));
+	if (!charger->wqueue) {
+		pr_err("%s: Fail to Create Workqueue\n", __func__);
+		goto err_free;
+	}
+	wake_lock_init(&charger->chgin_wake_lock, WAKE_LOCK_SUSPEND,
+		       "charger->chgin");
+	INIT_WORK(&charger->chgin_work, max77823_chgin_isr_work);
+	INIT_DELAYED_WORK(&charger->chgin_init_work, max77823_chgin_init_work);
+	wake_lock_init(&charger->wpc_wake_lock, WAKE_LOCK_SUSPEND,
+					       "charger-wpc");
+	INIT_DELAYED_WORK(&charger->wpc_work, wpc_detect_work);
+	ret = power_supply_register(&pdev->dev, &charger->psy_chg);
+	if (ret) {
+		pr_err("%s: Failed to Register psy_chg\n", __func__);
+		goto err_power_supply_register;
+	}
+
+	if (charger->pdata->chg_irq) {
+		INIT_DELAYED_WORK(&charger->isr_work, max77823_chg_isr_work);
+
+		ret = request_threaded_irq(charger->pdata->chg_irq,
+				NULL, max77823_chg_irq_thread,
+				charger->pdata->chg_irq_attr,
+				"charger-irq", charger);
+		if (ret) {
+			pr_err("%s: Failed to Reqeust IRQ\n", __func__);
+			goto err_irq;
+		}
+
+			ret = enable_irq_wake(charger->pdata->chg_irq);
+			if (ret < 0)
+				pr_err("%s: Failed to Enable Wakeup Source(%d)\n",
+					__func__, ret);
+		}
+
+	charger->wc_w_irq = pdata->irq_base + MAX77823_CHG_IRQ_WCIN_I;
+	ret = request_threaded_irq(charger->wc_w_irq,
+				   NULL, wpc_charger_irq,
+				   IRQF_TRIGGER_FALLING,
+				   "wpc-int", charger);
+	if (ret) {
+		pr_err("%s: Failed to Reqeust IRQ\n", __func__);
+		goto err_wc_irq;
+	}
+
+	max77823_read_reg(charger->i2c,
+			  MAX77823_CHG_INT_OK, &reg_data);
+	charger->wc_w_state = (reg_data & MAX77823_WCIN_OK)
+		>> MAX77823_WCIN_OK_SHIFT;
+
+	charger->irq_chgin = pdata->irq_base + MAX77823_CHG_IRQ_CHGIN_I;
+	/* enable chgin irq after sec_battery_probe */
+	queue_delayed_work(charger->wqueue, &charger->chgin_init_work,
+			msecs_to_jiffies(3000));
+
+	charger->irq_bypass = pdata->irq_base + MAX77823_CHG_IRQ_BYP_I;
+	ret = request_threaded_irq(charger->irq_bypass, NULL,
+			max77823_bypass_irq, 0, "bypass-irq", charger);
+	if (ret < 0)
+		pr_err("%s: fail to request bypass IRQ: %d: %d\n",
+				__func__, charger->irq_bypass, ret);
+
+	charger->irq_batp = pdata->irq_base + MAX77823_CHG_IRQ_BATP_I;
+	ret = request_threaded_irq(charger->irq_batp, NULL,
+				   max77823_batp_irq, 0,
+				   "batp-irq", charger);
+	if (ret < 0)
+		pr_err("%s: fail to request bypass IRQ: %d: %d\n",
+		       __func__, charger->irq_batp, ret);
+
+	cp_usb_power_control(cp_usb_enable);
+
+	pr_info("%s: Max77823 Charger Driver Loaded\n", __func__);
+
+	return 0;
+
+err_wc_irq:
+	free_irq(charger->pdata->chg_irq, NULL);
+err_irq:
+	power_supply_unregister(&charger->psy_chg);
+err_power_supply_register:
+	destroy_workqueue(charger->wqueue);
+err_free:
+	kfree(charger);
+
+	return ret;
+}
+
+static int __devexit max77823_charger_remove(struct platform_device *pdev)
+{
+	struct max77823_charger_data *charger =
+		platform_get_drvdata(pdev);
+
+	destroy_workqueue(charger->wqueue);
+	free_irq(charger->wc_w_irq, NULL);
+	free_irq(charger->pdata->chg_irq, NULL);
+	power_supply_unregister(&charger->psy_chg);
+	kfree(charger);
+
+	return 0;
+}
+
+#if defined CONFIG_PM
+static int max77823_charger_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int max77823_charger_resume(struct device *dev)
+{
+	return 0;
+}
+#else
+#define max77823_charger_suspend NULL
+#define max77823_charger_resume NULL
+#endif
+
+static void max77823_charger_shutdown(struct device *dev)
+{
+	struct max77823_charger_data *charger =
+				dev_get_drvdata(dev);
+	u8 reg_data;
+
+	pr_info("%s: MAX77823 Charger driver shutdown\n", __func__);
+	if (!charger->i2c) {
+		pr_err("%s: no max77823 i2c client\n", __func__);
+		return;
+	}
+	reg_data = 0x04;
+	max77823_write_reg(charger->i2c,
+		MAX77823_CHG_CNFG_00, reg_data);
+
+	reg_data = 0x19;
+
+	max77823_write_reg(charger->i2c,
+		MAX77823_CHG_CNFG_09, reg_data);
+	reg_data = 0x19;
+	max77823_write_reg(charger->i2c,
+		MAX77823_CHG_CNFG_10, reg_data);
+	pr_info("func:%s \n", __func__);
+}
+
+#ifdef CONFIG_OF
+static struct of_device_id max77823_charger_dt_ids[] = {
+	{ .compatible = "samsung,max77823-charger" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, max77823_charger_dt_ids);
+#endif
+
+static SIMPLE_DEV_PM_OPS(max77823_charger_pm_ops, max77823_charger_suspend,
+			 max77823_charger_resume);
+
+static struct platform_driver max77823_charger_driver = {
+	.driver = {
+		.name = "max77823-charger",
+		.owner = THIS_MODULE,
+#ifdef CONFIG_PM
+		.pm = &max77823_charger_pm_ops,
+#endif
+		.shutdown = max77823_charger_shutdown,
+#ifdef CONFIG_OF
+		.of_match_table = max77823_charger_dt_ids,
+#endif
+	},
+	.probe = max77823_charger_probe,
+	.remove = __devexit_p(max77823_charger_remove),
+};
+
+static int __init max77823_charger_init(void)
+{
+	pr_info("%s : \n", __func__);
+	return platform_driver_register(&max77823_charger_driver);
+}
+
+static void __exit max77823_charger_exit(void)
+{
+	platform_driver_unregister(&max77823_charger_driver);
+}
+
+module_init(max77823_charger_init);
+module_exit(max77823_charger_exit);
+
+MODULE_DESCRIPTION("Samsung MAX77823 Charger Driver");
+MODULE_AUTHOR("Samsung Electronics");
+MODULE_LICENSE("GPL");
diff -Naur linux-3.18.14/drivers/battery/max77823_fuelgauge.c samsung/drivers/battery/max77823_fuelgauge.c
--- linux-3.18.14/drivers/battery/max77823_fuelgauge.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery/max77823_fuelgauge.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,2580 @@
+/*
+ *  max77823_fuelgauge.c
+ *  Samsung MAX77823 Fuel Gauge Driver
+ *
+ *  Copyright (C) 2012 Samsung Electronics
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#define DEBUG
+
+#include <linux/mfd/max77823-private.h>
+#include <linux/of_gpio.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+
+static enum power_supply_property max77823_fuelgauge_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_VOLTAGE_AVG,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CURRENT_AVG,
+	POWER_SUPPLY_PROP_CHARGE_FULL,
+	POWER_SUPPLY_PROP_ENERGY_NOW,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_TEMP_AMBIENT,
+};
+
+#ifdef CONFIG_FUELGAUGE_MAX77823_VOLTAGE_TRACKING
+static void max77823_init_regs(struct max77823_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+
+	if (max77823_read_reg(fuelgauge->i2c, MAX77823_REG_FILTERCFG, data) < 0)
+		return;
+
+	/* Clear average vcell (12 sec) */
+	data[0] &= 0x8f;
+
+	max77823_write_reg(fuelgauge->i2c, MAX77823_REG_FILTERCFG, data);
+}
+
+static void max77823_get_version(struct max77823_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+
+	if (max77823_read_reg(fuelgauge->i2c, MAX77823_REG_VERSION, data) < 0)
+		return;
+
+	pr_debug("MAX77823 Fuel-Gauge Ver %d%d\n",
+		 data[0], data[1]);
+}
+
+static void max77823_alert_init(struct max77823_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+
+	/* SALRT Threshold setting */
+	data[0] = fuelgauge->pdata->fuel_alert_soc;
+	data[1] = 0xff;
+	max77823_write_reg(fuelgauge->i2c, MAX77823_REG_SALRT_TH, data);
+
+	/* VALRT Threshold setting */
+	data[0] = 0x00;
+	data[1] = 0xff;
+	max77823_write_reg(fuelgauge->i2c, MAX77823_REG_VALRT_TH, data);
+
+	/* TALRT Threshold setting */
+	data[0] = 0x80;
+	data[1] = 0x7f;
+	max77823_write_reg(fuelgauge->i2c, MAX77823_REG_TALRT_TH, data);
+}
+
+static bool max77823_check_status(struct max77823_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	bool ret = false;
+
+	/* check if Smn was generated */
+	if (max77823_read_reg(fuelgauge->i2c, MAX77823_REG_STATUS, data) < 0)
+		return ret;
+
+	pr_info("%s: status_reg(%02x%02x)\n",
+		__func__, data[1], data[0]);
+
+	/* minimum SOC threshold exceeded. */
+	if (data[1] & (0x1 << 2))
+		ret = true;
+
+	/* clear status reg */
+	if (!ret) {
+		data[1] = 0;
+		max77823_write_reg(fuelgauge->i2c, MAX77823_REG_STATUS, data);
+		msleep(200);
+	}
+
+	return ret;
+}
+
+static int max77823_set_temperature(struct max77823_fuelgauge_data *fuelgauge,
+				    int temperature)
+{
+	u8 data[2];
+
+	data[0] = 0;
+	data[1] = temperature;
+	max77823_write_reg(fuelgauge->i2c, MAX77823_REG_TEMPERATURE, data);
+
+	pr_debug("%s: temperature to (%d)\n", __func__, temperature);
+
+	return temperature;
+}
+
+static int max77823_get_temperature(struct max77823_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	s32 temperature = 0;
+
+	if (max77823_read_reg(fuelgauge->i2c,
+			      MAX77823_REG_TEMPERATURE, data) < 0)
+		return -ERANGE;
+
+	/* data[] store 2's compliment format number */
+	if (data[1] & (0x1 << 7)) {
+		/* Negative */
+		temperature = ((~(data[1])) & 0xFF) + 1;
+		temperature *= (-1000);
+	} else {
+		temperature = data[1] & 0x7F;
+		temperature *= 1000;
+		temperature += data[0] * 39 / 10;
+	}
+
+	pr_debug("%s: temperature (%d)\n", __func__, temperature);
+
+	return temperature;
+}
+
+/* soc should be 0.01% unit */
+static int max77823_get_soc(struct max77823_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	int soc;
+
+	if (max77823_read_reg(fuelgauge->i2c, MAX77823_REG_SOC_VF, data) < 0)
+		return -EINVAL;
+
+	soc = ((data[1] * 100) + (data[0] * 100 / 256));
+
+	pr_debug("%s: raw capacity (%d)\n", __func__, soc);
+
+	return min(soc, 10000);
+}
+
+static int max77823_get_vfocv(struct max77823_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u32 vfocv = 0;
+
+	if (max77823_read_reg(fuelgauge->i2c, MAX77823_REG_VFOCV, data) < 0)
+		return -EINVAL;
+
+	vfocv = ((data[0] >> 3) + (data[1] << 5)) * 625 / 1000;
+
+	pr_debug("%s: vfocv (%d)\n", __func__, vfocv);
+
+	return vfocv;
+}
+
+static int max77823_get_vcell(struct max77823_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u32 vcell = 0;
+
+	if (max77823_read_reg(fuelgauge->i2c, MAX77823_REG_VCELL, data) < 0)
+		return -EINVAL;
+
+	vcell = ((data[0] >> 3) + (data[1] << 5)) * 625 / 1000;
+
+	pr_debug("%s: vcell (%d)\n", __func__, vcell);
+
+	return vcell;
+}
+
+static int max77823_get_avgvcell(struct max77823_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u32 avgvcell = 0;
+
+	if (max77823_read_reg(fuelgauge->i2c, MAX77823_REG_AVGVCELL, data) < 0)
+		return -EINVAL;
+
+	avgvcell = ((data[0] >> 3) + (data[1] << 5)) * 625 / 1000;
+
+	pr_debug("%s: avgvcell (%d)\n", __func__, avgvcell);
+
+	return avgvcell;
+}
+
+bool max77823_fg_init(struct max77823_fuelgauge_data *fuelgauge)
+{
+	/* initialize fuel gauge registers */
+	max77823_init_regs(fuelgauge);
+
+	max77823_get_version(fuelgauge);
+
+	return true;
+}
+
+bool max77823_fg_fuelalert_init(struct max77823_fuelgauge_data *fuelgauge,
+				int soc)
+{
+	u8 data[2];
+
+	/* 1. Set max77823 alert configuration. */
+	max77823_alert_init(fuelgauge);
+
+	if (max77823_read_reg(fuelgauge->i2c, MAX77823_REG_CONFIG, data)
+	    < 0)
+		return -1;
+
+	/*Enable Alert (Aen = 1) */
+	data[0] |= (0x1 << 2);
+
+	max77823_write_reg(fuelgauge, MAX77823_REG_CONFIG, data);
+
+	pr_debug("%s: config_reg(%02x%02x) irq(%d)\n",
+		 __func__, data[1], data[0], fuelgauge->pdata->fg_irq);
+
+	return true;
+}
+
+bool max77823_fg_is_fuelalerted(struct max77823_fuelgauge_data *fuelgauge)
+{
+	return max77823_check_status(fuelgauge);
+}
+
+bool max77823_fg_fuelalert_process(void *irq_data, bool is_fuel_alerted)
+{
+	struct max77823_fuelgauge_data *fuelgauge = irq_data;
+	u8 data[2];
+
+	/* update SOC */
+	/* max77823_get_soc(fuelgauge); */
+
+	if (is_fuel_alerted) {
+		if (max77823_read_reg(fuelgauge->i2c,
+				      MAX77823_REG_CONFIG, data) < 0)
+			return false;
+
+		data[1] |= (0x1 << 3);
+
+		max77823_write_reg(fuelgauge->i2c,
+				   MAX77823_REG_CONFIG, data);
+
+		pr_info("%s: Fuel-alert Alerted!! (%02x%02x)\n",
+			__func__, data[1], data[0]);
+	} else {
+		if (max77823_read_reg(fuelgauge->i2c,
+				      MAX77823_REG_CONFIG, data)
+		    < 0)
+			return false;
+
+		data[1] &= (~(0x1 << 3));
+
+		max77823_write_reg(fuelgauge->i2c,
+				   MAX77823_REG_CONFIG, data);
+
+		pr_info("%s: Fuel-alert Released!! (%02x%02x)\n",
+			__func__, data[1], data[0]);
+	}
+
+	max77823_read_reg(fuelgauge->i2c, MAX77823_REG_VCELL, data);
+	pr_debug("%s: MAX77823_REG_VCELL(%02x%02x)\n",
+		 __func__, data[1], data[0]);
+
+	max77823_read_reg(fuelgauge->i2c, MAX77823_REG_TEMPERATURE, data);
+	pr_debug("%s: MAX77823_REG_TEMPERATURE(%02x%02x)\n",
+		 __func__, data[1], data[0]);
+
+	max77823_read_reg(fuelgauge->i2c, MAX77823_REG_CONFIG, data);
+	pr_debug("%s: MAX77823_REG_CONFIG(%02x%02x)\n",
+		 __func__, data[1], data[0]);
+
+	max77823_read_reg(fuelgauge->i2c, MAX77823_REG_VFOCV, data);
+	pr_debug("%s: MAX77823_REG_VFOCV(%02x%02x)\n",
+		 __func__, data[1], data[0]);
+
+	max77823_read_reg(fuelgauge->i2c, MAX77823_REG_SOC_VF, data);
+	pr_debug("%s: MAX77823_REG_SOC_VF(%02x%02x)\n",
+		 __func__, data[1], data[0]);
+
+	pr_debug("%s: FUEL GAUGE IRQ (%d)\n",
+		 __func__,
+		 gpio_get_value(fuelgauge->pdata->fg_irq));
+
+	return true;
+}
+
+bool max77823_fg_full_charged(struct max77823_fuelgauge_data *fuelgauge)
+{
+	return true;
+}
+#endif
+
+#ifdef CONFIG_FUELGAUGE_MAX77823_COULOMB_COUNTING
+static void fg_test_print(struct max77823_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u32 average_vcell;
+	u16 w_data;
+	u32 temp;
+	u32 temp2;
+	u16 reg_data;
+
+	if (max77823_bulk_write(fuelgauge->i2c,
+				AVR_VCELL_REG, 2, data) < 0) {
+		pr_err("%s: Failed to read VCELL\n", __func__);
+		return;
+	}
+
+	w_data = (data[1]<<8) | data[0];
+
+	temp = (w_data & 0xFFF) * 78125;
+	average_vcell = temp / 1000000;
+
+	temp = ((w_data & 0xF000) >> 4) * 78125;
+	temp2 = temp / 1000000;
+	average_vcell += (temp2 << 4);
+
+	pr_info("%s: AVG_VCELL(%d), data(0x%04x)\n", __func__,
+		average_vcell, (data[1]<<8) | data[0]);
+
+	reg_data = max77823_read_word(fuelgauge->i2c, FULLCAP_REG);
+	pr_info("%s: FULLCAP(%d), data(0x%04x)\n", __func__,
+		reg_data/2, reg_data);
+
+	reg_data = max77823_read_word(fuelgauge->i2c, REMCAP_REP_REG);
+	pr_info("%s: REMCAP_REP(%d), data(0x%04x)\n", __func__,
+		reg_data/2, reg_data);
+
+	reg_data = max77823_read_word(fuelgauge->i2c, REMCAP_MIX_REG);
+	pr_info("%s: REMCAP_MIX(%d), data(0x%04x)\n", __func__,
+		reg_data/2, reg_data);
+
+	reg_data = max77823_read_word(fuelgauge->i2c, REMCAP_AV_REG);
+	pr_info("%s: REMCAP_AV(%d), data(0x%04x)\n", __func__,
+		reg_data/2, reg_data);
+
+	reg_data = max77823_read_word(fuelgauge->i2c, CONFIG_REG);
+	pr_info("%s: CONFIG_REG(0x%02x), data(0x%04x)\n", __func__,
+		CONFIG_REG, reg_data);
+
+}
+
+static void fg_periodic_read(struct max77823_fuelgauge_data *fuelgauge)
+{
+	u8 reg;
+	int i;
+	int data[0x10];
+	char *str = NULL;
+
+	str = kzalloc(sizeof(char)*1024, GFP_KERNEL);
+	if (!str)
+		return;
+
+	for (i = 0; i < 16; i++) {
+		for (reg = 0; reg < 0x10; reg++)
+			data[reg] = max77823_read_word(fuelgauge->i2c, reg + i * 0x10);
+
+		sprintf(str+strlen(str),
+			"%04xh,%04xh,%04xh,%04xh,%04xh,%04xh,%04xh,%04xh,",
+			data[0x00], data[0x01], data[0x02], data[0x03],
+			data[0x04], data[0x05], data[0x06], data[0x07]);
+		sprintf(str+strlen(str),
+			"%04xh,%04xh,%04xh,%04xh,%04xh,%04xh,%04xh,%04xh,",
+			data[0x08], data[0x09], data[0x0a], data[0x0b],
+			data[0x0c], data[0x0d], data[0x0e], data[0x0f]);
+		if (i == 4)
+			i = 13;
+	}
+
+	pr_info("%s", str);
+
+	kfree(str);
+}
+
+static int fg_read_vcell(struct max77823_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u32 vcell;
+	u16 w_data;
+	u32 temp;
+	u32 temp2;
+
+	if (max77823_bulk_read(fuelgauge->i2c, VCELL_REG, 2, data) < 0) {
+		pr_err("%s: Failed to read VCELL\n", __func__);
+		return -1;
+	}
+
+	w_data = (data[1]<<8) | data[0];
+
+	temp = (w_data & 0xFFF) * 78125;
+	vcell = temp / 1000000;
+
+	temp = ((w_data & 0xF000) >> 4) * 78125;
+	temp2 = temp / 1000000;
+	vcell += (temp2 << 4);
+
+	if (!(fuelgauge->info.pr_cnt % PRINT_COUNT))
+		pr_info("%s: VCELL(%d), data(0x%04x)\n",
+			__func__, vcell, (data[1]<<8) | data[0]);
+
+	return vcell;
+}
+
+static int fg_read_vfocv(struct max77823_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u32 vfocv = 0;
+	u16 w_data;
+	u32 temp;
+	u32 temp2;
+
+	if (max77823_bulk_read(fuelgauge->i2c, VFOCV_REG, 2, data) < 0) {
+		pr_err("%s: Failed to read VFOCV\n", __func__);
+		return -1;
+	}
+
+	w_data = (data[1]<<8) | data[0];
+
+	temp = (w_data & 0xFFF) * 78125;
+	vfocv = temp / 1000000;
+
+	temp = ((w_data & 0xF000) >> 4) * 78125;
+	temp2 = temp / 1000000;
+	vfocv += (temp2 << 4);
+
+	return vfocv;
+}
+
+static int fg_read_avg_vcell(struct max77823_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u32 avg_vcell = 0;
+	u16 w_data;
+	u32 temp;
+	u32 temp2;
+
+	if (max77823_bulk_read(fuelgauge->i2c, AVR_VCELL_REG,
+			       2, data) < 0) {
+		pr_err("%s: Failed to read AVG_VCELL\n", __func__);
+		return -1;
+	}
+
+	w_data = (data[1]<<8) | data[0];
+
+	temp = (w_data & 0xFFF) * 78125;
+	avg_vcell = temp / 1000000;
+
+	temp = ((w_data & 0xF000) >> 4) * 78125;
+	temp2 = temp / 1000000;
+	avg_vcell += (temp2 << 4);
+
+	return avg_vcell;
+}
+
+static int fg_check_battery_present(struct max77823_fuelgauge_data *fuelgauge)
+{
+	u8 status_data[2];
+	int ret = 1;
+
+	/* 1. Check Bst bit */
+	if (max77823_bulk_read(fuelgauge->i2c, STATUS_REG,
+			       2, status_data) < 0) {
+		pr_err("%s: Failed to read STATUS_REG\n", __func__);
+		return 0;
+	}
+
+	if (status_data[0] & (0x1 << 3)) {
+		pr_info("%s: addr(0x01), data(0x%04x)\n", __func__,
+			(status_data[1]<<8) | status_data[0]);
+		pr_info("%s: battery is absent!!\n", __func__);
+		ret = 0;
+	}
+
+	return ret;
+}
+
+static int fg_write_temp(struct max77823_fuelgauge_data *fuelgauge,
+			 int temperature)
+{
+	u8 data[2];
+
+	data[0] = (temperature%10) * 1000 / 39;
+	data[1] = temperature / 10;
+	max77823_bulk_read(fuelgauge->i2c, TEMPERATURE_REG,
+			   2, data);
+
+	pr_debug("%s: temperature to (%d, 0x%02x%02x)\n",
+		__func__, temperature, data[1], data[0]);
+
+	return temperature;
+}
+
+static int fg_read_temp(struct max77823_fuelgauge_data *fuelgauge)
+{
+	u8 data[2] = {0, 0};
+	int temper = 0;
+
+	if (fg_check_battery_present(fuelgauge)) {
+		if (max77823_bulk_read(fuelgauge->i2c,
+				       TEMPERATURE_REG, 2, data) < 0) {
+			pr_err("%s: Failed to read TEMPERATURE_REG\n",
+				__func__);
+			return -1;
+		}
+
+		if (data[1]&(0x1 << 7)) {
+			temper = ((~(data[1]))&0xFF)+1;
+			temper *= (-1000);
+			temper -= ((~((int)data[0]))+1) * 39 / 10;
+		} else {
+			temper = data[1] & 0x7f;
+			temper *= 1000;
+			temper += data[0] * 39 / 10;
+		}
+	} else
+		temper = 20000;
+
+	if (!(fuelgauge->info.pr_cnt % PRINT_COUNT))
+		pr_info("%s: TEMPERATURE(%d), data(0x%04x)\n",
+			__func__, temper, (data[1]<<8) | data[0]);
+
+	return temper/100;
+}
+
+/* soc should be 0.1% unit */
+static int fg_read_vfsoc(struct max77823_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	int soc;
+
+	if (max77823_bulk_read(fuelgauge->i2c, VFSOC_REG,
+			       2, data) < 0) {
+		pr_err("%s: Failed to read VFSOC\n", __func__);
+		return -1;
+	}
+
+	soc = ((data[1] * 100) + (data[0] * 100 / 256)) / 10;
+
+	return min(soc, 1000);
+}
+
+/* soc should be 0.1% unit */
+static int fg_read_avsoc(struct max77823_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	int soc;
+
+	if (max77823_bulk_read(fuelgauge->i2c, SOCAV_REG,
+			       2, data) < 0) {
+		pr_err("%s: Failed to read AVSOC\n", __func__);
+		return -1;
+	}
+
+	soc = ((data[1] * 100) + (data[0] * 100 / 256)) / 10;
+
+	return min(soc, 1000);
+}
+
+/* soc should be 0.1% unit */
+static int fg_read_soc(struct max77823_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	int soc;
+
+	if (max77823_bulk_read(fuelgauge->i2c, SOCREP_REG, 2, data) < 0) {
+		pr_err("%s: Failed to read SOCREP\n", __func__);
+		return -1;
+	}
+
+	soc = ((data[1] * 100) + (data[0] * 100 / 256)) / 10;
+
+	pr_debug("%s: raw capacity (%d)\n", __func__, soc);
+
+	if (!(fuelgauge->info.pr_cnt % PRINT_COUNT))
+		pr_debug("%s: raw capacity (%d), data(0x%04x)\n",
+			 __func__, soc, (data[1]<<8) | data[0]);
+
+	return min(soc, 1000);
+}
+
+/* soc should be 0.01% unit */
+static int fg_read_rawsoc(struct max77823_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	int soc;
+
+	if (max77823_bulk_read(fuelgauge->i2c, SOCREP_REG,
+			       2, data) < 0) {
+		pr_err("%s: Failed to read SOCREP\n", __func__);
+		return -1;
+	}
+
+	soc = (data[1] * 100) + (data[0] * 100 / 256);
+
+	pr_debug("%s: raw capacity (0.01%%) (%d)\n",
+		 __func__, soc);
+
+	if (!(fuelgauge->info.pr_cnt % PRINT_COUNT))
+		pr_debug("%s: raw capacity (%d), data(0x%04x)\n",
+			 __func__, soc, (data[1]<<8) | data[0]);
+
+	return min(soc, 10000);
+}
+
+static int fg_read_fullcap(struct max77823_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	int ret;
+
+	if (max77823_bulk_read(fuelgauge->i2c, FULLCAP_REG,
+			       2, data) < 0) {
+		pr_err("%s: Failed to read FULLCAP\n", __func__);
+		return -1;
+	}
+
+	ret = (data[1] << 8) + data[0];
+
+	return ret;
+}
+
+static int fg_read_mixcap(struct max77823_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	int ret;
+
+	if (max77823_bulk_read(fuelgauge->i2c, REMCAP_MIX_REG,
+			       2, data) < 0) {
+		pr_err("%s: Failed to read REMCAP_MIX_REG\n",
+		       __func__);
+		return -1;
+	}
+
+	ret = (data[1] << 8) + data[0];
+
+	return ret;
+}
+
+static int fg_read_avcap(struct max77823_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	int ret;
+
+	if (max77823_bulk_read(fuelgauge->i2c, REMCAP_AV_REG,
+			       2, data) < 0) {
+		pr_err("%s: Failed to read REMCAP_AV_REG\n",
+		       __func__);
+		return -1;
+	}
+
+	ret = (data[1] << 8) + data[0];
+
+	return ret;
+}
+
+static int fg_read_repcap(struct max77823_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	int ret;
+
+	if (max77823_bulk_read(fuelgauge->i2c, REMCAP_REP_REG,
+			       2, data) < 0) {
+		pr_err("%s: Failed to read REMCAP_REP_REG\n",
+		       __func__);
+		return -1;
+	}
+
+	ret = (data[1] << 8) + data[0];
+
+	return ret;
+}
+
+static int fg_read_current(struct max77823_fuelgauge_data *fuelgauge, int unit)
+{
+	u8 data1[2], data2[2];
+	u32 temp, sign;
+	s32 i_current;
+	s32 avg_current;
+
+	if (max77823_bulk_read(fuelgauge->i2c, CURRENT_REG,
+			      2, data1) < 0) {
+		pr_err("%s: Failed to read CURRENT\n", __func__);
+		return -1;
+	}
+
+	if (max77823_bulk_read(fuelgauge->i2c, AVG_CURRENT_REG,
+			       2, data2) < 0) {
+		pr_err("%s: Failed to read AVERAGE CURRENT\n", __func__);
+		return -1;
+	}
+
+	temp = ((data1[1]<<8) | data1[0]) & 0xFFFF;
+	if (temp & (0x1 << 15)) {
+		sign = NEGATIVE;
+		temp = (~temp & 0xFFFF) + 1;
+	} else
+		sign = POSITIVE;
+
+	/* 1.5625uV/0.01Ohm(Rsense) = 156.25uA */
+	switch (unit) {
+	case SEC_BATTEY_CURRENT_UA:
+		i_current = temp * 15625 / 100;
+		break;
+	case SEC_BATTEY_CURRENT_MA:
+	default:
+		i_current = temp * 15625 / 100000;
+	}
+
+	if (sign)
+		i_current *= -1;
+
+	temp = ((data2[1]<<8) | data2[0]) & 0xFFFF;
+	if (temp & (0x1 << 15)) {
+		sign = NEGATIVE;
+		temp = (~temp & 0xFFFF) + 1;
+	} else
+		sign = POSITIVE;
+
+	/* 1.5625uV/0.01Ohm(Rsense) = 156.25uA */
+	avg_current = temp * 15625 / 100000;
+	if (sign)
+		avg_current *= -1;
+
+	if (!(fuelgauge->info.pr_cnt++ % PRINT_COUNT)) {
+		fg_test_print(fuelgauge);
+		pr_info("%s: CURRENT(%dmA), AVG_CURRENT(%dmA)\n",
+			__func__, i_current, avg_current);
+		fuelgauge->info.pr_cnt = 1;
+		/* Read max77823's all registers every 5 minute. */
+		fg_periodic_read(fuelgauge);
+	}
+
+	return i_current;
+}
+
+static int fg_read_avg_current(struct max77823_fuelgauge_data *fuelgauge, int unit)
+{
+	u8  data2[2];
+	u32 temp, sign;
+	s32 avg_current;
+
+	if (max77823_bulk_read(fuelgauge->i2c, AVG_CURRENT_REG,
+			       2, data2) < 0) {
+		pr_err("%s: Failed to read AVERAGE CURRENT\n",
+		       __func__);
+		return -1;
+	}
+
+	temp = ((data2[1]<<8) | data2[0]) & 0xFFFF;
+	if (temp & (0x1 << 15)) {
+		sign = NEGATIVE;
+		temp = (~temp & 0xFFFF) + 1;
+	} else
+		sign = POSITIVE;
+
+	/* 1.5625uV/0.01Ohm(Rsense) = 156.25uA */
+	switch (unit) {
+	case SEC_BATTEY_CURRENT_UA:
+		avg_current = temp * 15625 / 100;
+		break;
+	case SEC_BATTEY_CURRENT_MA:
+	default:
+		avg_current = temp * 15625 / 100000;
+	}
+
+	if (sign)
+		avg_current *= -1;
+
+	return avg_current;
+}
+
+int fg_reset_soc(struct max77823_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	int vfocv, fullcap;
+
+	/* delay for current stablization */
+	msleep(500);
+
+	pr_info("%s: Before quick-start - VCELL(%d), VFOCV(%d), VfSOC(%d), RepSOC(%d)\n",
+		__func__, fg_read_vcell(fuelgauge), fg_read_vfocv(fuelgauge),
+		fg_read_vfsoc(fuelgauge), fg_read_soc(fuelgauge));
+	pr_info("%s: Before quick-start - current(%d), avg current(%d)\n",
+		__func__, fg_read_current(fuelgauge, SEC_BATTEY_CURRENT_MA),
+		fg_read_avg_current(fuelgauge, SEC_BATTEY_CURRENT_MA));
+
+	if (fuelgauge->pdata->check_jig_status ||
+	    !fuelgauge->pdata->check_jig_status()) {
+		pr_info("%s : Return by No JIG_ON signal\n", __func__);
+		return 0;
+	}
+
+	max77823_write_word(fuelgauge->i2c, CYCLES_REG, 0);
+
+	if (max77823_bulk_read(fuelgauge->i2c, MISCCFG_REG,
+			       2, data) < 0) {
+		pr_err("%s: Failed to read MiscCFG\n", __func__);
+		return -1;
+	}
+
+	data[1] |= (0x1 << 2);
+	if (max77823_bulk_write(fuelgauge->i2c, MISCCFG_REG,
+				2, data) < 0) {
+		pr_err("%s: Failed to write MiscCFG\n", __func__);
+		return -1;
+	}
+
+	msleep(250);
+	max77823_write_word(fuelgauge->i2c, FULLCAP_REG,
+			    fuelgauge->battery_data->Capacity);
+	msleep(500);
+
+	pr_info("%s: After quick-start - VCELL(%d), VFOCV(%d), VfSOC(%d), RepSOC(%d)\n",
+		__func__, fg_read_vcell(fuelgauge), fg_read_vfocv(fuelgauge),
+		fg_read_vfsoc(fuelgauge), fg_read_soc(fuelgauge));
+	pr_info("%s: After quick-start - current(%d), avg current(%d)\n",
+		__func__, fg_read_current(fuelgauge, SEC_BATTEY_CURRENT_MA),
+		fg_read_avg_current(fuelgauge, SEC_BATTEY_CURRENT_MA));
+
+	max77823_write_word(fuelgauge->i2c, CYCLES_REG, 0x00a0);
+
+/* P8 is not turned off by Quickstart @3.4V
+ * (It's not a problem, depend on mode data)
+ * Power off for factory test(File system, etc..) */
+	vfocv = fg_read_vfocv(fuelgauge);
+	if (vfocv < POWER_OFF_VOLTAGE_LOW_MARGIN) {
+		pr_info("%s: Power off condition(%d)\n", __func__, vfocv);
+
+		fullcap = max77823_read_word(fuelgauge->i2c, FULLCAP_REG);
+
+		/* FullCAP * 0.009 */
+		max77823_write_word(fuelgauge->i2c, REMCAP_REP_REG,
+				    (u16)(fullcap * 9 / 1000));
+		msleep(200);
+		pr_info("%s: new soc=%d, vfocv=%d\n", __func__,
+			fg_read_soc(fuelgauge), vfocv);
+	}
+
+	pr_info("%s: Additional step - VfOCV(%d), VfSOC(%d), RepSOC(%d)\n",
+		__func__, fg_read_vfocv(fuelgauge),
+		fg_read_vfsoc(fuelgauge), fg_read_soc(fuelgauge));
+
+	return 0;
+}
+
+int fg_reset_capacity_by_jig_connection(struct max77823_fuelgauge_data *fuelgauge)
+{
+
+	pr_info("%s: DesignCap = Capacity - 1 (Jig Connection)\n", __func__);
+
+	return max77823_write_word(fuelgauge->i2c, DESIGNCAP_REG,
+				   fuelgauge->battery_data->Capacity-1);
+}
+
+int fg_adjust_capacity(struct max77823_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+
+	data[0] = 0;
+	data[1] = 0;
+
+	/* 1. Write RemCapREP(05h)=0; */
+	if (max77823_bulk_write(fuelgauge->i2c, REMCAP_REP_REG,
+				2, data) < 0) {
+		pr_err("%s: Failed to write RemCap_REP\n", __func__);
+		return -1;
+	}
+	msleep(200);
+
+	pr_info("%s: After adjust - RepSOC(%d)\n", __func__,
+		fg_read_soc(fuelgauge));
+
+	return 0;
+}
+
+void fg_low_batt_compensation(struct max77823_fuelgauge_data *fuelgauge,
+			      u32 level)
+{
+	int read_val;
+	u32 temp;
+
+	pr_info("%s: Adjust SOCrep to %d!!\n", __func__, level);
+
+	read_val = max77823_read_word(fuelgauge->i2c, FULLCAP_REG);
+	/* RemCapREP (05h) = FullCap(10h) x 0.0090 */
+	temp = read_val * (level*90) / 10000;
+	max77823_write_word(fuelgauge->i2c, REMCAP_REP_REG,
+			    (u16)temp);
+}
+
+static int fg_check_status_reg(struct max77823_fuelgauge_data *fuelgauge)
+{
+	u8 status_data[2];
+	int ret = 0;
+
+	/* 1. Check Smn was generatedread */
+	if (max77823_bulk_read(fuelgauge->i2c, STATUS_REG,
+			       2, status_data) < 0) {
+		pr_err("%s: Failed to read STATUS_REG\n", __func__);
+		return -1;
+	}
+	pr_info("%s: addr(0x00), data(0x%04x)\n", __func__,
+		(status_data[1]<<8) | status_data[0]);
+
+	if (status_data[1] & (0x1 << 2))
+		ret = 1;
+
+	/* 2. clear Status reg */
+	status_data[1] = 0;
+	if (max77823_bulk_write(fuelgauge->i2c, STATUS_REG,
+				2, status_data) < 0) {
+		pr_info("%s: Failed to write STATUS_REG\n", __func__);
+		return -1;
+	}
+
+	return ret;
+}
+
+int get_fuelgauge_value(struct max77823_fuelgauge_data *fuelgauge, int data)
+{
+	int ret;
+
+	switch (data) {
+	case FG_LEVEL:
+		ret = fg_read_soc(fuelgauge);
+		break;
+
+	case FG_TEMPERATURE:
+		ret = fg_read_temp(fuelgauge);
+		break;
+
+	case FG_VOLTAGE:
+		ret = fg_read_vcell(fuelgauge);
+		break;
+
+	case FG_CURRENT:
+		ret = fg_read_current(fuelgauge, SEC_BATTEY_CURRENT_MA);
+		break;
+
+	case FG_CURRENT_AVG:
+		ret = fg_read_avg_current(fuelgauge, SEC_BATTEY_CURRENT_MA);
+		break;
+
+	case FG_CHECK_STATUS:
+		ret = fg_check_status_reg(fuelgauge);
+		break;
+
+	case FG_RAW_SOC:
+		ret = fg_read_rawsoc(fuelgauge);
+		break;
+
+	case FG_VF_SOC:
+		ret = fg_read_vfsoc(fuelgauge);
+		break;
+
+	case FG_AV_SOC:
+		ret = fg_read_avsoc(fuelgauge);
+		break;
+
+	case FG_FULLCAP:
+		ret = fg_read_fullcap(fuelgauge);
+		break;
+
+	case FG_MIXCAP:
+		ret = fg_read_mixcap(fuelgauge);
+		break;
+
+	case FG_AVCAP:
+		ret = fg_read_avcap(fuelgauge);
+		break;
+
+	case FG_REPCAP:
+		ret = fg_read_repcap(fuelgauge);
+		break;
+
+	default:
+		ret = -1;
+		break;
+	}
+
+	return ret;
+}
+
+int max77823_alert_init(struct max77823_fuelgauge_data *fuelgauge, int soc)
+{
+	u8 misccgf_data[2];
+	u8 salrt_data[2];
+	u8 config_data[2];
+	u8 valrt_data[2];
+	u8 talrt_data[2];
+	u16 read_data = 0;
+
+	/* Using RepSOC */
+	if (max77823_bulk_read(fuelgauge->i2c, MISCCFG_REG, 2,
+			       misccgf_data) < 0) {
+		pr_err("%s: Failed to read MISCCFG_REG\n", __func__);
+		return -1;
+	}
+	misccgf_data[0] = misccgf_data[0] & ~(0x03);
+
+	if (max77823_bulk_write(fuelgauge->i2c, MISCCFG_REG,
+				2, misccgf_data) < 0) {
+		pr_info("%s: Failed to write MISCCFG_REG\n", __func__);
+		return -1;
+	}
+
+	/* SALRT Threshold setting */
+	salrt_data[1] = 0xff;
+	salrt_data[0] = soc;
+	if (max77823_bulk_write(fuelgauge->i2c, SALRT_THRESHOLD_REG,
+				2, salrt_data) < 0) {
+		pr_info("%s: Failed to write SALRT_THRESHOLD_REG\n", __func__);
+		return -1;
+	}
+
+	/* Reset VALRT Threshold setting (disable) */
+	valrt_data[1] = 0xFF;
+	valrt_data[0] = 0x00;
+	if (max77823_bulk_write(fuelgauge->i2c, VALRT_THRESHOLD_REG,
+				2, valrt_data) < 0) {
+		pr_info("%s: Failed to write VALRT_THRESHOLD_REG\n", __func__);
+		return -1;
+	}
+
+	read_data = max77823_read_word(fuelgauge->i2c, (u8)VALRT_THRESHOLD_REG);
+	if (read_data != 0xff00)
+		pr_err("%s: VALRT_THRESHOLD_REG is not valid (0x%x)\n",
+			__func__, read_data);
+
+	/* Reset TALRT Threshold setting (disable) */
+	talrt_data[1] = 0x7F;
+	talrt_data[0] = 0x80;
+	if (max77823_bulk_write(fuelgauge->i2c, TALRT_THRESHOLD_REG,
+				2, talrt_data) < 0) {
+		pr_info("%s: Failed to write TALRT_THRESHOLD_REG\n", __func__);
+		return -1;
+	}
+
+	read_data = max77823_read_word(fuelgauge->i2c, (u8)TALRT_THRESHOLD_REG);
+	if (read_data != 0x7f80)
+		pr_err("%s: TALRT_THRESHOLD_REG is not valid (0x%x)\n",
+			__func__, read_data);
+
+	/*mdelay(100);*/
+
+	/* Enable SOC alerts */
+	if (max77823_bulk_read(fuelgauge->i2c, CONFIG_REG,
+			       2, config_data) < 0) {
+		pr_err("%s: Failed to read CONFIG_REG\n", __func__);
+		return -1;
+	}
+	config_data[0] = config_data[0] | (0x1 << 2);
+
+	if (max77823_bulk_write(fuelgauge->i2c, CONFIG_REG,
+				2, config_data) < 0) {
+		pr_info("%s: Failed to write CONFIG_REG\n", __func__);
+		return -1;
+	}
+
+	pr_info("[%s] SALRT(0x%x%x), VALRT(0x%x%x), CONFIG(0x%x%x)\n",
+		__func__,
+		salrt_data[1], salrt_data[0],
+		valrt_data[1], valrt_data[0],
+		config_data[1], config_data[0]);
+
+	return 1;
+}
+
+void fg_fullcharged_compensation(struct max77823_fuelgauge_data *fuelgauge,
+		u32 is_recharging, bool pre_update)
+{
+	static int new_fullcap_data;
+
+	pr_info("%s: is_recharging(%d), pre_update(%d)\n",
+		__func__, is_recharging, pre_update);
+
+	new_fullcap_data =
+		max77823_read_word(fuelgauge->i2c, FULLCAP_REG);
+	if (new_fullcap_data < 0)
+		new_fullcap_data = fuelgauge->battery_data->Capacity;
+
+	/* compare with initial capacity */
+	if (new_fullcap_data >
+		(fuelgauge->battery_data->Capacity * 110 / 100)) {
+		pr_info("%s: [Case 1] capacity = 0x%04x, NewFullCap = 0x%04x\n",
+			__func__, fuelgauge->battery_data->Capacity,
+			new_fullcap_data);
+
+		new_fullcap_data =
+			(fuelgauge->battery_data->Capacity * 110) / 100;
+
+		max77823_write_word(fuelgauge->i2c, REMCAP_REP_REG,
+				    (u16)(new_fullcap_data));
+		max77823_write_word(fuelgauge->i2c, FULLCAP_REG,
+				    (u16)(new_fullcap_data));
+	} else if (new_fullcap_data <
+		(fuelgauge->battery_data->Capacity * 50 / 100)) {
+		pr_info("%s: [Case 5] capacity = 0x%04x, NewFullCap = 0x%04x\n",
+			__func__, fuelgauge->battery_data->Capacity,
+			new_fullcap_data);
+
+		new_fullcap_data =
+			(fuelgauge->battery_data->Capacity * 50) / 100;
+
+		max77823_write_word(fuelgauge->i2c, REMCAP_REP_REG,
+				    (u16)(new_fullcap_data));
+		max77823_write_word(fuelgauge->i2c, FULLCAP_REG,
+				    (u16)(new_fullcap_data));
+	} else {
+	/* compare with previous capacity */
+		if (new_fullcap_data >
+			(fuelgauge->info.previous_fullcap * 110 / 100)) {
+			pr_info("%s: [Case 2] previous_fullcap = 0x%04x, NewFullCap = 0x%04x\n",
+				__func__, fuelgauge->info.previous_fullcap,
+				new_fullcap_data);
+
+			new_fullcap_data =
+				(fuelgauge->info.previous_fullcap * 110) / 100;
+
+			max77823_write_word(fuelgauge->i2c, REMCAP_REP_REG,
+					    (u16)(new_fullcap_data));
+			max77823_write_word(fuelgauge->i2c, FULLCAP_REG,
+					    (u16)(new_fullcap_data));
+		} else if (new_fullcap_data <
+			(fuelgauge->info.previous_fullcap * 90 / 100)) {
+			pr_info("%s: [Case 3] previous_fullcap = 0x%04x, NewFullCap = 0x%04x\n",
+				__func__, fuelgauge->info.previous_fullcap,
+				new_fullcap_data);
+
+			new_fullcap_data =
+				(fuelgauge->info.previous_fullcap * 90) / 100;
+
+			max77823_write_word(fuelgauge->i2c, REMCAP_REP_REG,
+					    (u16)(new_fullcap_data));
+			max77823_write_word(fuelgauge->i2c, FULLCAP_REG,
+					    (u16)(new_fullcap_data));
+		} else {
+			pr_info("%s: [Case 4] previous_fullcap = 0x%04x, NewFullCap = 0x%04x\n",
+				__func__, fuelgauge->info.previous_fullcap,
+				new_fullcap_data);
+		}
+	}
+
+	/* 4. Write RepSOC(06h)=100%; */
+	max77823_write_word(fuelgauge->i2c, SOCREP_REG, (u16)(0x64 << 8));
+
+	/* 5. Write MixSOC(0Dh)=100%; */
+	max77823_write_word(fuelgauge->i2c, SOCMIX_REG, (u16)(0x64 << 8));
+
+	/* 6. Write AVSOC(0Eh)=100%; */
+	max77823_write_word(fuelgauge->i2c, SOCAV_REG, (u16)(0x64 << 8));
+
+	/* if pre_update case, skip updating PrevFullCAP value. */
+	if (!pre_update)
+		fuelgauge->info.previous_fullcap =
+			max77823_read_word(fuelgauge->i2c, FULLCAP_REG);
+
+	pr_info("%s: (A) FullCap = 0x%04x, RemCap = 0x%04x\n", __func__,
+		max77823_read_word(fuelgauge->i2c, FULLCAP_REG),
+		max77823_read_word(fuelgauge->i2c, REMCAP_REP_REG));
+
+	fg_periodic_read(fuelgauge);
+}
+
+void fg_check_vf_fullcap_range(struct max77823_fuelgauge_data *fuelgauge)
+{
+	static int new_vffullcap;
+	bool is_vffullcap_changed = true;
+
+	if (fuelgauge->pdata->check_jig_status &&
+	    fuelgauge->pdata->check_jig_status())
+		fg_reset_capacity_by_jig_connection(fuelgauge);
+
+	new_vffullcap = max77823_read_word(fuelgauge->i2c, FULLCAP_NOM_REG);
+	if (new_vffullcap < 0)
+		new_vffullcap = fuelgauge->battery_data->Capacity;
+
+	pr_info("[%s]vffullcap = %d\n", __func__, new_vffullcap);
+
+	/* compare with initial capacity */
+	if (new_vffullcap >
+		(fuelgauge->battery_data->Capacity * 110 / 100)) {
+		pr_info("%s: [Case 1] capacity = 0x%04x, NewVfFullCap = 0x%04x\n",
+			__func__, fuelgauge->battery_data->Capacity,
+			new_vffullcap);
+
+		new_vffullcap =
+			(fuelgauge->battery_data->Capacity * 110) / 100;
+
+		max77823_write_word(fuelgauge->i2c, DQACC_REG,
+				    (u16)(new_vffullcap / 4));
+		max77823_write_word(fuelgauge->i2c, DPACC_REG, (u16)0x3200);
+	} else if (new_vffullcap <
+		(fuelgauge->battery_data->Capacity * 50 / 100)) {
+		pr_info("%s: [Case 5] capacity = 0x%04x, NewVfFullCap = 0x%04x\n",
+			__func__, fuelgauge->battery_data->Capacity,
+			new_vffullcap);
+
+		new_vffullcap =
+			(fuelgauge->battery_data->Capacity * 50) / 100;
+
+		max77823_write_word(fuelgauge->i2c, DQACC_REG,
+				    (u16)(new_vffullcap / 4));
+		max77823_write_word(fuelgauge->i2c, DPACC_REG,
+				    (u16)0x3200);
+	} else {
+	/* compare with previous capacity */
+		if (new_vffullcap >
+			(fuelgauge->info.previous_vffullcap * 110 / 100)) {
+			pr_info("%s: [Case 2] previous_vffullcap = 0x%04x, NewVfFullCap = 0x%04x\n",
+				__func__, fuelgauge->info.previous_vffullcap,
+				new_vffullcap);
+
+			new_vffullcap =
+				(fuelgauge->info.previous_vffullcap * 110) /
+				100;
+
+			max77823_write_word(fuelgauge->i2c, DQACC_REG,
+					    (u16)(new_vffullcap / 4));
+			max77823_write_word(fuelgauge->i2c, DPACC_REG,
+					    (u16)0x3200);
+		} else if (new_vffullcap <
+			(fuelgauge->info.previous_vffullcap * 90 / 100)) {
+			pr_info("%s: [Case 3] previous_vffullcap = 0x%04x, NewVfFullCap = 0x%04x\n",
+				__func__, fuelgauge->info.previous_vffullcap,
+				new_vffullcap);
+
+			new_vffullcap =
+				(fuelgauge->info.previous_vffullcap * 90) / 100;
+
+			max77823_write_word(fuelgauge->i2c, DQACC_REG,
+					    (u16)(new_vffullcap / 4));
+			max77823_write_word(fuelgauge->i2c, DPACC_REG,
+					    (u16)0x3200);
+		} else {
+			pr_info("%s: [Case 4] previous_vffullcap = 0x%04x, NewVfFullCap = 0x%04x\n",
+				__func__, fuelgauge->info.previous_vffullcap,
+				new_vffullcap);
+			is_vffullcap_changed = false;
+		}
+	}
+
+	/* delay for register setting (dQacc, dPacc) */
+	if (is_vffullcap_changed)
+		msleep(300);
+
+	fuelgauge->info.previous_vffullcap =
+		max77823_read_word(fuelgauge->i2c, FULLCAP_NOM_REG);
+
+	if (is_vffullcap_changed)
+		pr_info("%s : VfFullCap(0x%04x), dQacc(0x%04x), dPacc(0x%04x)\n",
+			__func__,
+			max77823_read_word(fuelgauge->i2c, FULLCAP_NOM_REG),
+			max77823_read_word(fuelgauge->i2c, DQACC_REG),
+			max77823_read_word(fuelgauge->i2c, DPACC_REG));
+
+}
+
+void fg_set_full_charged(struct max77823_fuelgauge_data *fuelgauge)
+{
+	pr_info("[FG_Set_Full] (B) FullCAP(%d), RemCAP(%d)\n",
+		(max77823_read_word(fuelgauge->i2c, FULLCAP_REG)/2),
+		(max77823_read_word(fuelgauge->i2c, REMCAP_REP_REG)/2));
+
+	max77823_write_word(fuelgauge->i2c, FULLCAP_REG,
+		(u16)max77823_read_word(fuelgauge->i2c, REMCAP_REP_REG));
+
+	pr_info("[FG_Set_Full] (A) FullCAP(%d), RemCAP(%d)\n",
+		(max77823_read_word(fuelgauge->i2c, FULLCAP_REG)/2),
+		(max77823_read_word(fuelgauge->i2c, REMCAP_REP_REG)/2));
+}
+
+static void display_low_batt_comp_cnt(struct max77823_fuelgauge_data *fuelgauge)
+{
+	pr_info("[%d, %d], [%d, %d], ",
+			fuelgauge->info.low_batt_comp_cnt[0][0],
+			fuelgauge->info.low_batt_comp_cnt[0][1],
+			fuelgauge->info.low_batt_comp_cnt[1][0],
+			fuelgauge->info.low_batt_comp_cnt[1][1]);
+	pr_info("[%d, %d], [%d, %d], [%d, %d]\n",
+			fuelgauge->info.low_batt_comp_cnt[2][0],
+			fuelgauge->info.low_batt_comp_cnt[2][1],
+			fuelgauge->info.low_batt_comp_cnt[3][0],
+			fuelgauge->info.low_batt_comp_cnt[3][1],
+			fuelgauge->info.low_batt_comp_cnt[4][0],
+			fuelgauge->info.low_batt_comp_cnt[4][1]);
+}
+
+static void add_low_batt_comp_cnt(struct max77823_fuelgauge_data *fuelgauge,
+				int range, int level)
+{
+	int i;
+	int j;
+
+	/* Increase the requested count value, and reset others. */
+	fuelgauge->info.low_batt_comp_cnt[range-1][level/2]++;
+
+	for (i = 0; i < LOW_BATT_COMP_RANGE_NUM; i++) {
+		for (j = 0; j < LOW_BATT_COMP_LEVEL_NUM; j++) {
+			if (i == range-1 && j == level/2)
+				continue;
+			else
+				fuelgauge->info.low_batt_comp_cnt[i][j] = 0;
+		}
+	}
+}
+
+void prevent_early_poweroff(struct max77823_fuelgauge_data *fuelgauge,
+	int vcell, int *fg_soc)
+{
+	int soc = 0;
+	int read_val;
+
+	soc = fg_read_soc(fuelgauge);
+
+	/* No need to write REMCAP_REP in below normal cases */
+	if (soc > POWER_OFF_SOC_HIGH_MARGIN ||
+	    vcell > fuelgauge->battery_data->low_battery_comp_voltage)
+		return;
+
+	pr_info("%s: soc=%d, vcell=%d\n", __func__, soc, vcell);
+
+	if (vcell > POWER_OFF_VOLTAGE_HIGH_MARGIN) {
+		read_val = max77823_read_word(fuelgauge->i2c, FULLCAP_REG);
+		/* FullCAP * 0.013 */
+		max77823_write_word(fuelgauge->i2c, REMCAP_REP_REG,
+		(u16)(read_val * 13 / 1000));
+		msleep(200);
+		*fg_soc = fg_read_soc(fuelgauge);
+		pr_info("%s: new soc=%d, vcell=%d\n", __func__, *fg_soc, vcell);
+	}
+}
+
+void reset_low_batt_comp_cnt(struct max77823_fuelgauge_data *fuelgauge)
+{
+	memset(fuelgauge->info.low_batt_comp_cnt, 0,
+		sizeof(fuelgauge->info.low_batt_comp_cnt));
+}
+
+static int check_low_batt_comp_condition(
+	struct max77823_fuelgauge_data *fuelgauge,
+	int *nLevel)
+{
+	int i;
+	int j;
+	int ret = 0;
+
+	for (i = 0; i < LOW_BATT_COMP_RANGE_NUM; i++) {
+		for (j = 0; j < LOW_BATT_COMP_LEVEL_NUM; j++) {
+			if (fuelgauge->info.low_batt_comp_cnt[i][j] >=
+				MAX_LOW_BATT_CHECK_CNT) {
+				display_low_batt_comp_cnt(fuelgauge);
+				ret = 1;
+				*nLevel = j*2 + 1;
+				break;
+			}
+		}
+	}
+
+	return ret;
+}
+
+static int get_low_batt_threshold(struct max77823_fuelgauge_data *fuelgauge,
+				int range, int nCurrent, int level)
+{
+	int ret = 0;
+
+	ret = fuelgauge->battery_data->low_battery_table[range][OFFSET] +
+		((nCurrent *
+		fuelgauge->battery_data->low_battery_table[range][SLOPE]) /
+		1000);
+
+	return ret;
+}
+
+int low_batt_compensation(struct max77823_fuelgauge_data *fuelgauge,
+		int fg_soc, int fg_vcell, int fg_current)
+{
+	int fg_avg_current = 0;
+	int fg_min_current = 0;
+	int new_level = 0;
+	int i, table_size;
+
+	/* Not charging, Under low battery comp voltage */
+	if (fg_vcell <= fuelgauge->battery_data->low_battery_comp_voltage) {
+		fg_avg_current = fg_read_avg_current(fuelgauge,
+			SEC_BATTEY_CURRENT_MA);
+		fg_min_current = min(fg_avg_current, fg_current);
+
+		table_size =
+			sizeof(fuelgauge->battery_data->low_battery_table) /
+			(sizeof(s16)*TABLE_MAX);
+
+		for (i = 1; i < CURRENT_RANGE_MAX_NUM; i++) {
+			if ((fg_min_current >= fuelgauge->battery_data->
+				low_battery_table[i-1][RANGE]) &&
+				(fg_min_current < fuelgauge->battery_data->
+				low_battery_table[i][RANGE])) {
+				if (fg_soc >= 10 && fg_vcell <
+					get_low_batt_threshold(fuelgauge,
+					i, fg_min_current, 1)) {
+					add_low_batt_comp_cnt(
+						fuelgauge, i, 1);
+				} else {
+					reset_low_batt_comp_cnt(fuelgauge);
+				}
+			}
+		}
+
+		if (check_low_batt_comp_condition(fuelgauge, &new_level)) {
+			fg_low_batt_compensation(fuelgauge, new_level);
+			reset_low_batt_comp_cnt(fuelgauge);
+
+			/* Do not update soc right after
+			 * low battery compensation
+			 * to prevent from powering-off suddenly
+			 */
+			pr_info("%s: SOC is set to %d by low compensation!!\n",
+				__func__, fg_read_soc(fuelgauge));
+		}
+	}
+
+	/* Prevent power off over 3500mV */
+	prevent_early_poweroff(fuelgauge, fg_vcell, &fg_soc);
+
+	return fg_soc;
+}
+
+static bool is_booted_in_low_battery(struct max77823_fuelgauge_data *fuelgauge)
+{
+	int fg_vcell = get_fuelgauge_value(fuelgauge, FG_VOLTAGE);
+	int fg_current = get_fuelgauge_value(fuelgauge, FG_CURRENT);
+	int threshold = 0;
+
+	threshold = 3300 + ((fg_current * 17) / 100);
+
+	if (fg_vcell <= threshold)
+		return true;
+	else
+		return false;
+}
+
+static bool fuelgauge_recovery_handler(struct max77823_fuelgauge_data *fuelgauge)
+{
+	int current_soc;
+	int avsoc;
+	int temperature;
+
+	if (fuelgauge->info.soc >= LOW_BATTERY_SOC_REDUCE_UNIT) {
+		pr_err("%s: Reduce the Reported SOC by 1%%\n",
+			__func__);
+		current_soc =
+			get_fuelgauge_value(fuelgauge, FG_LEVEL) / 10;
+
+		if (current_soc) {
+			pr_info("%s: Returning to Normal discharge path\n",
+				__func__);
+			pr_info("%s: Actual SOC(%d) non-zero\n",
+				__func__, current_soc);
+			fuelgauge->info.is_low_batt_alarm = false;
+		} else {
+			temperature =
+				get_fuelgauge_value(fuelgauge, FG_TEMPERATURE);
+			avsoc =
+				get_fuelgauge_value(fuelgauge, FG_AV_SOC);
+
+			if ((fuelgauge->info.soc > avsoc) ||
+				(temperature < 0)) {
+				fuelgauge->info.soc -=
+					LOW_BATTERY_SOC_REDUCE_UNIT;
+				pr_err("%s: New Reduced RepSOC (%d)\n",
+					__func__, fuelgauge->info.soc);
+			} else
+				pr_info("%s: Waiting for recovery (AvSOC:%d)\n",
+					__func__, avsoc);
+		}
+	}
+
+	return fuelgauge->info.is_low_batt_alarm;
+}
+
+static int get_fuelgauge_soc(struct max77823_fuelgauge_data *fuelgauge)
+{
+	union power_supply_propval value;
+	int fg_soc = 0;
+	int fg_vfsoc;
+	int fg_vcell;
+	int fg_current;
+	int avg_current;
+	ktime_t	current_time;
+	struct timespec ts;
+	int fullcap_check_interval;
+
+	if (fuelgauge->info.is_low_batt_alarm)
+		if (fuelgauge_recovery_handler(fuelgauge)) {
+			fg_soc = fuelgauge->info.soc;
+			goto return_soc;
+		}
+
+#if defined(ANDROID_ALARM_ACTIVATED)
+	current_time = alarm_get_elapsed_realtime();
+	ts = ktime_to_timespec(current_time);
+#else
+	current_time = ktime_get_boottime();
+	ts = ktime_to_timespec(current_time);
+#endif
+
+	/* check fullcap range */
+	fullcap_check_interval =
+		(ts.tv_sec - fuelgauge->info.fullcap_check_interval);
+	if (fullcap_check_interval >
+		VFFULLCAP_CHECK_INTERVAL) {
+		pr_info("%s: check fullcap range (interval:%d)\n",
+			__func__, fullcap_check_interval);
+		fg_check_vf_fullcap_range(fuelgauge);
+		fuelgauge->info.fullcap_check_interval = ts.tv_sec;
+	}
+
+	fg_soc = get_fuelgauge_value(fuelgauge, FG_LEVEL);
+	if (fg_soc < 0) {
+		pr_info("Can't read soc!!!");
+		fg_soc = fuelgauge->info.soc;
+	}
+
+	if (fuelgauge->info.low_batt_boot_flag) {
+		fg_soc = 0;
+
+		if (fuelgauge->pdata->check_cable_callback &&
+		    fuelgauge->pdata->check_cable_callback() !=
+			POWER_SUPPLY_TYPE_BATTERY &&
+			!is_booted_in_low_battery(fuelgauge)) {
+			fg_adjust_capacity(fuelgauge);
+			fuelgauge->info.low_batt_boot_flag = 0;
+		}
+
+		if (fuelgauge->pdata->check_cable_callback &&
+		    fuelgauge->pdata->check_cable_callback() ==
+			POWER_SUPPLY_TYPE_BATTERY)
+			fuelgauge->info.low_batt_boot_flag = 0;
+	}
+
+	fg_vcell = get_fuelgauge_value(fuelgauge, FG_VOLTAGE);
+	fg_current = get_fuelgauge_value(fuelgauge, FG_CURRENT);
+	avg_current = get_fuelgauge_value(fuelgauge, FG_CURRENT_AVG);
+	fg_vfsoc = get_fuelgauge_value(fuelgauge, FG_VF_SOC);
+
+	psy_do_property("battery", get,
+		POWER_SUPPLY_PROP_STATUS, value);
+
+	/* Algorithm for reducing time to fully charged (from MAXIM) */
+	if (value.intval != POWER_SUPPLY_STATUS_DISCHARGING &&
+		value.intval != POWER_SUPPLY_STATUS_FULL &&
+		fuelgauge->cable_type != POWER_SUPPLY_TYPE_USB &&
+		/* Skip when first check after boot up */
+		!fuelgauge->info.is_first_check &&
+		(fg_vfsoc > VFSOC_FOR_FULLCAP_LEARNING &&
+		(fg_current > LOW_CURRENT_FOR_FULLCAP_LEARNING &&
+		fg_current < HIGH_CURRENT_FOR_FULLCAP_LEARNING) &&
+		(avg_current > LOW_AVGCURRENT_FOR_FULLCAP_LEARNING &&
+		avg_current < HIGH_AVGCURRENT_FOR_FULLCAP_LEARNING))) {
+
+		if (fuelgauge->info.full_check_flag == 2) {
+			pr_info("%s: force fully charged SOC !! (%d)",
+				__func__, fuelgauge->info.full_check_flag);
+			fg_set_full_charged(fuelgauge);
+			fg_soc = get_fuelgauge_value(fuelgauge, FG_LEVEL);
+		} else if (fuelgauge->info.full_check_flag < 2)
+			pr_info("%s: full_check_flag (%d)",
+				__func__, fuelgauge->info.full_check_flag);
+
+		/* prevent overflow */
+		if (fuelgauge->info.full_check_flag++ > 10000)
+			fuelgauge->info.full_check_flag = 3;
+	} else
+		fuelgauge->info.full_check_flag = 0;
+
+	/*  Checks vcell level and tries to compensate SOC if needed.*/
+	/*  If jig cable is connected, then skip low batt compensation check. */
+	if (fuelgauge->pdata->check_jig_status &&
+	    !fuelgauge->pdata->check_jig_status() &&
+		value.intval == POWER_SUPPLY_STATUS_DISCHARGING)
+		fg_soc = low_batt_compensation(
+			fuelgauge, fg_soc, fg_vcell, fg_current);
+
+	if (fuelgauge->info.is_first_check)
+		fuelgauge->info.is_first_check = false;
+
+	fuelgauge->info.soc = fg_soc;
+
+return_soc:
+	pr_debug("%s: soc(%d), low_batt_alarm(%d)\n",
+		__func__, fuelgauge->info.soc,
+		fuelgauge->info.is_low_batt_alarm);
+
+	return fg_soc;
+}
+
+static void full_comp_work_handler(struct work_struct *work)
+{
+	struct sec_fg_info *fg_info =
+		container_of(work, struct sec_fg_info, full_comp_work.work);
+	struct max77823_fuelgauge_data *fuelgauge =
+		container_of(fg_info, struct max77823_fuelgauge_data, info);
+	int avg_current;
+	union power_supply_propval value;
+
+	avg_current = get_fuelgauge_value(fuelgauge, FG_CURRENT_AVG);
+	psy_do_property("battery", get,
+		POWER_SUPPLY_PROP_STATUS, value);
+
+	if (avg_current >= 25) {
+		cancel_delayed_work(&fuelgauge->info.full_comp_work);
+		schedule_delayed_work(&fuelgauge->info.full_comp_work, 100);
+	} else {
+		pr_info("%s: full charge compensation start (avg_current %d)\n",
+			__func__, avg_current);
+		fg_fullcharged_compensation(fuelgauge,
+			(int)(value.intval ==
+			POWER_SUPPLY_STATUS_FULL), false);
+	}
+}
+
+static irqreturn_t max77823_jig_irq_thread(int irq, void *irq_data)
+{
+	struct max77823_fuelgauge_data *fuelgauge = irq_data;
+
+	if (fuelgauge->pdata->check_jig_status &&
+	    fuelgauge->pdata->check_jig_status())
+		fg_reset_capacity_by_jig_connection(fuelgauge);
+	else
+		pr_info("%s: jig removed\n", __func__);
+	return IRQ_HANDLED;
+}
+
+bool max77823_fg_init(struct max77823_fuelgauge_data *fuelgauge)
+{
+	ktime_t	current_time;
+	struct timespec ts;
+	u8 data[2] = {0, 0};
+
+#if defined(ANDROID_ALARM_ACTIVATED)
+	current_time = alarm_get_elapsed_realtime();
+	ts = ktime_to_timespec(current_time);
+#else
+	current_time = ktime_get_boottime();
+	ts = ktime_to_timespec(current_time);
+#endif
+
+	fuelgauge->info.fullcap_check_interval = ts.tv_sec;
+
+	fuelgauge->info.is_low_batt_alarm = false;
+	fuelgauge->info.is_first_check = true;
+
+	/* Init parameters to prevent wrong compensation. */
+	fuelgauge->info.previous_fullcap =
+		max77823_read_word(fuelgauge->i2c, FULLCAP_REG);
+	fuelgauge->info.previous_vffullcap =
+		max77823_read_word(fuelgauge->i2c, FULLCAP_NOM_REG);
+
+	if (fuelgauge->pdata->check_cable_callback &&
+	    (fuelgauge->pdata->check_cable_callback() !=
+	     POWER_SUPPLY_TYPE_BATTERY) &&
+	    is_booted_in_low_battery(fuelgauge))
+		fuelgauge->info.low_batt_boot_flag = 1;
+
+	if (fuelgauge->pdata->check_jig_status &&
+	    fuelgauge->pdata->check_jig_status())
+		fg_reset_capacity_by_jig_connection(fuelgauge);
+	else {
+		if (fuelgauge->pdata->jig_irq) {
+			int ret;
+			ret = request_threaded_irq(fuelgauge->pdata->jig_irq,
+					NULL, max77823_jig_irq_thread,
+					fuelgauge->pdata->jig_irq_attr,
+					"jig-irq", fuelgauge);
+			if (ret) {
+				pr_info("%s: Failed to Reqeust IRQ\n",
+					__func__);
+			}
+		}
+	}
+
+	INIT_DELAYED_WORK(&fuelgauge->info.full_comp_work,
+		full_comp_work_handler);
+
+	/* NOT using FG for temperature */
+	if (fuelgauge->pdata->thermal_source != SEC_BATTERY_THERMAL_SOURCE_FG) {
+		data[0] = 0x00;
+		data[1] = 0x21;
+		max77823_bulk_write(fuelgauge->i2c, CONFIG_REG,
+				    2, data);
+	}
+
+	return true;
+}
+
+bool max77823_fg_fuelalert_init(struct max77823_fuelgauge_data *fuelgauge,
+				int soc)
+{
+	/* 1. Set max77823 alert configuration. */
+	if (max77823_alert_init(fuelgauge, soc) > 0)
+		return true;
+	else
+		return false;
+}
+
+bool max77823_fg_is_fuelalerted(struct max77823_fuelgauge_data *fuelgauge)
+{
+	if (get_fuelgauge_value(fuelgauge, FG_CHECK_STATUS) > 0)
+		return true;
+	else
+		return false;
+}
+
+bool max77823_fg_fuelalert_process(void *irq_data, bool is_fuel_alerted)
+{
+	struct max77823_fuelgauge_data *fuelgauge =
+		(struct max77823_fuelgauge_data *)irq_data;
+	union power_supply_propval value;
+	int overcurrent_limit_in_soc;
+	int current_soc =
+		get_fuelgauge_value(fuelgauge, FG_LEVEL);
+
+	psy_do_property("battery", get,
+		POWER_SUPPLY_PROP_STATUS, value);
+	if (value.intval == POWER_SUPPLY_STATUS_CHARGING)
+		return true;
+
+	if (fuelgauge->info.soc <= STABLE_LOW_BATTERY_DIFF)
+		overcurrent_limit_in_soc = STABLE_LOW_BATTERY_DIFF_LOWBATT;
+	else
+		overcurrent_limit_in_soc = STABLE_LOW_BATTERY_DIFF;
+
+	if (((int)fuelgauge->info.soc - current_soc) >
+		overcurrent_limit_in_soc) {
+		pr_info("%s: Abnormal Current Consumption jump by %d units\n",
+			__func__, (((int)fuelgauge->info.soc - current_soc)));
+		pr_info("%s: Last Reported SOC (%d).\n",
+			__func__, fuelgauge->info.soc);
+
+		fuelgauge->info.is_low_batt_alarm = true;
+
+		if (fuelgauge->info.soc >=
+			LOW_BATTERY_SOC_REDUCE_UNIT)
+			return true;
+	}
+
+	if (value.intval ==
+			POWER_SUPPLY_STATUS_DISCHARGING) {
+		pr_err("Set battery level as 0, power off.\n");
+		fuelgauge->info.soc = 0;
+		value.intval = 0;
+		psy_do_property("battery", set,
+			POWER_SUPPLY_PROP_CAPACITY, value);
+	}
+
+	return true;
+}
+
+bool max77823_fg_full_charged(struct max77823_fuelgauge_data *fuelgauge)
+{
+	union power_supply_propval value;
+
+	psy_do_property("battery", get,
+		POWER_SUPPLY_PROP_STATUS, value);
+
+	/* full charge compensation algorithm by MAXIM */
+	fg_fullcharged_compensation(fuelgauge,
+		(int)(value.intval == POWER_SUPPLY_STATUS_FULL), true);
+
+	cancel_delayed_work(&fuelgauge->info.full_comp_work);
+	schedule_delayed_work(&fuelgauge->info.full_comp_work, 100);
+
+	return false;
+}
+
+bool max77823_fg_reset(struct max77823_fuelgauge_data *fuelgauge)
+{
+	if (!fg_reset_soc(fuelgauge))
+		return true;
+	else
+		return false;
+}
+#endif
+
+static void max77823_fg_get_scaled_capacity(
+	struct max77823_fuelgauge_data *fuelgauge,
+	union power_supply_propval *val)
+{
+	val->intval = (val->intval < fuelgauge->pdata->capacity_min) ?
+		0 : ((val->intval - fuelgauge->pdata->capacity_min) * 1000 /
+		     (fuelgauge->capacity_max - fuelgauge->pdata->capacity_min));
+
+	pr_debug("%s: scaled capacity (%d.%d)\n",
+		__func__, val->intval/10, val->intval%10);
+}
+
+/* capacity is integer */
+static void max77823_fg_get_atomic_capacity(
+	struct max77823_fuelgauge_data *fuelgauge,
+	union power_supply_propval *val)
+{
+	if (fuelgauge->pdata->capacity_calculation_type &
+		SEC_FUELGAUGE_CAPACITY_TYPE_ATOMIC) {
+	if (fuelgauge->capacity_old < val->intval)
+		val->intval = fuelgauge->capacity_old + 1;
+	else if (fuelgauge->capacity_old > val->intval)
+		val->intval = fuelgauge->capacity_old - 1;
+	}
+
+	/* keep SOC stable in abnormal status */
+	if (fuelgauge->pdata->capacity_calculation_type &
+		SEC_FUELGAUGE_CAPACITY_TYPE_SKIP_ABNORMAL) {
+		if (!fuelgauge->is_charging &&
+			fuelgauge->capacity_old < val->intval) {
+			pr_err("%s: capacity (old %d : new %d)\n",
+				__func__, fuelgauge->capacity_old, val->intval);
+			val->intval = fuelgauge->capacity_old;
+		}
+	}
+
+	/* updated old capacity */
+	fuelgauge->capacity_old = val->intval;
+}
+
+static int max77823_fg_calculate_dynamic_scale(
+	struct max77823_fuelgauge_data *fuelgauge)
+{
+	union power_supply_propval raw_soc_val;
+
+#ifdef CONFIG_FUELGAUGE_MAX77823_VOLTAGE_TRACKING
+	raw_soc_val.intval = max77823_get_soc(fuelgauge) / 10;
+#else
+	raw_soc_val.intval = get_fuelgauge_value(fuelgauge,
+						 FG_RAW_SOC);
+#endif
+
+	if (raw_soc_val.intval <
+		fuelgauge->pdata->capacity_max -
+		fuelgauge->pdata->capacity_max_margin) {
+		fuelgauge->capacity_max =
+			fuelgauge->pdata->capacity_max -
+			fuelgauge->pdata->capacity_max_margin;
+		pr_debug("%s: capacity_max (%d)", __func__,
+			 fuelgauge->capacity_max);
+	} else {
+		fuelgauge->capacity_max =
+			(raw_soc_val.intval >
+			fuelgauge->pdata->capacity_max +
+			fuelgauge->pdata->capacity_max_margin) ?
+			(fuelgauge->pdata->capacity_max +
+			fuelgauge->pdata->capacity_max_margin) :
+			raw_soc_val.intval;
+		pr_debug("%s: raw soc (%d)", __func__,
+			 fuelgauge->capacity_max);
+	}
+
+	fuelgauge->capacity_max =
+		(fuelgauge->capacity_max * 99 / 100);
+
+	/* update capacity_old for sec_fg_get_atomic_capacity algorithm */
+	fuelgauge->capacity_old = 100;
+
+	pr_info("%s: %d is used for capacity_max\n",
+		__func__, fuelgauge->capacity_max);
+
+	return fuelgauge->capacity_max;
+}
+
+#ifdef CONFIG_FUELGAUGE_MAX77823_VOLTAGE_TRACKING
+static int max77823_fg_get_property(strcut power_supply *psy,
+			     enum power_supply_property psp,
+			     union power_supply_propval *val)
+{
+	struct max77823_fuelgauge_data *fuelgauge =
+		container_of(psy, struct max77823_fuelgauge_data, psy_fg);
+
+	switch (psp) {
+		/* Cell voltage (VCELL, mV) */
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = max77823_get_vcell(fuelgauge);
+		break;
+		/* Additional Voltage Information (mV) */
+	case POWER_SUPPLY_PROP_VOLTAGE_AVG:
+		switch (val->intval) {
+		case SEC_BATTEY_VOLTAGE_AVERAGE:
+			val->intval = max77823_get_avgvcell(fuelgauge);
+			break;
+		case SEC_BATTEY_VOLTAGE_OCV:
+			val->intval = max77823_get_vfocv(fuelgauge);
+			break;
+		}
+		break;
+		/* Current (mA) */
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = 0;
+		break;
+		/* Average Current (mA) */
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+		val->intval = 0;
+		break;
+		/* SOC (%) */
+	case POWER_SUPPLY_PROP_CAPACITY:
+		if (val->intval == SEC_FUELGAUGE_CAPACITY_TYPE_RAW) {
+			val->intval = max77823_get_soc(fuelgauge);
+		} else {
+			val->intval = max77823_get_soc(fuelgauge) / 10;
+
+			if (fuelgauge->pdata->capacity_calculation_type &
+			    (SEC_FUELGAUGE_CAPACITY_TYPE_SCALE |
+			     SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE))
+				max77823_fg_get_scaled_capacity(fuelgauge, val);
+
+			/* capacity should be between 0% and 100%
+			 * (0.1% degree)
+			 */
+			if (val->intval > 1000)
+				val->intval = 1000;
+			if (val->intval < 0)
+				val->intval = 0;
+
+			/* get only integer part */
+			val->intval /= 10;
+
+			/* check whether doing the wake_unlock */
+			if ((val->intval > fuelgauge->pdata->fuel_alert_soc) &&
+			    fuelgauge->is_fuel_alerted) {
+				wake_unlock(&fuelgauge->fuel_alert_wake_lock);
+				max77823_fg_fuelalert_init(fuelgauge,
+					  fuelgauge->pdata->fuel_alert_soc);
+			}
+
+			/* (Only for atomic capacity)
+			 * In initial time, capacity_old is 0.
+			 * and in resume from sleep,
+			 * capacity_old is too different from actual soc.
+			 * should update capacity_old
+			 * by val->intval in booting or resume.
+			 */
+			if (fuelgauge->initial_update_of_soc) {
+				/* updated old capacity */
+				fuelgauge->capacity_old = val->intval;
+				fuelgauge->initial_update_of_soc = false;
+				break;
+			}
+
+			if (fuelgauge->pdata->capacity_calculation_type &
+			    (SEC_FUELGAUGE_CAPACITY_TYPE_ATOMIC |
+			     SEC_FUELGAUGE_CAPACITY_TYPE_SKIP_ABNORMAL))
+				max77823_fg_get_atomic_capacity(fuelgauge, val);
+		}
+		break;
+		/* Battery Temperature */
+	case POWER_SUPPLY_PROP_TEMP:
+		/* Target Temperature */
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		val->intval = max77823_get_temperature(fuelgauge);
+		break;
+	default:
+		return false;
+	}
+	return true;
+}
+
+
+static int max77823_fg_set_property(struct power_supply *psy,
+			     enum power_supply_property psp,
+			     const union power_supply_propval *val)
+{
+	struct max77823_fuelgauge_data *fuelgauge =
+		container_of(psy, struct max77823_fuelgauge_data, psy_fg);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		if (val->intval == POWER_SUPPLY_STATUS_FULL)
+			max77823_fg_full_charged(fuelgauge);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+		if (val->intval == POWER_SUPPLY_TYPE_BATTERY) {
+			if (fuelgauge->pdata->capacity_calculation_type &
+			    SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE)
+				max77823_fg_calculate_dynamic_scale(fuelgauge);
+		}
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		fuelgauge->cable_type = val->intval;
+		if (val->intval == POWER_SUPPLY_TYPE_BATTERY)
+			fuelgauge->is_charging = false;
+		else
+			fuelgauge->is_charging = true;
+		break;
+		/* Battery Temperature */
+	case POWER_SUPPLY_PROP_CAPACITY:
+		if (val->intval == SEC_FUELGAUGE_CAPACITY_TYPE_RESET) {
+			fuelgauge->initial_update_of_soc = true;
+			if (!max77823_fg_reset(fuelgauge))
+				return -EINVAL;
+			else
+				break;
+		}
+		/* Battery Temperature */
+	case POWER_SUPPLY_PROP_TEMP:
+		/* Target Temperature */
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		max77823_set_temperature(fuelgauge, val->intval);
+		break;
+	default:
+		return false;
+	}
+	return true;
+}
+#endif
+
+#ifdef CONFIG_FUELGAUGE_MAX77823_COULOMB_COUNTING
+static int max77823_fg_get_property(struct power_supply *psy,
+			     enum power_supply_property psp,
+			     union power_supply_propval *val)
+{
+	struct max77823_fuelgauge_data *fuelgauge =
+		container_of(psy, struct max77823_fuelgauge_data, psy_fg);
+
+	switch (psp) {
+		/* Cell voltage (VCELL, mV) */
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = get_fuelgauge_value(fuelgauge, FG_VOLTAGE);
+		break;
+		/* Additional Voltage Information (mV) */
+	case POWER_SUPPLY_PROP_VOLTAGE_AVG:
+		switch (val->intval) {
+		case SEC_BATTEY_VOLTAGE_OCV:
+			val->intval = fg_read_vfocv(fuelgauge);
+			break;
+		case SEC_BATTEY_VOLTAGE_AVERAGE:
+		default:
+			val->intval = fg_read_avg_vcell(fuelgauge);
+			break;
+		}
+		break;
+		/* Current */
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		switch (val->intval) {
+		case SEC_BATTEY_CURRENT_UA:
+			val->intval =
+				fg_read_current(fuelgauge,
+						SEC_BATTEY_CURRENT_UA);
+			break;
+		case SEC_BATTEY_CURRENT_MA:
+		default:
+			val->intval = get_fuelgauge_value(fuelgauge,
+							  FG_CURRENT);
+			break;
+		}
+		break;
+		/* Average Current */
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+		switch (val->intval) {
+		case SEC_BATTEY_CURRENT_UA:
+			val->intval =
+				fg_read_avg_current(fuelgauge,
+						    SEC_BATTEY_CURRENT_UA);
+			break;
+		case SEC_BATTEY_CURRENT_MA:
+		default:
+			val->intval =
+				get_fuelgauge_value(fuelgauge,
+						    FG_CURRENT_AVG);
+			break;
+		}
+		break;
+		/* Full Capacity */
+	case POWER_SUPPLY_PROP_ENERGY_NOW:
+		switch (val->intval) {
+		case SEC_BATTEY_CAPACITY_DESIGNED:
+			val->intval = get_fuelgauge_value(fuelgauge,
+							  FG_FULLCAP);
+			break;
+		case SEC_BATTEY_CAPACITY_ABSOLUTE:
+			val->intval = get_fuelgauge_value(fuelgauge,
+							  FG_MIXCAP);
+			break;
+		case SEC_BATTEY_CAPACITY_TEMPERARY:
+			val->intval = get_fuelgauge_value(fuelgauge,
+							  FG_AVCAP);
+			break;
+		case SEC_BATTEY_CAPACITY_CURRENT:
+			val->intval = get_fuelgauge_value(fuelgauge,
+							  FG_REPCAP);
+			break;
+		}
+		break;
+		/* SOC (%) */
+	case POWER_SUPPLY_PROP_CAPACITY:
+		if (val->intval == SEC_FUELGAUGE_CAPACITY_TYPE_RAW) {
+			val->intval = get_fuelgauge_value(fuelgauge,
+							  FG_RAW_SOC);
+		} else {
+			val->intval = get_fuelgauge_soc(fuelgauge);
+
+			if (fuelgauge->pdata->capacity_calculation_type &
+			    (SEC_FUELGAUGE_CAPACITY_TYPE_SCALE |
+			     SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE))
+				max77823_fg_get_scaled_capacity(fuelgauge, val);
+
+			/* capacity should be between 0% and 100%
+			 * (0.1% degree)
+			 */
+			if (val->intval > 1000)
+				val->intval = 1000;
+			if (val->intval < 0)
+				val->intval = 0;
+
+			/* get only integer part */
+			val->intval /= 10;
+
+			/* check whether doing the wake_unlock */
+			if ((val->intval > fuelgauge->pdata->fuel_alert_soc) &&
+			    fuelgauge->is_fuel_alerted) {
+				wake_unlock(&fuelgauge->fuel_alert_wake_lock);
+				max77823_fg_fuelalert_init(fuelgauge,
+					  fuelgauge->pdata->fuel_alert_soc);
+			}
+
+			/* (Only for atomic capacity)
+			 * In initial time, capacity_old is 0.
+			 * and in resume from sleep,
+			 * capacity_old is too different from actual soc.
+			 * should update capacity_old
+			 * by val->intval in booting or resume.
+			 */
+			if (fuelgauge->initial_update_of_soc) {
+				/* updated old capacity */
+				fuelgauge->capacity_old = val->intval;
+				fuelgauge->initial_update_of_soc = false;
+				break;
+			}
+
+			if (fuelgauge->pdata->capacity_calculation_type &
+			    (SEC_FUELGAUGE_CAPACITY_TYPE_ATOMIC |
+			     SEC_FUELGAUGE_CAPACITY_TYPE_SKIP_ABNORMAL))
+				max77823_fg_get_atomic_capacity(fuelgauge, val);
+		}
+		break;
+		/* Battery Temperature */
+	case POWER_SUPPLY_PROP_TEMP:
+		/* Target Temperature */
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		val->intval = get_fuelgauge_value(fuelgauge,
+						  FG_TEMPERATURE);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int max77823_fg_set_property(struct power_supply *psy,
+			     enum power_supply_property psp,
+			     const union power_supply_propval *val)
+{
+	struct max77823_fuelgauge_data *fuelgauge =
+		container_of(psy, struct max77823_fuelgauge_data, psy_fg);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		if (val->intval == POWER_SUPPLY_STATUS_FULL)
+			max77823_fg_full_charged(fuelgauge);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+		if (val->intval == POWER_SUPPLY_TYPE_BATTERY) {
+			if (fuelgauge->pdata->capacity_calculation_type &
+			    SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE)
+				max77823_fg_calculate_dynamic_scale(fuelgauge);
+		}
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		fuelgauge->cable_type = val->intval;
+		if (val->intval == POWER_SUPPLY_TYPE_BATTERY) {
+			fuelgauge->is_charging = false;
+		} else {
+			fuelgauge->is_charging = true;
+
+			if (fuelgauge->info.is_low_batt_alarm) {
+				pr_info("%s: Reset low_batt_alarm\n",
+					 __func__);
+				fuelgauge->info.is_low_batt_alarm = false;
+			}
+
+			reset_low_batt_comp_cnt(fuelgauge);
+		}
+		break;
+		/* Battery Temperature */
+	case POWER_SUPPLY_PROP_CAPACITY:
+		if (val->intval == SEC_FUELGAUGE_CAPACITY_TYPE_RESET) {
+			fuelgauge->initial_update_of_soc = true;
+			if (!max77823_fg_reset(fuelgauge))
+				return -EINVAL;
+			else
+				break;
+		}
+	case POWER_SUPPLY_PROP_TEMP:
+		/* Target Temperature */
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		fg_write_temp(fuelgauge, val->intval);
+		break;
+	case POWER_SUPPLY_PROP_ENERGY_NOW:
+		fg_reset_capacity_by_jig_connection(fuelgauge);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+#endif
+
+static void max77823_fg_isr_work(struct work_struct *work)
+{
+	struct max77823_fuelgauge_data *fuelgauge =
+		container_of(work, struct max77823_fuelgauge_data, isr_work.work);
+
+	/* process for fuel gauge chip */
+	max77823_fg_fuelalert_process(fuelgauge, fuelgauge->is_fuel_alerted);
+
+	/* process for others */
+	if (fuelgauge->pdata->fuelalert_process != NULL)
+		fuelgauge->pdata->fuelalert_process(fuelgauge->is_fuel_alerted);
+}
+
+static irqreturn_t max77823_fg_irq_thread(int irq, void *irq_data)
+{
+	struct max77823_fuelgauge_data *fuelgauge = irq_data;
+	bool fuel_alerted;
+
+	if (fuelgauge->pdata->fuel_alert_soc >= 0) {
+		fuel_alerted =
+			max77823_fg_is_fuelalerted(fuelgauge);
+
+		pr_info("%s: Fuel-alert %salerted!\n",
+			__func__, fuel_alerted ? "" : "NOT ");
+
+		fg_test_print(fuelgauge);
+
+		if (fuel_alerted == fuelgauge->is_fuel_alerted) {
+			if (!fuelgauge->pdata->repeated_fuelalert) {
+				pr_debug("%s: Fuel-alert Repeated (%d)\n",
+					__func__, fuelgauge->is_fuel_alerted);
+				return IRQ_HANDLED;
+			}
+		}
+
+		if (fuel_alerted)
+			wake_lock(&fuelgauge->fuel_alert_wake_lock);
+		else
+			wake_unlock(&fuelgauge->fuel_alert_wake_lock);
+
+		schedule_delayed_work(&fuelgauge->isr_work, 0);
+
+		fuelgauge->is_fuel_alerted = fuel_alerted;
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int max77823_fuelgauge_debugfs_show(struct seq_file *s, void *data)
+{
+	struct max77823_fuelgauge_data *fuelgauge = s->private;
+	u8 reg;
+	u8 reg_data;
+
+	seq_printf(s, "MAX77823 FUELGAUGE IC :\n");
+	seq_printf(s, "===================\n");
+	for (reg = 0xB0; reg <= 0xC3; reg++) {
+		max77823_read_reg(fuelgauge->i2c, reg, &reg_data);
+		seq_printf(s, "0x%02x:\t0x%02x\n", reg, reg_data);
+	}
+
+	seq_printf(s, "\n");
+	return 0;
+}
+
+static int max77823_fuelgauge_debugfs_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, max77823_fuelgauge_debugfs_show, inode->i_private);
+}
+
+static const struct file_operations max77823_fuelgauge_debugfs_fops = {
+	.open           = max77823_fuelgauge_debugfs_open,
+	.read           = seq_read,
+	.llseek         = seq_lseek,
+	.release        = single_release,
+};
+
+#ifdef CONFIG_OF
+static int max77823_fuelgauge_parse_dt(struct max77823_fuelgauge_data *fuelgauge)
+{
+	struct device_node *np = of_find_node_by_name(NULL, "max77823-fuelgauge");
+	sec_battery_platform_data_t *pdata = fuelgauge->pdata;
+	int ret;
+	int i;
+
+	/* reset, irq gpio info */
+	if (np == NULL) {
+		pr_err("%s np NULL\n", __func__);
+	} else {
+		ret = of_property_read_u32(np, "fuelgauge,capacity_max",
+				&pdata->capacity_max);
+		if (ret < 0)
+			pr_err("%s error reading capacity_max %d\n", __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_max_margin",
+				&pdata->capacity_max_margin);
+		if (ret < 0)
+			pr_err("%s error reading capacity_max_margin %d\n", __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_min",
+				&pdata->capacity_min);
+		if (ret < 0)
+			pr_err("%s error reading capacity_min %d\n", __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_calculation_type",
+				&pdata->capacity_calculation_type);
+		if (ret < 0)
+			pr_err("%s error reading capacity_calculation_type %d\n",
+					__func__, ret);
+		ret = of_property_read_u32(np, "fuelgauge,fuel_alert_soc",
+				&pdata->fuel_alert_soc);
+		if (ret < 0)
+			pr_err("%s error reading pdata->fuel_alert_soc %d\n",
+					__func__, ret);
+		pdata->repeated_fuelalert = of_property_read_bool(np,
+				"fuelgauge,repeated_fuelalert");
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity",
+					   &fuelgauge->battery_data->Capacity);
+		if (ret < 0)
+			pr_err("%s error reading capacity_calculation_type %d\n",
+					__func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,low_battery_comp_voltage",
+			   &fuelgauge->battery_data->low_battery_comp_voltage);
+		if (ret < 0)
+			pr_err("%s error reading capacity_calculation_type %d\n",
+					__func__, ret);
+
+
+		for(i = 0; i < (CURRENT_RANGE_MAX_NUM * TABLE_MAX); i++) {
+			ret = of_property_read_u32_index(np,
+					 "fuelgauge,low_battery_table",
+					 i,
+					 &fuelgauge->battery_data->low_battery_table[i/3][i%3]);
+			pr_info("[%d]",
+				fuelgauge->battery_data->low_battery_table[i/3][i%3]);
+			if ((i%3) == 2)
+				pr_info("\n");
+		}
+
+		pr_info("%s fg_irq: %d, capacity_max: %d\n"
+			"cpacity_max_margin: %d, capacity_min: %d\n"
+			"calculation_type: 0x%x, fuel_alert_soc: %d,\n"
+			"repeated_fuelalert: %d\n",
+			__func__, pdata->fg_irq,
+			pdata->capacity_max, pdata->capacity_max_margin,
+			pdata->capacity_min, pdata->capacity_calculation_type,
+			pdata->fuel_alert_soc, pdata->repeated_fuelalert);
+	}
+
+	pr_info("[%s][%d][%d]\n",
+		__func__, fuelgauge->battery_data->Capacity,
+	        fuelgauge->battery_data->low_battery_comp_voltage);
+
+	return 0;
+}
+#endif
+
+static int __devinit max77823_fuelgauge_probe(struct platform_device *pdev)
+{
+	struct max77823_dev *max77823 = dev_get_drvdata(pdev->dev.parent);
+	struct max77823_platform_data *pdata = dev_get_platdata(max77823->dev);
+	struct max77823_fuelgauge_data *fuelgauge;
+	int ret = 0;
+	union power_supply_propval raw_soc_val;
+
+	pr_info("%s: MAX77823 Fuelgauge Driver Loading\n", __func__);
+
+	fuelgauge = kzalloc(sizeof(*fuelgauge), GFP_KERNEL);
+	if (!fuelgauge)
+		return -ENOMEM;
+
+	pdata->fuelgauge_data = kzalloc(sizeof(sec_battery_platform_data_t), GFP_KERNEL);
+	if (!pdata->fuelgauge_data)
+		return -ENOMEM;
+
+	mutex_init(&fuelgauge->fg_lock);
+
+	fuelgauge->dev = &pdev->dev;
+	fuelgauge->pdata = pdata->fuelgauge_data;
+	fuelgauge->i2c = max77823->fuelgauge;
+	fuelgauge->max77823_pdata = pdata;
+
+#if defined(CONFIG_OF)
+	fuelgauge->battery_data = kzalloc(sizeof(struct battery_data_t),
+					  GFP_KERNEL);
+	if(!fuelgauge->battery_data) {
+		pr_err("Failed to allocate memory\n");
+		return -ENOMEM;
+	}
+	ret = max77823_fuelgauge_parse_dt(fuelgauge);
+	if (ret < 0) {
+		pr_err("%s not found charger dt! ret[%d]\n",
+		       __func__, ret);
+	}
+#endif
+
+	platform_set_drvdata(pdev, fuelgauge);
+
+	fuelgauge->psy_fg.name		= "max77823-fuelgauge";
+	fuelgauge->psy_fg.type		= POWER_SUPPLY_TYPE_UNKNOWN;
+	fuelgauge->psy_fg.get_property	= max77823_fg_get_property;
+	fuelgauge->psy_fg.set_property	= max77823_fg_set_property;
+	fuelgauge->psy_fg.properties	= max77823_fuelgauge_props;
+	fuelgauge->psy_fg.num_properties =
+		ARRAY_SIZE(max77823_fuelgauge_props);
+	fuelgauge->capacity_max = fuelgauge->pdata->capacity_max;
+#ifdef CONFIG_FUELGAUGE_MAX77823_VOLTAGE_TRACKING
+	raw_soc_val.intval = max77823_get_soc(fuelgauge) / 10;
+#else
+	raw_soc_val.intval = get_fuelgauge_value(fuelgauge, FG_RAW_SOC);
+#endif
+
+	if(raw_soc_val.intval > fuelgauge->pdata->capacity_max)
+		max77823_fg_calculate_dynamic_scale(fuelgauge);
+
+	(void) debugfs_create_file("max77823-fuelgauge-regs",
+		S_IRUGO, NULL, (void *)fuelgauge, &max77823_fuelgauge_debugfs_fops);
+
+	if (!max77823_fg_init(fuelgauge)) {
+		pr_err("%s: Failed to Initialize Fuelgauge\n", __func__);
+		goto err_free;
+	}
+
+	ret = power_supply_register(&pdev->dev, &fuelgauge->psy_fg);
+	if (ret) {
+		pr_err("%s: Failed to Register psy_fg\n", __func__);
+		goto err_free;
+	}
+
+	fuelgauge->fg_irq = pdata->irq_base + MAX77823_FG_IRQ_ALERT;
+	pr_info("[%s]IRQ_BASE(%d) FG_IRQ(%d)\n",
+		__func__, pdata->irq_base, fuelgauge->fg_irq);
+
+	if (fuelgauge->fg_irq) {
+		INIT_DELAYED_WORK(&fuelgauge->isr_work, max77823_fg_isr_work);
+
+		ret = request_threaded_irq(fuelgauge->fg_irq,
+				NULL, max77823_fg_irq_thread,
+			        IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+				"fuelgauge-irq", fuelgauge);
+		if (ret) {
+			pr_err("%s: Failed to Reqeust IRQ\n", __func__);
+			goto err_supply_unreg;
+		}
+	}
+
+	fuelgauge->is_fuel_alerted = false;
+	if (fuelgauge->pdata->fuel_alert_soc >= 0) {
+		if (max77823_fg_fuelalert_init(fuelgauge,
+				       fuelgauge->pdata->fuel_alert_soc))
+			wake_lock_init(&fuelgauge->fuel_alert_wake_lock,
+				       WAKE_LOCK_SUSPEND, "fuel_alerted");
+		else {
+			pr_err("%s: Failed to Initialize Fuel-alert\n",
+				__func__);
+			goto err_irq;
+		}
+	}
+
+	fuelgauge->initial_update_of_soc = true;
+
+	pr_info("%s: MAX77823 Fuelgauge Driver Loaded\n", __func__);
+	return 0;
+
+err_irq:
+	if (fuelgauge->fg_irq)
+		free_irq(fuelgauge->fg_irq, fuelgauge);
+err_supply_unreg:
+	power_supply_unregister(&fuelgauge->psy_fg);
+err_free:
+	mutex_destroy(&fuelgauge->fg_lock);
+	kfree(fuelgauge);
+
+	return ret;
+}
+
+static int __devexit max77823_fuelgauge_remove(struct platform_device *pdev)
+{
+	struct max77823_fuelgauge_data *fuelgauge =
+		platform_get_drvdata(pdev);
+
+	if (fuelgauge->pdata->fuel_alert_soc >= 0)
+		wake_lock_destroy(&fuelgauge->fuel_alert_wake_lock);
+
+	return 0;
+}
+
+static int max77823_fuelgauge_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int max77823_fuelgauge_resume(struct device *dev)
+{
+	struct max77823_fuelgauge_data *fuelgauge = dev_get_drvdata(dev);
+
+	fuelgauge->initial_update_of_soc = true;
+
+	return 0;
+}
+
+static void max77823_fuelgauge_shutdown(struct device *dev)
+{
+}
+
+#if defined(CONFIG_OF)
+static struct of_device_id max77823_fuelgauge_dt_ids[] = {
+	{ .compatible = "samsung,max77823-fuelgauge" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, max77823_fuelgauge_dt_ids);
+#endif /* CONFIG_OF */
+
+static SIMPLE_DEV_PM_OPS(max77823_fuelgauge_pm_ops, max77823_fuelgauge_suspend,
+			 max77823_fuelgauge_resume);
+
+static struct platform_driver max77823_fuelgauge_driver = {
+	.driver = {
+		   .name = "max77823-fuelgauge",
+		   .owner = THIS_MODULE,
+#ifdef CONFIG_PM
+		   .pm = &max77823_fuelgauge_pm_ops,
+#endif
+		.shutdown = max77823_fuelgauge_shutdown,
+#if defined(CONFIG_OF)
+		.of_match_table	= max77823_fuelgauge_dt_ids,
+#endif /* CONFIG_OF */
+		   },
+	.probe	= max77823_fuelgauge_probe,
+	.remove	= __devexit_p(max77823_fuelgauge_remove),
+};
+
+static int __init max77823_fuelgauge_init(void)
+{
+	pr_info("%s: \n", __func__);
+	return platform_driver_register(&max77823_fuelgauge_driver);
+}
+
+static void __exit max77823_fuelgauge_exit(void)
+{
+	platform_driver_unregister(&max77823_fuelgauge_driver);
+}
+module_init(max77823_fuelgauge_init);
+module_exit(max77823_fuelgauge_exit);
+
+MODULE_DESCRIPTION("Samsung MAX778023 Fuel Gauge Driver");
+MODULE_AUTHOR("Samsung Electronics");
+MODULE_LICENSE("GPL");
diff -Naur linux-3.18.14/drivers/battery/max77833_charger.c samsung/drivers/battery/max77833_charger.c
--- linux-3.18.14/drivers/battery/max77833_charger.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery/max77833_charger.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,2032 @@
+/*
+ *  max77833_charger.c
+ *  Samsung MAX77833 Charger Driver
+ *
+ *  Copyright (C) 2012 Samsung Electronics
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#define DEBUG
+
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+
+#include <linux/mfd/max77833-private.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/power_supply.h>
+#include <linux/mfd/max77833.h>
+#ifdef CONFIG_USB_HOST_NOTIFY
+#include <linux/usb_notify.h>
+#endif
+
+#define ENABLE 1
+#define DISABLE 0
+
+static enum power_supply_property max77833_charger_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_CHARGE_TYPE,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_CURRENT_MAX,
+	POWER_SUPPLY_PROP_CURRENT_AVG,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
+	POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL,
+	POWER_SUPPLY_PROP_USB_HC,
+#if defined(CONFIG_BATTERY_SWELLING) || defined(CONFIG_BATTERY_SWELLING_SELF_DISCHARGING)
+	POWER_SUPPLY_PROP_VOLTAGE_MAX,
+#endif
+#if defined(CONFIG_AFC_CHARGER_MODE)
+	POWER_SUPPLY_PROP_AFC_CHARGER_MODE,
+#endif
+	POWER_SUPPLY_PROP_CHARGE_NOW,
+};
+
+static struct device_attribute max77833_charger_attrs[] = {
+	MAX77833_CHARGER_ATTR(chip_id),
+};
+
+static void max77833_charger_initialize(struct max77833_charger_data *charger);
+static int max77833_get_vbus_state(struct max77833_charger_data *charger);
+static int max77833_get_charger_state(struct max77833_charger_data *charger);
+static void max77833_set_charger_state(struct max77833_charger_data *charger,
+				       int enable);
+static bool max77833_charger_unlock(struct max77833_charger_data *charger)
+{
+	u8 reg_data;
+	u8 chgprot;
+	int retry_cnt = 0;
+	bool need_init = false;
+
+	do {
+		max77833_read_reg(charger->i2c, MAX77833_CHG_REG_PROTECT, &reg_data);
+		chgprot = reg_data & 0x03;
+		if (chgprot != 0x03) {
+			pr_err("%s: unlock err, chgprot(0x%x), retry(%d)\n",
+					__func__, chgprot, retry_cnt);
+			max77833_write_reg(charger->i2c, MAX77833_CHG_REG_PROTECT,
+					   0x03);
+			need_init = true;
+			msleep(20);
+		} else {
+			pr_debug("%s: unlock success, chgprot(0x%x)\n",
+				__func__, chgprot);
+			break;
+		}
+	} while ((chgprot != 0x03) && (++retry_cnt < 10));
+
+	return need_init;
+}
+
+static void check_charger_unlock_state(struct max77833_charger_data *charger)
+{
+	bool need_reg_init;
+	pr_debug("%s\n", __func__);
+
+	need_reg_init = max77833_charger_unlock(charger);
+	if (need_reg_init) {
+		pr_err("%s: charger locked state, reg init\n", __func__);
+		max77833_charger_initialize(charger);
+	}
+}
+
+static void max77833_test_read(struct max77833_charger_data *charger)
+{
+	u8 data = 0;
+	u32 addr = 0;
+	for (addr = 0x81; addr <= 0x9D; addr++) {
+		max77833_read_reg(charger->i2c, addr, &data);
+		pr_debug("MAX77833 addr : 0x%02x data : 0x%02x\n", addr, data);
+	}
+}
+
+static int max77833_get_vbus_state(struct max77833_charger_data *charger)
+{
+	u8 reg_data;
+	union power_supply_propval value;
+
+	max77833_read_reg(charger->i2c,
+			  MAX77833_CHG_REG_DTLS_00, &reg_data);
+
+	psy_do_property("battery", get, POWER_SUPPLY_PROP_ONLINE,
+			value);
+	if (value.intval == POWER_SUPPLY_TYPE_WIRELESS)
+		reg_data = ((reg_data & MAX77833_WCIN_DTLS) >>
+			    MAX77833_WCIN_DTLS_SHIFT);
+	else
+		reg_data = ((reg_data & MAX77833_CHGIN_DTLS) >>
+			    MAX77833_CHGIN_DTLS_SHIFT);
+
+	switch (reg_data) {
+	case 0x00:
+		pr_info("%s: VBUS is invalid. CHGIN < CHGIN_UVLO\n",
+			__func__);
+		break;
+	case 0x01:
+		pr_info("%s: VBUS is invalid. CHGIN < MBAT+CHGIN2SYS" \
+			"and CHGIN > CHGIN_UVLO\n", __func__);
+		break;
+	case 0x02:
+		pr_info("%s: VBUS is invalid. CHGIN > CHGIN_OVLO",
+			__func__);
+		break;
+	case 0x03:
+		pr_info("%s: VBUS is valid. CHGIN < CHGIN_OVLO", __func__);
+		break;
+	default:
+		break;
+	}
+
+	return reg_data;
+}
+
+static int max77833_get_charger_state(struct max77833_charger_data *charger)
+{
+	int status = POWER_SUPPLY_STATUS_UNKNOWN;
+	u8 reg_data;
+
+	max77833_read_reg(charger->i2c,
+			  MAX77833_CHG_REG_DTLS_01, &reg_data);
+
+	pr_info("%s : charger status (0x%02x)\n", __func__, reg_data);
+
+	reg_data &= 0x0f;
+
+	switch (reg_data)
+	{
+	case 0x00:
+	case 0x01:
+	case 0x02:
+		status = POWER_SUPPLY_STATUS_CHARGING;
+		break;
+	case 0x03:
+	case 0x04:
+		status = POWER_SUPPLY_STATUS_FULL;
+		break;
+	case 0x05:
+	case 0x06:
+	case 0x07:
+		status = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		break;
+	case 0x08:
+	case 0xA:
+	case 0xB:
+		status = POWER_SUPPLY_STATUS_DISCHARGING;
+		break;
+	default:
+		status = POWER_SUPPLY_STATUS_UNKNOWN;
+		break;
+	}
+
+	return (int)status;
+}
+
+static int max77833_get_charging_health(struct max77833_charger_data *charger)
+{
+	int state;
+	int vbus_state;
+	int retry_cnt;
+	u8 chg_dtls_00, chg_dtls, reg_data;
+	u8 chg_cnfg_00, chg_cnfg_04 ,chg_cnfg_05, chg_cnfg_06, chg_cnfg_16, chg_cnfg_18;
+
+	max77833_read_reg(charger->i2c,
+			  MAX77833_CHG_REG_DTLS_01, &reg_data);
+	reg_data = ((reg_data & MAX77833_BAT_DTLS) >> MAX77833_BAT_DTLS_SHIFT);
+
+	pr_info("%s: reg_data(0x%x)\n", __func__, reg_data);
+	switch (reg_data) {
+	case 0x00:
+		pr_info("%s: No battery and the charger is suspended\n",
+			__func__);
+		state = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;
+		break;
+	case 0x01:
+		pr_info("%s: battery is okay "
+			"but its voltage is low(~VPQLB)\n", __func__);
+		state = POWER_SUPPLY_HEALTH_GOOD;
+		break;
+	case 0x02:
+		pr_info("%s: battery dead\n", __func__);
+		state = POWER_SUPPLY_HEALTH_DEAD;
+		break;
+	case 0x03:
+		state = POWER_SUPPLY_HEALTH_GOOD;
+		break;
+	case 0x04:
+		pr_info("%s: battery is okay" \
+			"but its voltage is low\n", __func__);
+		state = POWER_SUPPLY_HEALTH_GOOD;
+		break;
+	case 0x07:
+		pr_info("%s: battery voltage information not available\n",
+			__func__);
+		state = POWER_SUPPLY_HEALTH_UNKNOWN;
+		break;
+	default:
+		pr_info("%s: battery unknown : 0x%d\n", __func__, reg_data);
+		state = POWER_SUPPLY_HEALTH_UNKNOWN;
+		break;
+	}
+
+	if (state == POWER_SUPPLY_HEALTH_GOOD) {
+		union power_supply_propval value;
+		psy_do_property("battery", get,
+				POWER_SUPPLY_PROP_HEALTH, value);
+		/* VBUS OVP state return battery OVP state */
+		vbus_state = max77833_get_vbus_state(charger);
+		/* read CHG_DTLS and detecting battery terminal error */
+		max77833_read_reg(charger->i2c,
+				  MAX77833_CHG_REG_DTLS_01, &chg_dtls);
+		chg_dtls = ((chg_dtls & MAX77833_CHG_DTLS) >>
+			    MAX77833_CHG_DTLS_SHIFT);
+		max77833_read_reg(charger->i2c,
+				  MAX77833_CHG_REG_CNFG_00, &chg_cnfg_00);
+
+		/* print the log at the abnormal case */
+		if((charger->is_charging == 1) && (chg_dtls & 0x08)) {
+			max77833_read_reg(charger->i2c,
+				MAX77833_CHG_REG_DTLS_00, &chg_dtls_00);
+			max77833_read_reg(charger->i2c,
+				MAX77833_CHG_REG_CNFG_04, &chg_cnfg_04);
+			max77833_read_reg(charger->i2c,
+				MAX77833_CHG_REG_CNFG_05, &chg_cnfg_05);
+			max77833_read_reg(charger->i2c,
+				MAX77833_CHG_REG_CNFG_06, &chg_cnfg_06);
+			max77833_read_reg(charger->i2c,
+					MAX77833_CHG_REG_CNFG_16, &chg_cnfg_16);
+			max77833_read_reg(charger->i2c,
+					MAX77833_CHG_REG_CNFG_18, &chg_cnfg_18);
+
+			pr_info("%s: CHG_DTLS_00(0x%x), CHG_DTLS_01(0x%x), CHG_CNFG_00(0x%x)\n",
+				__func__, chg_dtls_00, chg_dtls, chg_cnfg_00);
+			pr_info("%s:  CHG_CNFG_04(0x%x), CHG_CNFG_05(0x%x), CHG_CNFG_06(0x%x)\n",
+				__func__, chg_cnfg_04, chg_cnfg_05, chg_cnfg_06);
+			pr_info("%s:  CHG_CNFG_16(0x%x), CHG_CNFG_18(0x%x)\n",
+				__func__, chg_cnfg_16, chg_cnfg_18);
+			max77833_set_charger_state(charger, 0);
+			max77833_set_charger_state(charger, 1);
+		}
+
+		pr_info("%s: vbus_state : 0x%d, chg_dtls : 0x%d\n", __func__, vbus_state, chg_dtls);
+		/*  OVP is higher priority */
+		if (vbus_state == 0x02) { /*  CHGIN_OVLO */
+			pr_info("%s: vbus ovp\n", __func__);
+			state = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+			if (charger->cable_type == POWER_SUPPLY_TYPE_WIRELESS) {
+				retry_cnt = 0;
+				do {
+					msleep(50);
+					vbus_state = max77833_get_vbus_state(charger);
+				} while((retry_cnt++ < 2) && (vbus_state == 0x02));
+				if (vbus_state == 0x02) {
+					state = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+					pr_info("%s: wpc and over-voltage\n", __func__);
+				} else
+					state = POWER_SUPPLY_HEALTH_GOOD;
+			}
+		} else if (((vbus_state == 0x0) || (vbus_state == 0x01)) && (chg_dtls & 0x08) && \
+			    (chg_cnfg_00 & MAX77833_MODE_BUCK) &&	\
+			    (chg_cnfg_00 & MAX77833_MODE_CHGR) &&	\
+			    (charger->cable_type != POWER_SUPPLY_TYPE_WIRELESS)) {
+			pr_info("%s: vbus is under\n", __func__);
+			state = POWER_SUPPLY_HEALTH_UNDERVOLTAGE;
+		} else if ((value.intval == POWER_SUPPLY_HEALTH_UNDERVOLTAGE) && \
+				((vbus_state == 0x0) || (vbus_state == 0x01)) && \
+				(charger->cable_type != POWER_SUPPLY_TYPE_WIRELESS)) {
+			pr_info("%s: keep under-voltage\n", __func__);
+			state = POWER_SUPPLY_HEALTH_UNDERVOLTAGE;
+		}
+	}
+
+	return (int)state;
+}
+
+static u8 max77833_get_float_voltage_data(int float_voltage)
+{
+	int voltage = 3000;
+	int i;
+
+	for (i = 0; voltage <= 4500; i++) {
+		if (float_voltage <= voltage)
+			break;
+		voltage += 10;
+	}
+
+	return i;
+}
+
+static int max77833_get_input_current(struct max77833_charger_data *charger)
+{
+	u8 reg_data;
+	int get_current = 0;
+
+	if (charger->cable_type == POWER_SUPPLY_TYPE_WIRELESS) {
+		max77833_read_reg(charger->i2c,
+			MAX77833_CHG_REG_CNFG_17, &reg_data);
+		/* AND operation for removing the formal 2bit  */
+		reg_data = reg_data & 0x7F;
+
+		if (reg_data <= 0x3)
+			get_current = 75;
+		else if (reg_data >= 0x50)
+			get_current = 2000;
+		else
+			get_current = reg_data * 25;
+	} else {
+		max77833_read_reg(charger->i2c,
+			MAX77833_CHG_REG_CNFG_16, &reg_data);
+		/* AND operation for removing the formal 1bit  */
+
+		if (reg_data <= 0x3)
+			get_current = 75;
+		else if (reg_data >= 0xA0)
+			get_current = 4000;
+		else
+			get_current = reg_data * 25;
+	}
+
+	return get_current;
+}
+
+static bool max77833_check_battery(struct max77833_charger_data *charger)
+{
+	u8 reg_data;
+	u8 reg_data2;
+
+	max77833_read_reg(charger->i2c,
+			  MAX77833_CHG_REG_INT_OK, &reg_data);
+
+	pr_info("%s : CHG_INT_OK(0x%x)\n", __func__, reg_data);
+
+	max77833_read_reg(charger->i2c,
+			  MAX77833_CHG_REG_DTLS_00, &reg_data2);
+
+	pr_info("%s : CHG_DETAILS00(0x%x)\n", __func__, reg_data2);
+
+	if ((reg_data & MAX77833_BATP_OK) ||
+	    !(reg_data2 & MAX77833_BATP_DTLS))
+		return true;
+	else
+		return false;
+}
+
+static void max77833_set_buck(struct max77833_charger_data *charger,
+		int enable)
+{
+	u8 reg_data;
+
+	if (enable) {
+		max77833_update_reg(charger->i2c, MAX77833_CHG_REG_CNFG_00,
+				    CHG_CNFG_00_BUCK_MASK, CHG_CNFG_00_BUCK_MASK);
+	} else {
+		max77833_update_reg(charger->i2c, MAX77833_CHG_REG_CNFG_00,
+				    0, CHG_CNFG_00_BUCK_MASK);
+	}
+	max77833_read_reg(charger->i2c, MAX77833_CHG_REG_CNFG_00, &reg_data);
+	pr_debug("%s : CHG_CNFG_00(0x%02x)\n", __func__, reg_data);
+}
+
+static void max77833_check_slow_charging(struct max77833_charger_data *charger,
+		int input_current)
+{
+	/* under 400mA considered as slow charging concept for VZW */
+	if (input_current <= SLOW_CHARGING_CURRENT_STANDARD &&
+			charger->cable_type != POWER_SUPPLY_TYPE_BATTERY) {
+		union power_supply_propval value;
+
+		charger->aicl_on = true;
+		pr_info("%s: slow charging on : input current(%dmA), cable type(%d)\n",
+			__func__, input_current, charger->cable_type);
+
+		psy_do_property("battery", set,
+			POWER_SUPPLY_PROP_CHARGE_TYPE, value);
+	}
+	else
+		charger->aicl_on = false;
+}
+
+static void max77833_set_input_current(struct max77833_charger_data *charger,
+				       int input_current)
+{
+	u8 set_reg, reg_data;
+
+	mutex_lock(&charger->charger_mutex);
+	if (charger->cable_type == POWER_SUPPLY_TYPE_WIRELESS) {
+		set_reg = MAX77833_CHG_REG_CNFG_17;
+		max77833_read_reg(charger->i2c,
+				  set_reg, &reg_data);
+		reg_data &= ~MAX77833_CHG_WCIN_LIM;
+	} else {
+		set_reg = MAX77833_CHG_REG_CNFG_16;
+		max77833_read_reg(charger->i2c,
+				  set_reg, &reg_data);
+	}
+
+	if (input_current <= 0)
+		max77833_set_buck(charger, DISABLE);
+	else {
+		max77833_set_buck(charger, ENABLE);
+	}
+
+	if (!input_current) {
+		max77833_write_reg(charger->i2c,
+				   set_reg, reg_data);
+	} else if(charger->cable_type == POWER_SUPPLY_TYPE_WIRELESS) {
+		if (input_current >= 2000)
+			reg_data = 0x50;
+		else
+			reg_data = input_current / 25;
+		max77833_write_reg(charger->i2c,
+				   set_reg, reg_data);
+	} else {
+		input_current = (input_current > charger->charging_current_max) ?
+		charger->charging_current_max : input_current;
+
+		if (input_current >= 4000)
+			reg_data = 0xA0;
+		else
+			reg_data = input_current / 25;
+		max77833_write_reg(charger->i2c,
+				   set_reg, reg_data);
+	}
+
+	mutex_unlock(&charger->charger_mutex);
+	pr_info("[%s] REG(0x%02x) DATA(0x%02x)\n",
+		__func__, set_reg, reg_data);
+}
+
+static void max77833_set_charge_current(struct max77833_charger_data *charger,
+					int fast_charging_current)
+{
+	int curr_step = 50;
+	u8 reg_data;
+
+	max77833_read_reg(charger->i2c,
+			  MAX77833_CHG_REG_CNFG_05, &reg_data);
+
+	if (!fast_charging_current) {
+		max77833_write_reg(charger->i2c,
+				   MAX77833_CHG_REG_CNFG_05, 0x00);
+	} else {
+		reg_data = fast_charging_current / curr_step;
+		max77833_write_reg(charger->i2c,MAX77833_CHG_REG_CNFG_05, reg_data);
+	}
+
+	pr_info("[%s] REG(0x%02x) DATA(0x%02x), CURRENT(%d)\n",
+		__func__, MAX77833_CHG_REG_CNFG_05,
+		reg_data, fast_charging_current);
+}
+
+static int max77833_check_aicl_state(struct max77833_charger_data *charger)
+{
+	u8 aicl_state;
+	if (!max77833_read_reg(charger->i2c, MAX77833_CHG_REG_INT_OK, &aicl_state)) {
+		pr_info("%s aicl state \n", __func__);
+		return !(aicl_state & 0x80);
+	}
+	return 0;
+}
+
+static void max77833_set_current(struct max77833_charger_data *charger)
+{
+	int current_now = charger->charging_current,
+		current_max = charger->charging_current_max;
+	int usb_charging_current = charger->pdata->charging_current[
+		POWER_SUPPLY_TYPE_USB].fast_charging_current;
+
+	pr_info("%s: siop_level=%d, afc_detec=%d, current_max=%d, current_now=%d\n",
+		__func__, charger->siop_level, charger->afc_detect, current_max, current_now);
+
+	if (charger->is_charging) {
+		/* decrease the charging current according to siop level */
+		current_now = current_now * charger->siop_level / 100;
+
+		/* do forced set charging current */
+		if (current_now > 0 && current_now < usb_charging_current)
+			current_now = usb_charging_current;
+
+		if (charger->siop_level < 100) {
+			if (charger->cable_type == POWER_SUPPLY_TYPE_WIRELESS) {
+				current_max = SIOP_WIRELESS_INPUT_LIMIT_CURRENT;
+				if (current_now > SIOP_WIRELESS_CHARGING_LIMIT_CURRENT)
+					current_now = SIOP_WIRELESS_CHARGING_LIMIT_CURRENT;
+			} else if (charger->cable_type == POWER_SUPPLY_TYPE_HV_MAINS ||
+					   charger->cable_type == POWER_SUPPLY_TYPE_HV_ERR){
+				if (current_max > SIOP_HV_INPUT_LIMIT_CURRENT)
+					current_max = SIOP_HV_INPUT_LIMIT_CURRENT;
+				if (current_now > SIOP_HV_CHARGING_LIMIT_CURRENT)
+					current_now = SIOP_HV_CHARGING_LIMIT_CURRENT;
+			} else {
+				if (current_max > SIOP_INPUT_LIMIT_CURRENT)
+					current_max = SIOP_INPUT_LIMIT_CURRENT;
+				if (current_now > SIOP_CHARGING_LIMIT_CURRENT)
+					current_now = SIOP_CHARGING_LIMIT_CURRENT;
+			}
+		}
+	}
+
+	pr_info("%s: siop_level=%d, afc_detec=%d, current_max=%d, current_now=%d\n",
+		__func__, charger->siop_level, charger->afc_detect, current_max, current_now);
+
+	if (max77833_check_aicl_state(charger)) {
+		wake_lock(&charger->aicl_wake_lock);
+		queue_delayed_work(charger->wqueue, &charger->aicl_work,
+				msecs_to_jiffies(50));
+	}
+
+	max77833_set_charge_current(charger, current_now);
+	max77833_set_input_current(charger, current_max);
+
+	max77833_test_read(charger);
+}
+
+static void afc_detect_work(struct work_struct *work)
+{
+	struct max77833_charger_data *charger = container_of(work,
+							     struct max77833_charger_data,
+							     afc_work.work);
+	pr_info("%s\n", __func__);
+
+	if ((charger->cable_type == POWER_SUPPLY_TYPE_MAINS) && charger->is_charging && charger->afc_detect) {
+		charger->afc_detect = false;
+
+		if (charger->charging_current_max >= INPUT_CURRENT_TA) {
+			charger->charging_current_max = charger->pdata->charging_current[
+					POWER_SUPPLY_TYPE_MAINS].input_current_limit;
+		}
+		pr_info("%s: current_max(%d)\n", __func__, charger->charging_current_max);
+		max77833_set_current(charger);
+	}
+}
+
+static void max77833_set_topoff_current(struct max77833_charger_data *charger,
+					int termination_current,
+					int termination_time)
+{
+	int curr_base, curr_step;
+	u8 reg_data;
+
+	curr_base = 125;
+	curr_step = 75;
+
+	if (termination_current < curr_base)
+		termination_current = curr_base;
+	else if (termination_current > 650)
+		termination_current = 650;
+
+	reg_data = (termination_current - curr_base) / curr_step;
+	max77833_update_reg(charger->i2c, MAX77833_CHG_REG_CNFG_02,
+			    reg_data, 0x7);
+
+	pr_info("%s: reg_data(0x%02x), topoff(%d)\n",
+		__func__, reg_data, termination_current);
+}
+
+static void max77833_set_charger_state(struct max77833_charger_data *charger,
+				       int enable)
+{
+	u8 reg_data;
+
+	max77833_read_reg(charger->i2c, MAX77833_CHG_REG_CNFG_00, &reg_data);
+
+	if (enable) {
+		max77833_update_reg(charger->i2c, MAX77833_CHG_REG_CNFG_00,
+				CHG_CNFG_00_CHG_MASK, CHG_CNFG_00_CHG_MASK);
+	} else {
+		max77833_update_reg(charger->i2c, MAX77833_CHG_REG_CNFG_00,
+				0, CHG_CNFG_00_CHG_MASK);
+	}
+	max77833_read_reg(charger->i2c, MAX77833_CHG_REG_CNFG_00, &reg_data);
+	pr_debug("%s : CHG_CNFG_00(0x%02x)\n", __func__, reg_data);
+}
+
+static void reduce_input_current(struct max77833_charger_data *charger, int cur)
+{
+	u8 set_value;
+	unsigned int min_input_current = 0;
+
+	min_input_current = MINIMUM_INPUT_CURRENT;
+
+	if (!max77833_read_reg(charger->i2c, MAX77833_CHG_REG_CNFG_16, &set_value)) {
+		if ((set_value <= (min_input_current / charger->input_curr_limit_step)) ||
+		    (set_value <= (cur / charger->input_curr_limit_step)))
+			return;
+		set_value -= (cur / charger->input_curr_limit_step);
+		set_value = (set_value < (min_input_current / charger->input_curr_limit_step)) ?
+			(min_input_current / charger->input_curr_limit_step) : set_value;
+		max77833_write_reg(charger->i2c, MAX77833_CHG_REG_CNFG_16, set_value);
+		charger->charging_current_max = max77833_get_input_current(charger);
+		pr_info("%s: set current: reg:(0x%x), val:(0x%x), input_current(%d)\n",
+			__func__, MAX77833_CHG_REG_CNFG_16, set_value, charger->charging_current_max);
+	}
+}
+
+static void max77833_charger_function_control(
+	struct max77833_charger_data *charger)
+{
+	u8 chg_cnfg_00 = 0;
+	union power_supply_propval value;
+	union power_supply_propval chg_mode;
+	union power_supply_propval swelling_state;
+	union power_supply_propval battery_status;
+
+	psy_do_property("battery", get, POWER_SUPPLY_PROP_ONLINE, value);
+	psy_do_property("battery", get, POWER_SUPPLY_PROP_CHARGE_COUNTER_SHADOW, battery_status);
+
+	/* OTG_EN control */
+	if (charger->pdata->otg_en) {
+		if (battery_status.intval == POWER_SUPPLY_TYPE_USB) {
+			gpio_direction_output(charger->pdata->otg_en, 1);
+			pr_info("%s: OTG_EN set to HIGH. cable(%d)\n", __func__, value.intval);
+		} else {
+			if (value.intval != POWER_SUPPLY_TYPE_WIRELESS) {
+				gpio_direction_output(charger->pdata->otg_en, 0);
+				pr_info("%s: OTG_EN set to LOW. cable(%d)\n", __func__, value.intval);
+			}
+		}
+	}
+
+	psy_do_property("battery", get, POWER_SUPPLY_PROP_HEALTH, value);
+
+	pr_info("####%s####\n", __func__);
+
+	if (charger->cable_type == POWER_SUPPLY_TYPE_BATTERY ||
+	    charger->cable_type == POWER_SUPPLY_TYPE_OTG) {
+		charger->is_charging = false;
+		charger->afc_detect = false;
+		charger->aicl_on = false;
+		charger->is_mdock = false;
+		charger->charging_current = 0;
+
+		if ((charger->status == POWER_SUPPLY_STATUS_DISCHARGING) ||
+		    (value.intval == POWER_SUPPLY_HEALTH_UNSPEC_FAILURE) ||
+		    (value.intval == POWER_SUPPLY_HEALTH_OVERHEATLIMIT)) {
+			charger->charging_current_max =
+				((value.intval == POWER_SUPPLY_HEALTH_UNSPEC_FAILURE) || \
+				 (value.intval == POWER_SUPPLY_HEALTH_OVERHEATLIMIT)) ?
+				0 : charger->pdata->charging_current[POWER_SUPPLY_TYPE_USB].input_current_limit;
+		}
+
+		if (charger->cable_type == POWER_SUPPLY_TYPE_OTG) {
+			/* OTG_EN set to HIGH */
+			if (charger->pdata->otg_en) {
+				gpio_direction_output(charger->pdata->otg_en, 1);
+				pr_info("%s: OTG_EN set to HIGH. cable type OTG\n", __func__);
+			}
+
+			chg_cnfg_00 |= (CHG_CNFG_00_OTG_MASK
+					| CHG_CNFG_00_BOOST_MASK);
+
+			chg_cnfg_00 &= ~(CHG_CNFG_00_BUCK_MASK);
+
+			max77833_update_reg(charger->i2c,
+					    MAX77833_CHG_REG_CNFG_00,
+					    chg_cnfg_00,
+					    (CHG_CNFG_00_OTG_MASK |
+					     CHG_CNFG_00_BOOST_MASK |
+					     CHG_CNFG_00_BUCK_MASK));
+		} else {
+			if (charger->status == POWER_SUPPLY_STATUS_DISCHARGING) { /* cable type battery + discharging */
+				max77833_write_reg(charger->i2c, MAX77833_CHG_REG_CNFG_07, 0x00);
+				pr_info("%s: Vsysmin set to 3.0V. cable(%d)\n", __func__, charger->cable_type);
+			}
+			psy_do_property("battery", get, POWER_SUPPLY_PROP_CHARGE_COUNTER_SHADOW, value);
+			/* OTG_EN set to LOW */
+			if (charger->pdata->otg_en && value.intval != POWER_SUPPLY_TYPE_USB) {
+				gpio_direction_output(charger->pdata->otg_en, 0);
+				pr_info("%s: OTG_EN set to LOW. cable type BATTERY\n", __func__);
+			}
+
+			chg_cnfg_00 &= ~(CHG_CNFG_00_CHG_MASK
+					 | CHG_CNFG_00_OTG_MASK
+					 | CHG_CNFG_00_BOOST_MASK);
+
+			max77833_update_reg(charger->i2c,
+					    MAX77833_CHG_REG_CNFG_00,
+					    chg_cnfg_00,
+					    (CHG_CNFG_00_CHG_MASK |
+					     CHG_CNFG_00_OTG_MASK |
+					     CHG_CNFG_00_BOOST_MASK));
+		}
+	} else {
+		if (charger->cable_type == POWER_SUPPLY_TYPE_HMT_CONNECTED)
+			charger->is_charging = false;
+		else
+			charger->is_charging = true;
+		charger->afc_detect = false;
+		charger->charging_current_max =
+			charger->pdata->charging_current
+			[charger->cable_type].input_current_limit;
+		charger->charging_current =
+			charger->pdata->charging_current
+			[charger->cable_type].fast_charging_current;
+		if (charger->is_mdock) { /* if mdock was alread inserted, then check OTG, or NOTG state */
+			if (charger->cable_type == POWER_SUPPLY_TYPE_SMART_NOTG) {
+				charger->charging_current =
+					charger->pdata->charging_current
+					[POWER_SUPPLY_TYPE_MDOCK_TA].fast_charging_current;
+				charger->charging_current_max =
+					charger->pdata->charging_current
+					[POWER_SUPPLY_TYPE_MDOCK_TA].input_current_limit;
+			} else if (charger->cable_type == POWER_SUPPLY_TYPE_SMART_OTG) {
+				charger->charging_current =
+					charger->pdata->charging_current
+					[POWER_SUPPLY_TYPE_MDOCK_TA].fast_charging_current - 500;
+				charger->charging_current_max =
+					charger->pdata->charging_current
+					[POWER_SUPPLY_TYPE_MDOCK_TA].input_current_limit - 500;
+			}
+		} else { /*if mdock wasn't inserted, then check mdock state*/
+			if (charger->cable_type == POWER_SUPPLY_TYPE_MDOCK_TA)
+				charger->is_mdock = true;
+		}
+
+		if (charger->cable_type == POWER_SUPPLY_TYPE_MAINS) {
+			charger->afc_detect = true;
+			charger->charging_current_max = INPUT_CURRENT_TA;
+			queue_delayed_work(charger->wqueue, &charger->afc_work, msecs_to_jiffies(2000));
+			wake_lock_timeout(&charger->afc_wake_lock, HZ * 3);
+		}
+	}
+
+	pr_info("charging = %d, fc = %d, il = %d, t1 = %d, t2 = %d, cable = %d\n",
+		charger->is_charging,
+		charger->charging_current,
+		charger->charging_current_max,
+		charger->pdata->charging_current[charger->cable_type].full_check_current_1st,
+		charger->pdata->charging_current[charger->cable_type].full_check_current_2nd,
+		charger->cable_type);
+
+	if (charger->pdata->full_check_type_2nd == SEC_BATTERY_FULLCHARGED_CHGPSY) {
+		psy_do_property("battery", get,
+				POWER_SUPPLY_PROP_CHARGE_NOW,
+				chg_mode);
+#if defined(CONFIG_BATTERY_SWELLING)
+		psy_do_property("battery", get,
+				POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT,
+				swelling_state);
+#else
+		swelling_state.intval = 0;
+#endif
+		if (chg_mode.intval == SEC_BATTERY_CHARGING_2ND || swelling_state.intval) {
+			max77833_set_charger_state(charger, 0);
+			max77833_set_topoff_current(charger,
+						    charger->pdata->charging_current[
+							    charger->cable_type].full_check_current_2nd,
+						    (70 * 60));
+		} else {
+			max77833_set_topoff_current(charger,
+						    charger->pdata->charging_current[
+							    charger->cable_type].full_check_current_1st,
+						    (70 * 60));
+		}
+	} else {
+		max77833_set_topoff_current(charger,
+					    charger->pdata->charging_current[
+						    charger->cable_type].full_check_current_1st,
+					    charger->pdata->charging_current[
+						    charger->cable_type].full_check_current_2nd);
+	}
+
+	max77833_set_charger_state(charger, charger->is_charging);
+
+
+	pr_info("charging = %d, fc = %d, il = %d, t1 = %d, t2 = %d, cable = %d\n",
+		charger->is_charging,
+		charger->charging_current,
+		charger->charging_current_max,
+		charger->pdata->charging_current[charger->cable_type].full_check_current_1st,
+		charger->pdata->charging_current[charger->cable_type].full_check_current_2nd,
+		charger->cable_type);
+
+	max77833_test_read(charger);
+
+}
+
+static void max77833_charger_initialize(struct max77833_charger_data *charger)
+{
+	u8 reg_data;
+	pr_info("%s\n", __func__);
+
+	/* unmasked: CHGIN_I, WCIN_I, BATP_I, BYP_I	*/
+	/*max77833_write_reg(charger->i2c, MAX77833_CHG_REG_INT_MASK, 0x9a);*/
+
+	/* unlock charger setting protect */
+	reg_data = 0x03;
+	max77833_write_reg(charger->i2c, MAX77833_CHG_REG_PROTECT, reg_data);
+
+	/*
+	 * fast charge timer disable
+	 * restart threshold disable
+	 * pre-qual charge enable(default)
+	 */
+	reg_data = (0x03 << 4);
+	max77833_write_reg(charger->i2c, MAX77833_CHG_REG_CNFG_04, reg_data);
+
+	/*
+	 * top off current 125mA
+	 * top off timer 70min
+	 * otg current limit 1200mA
+	 */
+	reg_data = 0xB8;
+	max77833_write_reg(charger->i2c, MAX77833_CHG_REG_CNFG_02, reg_data);
+
+	/*
+	 * cv voltage 4.2V or 4.35V
+	 * MINVSYS 3.6V(default)
+	 */
+	reg_data = max77833_get_float_voltage_data(charger->pdata->chg_float_voltage);
+	max77833_write_word(charger->i2c, MAX77833_CHG_REG_CNFG_06, reg_data);
+	pr_info("%s: battery cv voltage 0x%x\n", __func__, reg_data);
+
+	/*
+	 * CHGIN falling AICL threshold 4.3V(default)
+	 */
+	reg_data = 0x03;
+	max77833_write_word(charger->i2c, MAX77833_CHG_REG_CNFG_11, reg_data);
+	pr_info("%s: CHGIN AICL threshold 0x%x\n", __func__, reg_data);
+
+	/* SYS_OCT_ACT = 0 */
+	max77833_update_reg(charger->i2c, MAX77833_CHG_REG_CNFG_15, 0, 1);
+
+	max77833_test_read(charger);
+}
+
+#if defined(CONFIG_BATTERY_SWELLING) || defined(CONFIG_BATTERY_SWELLING_SELF_DISCHARGING)
+static void max77833_set_float_voltage(struct max77833_charger_data *charger, int float_voltage)
+{
+	u8 reg_data = 0;
+
+	reg_data = max77833_get_float_voltage_data(float_voltage);
+	max77833_write_word(charger->i2c, MAX77833_CHG_REG_CNFG_06, reg_data);
+	charger->pdata->chg_float_voltage = float_voltage;
+	pr_info("%s: battery cv voltage 0x%x, chg_float_voltage = %dmV \n", __func__, reg_data, charger->pdata->chg_float_voltage);
+}
+
+static u8 max77833_get_float_voltage(struct max77833_charger_data *charger)
+{
+	u8 reg_data = 0;
+
+	max77833_read_reg(charger->i2c, MAX77833_CHG_REG_CNFG_06, &reg_data);
+	pr_info("%s: battery cv voltage 0x%x, chg_float_voltage = %dmV \n", __func__, reg_data, charger->pdata->chg_float_voltage);
+	return reg_data;
+}
+
+#endif
+
+static int max77833_chg_create_attrs(struct device *dev)
+{
+	unsigned long i;
+	int rc;
+
+	for (i = 0; i < ARRAY_SIZE(max77833_charger_attrs); i++) {
+		rc = device_create_file(dev, &max77833_charger_attrs[i]);
+		if (rc)
+			goto create_attrs_failed;
+	}
+	return rc;
+
+create_attrs_failed:
+	dev_err(dev, "%s: failed (%d)\n", __func__, rc);
+	while (i--)
+		device_remove_file(dev, &max77833_charger_attrs[i]);
+	return rc;
+}
+
+ssize_t max77833_chg_show_attrs(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	const ptrdiff_t offset = attr - max77833_charger_attrs;
+	int i = 0;
+
+	switch(offset) {
+	case CHIP_ID:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%s\n", "MAX77833");
+		break;
+	default:
+		return -EINVAL;
+	}
+	return i;
+}
+
+ssize_t max77833_chg_store_attrs(struct device *dev,
+			    struct device_attribute *attr,
+			    const char *buf, size_t count)
+{
+	const ptrdiff_t offset = attr - max77833_charger_attrs;
+	int ret = 0;
+
+	switch(offset) {
+	case CHIP_ID:
+		ret = count;
+		break;
+	default:
+		ret = -EINVAL;
+	}
+	return ret;
+}
+
+static void max77833_chg_otype_check(struct max77833_charger_data *charger)
+{
+	u8 reg_data;
+	max77833_read_reg(charger->i2c, MAX77833_CHG_REG_CNFG_06, &reg_data);
+
+	if (reg_data != 0x78) {
+		return;
+	} else {
+		pr_info("%s : o-type register reset.\n", __func__);
+
+		/* unlock charger setting protect */
+		reg_data = 0x03;
+		max77833_write_reg(charger->i2c, MAX77833_CHG_REG_PROTECT, reg_data);
+
+		reg_data = max77833_get_float_voltage_data(charger->pdata->chg_float_voltage);
+		max77833_write_word(charger->i2c, MAX77833_CHG_REG_CNFG_06, reg_data);
+		pr_info("%s: battery cv voltage 0x%x\n", __func__, reg_data);
+
+		if (!charger->is_charging) {
+			return;
+		} else {
+			max77833_set_charger_state(charger, 0);
+			max77833_charger_function_control(charger);
+		}
+	}
+}
+
+static int max77833_chg_get_property(struct power_supply *psy,
+			      enum power_supply_property psp,
+			      union power_supply_propval *val)
+{
+	struct max77833_charger_data *charger =
+		container_of(psy, struct max77833_charger_data, psy_chg);
+	u8 reg_data;
+
+	max77833_chg_otype_check(charger);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = POWER_SUPPLY_TYPE_BATTERY;
+		if (max77833_read_reg(charger->i2c,
+			MAX77833_CHG_REG_INT_OK, &reg_data) == 0) {
+			if (reg_data & MAX77833_WCIN_OK) {
+				val->intval = POWER_SUPPLY_TYPE_WIRELESS;
+				charger->wc_w_state = 1;
+			} else if (reg_data & MAX77833_CHGIN_OK) {
+				val->intval = POWER_SUPPLY_TYPE_MAINS;
+			}
+		}
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = max77833_check_battery(charger);
+		break;
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = max77833_get_charger_state(charger);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+		if (!charger->is_charging)
+			val->intval = POWER_SUPPLY_CHARGE_TYPE_NONE;
+		else if (charger->aicl_on)
+		{
+			val->intval = POWER_SUPPLY_CHARGE_TYPE_SLOW;
+			pr_info("%s: slow-charging mode\n", __func__);
+		}
+		else
+			val->intval = POWER_SUPPLY_CHARGE_TYPE_FAST;
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = max77833_get_charging_health(charger);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		val->intval = charger->charging_current_max;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+		val->intval = max77833_get_input_current(charger);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = max77833_get_input_current(charger);
+		pr_debug("%s : set-current(%dmA), current now(%dmA)\n",
+			__func__, charger->charging_current, val->intval);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+		break;
+#if defined(CONFIG_BATTERY_SWELLING) || defined(CONFIG_BATTERY_SWELLING_SELF_DISCHARGING)
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+		val->intval = max77833_get_float_voltage(charger);
+		break;
+#endif
+#if defined(CONFIG_AFC_CHARGER_MODE)
+	case POWER_SUPPLY_PROP_AFC_CHARGER_MODE:
+		return -ENODATA;
+#endif
+	case POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL:
+		return -ENODATA;
+	case POWER_SUPPLY_PROP_USB_HC:
+		return -ENODATA;
+	case POWER_SUPPLY_PROP_CHARGE_NOW:
+		max77833_read_reg(charger->i2c,
+				  MAX77833_CHG_REG_DTLS_01, &reg_data);
+		reg_data &= 0x0F;
+		switch (reg_data) {
+		case 0x01:
+			val->strval = "CC Mode";
+			break;
+		case 0x02:
+			val->strval = "CV Mode";
+			break;
+		case 0x03:
+			val->strval = "EOC";
+			break;
+		case 0x04:
+			val->strval = "DONE";
+			break;
+		default:
+			val->strval = "NONE";
+			break;
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int max77833_chg_set_property(struct power_supply *psy,
+			  enum power_supply_property psp,
+			  const union power_supply_propval *val)
+{
+	struct max77833_charger_data *charger =
+		container_of(psy, struct max77833_charger_data, psy_chg);
+	union power_supply_propval value;
+	u8 chg_cnfg_00 = 0;
+	static u8 chg_int_state;
+
+	switch (psp) {
+	/* val->intval : type */
+	case POWER_SUPPLY_PROP_STATUS:
+		charger->status = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		/* check and unlock */
+		check_charger_unlock_state(charger);
+		if (val->intval == POWER_SUPPLY_TYPE_POWER_SHARING) {
+			psy_do_property("ps", get,
+				POWER_SUPPLY_PROP_STATUS, value);
+			if (value.intval) {
+				max77833_update_reg(charger->i2c, MAX77833_CHG_REG_CNFG_00,
+					CHG_CNFG_00_OTG_CTRL, CHG_CNFG_00_OTG_CTRL);
+			} else {
+				max77833_update_reg(charger->i2c, MAX77833_CHG_REG_CNFG_00,
+					0, CHG_CNFG_00_OTG_CTRL);
+			}
+			break;
+		}
+
+		charger->cable_type = val->intval;
+		max77833_charger_function_control(charger);
+		max77833_set_current(charger);
+		break;
+	/* val->intval : input charging current */
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		charger->charging_current_max = val->intval;
+		max77833_set_input_current(charger, val->intval);
+		break;
+	/*  val->intval : charging current */
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+#if defined(CONFIG_BATTERY_SWELLING)
+		if (val->intval > charger->pdata->charging_current
+			[charger->cable_type].fast_charging_current) {
+			break;
+		}
+#endif
+		charger->charging_current = val->intval;
+		max77833_set_charge_current(charger,
+			val->intval);
+		break;
+	/* val->intval : charging current */
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		max77833_set_charge_current(charger,
+			val->intval);
+		max77833_set_input_current(charger,
+			val->intval);
+		break;
+#if defined(CONFIG_AFC_CHARGER_MODE)
+	case POWER_SUPPLY_PROP_AFC_CHARGER_MODE:
+	//	max77833_hv_muic_charger_init();
+		break;
+#endif
+#if defined(CONFIG_BATTERY_SWELLING) || defined(CONFIG_BATTERY_SWELLING_SELF_DISCHARGING)
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+		pr_info("%s: float voltage(%d)\n", __func__, val->intval);
+		max77833_set_float_voltage(charger, val->intval);
+		break;
+#endif
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+		charger->siop_level = val->intval;
+		max77833_set_current(charger);
+		break;
+	case POWER_SUPPLY_PROP_USB_HC:
+		/* set input/charging current for usb up to TA's current */
+		if (val->intval) {
+			charger->pdata->charging_current[
+				POWER_SUPPLY_TYPE_USB].fast_charging_current =
+			charger->pdata->charging_current[
+				POWER_SUPPLY_TYPE_MAINS].fast_charging_current;
+			charger->pdata->charging_current[
+				POWER_SUPPLY_TYPE_USB].input_current_limit =
+			charger->pdata->charging_current[
+				POWER_SUPPLY_TYPE_MAINS].input_current_limit;
+		/* restore input/charging current for usb */
+		} else {
+			charger->pdata->charging_current[
+				POWER_SUPPLY_TYPE_USB].fast_charging_current =
+			charger->pdata->charging_current[
+				POWER_SUPPLY_TYPE_BATTERY].input_current_limit;
+			charger->pdata->charging_current[
+				POWER_SUPPLY_TYPE_USB].input_current_limit =
+			charger->pdata->charging_current[
+				POWER_SUPPLY_TYPE_BATTERY].input_current_limit;
+		}
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL:
+		if (val->intval) {
+			max77833_read_reg(charger->i2c, MAX77833_CHG_REG_INT_MASK,
+				&chg_int_state);
+
+			/* OTG_EN set to HIGH */
+			if (charger->pdata->otg_en)
+					gpio_direction_output(charger->pdata->otg_en, 1);
+
+			/* eable charger interrupt: CHG_I, CHGIN_I */
+			/* enable charger interrupt: BYP_I */
+			max77833_update_reg(charger->i2c, MAX77833_CHG_REG_INT_MASK,
+				0,
+				MAX77833_CHG_IM | MAX77833_CHGIN_IM | MAX77833_BYP_IM);
+
+			/* OTG on, boost on */
+			max77833_update_reg(charger->i2c, MAX77833_CHG_REG_CNFG_00,
+				CHG_CNFG_00_OTG_CTRL, CHG_CNFG_00_OTG_CTRL);
+
+		} else {
+			psy_do_property("battery", get, POWER_SUPPLY_PROP_CHARGE_COUNTER_SHADOW, value);
+			if (charger->pdata->otg_en && value.intval != POWER_SUPPLY_TYPE_USB) {
+				gpio_direction_output(charger->pdata->otg_en, 0);
+				pr_info("%s: OTG_EN set to LOW. cable(%d)\n", __func__, charger->cable_type);
+			}
+
+			/* OTG off, boost off, (buck on) */
+			max77833_update_reg(charger->i2c, MAX77833_CHG_REG_CNFG_00,
+				CHG_CNFG_00_BUCK_MASK, CHG_CNFG_00_BUCK_MASK | CHG_CNFG_00_OTG_CTRL);
+
+
+			/* enable charger interrupt */
+			max77833_write_reg(charger->i2c,
+				MAX77833_CHG_REG_INT_MASK, chg_int_state);
+		}
+		max77833_read_reg(charger->i2c, MAX77833_CHG_REG_INT_MASK,
+			&chg_int_state);
+		max77833_read_reg(charger->i2c, MAX77833_CHG_REG_CNFG_00,
+			&chg_cnfg_00);
+		pr_info("%s: INT_MASK(0x%x), CHG_CNFG_00(0x%x)\n",
+			__func__, chg_int_state, chg_cnfg_00);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_NOW:
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int max77833_debugfs_show(struct seq_file *s, void *data)
+{
+	struct max77833_charger_data *charger = s->private;
+	u8 reg;
+	u8 reg_data;
+
+	seq_printf(s, "MAX77833 CHARGER IC :\n");
+	seq_printf(s, "===================\n");
+	for (reg = 0x80; reg <= 0x9D; reg++) {
+		max77833_read_reg(charger->i2c, reg, &reg_data);
+		seq_printf(s, "0x%02x:\t0x%02x\n", reg, reg_data);
+	}
+
+	seq_printf(s, "\n");
+	return 0;
+}
+
+static int max77833_debugfs_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, max77833_debugfs_show, inode->i_private);
+}
+
+static const struct file_operations max77833_debugfs_fops = {
+	.open           = max77833_debugfs_open,
+	.read           = seq_read,
+	.llseek         = seq_lseek,
+	.release        = single_release,
+};
+
+static void max77833_chg_isr_work(struct work_struct *work)
+{
+	struct max77833_charger_data *charger =
+		container_of(work, struct max77833_charger_data, isr_work.work);
+
+	union power_supply_propval val;
+
+	if (charger->pdata->full_check_type ==
+	    SEC_BATTERY_FULLCHARGED_CHGINT) {
+
+		val.intval = max77833_get_charger_state(charger);
+
+		switch (val.intval) {
+		case POWER_SUPPLY_STATUS_DISCHARGING:
+			pr_err("%s: Interrupted but Discharging\n", __func__);
+			break;
+
+		case POWER_SUPPLY_STATUS_NOT_CHARGING:
+			pr_err("%s: Interrupted but NOT Charging\n", __func__);
+			break;
+
+		case POWER_SUPPLY_STATUS_FULL:
+			pr_info("%s: Interrupted by Full\n", __func__);
+			psy_do_property("battery", set,
+				POWER_SUPPLY_PROP_STATUS, val);
+			break;
+
+		case POWER_SUPPLY_STATUS_CHARGING:
+			pr_err("%s: Interrupted but Charging\n", __func__);
+			break;
+
+		case POWER_SUPPLY_STATUS_UNKNOWN:
+		default:
+			pr_err("%s: Invalid Charger Status\n", __func__);
+			break;
+		}
+	}
+
+	if (charger->pdata->ovp_uvlo_check_type ==
+		SEC_BATTERY_OVP_UVLO_CHGINT) {
+		val.intval = max77833_get_charging_health(charger);
+		switch (val.intval) {
+		case POWER_SUPPLY_HEALTH_OVERHEAT:
+		case POWER_SUPPLY_HEALTH_COLD:
+			pr_err("%s: Interrupted but Hot/Cold\n", __func__);
+			break;
+
+		case POWER_SUPPLY_HEALTH_DEAD:
+			pr_err("%s: Interrupted but Dead\n", __func__);
+			break;
+
+		case POWER_SUPPLY_HEALTH_OVERVOLTAGE:
+		case POWER_SUPPLY_HEALTH_UNDERVOLTAGE:
+			pr_info("%s: Interrupted by OVP/UVLO\n", __func__);
+			psy_do_property("battery", set,
+				POWER_SUPPLY_PROP_HEALTH, val);
+			break;
+
+		case POWER_SUPPLY_HEALTH_UNSPEC_FAILURE:
+			pr_err("%s: Interrupted but Unspec\n", __func__);
+			break;
+
+		case POWER_SUPPLY_HEALTH_GOOD:
+			pr_err("%s: Interrupted but Good\n", __func__);
+			break;
+
+		case POWER_SUPPLY_HEALTH_UNKNOWN:
+		default:
+			pr_err("%s: Invalid Charger Health\n", __func__);
+			break;
+		}
+	}
+}
+
+static irqreturn_t max77833_chg_irq_thread(int irq, void *irq_data)
+{
+	struct max77833_charger_data *charger = irq_data;
+
+	pr_info("%s: Charger interrupt occured\n", __func__);
+
+	if ((charger->pdata->full_check_type ==
+	     SEC_BATTERY_FULLCHARGED_CHGINT) ||
+	    (charger->pdata->ovp_uvlo_check_type ==
+	     SEC_BATTERY_OVP_UVLO_CHGINT))
+		schedule_delayed_work(&charger->isr_work, 0);
+
+	return IRQ_HANDLED;
+}
+
+static void wpc_detect_work(struct work_struct *work)
+{
+	struct max77833_charger_data *charger = container_of(work,
+						struct max77833_charger_data,
+						wpc_work.work);
+	int wc_w_state;
+	int retry_cnt;
+	union power_supply_propval value;
+	u8 reg_data;
+
+	pr_info("%s\n", __func__);
+
+	max77833_update_reg(charger->i2c,
+		MAX77833_CHG_REG_INT_MASK, 0, MAX77833_WCIN_IM);
+
+	/* check and unlock */
+	check_charger_unlock_state(charger);
+
+	retry_cnt = 0;
+	do {
+		max77833_read_reg(charger->i2c,
+				  MAX77833_CHG_REG_INT_OK, &reg_data);
+		wc_w_state = (reg_data & MAX77833_WCIN_OK)
+			>> MAX77833_WCIN_OK_SHIFT;
+		msleep(50);
+	} while((retry_cnt++ < 2) && (wc_w_state == 0));
+
+	if ((charger->wc_w_state == 0) && (wc_w_state == 1)) {
+		value.intval = 1;
+		psy_do_property("wireless", set,
+				POWER_SUPPLY_PROP_ONLINE, value);
+		value.intval = POWER_SUPPLY_TYPE_WIRELESS;
+		pr_info("%s: wpc activated, set V_INT as PN\n",
+				__func__);
+	} else if ((charger->wc_w_state == 1) && (wc_w_state == 0)) {
+		if (!charger->is_charging)
+			max77833_set_charger_state(charger, true);
+
+		retry_cnt = 0;
+		do {
+			max77833_read_reg(charger->i2c,
+					  MAX77833_CHG_REG_DTLS_01, &reg_data);
+			reg_data = ((reg_data & MAX77833_CHG_DTLS)
+				    >> MAX77833_CHG_DTLS_SHIFT);
+			msleep(50);
+		} while((retry_cnt++ < 2) && (reg_data == 0x8));
+		pr_info("%s: reg_data: 0x%x, charging: %d\n", __func__,
+			reg_data, charger->is_charging);
+		if (!charger->is_charging)
+			max77833_set_charger_state(charger, false);
+		if ((reg_data != 0x08)
+		    && (charger->cable_type == POWER_SUPPLY_TYPE_WIRELESS)) {
+			pr_info("%s: wpc uvlo, but charging\n", __func__);
+			queue_delayed_work(charger->wqueue, &charger->wpc_work,
+					   msecs_to_jiffies(500));
+			return;
+		} else {
+			value.intval = 0;
+			psy_do_property("wireless", set,
+					POWER_SUPPLY_PROP_ONLINE, value);
+			pr_info("%s: wpc deactivated, set V_INT as PD\n",
+					__func__);
+		}
+	}
+	pr_info("%s: w(%d to %d)\n", __func__,
+		charger->wc_w_state, wc_w_state);
+
+	charger->wc_w_state = wc_w_state;
+
+	/* Do unmask again. (for frequent wcin irq problem) */
+	max77833_update_reg(charger->i2c,
+		MAX77833_CHG_REG_INT_MASK, 0, MAX77833_WCIN_IM);
+
+	wake_unlock(&charger->wpc_wake_lock);
+}
+
+static irqreturn_t wpc_charger_irq(int irq, void *data)
+{
+	struct max77833_charger_data *charger = data;
+	unsigned long delay;
+	u8 reg_data;
+
+	max77833_read_reg(charger->i2c,
+		MAX77833_CHG_REG_INT_MASK, &reg_data);
+	reg_data |= (1 << 5);
+	max77833_write_reg(charger->i2c,
+		MAX77833_CHG_REG_INT_MASK, reg_data);
+
+	wake_lock(&charger->wpc_wake_lock);
+#ifdef CONFIG_SAMSUNG_BATTERY_FACTORY
+	delay = msecs_to_jiffies(0);
+#else
+	if (charger->wc_w_state)
+		delay = msecs_to_jiffies(500);
+	else
+		delay = msecs_to_jiffies(0);
+#endif
+	queue_delayed_work(charger->wqueue, &charger->wpc_work,
+			delay);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t max77833_batp_irq(int irq, void *data)
+{
+	struct max77833_charger_data *charger = data;
+	union power_supply_propval value;
+	u8 reg_data;
+
+	pr_info("%s : irq(%d)\n", __func__, irq);
+
+	max77833_read_reg(charger->i2c,
+			  MAX77833_CHG_REG_INT_MASK, &reg_data);
+	reg_data |= (1 << 2);
+	max77833_write_reg(charger->i2c,
+		MAX77833_CHG_REG_INT_MASK, reg_data);
+
+	check_charger_unlock_state(charger);
+
+	max77833_read_reg(charger->i2c,
+			  MAX77833_CHG_REG_INT_OK,
+			  &reg_data);
+
+	if (!(reg_data & MAX77833_BATP_OK))
+		psy_do_property("battery", set, POWER_SUPPLY_PROP_PRESENT, value);
+
+	max77833_read_reg(charger->i2c,
+			  MAX77833_CHG_REG_INT_MASK, &reg_data);
+	reg_data &= ~(1 << 2);
+	max77833_write_reg(charger->i2c,
+			   MAX77833_CHG_REG_INT_MASK, reg_data);
+
+	return IRQ_HANDLED;
+}
+
+
+static irqreturn_t max77833_bypass_irq(int irq, void *data)
+{
+	struct max77833_charger_data *charger = data;
+	u8 dtls_02;
+	u8 byp_dtls;
+	u8 chg_cnfg_00;
+	u8 vbus_state;
+#ifdef CONFIG_USB_HOST_NOTIFY
+	struct otg_notify *o_notify;
+
+	o_notify = get_otg_notify();
+#endif
+
+	pr_info("%s: irq(%d)\n", __func__, irq);
+
+	/* check and unlock */
+	check_charger_unlock_state(charger);
+
+	max77833_read_reg(charger->i2c,
+			  MAX77833_CHG_REG_DTLS_02,
+			  &dtls_02);
+
+	byp_dtls = ((dtls_02 & MAX77833_BYP_DTLS) >>
+				MAX77833_BYP_DTLS_SHIFT);
+	pr_info("%s: BYP_DTLS(0x%02x)\n", __func__, byp_dtls);
+	vbus_state = max77833_get_vbus_state(charger);
+
+	if (byp_dtls & 0x1) {
+		pr_info("%s: bypass overcurrent limit\n", __func__);
+#ifdef CONFIG_USB_HOST_NOTIFY
+		send_otg_notify(o_notify, NOTIFY_EVENT_OVERCURRENT, 0);
+#endif
+		/* disable the register values just related to OTG and
+		   keep the values about the charging */
+		max77833_read_reg(charger->i2c,
+				  MAX77833_CHG_REG_CNFG_00, &chg_cnfg_00);
+		chg_cnfg_00 &= ~(CHG_CNFG_00_OTG_MASK
+				| CHG_CNFG_00_BOOST_MASK);
+		max77833_write_reg(charger->i2c,
+				   MAX77833_CHG_REG_CNFG_00,
+				   chg_cnfg_00);
+	}
+	return IRQ_HANDLED;
+}
+
+static void max77833_aicl_work(struct work_struct *work)
+{
+	struct max77833_charger_data *charger = container_of(work,
+				     struct max77833_charger_data, aicl_work.work);
+
+	charger->afc_detect = false;
+
+	if ((charger->is_charging) &&
+		(charger->cable_type != POWER_SUPPLY_TYPE_WIRELESS)) {
+		int now_count = 0,
+			max_count = charger->charging_current_max / REDUCE_CURRENT_STEP;
+		int prev_current_max = charger->charging_current_max;
+
+		mutex_lock(&charger->charger_mutex);
+		check_charger_unlock_state(charger);
+
+		while (max77833_check_aicl_state(charger) &&
+			(now_count++ < max_count) && (charger->is_charging) &&
+			(charger->cable_type != POWER_SUPPLY_TYPE_WIRELESS)) {
+			reduce_input_current(charger, REDUCE_CURRENT_STEP);
+			msleep(50);
+		}
+		pr_info("%s: charging_current_max(%d --> %d)\n",
+			__func__, prev_current_max, charger->charging_current_max);
+
+		if (prev_current_max > charger->charging_current_max) {
+			max77833_check_slow_charging(charger, charger->charging_current_max);
+		}
+		mutex_unlock(&charger->charger_mutex);
+	}
+
+	wake_unlock(&charger->aicl_wake_lock);
+}
+
+static irqreturn_t max77833_aicl_irq(int irq, void *data)
+{
+	struct max77833_charger_data *charger = data;
+
+	pr_info("%s: irq(%d)\n", __func__, irq);
+
+	wake_lock(&charger->aicl_wake_lock);
+	queue_delayed_work(charger->wqueue, &charger->aicl_work,
+		msecs_to_jiffies(50));
+
+	return IRQ_HANDLED;
+}
+
+static void max77833_chgin_isr_work(struct work_struct *work)
+{
+	struct max77833_charger_data *charger = container_of(work,
+				     struct max77833_charger_data, chgin_work);
+	u8 chgin_dtls, chg_dtls, chg_cnfg_00, reg_data;
+	u8 prev_chgin_dtls = 0xff;
+	int battery_health;
+	union power_supply_propval value;
+	int stable_count = 0;
+
+	wake_lock(&charger->chgin_wake_lock);
+
+	max77833_read_reg(charger->i2c,
+			  MAX77833_CHG_REG_INT_MASK, &reg_data);
+	reg_data |= (1 << 6);
+	max77833_write_reg(charger->i2c,
+		MAX77833_CHG_REG_INT_MASK, reg_data);
+
+	while (1) {
+		psy_do_property("battery", get,
+				POWER_SUPPLY_PROP_HEALTH, value);
+		battery_health = value.intval;
+
+		max77833_read_reg(charger->i2c,
+				MAX77833_CHG_REG_DTLS_00,
+				&chgin_dtls);
+		chgin_dtls = ((chgin_dtls & MAX77833_CHGIN_DTLS) >>
+				MAX77833_CHGIN_DTLS_SHIFT);
+		max77833_read_reg(charger->i2c,
+				MAX77833_CHG_REG_DTLS_01, &chg_dtls);
+		chg_dtls = ((chg_dtls & MAX77833_CHG_DTLS) >>
+				MAX77833_CHG_DTLS_SHIFT);
+		max77833_read_reg(charger->i2c,
+			MAX77833_CHG_REG_CNFG_00, &chg_cnfg_00);
+
+		if (prev_chgin_dtls == chgin_dtls)
+			stable_count++;
+		else
+			stable_count = 0;
+		if (stable_count > 10) {
+			pr_info("%s: irq(%d), chgin(0x%x), chg_dtls(0x%x) prev 0x%x\n",
+					__func__, charger->irq_chgin,
+					chgin_dtls, chg_dtls, prev_chgin_dtls);
+			if (charger->is_charging) {
+				if ((chgin_dtls == 0x02) && \
+					(battery_health != POWER_SUPPLY_HEALTH_OVERVOLTAGE)) {
+					pr_info("%s: charger is over voltage\n",
+							__func__);
+					value.intval = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+					psy_do_property("battery", set,
+						POWER_SUPPLY_PROP_HEALTH, value);
+				} else if (((chgin_dtls == 0x0) || (chgin_dtls == 0x01)) &&(chg_dtls & 0x08) && \
+						(chg_cnfg_00 & MAX77833_MODE_BUCK) && \
+						(chg_cnfg_00 & MAX77833_MODE_CHGR) && \
+						(battery_health != POWER_SUPPLY_HEALTH_UNDERVOLTAGE) && \
+						(charger->cable_type != POWER_SUPPLY_TYPE_WIRELESS)) {
+					pr_info("%s, vbus_state : 0x%d, chg_state : 0x%d\n", __func__, chgin_dtls, chg_dtls);
+					pr_info("%s: vBus is undervoltage\n", __func__);
+					value.intval = POWER_SUPPLY_HEALTH_UNDERVOLTAGE;
+					psy_do_property("battery", set,
+							POWER_SUPPLY_PROP_HEALTH, value);
+				}
+			} else {
+				if ((battery_health == \
+							POWER_SUPPLY_HEALTH_OVERVOLTAGE) &&
+						(chgin_dtls != 0x02)) {
+					pr_info("%s: vbus_state : 0x%d, chg_state : 0x%d\n", __func__, chgin_dtls, chg_dtls);
+					pr_info("%s: overvoltage->normal\n", __func__);
+					value.intval = POWER_SUPPLY_HEALTH_GOOD;
+					psy_do_property("battery", set,
+							POWER_SUPPLY_PROP_HEALTH, value);
+				} else if ((battery_health == \
+							POWER_SUPPLY_HEALTH_UNDERVOLTAGE) &&
+						!((chgin_dtls == 0x0) || (chgin_dtls == 0x01))){
+					pr_info("%s: vbus_state : 0x%d, chg_state : 0x%d\n", __func__, chgin_dtls, chg_dtls);
+					pr_info("%s: undervoltage->normal\n", __func__);
+					value.intval = POWER_SUPPLY_HEALTH_GOOD;
+					psy_do_property("battery", set,
+							POWER_SUPPLY_PROP_HEALTH, value);
+					max77833_set_input_current(charger,
+							charger->charging_current_max);
+				}
+			}
+			break;
+		}
+
+		prev_chgin_dtls = chgin_dtls;
+		msleep(100);
+	}
+	max77833_read_reg(charger->i2c,
+		MAX77833_CHG_REG_INT_MASK, &reg_data);
+	reg_data &= ~(1 << 6);
+	max77833_write_reg(charger->i2c,
+		MAX77833_CHG_REG_INT_MASK, reg_data);
+	wake_unlock(&charger->chgin_wake_lock);
+}
+
+static irqreturn_t max77833_chgin_irq(int irq, void *data)
+{
+	struct max77833_charger_data *charger = data;
+	queue_work(charger->wqueue, &charger->chgin_work);
+
+	return IRQ_HANDLED;
+}
+
+/* register chgin isr after sec_battery_probe */
+static void max77833_chgin_init_work(struct work_struct *work)
+{
+	struct max77833_charger_data *charger = container_of(work,
+						struct max77833_charger_data,
+						chgin_init_work.work);
+	int ret;
+
+	pr_info("%s \n", __func__);
+	ret = request_threaded_irq(charger->irq_chgin, NULL,
+			max77833_chgin_irq, 0, "chgin-irq", charger);
+	if (ret < 0) {
+		pr_err("%s: fail to request chgin IRQ: %d: %d\n",
+				__func__, charger->irq_chgin, ret);
+	} else {
+		max77833_update_reg(charger->i2c,
+			MAX77833_CHG_REG_INT_MASK, 0, MAX77833_CHGIN_IM);
+	}
+}
+
+#ifdef CONFIG_OF
+static int max77833_charger_parse_dt(struct max77833_charger_data *charger)
+{
+	struct device_node *np = of_find_node_by_name(NULL, "max77833-charger");
+	sec_charger_platform_data_t *pdata = charger->pdata;
+	int ret = 0;
+	int i, len;
+	const u32 *p;
+	u32 irq_gpio_flags;
+
+	if (np == NULL) {
+		pr_err("%s np NULL\n", __func__);
+	} else {
+		ret = of_property_read_u32(np, "battery,chg_float_voltage",
+					   &pdata->chg_float_voltage);
+	}
+
+	np = of_find_node_by_name(NULL, "battery");
+	if (!np) {
+		pr_err("%s np NULL\n", __func__);
+	} else {
+		ret = pdata->irq_gpio = of_get_named_gpio_flags(np, "battery,irq_gpio",
+				0, &irq_gpio_flags);
+		if (ret < 0)
+			pr_err("%s : can't get irq-gpio \n", __func__);
+		else {
+			pr_info("%s : irq_gpio = %d \n",__func__, pdata->irq_gpio);
+			pdata->chg_irq = gpio_to_irq(pdata->irq_gpio);
+			pr_info("%s : chg_irq = 0x%x \n",__func__, pdata->chg_irq);
+		}
+
+		pdata->wpc_det = of_get_named_gpio(np, "battery,wpc_det", 0);
+		if (pdata->wpc_det < 0)
+			pdata->wpc_det = 0;
+
+		pdata->otg_en = of_get_named_gpio(np, "battery,otg_en", 0);
+		if (pdata->otg_en < 0)
+			pdata->otg_en = 0;
+
+		ret = of_property_read_u32(np, "battery,full_check_type_2nd",
+					&pdata->full_check_type_2nd);
+		if (ret)
+			pr_info("%s : Full check type 2nd is Empty\n", __func__);
+
+		p = of_get_property(np, "battery,input_current_limit", &len);
+		if (!p)
+			return 1;
+
+		len = len / sizeof(u32);
+
+		pdata->charging_current = kzalloc(sizeof(sec_charging_current_t) * len,
+						  GFP_KERNEL);
+
+		for(i = 0; i < len; i++) {
+			ret = of_property_read_u32_index(np,
+				 "battery,input_current_limit", i,
+				 &pdata->charging_current[i].input_current_limit);
+			ret = of_property_read_u32_index(np,
+				 "battery,fast_charging_current", i,
+				 &pdata->charging_current[i].fast_charging_current);
+			ret = of_property_read_u32_index(np,
+				 "battery,full_check_current_1st", i,
+				 &pdata->charging_current[i].full_check_current_1st);
+			ret = of_property_read_u32_index(np,
+				 "battery,full_check_current_2nd", i,
+				 &pdata->charging_current[i].full_check_current_2nd);
+		}
+	}
+	return ret;
+}
+#endif
+
+static int __devinit max77833_charger_probe(struct platform_device *pdev)
+{
+	struct max77833_dev *max77833 = dev_get_drvdata(pdev->dev.parent);
+	struct max77833_platform_data *pdata = dev_get_platdata(max77833->dev);
+	struct max77833_charger_data *charger;
+	int ret = 0;
+	u8 reg_data;
+
+	pr_info("%s: Max77833 Charger Driver Loading\n", __func__);
+
+	charger = kzalloc(sizeof(*charger), GFP_KERNEL);
+	if (!charger)
+		return -ENOMEM;
+
+	pdata->charger_data = kzalloc(sizeof(sec_charger_platform_data_t), GFP_KERNEL);
+	if (!pdata->charger_data) {
+		ret = -ENOMEM;
+		goto err_free;
+	}
+
+	mutex_init(&charger->charger_mutex);
+	charger->dev = &pdev->dev;
+	charger->i2c = max77833->i2c;
+	charger->pdata = pdata->charger_data;
+	charger->aicl_on = false;
+	charger->afc_detect = false;
+	charger->is_mdock = false;
+	charger->siop_level = 100;
+	charger->max77833_pdata = pdata;
+	charger->input_curr_limit_step = 25;
+
+#if defined(CONFIG_OF)
+	ret = max77833_charger_parse_dt(charger);
+	if (ret < 0) {
+		pr_err("%s not found charger dt! ret[%d]\n",
+		       __func__, ret);
+	}
+#endif
+
+	platform_set_drvdata(pdev, charger);
+
+	charger->psy_chg.name		= "max77833-charger";
+	charger->psy_chg.type		= POWER_SUPPLY_TYPE_UNKNOWN;
+	charger->psy_chg.get_property	= max77833_chg_get_property;
+	charger->psy_chg.set_property	= max77833_chg_set_property;
+	charger->psy_chg.properties	= max77833_charger_props;
+	charger->psy_chg.num_properties	= ARRAY_SIZE(max77833_charger_props);
+
+	max77833_charger_initialize(charger);
+
+	if (charger->pdata->otg_en) {
+		ret = gpio_request(charger->pdata->otg_en, "OTG_EN");
+		if (ret) {
+			pr_err("failed to request GPIO %u\n", charger->pdata->otg_en);
+			goto err_gpio;
+		}
+	}
+
+	if (max77833_read_reg(max77833->i2c, MAX77833_PMIC_REG_PMICREV, &reg_data) < 0) {
+		pr_err("device not found on this channel (this is not an error)\n");
+		ret = -ENOMEM;
+		goto err_pdata_free;
+	} else {
+		charger->pmic_ver = (reg_data & 0x7);
+		pr_info("%s : device found : ver.0x%x\n", __func__, charger->pmic_ver);
+	}
+
+	(void) debugfs_create_file("max77833-regs",
+		S_IRUGO, NULL, (void *)charger, &max77833_debugfs_fops);
+
+	charger->wqueue =
+	    create_singlethread_workqueue(dev_name(&pdev->dev));
+	if (!charger->wqueue) {
+		pr_err("%s: Fail to Create Workqueue\n", __func__);
+		goto err_pdata_free;
+	}
+	wake_lock_init(&charger->chgin_wake_lock, WAKE_LOCK_SUSPEND,
+		       "charger->chgin");
+	INIT_WORK(&charger->chgin_work, max77833_chgin_isr_work);
+	INIT_DELAYED_WORK(&charger->chgin_init_work, max77833_chgin_init_work);
+	wake_lock_init(&charger->wpc_wake_lock, WAKE_LOCK_SUSPEND,
+					       "charger-wpc");
+	wake_lock_init(&charger->afc_wake_lock, WAKE_LOCK_SUSPEND,
+		       "charger-afc");
+	INIT_DELAYED_WORK(&charger->wpc_work, wpc_detect_work);
+	INIT_DELAYED_WORK(&charger->afc_work, afc_detect_work);
+
+	wake_lock_init(&charger->aicl_wake_lock, WAKE_LOCK_SUSPEND,
+					       "charger-aicl");
+	INIT_DELAYED_WORK(&charger->aicl_work, max77833_aicl_work);
+
+	ret = power_supply_register(&pdev->dev, &charger->psy_chg);
+	if (ret) {
+		pr_err("%s: Failed to Register psy_chg\n", __func__);
+		goto err_power_supply_register;
+	}
+
+	if (charger->pdata->chg_irq) {
+		INIT_DELAYED_WORK(&charger->isr_work, max77833_chg_isr_work);
+
+		ret = request_threaded_irq(charger->pdata->chg_irq,
+				NULL, max77833_chg_irq_thread,
+				IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING |
+				IRQF_ONESHOT,
+				"charger-irq", charger);
+		if (ret) {
+			pr_err("%s: Failed to Request IRQ\n", __func__);
+			goto err_irq;
+		}
+
+			ret = enable_irq_wake(charger->pdata->chg_irq);
+			if (ret < 0)
+				pr_err("%s: Failed to Enable Wakeup Source(%d)\n",
+					__func__, ret);
+		}
+
+	charger->wc_w_irq = pdata->irq_base + MAX77833_CHG_IRQ_WCIN_I;
+	ret = request_threaded_irq(charger->wc_w_irq,
+				   NULL, wpc_charger_irq,
+				   IRQF_TRIGGER_FALLING,
+				   "wpc-int", charger);
+	if (ret) {
+		pr_err("%s: Failed to Request IRQ\n", __func__);
+		goto err_wc_irq;
+	}
+
+	max77833_read_reg(charger->i2c,
+			  MAX77833_CHG_REG_INT_OK, &reg_data);
+	charger->wc_w_state = (reg_data & MAX77833_WCIN_OK)
+		>> MAX77833_WCIN_OK_SHIFT;
+
+	charger->irq_chgin = pdata->irq_base + MAX77833_CHG_IRQ_CHGIN_I;
+	/* enable chgin irq after sec_battery_probe */
+	queue_delayed_work(charger->wqueue, &charger->chgin_init_work,
+			msecs_to_jiffies(3000));
+
+	charger->irq_bypass = pdata->irq_base + MAX77833_CHG_IRQ_BYP_I;
+	ret = request_threaded_irq(charger->irq_bypass, NULL,
+			max77833_bypass_irq, 0, "bypass-irq", charger);
+	if (ret < 0) {
+		pr_err("%s: fail to request bypass IRQ: %d: %d\n",
+				__func__, charger->irq_bypass, ret);
+	} else {
+		max77833_update_reg(charger->i2c,
+			MAX77833_CHG_REG_INT_MASK, 0, MAX77833_BYP_IM);
+	}
+
+	charger->irq_batp = pdata->irq_base + MAX77833_CHG_IRQ_BATP_I;
+	ret = request_threaded_irq(charger->irq_batp, NULL,
+				   max77833_batp_irq, 0,
+				   "batp-irq", charger);
+	if (ret < 0) {
+		pr_err("%s: fail to request batp IRQ: %d: %d\n",
+		       __func__, charger->irq_batp, ret);
+	} else {
+		max77833_update_reg(charger->i2c,
+			MAX77833_CHG_REG_INT_MASK, 0, MAX77833_BATP_IM);
+	}
+
+	charger->irq_aicl = pdata->irq_base + MAX77833_CHG_IRQ_AICL_I;
+	ret = request_threaded_irq(charger->irq_aicl, NULL,
+			max77833_aicl_irq, 0, "aicl-irq", charger);
+	if (ret < 0) {
+		pr_err("%s: fail to request aicl IRQ: %d: %d\n",
+				__func__, charger->irq_aicl, ret);
+	} else {
+		max77833_update_reg(charger->i2c,
+			MAX77833_CHG_REG_INT_MASK, 0, MAX77833_AICL_IM);
+	}
+
+	ret = max77833_chg_create_attrs(charger->psy_chg.dev);
+	if (ret) {
+		dev_err(charger->dev,
+			"%s : Failed to create_attrs\n", __func__);
+		goto err_wc_irq;
+	}
+	pr_info("%s: MAX77833 Charger Driver Loaded\n", __func__);
+
+	return 0;
+
+err_wc_irq:
+	free_irq(charger->pdata->chg_irq, NULL);
+err_irq:
+	power_supply_unregister(&charger->psy_chg);
+err_power_supply_register:
+	destroy_workqueue(charger->wqueue);
+err_pdata_free:
+	if (charger->pdata->otg_en)
+			gpio_free(charger->pdata->otg_en);
+err_gpio:
+	kfree(pdata->charger_data);
+	mutex_destroy(&charger->charger_mutex);
+err_free:
+	kfree(charger);
+
+	return ret;
+}
+
+static int __devexit max77833_charger_remove(struct platform_device *pdev)
+{
+	struct max77833_charger_data *charger =
+		platform_get_drvdata(pdev);
+
+	destroy_workqueue(charger->wqueue);
+	free_irq(charger->wc_w_irq, NULL);
+	free_irq(charger->pdata->chg_irq, NULL);
+	power_supply_unregister(&charger->psy_chg);
+	mutex_destroy(&charger->charger_mutex);
+	kfree(charger);
+
+	return 0;
+}
+
+#if defined CONFIG_PM
+static int max77833_charger_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int max77833_charger_resume(struct device *dev)
+{
+	return 0;
+}
+#else
+#define max77833_charger_suspend NULL
+#define max77833_charger_resume NULL
+#endif
+
+static void max77833_charger_shutdown(struct device *dev)
+{
+	struct max77833_charger_data *charger =
+				dev_get_drvdata(dev);
+	u8 reg_data;
+
+	pr_info("%s: MAX77833 Charger driver shutdown\n", __func__);
+	if (!charger->i2c) {
+		pr_err("%s: no max77833 i2c client\n", __func__);
+		return;
+	}
+	reg_data = 0x04;
+	max77833_write_reg(charger->i2c,
+		MAX77833_CHG_REG_CNFG_00, reg_data);
+	reg_data = 0x14;
+	max77833_write_reg(charger->i2c,
+		MAX77833_CHG_REG_CNFG_16, reg_data);
+	reg_data = 0x14;
+	max77833_write_reg(charger->i2c,
+		MAX77833_CHG_REG_CNFG_17, reg_data);
+	reg_data = 0xE7;
+	max77833_write_reg(charger->i2c,
+		MAX77833_CHG_REG_CNFG_18, reg_data);
+	pr_info("func:%s \n", __func__);
+}
+
+static SIMPLE_DEV_PM_OPS(max77833_charger_pm_ops, max77833_charger_suspend,
+			 max77833_charger_resume);
+
+static struct platform_driver max77833_charger_driver = {
+	.driver = {
+		.name = "max77833-charger",
+		.owner = THIS_MODULE,
+#ifdef CONFIG_PM
+		.pm = &max77833_charger_pm_ops,
+#endif
+		.shutdown = max77833_charger_shutdown,
+	},
+	.probe = max77833_charger_probe,
+	.remove = __devexit_p(max77833_charger_remove),
+};
+
+static int __init max77833_charger_init(void)
+{
+	pr_info("%s : \n", __func__);
+	return platform_driver_register(&max77833_charger_driver);
+}
+
+static void __exit max77833_charger_exit(void)
+{
+	platform_driver_unregister(&max77833_charger_driver);
+}
+
+module_init(max77833_charger_init);
+module_exit(max77833_charger_exit);
+
+MODULE_DESCRIPTION("Samsung MAX77833 Charger Driver");
+MODULE_AUTHOR("Samsung Electronics");
+MODULE_LICENSE("GPL");
diff -Naur linux-3.18.14/drivers/battery/max77833_fuelgauge.c samsung/drivers/battery/max77833_fuelgauge.c
--- linux-3.18.14/drivers/battery/max77833_fuelgauge.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery/max77833_fuelgauge.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,2288 @@
+/*
+ *  max77833_fuelgauge.c
+ *  Samsung MAX77833 Fuel Gauge Driver
+ *
+ *  Copyright (C) 2012 Samsung Electronics
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#define DEBUG
+/* #define BATTERY_LOG_MESSAGE */
+
+#include <linux/mfd/max77833-private.h>
+#include <linux/of_gpio.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+
+static enum power_supply_property max77833_fuelgauge_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,
+#endif
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_VOLTAGE_AVG,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CURRENT_AVG,
+	POWER_SUPPLY_PROP_CHARGE_FULL,
+	POWER_SUPPLY_PROP_ENERGY_NOW,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_TEMP_AMBIENT,
+#if defined(CONFIG_EN_OOPS)
+	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
+#endif
+	POWER_SUPPLY_PROP_ENERGY_FULL,
+	POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN,
+	POWER_SUPPLY_PROP_TIME_TO_FULL_NOW,
+};
+
+#if !defined(CONFIG_SEC_FACTORY)
+static void max77833_fg_read_time(struct max77833_fuelgauge_data *fuelgauge)
+{
+	u16 data;
+	u8 test_data[2];
+	int lsb, msb, time;
+
+	if (max77833_read_fg(fuelgauge->i2c,
+			     TIME_TO_FULL_REG, &data) < 0) {
+		pr_err("%s: Failed to read TTF\n", __func__);
+		return;
+	}
+
+	test_data[0] = data & 0xFF;
+	test_data[1] = (data >> 8);
+	lsb = test_data[0] & 0x1f;
+	msb = ((test_data[1] << 3) + ((test_data[0] & 0xe0) >> 5));
+	time = msb * 180 + (lsb * 5625) / 1000;
+
+	pr_info("[Time-to-FULL] %d(secs), %d(mins)\n", time, time / 60);
+
+	if (max77833_read_fg(fuelgauge->i2c,
+			     TIME_TO_EMPTY_REG, &data) < 0) {
+		pr_err("%s: Failed to read TTE\n", __func__);
+		return;
+	}
+
+	test_data[0] = data & 0xFF;
+	test_data[1] = (data >> 8);
+
+	lsb = test_data[0] & 0x1f;
+	msb = ((test_data[1] << 3) + ((test_data[0] & 0xe0) >> 5));
+	time = msb * 180 + (lsb * 5625) / 1000;
+
+	pr_info("[Time-to-EMPTY] %d(secs), %d(mins)\n", time, time / 60);
+}
+
+static void max77833_fg_test_print(struct max77833_fuelgauge_data *fuelgauge)
+{
+#ifdef BATTERY_LOG_MESSAGE
+	u16 reg_data;
+
+	max77833_read_fg(fuelgauge->i2c, FULLCAP_REG, &reg_data);
+	pr_info("%s: FULLCAP(%d), data(0x%04x)\n", __func__,
+			reg_data/2, reg_data);
+
+	max77833_read_fg(fuelgauge->i2c, REMCAP_REP_REG, &reg_data);
+	pr_info("%s: REMCAP_REP(%d), data(0x%04x)\n", __func__,
+			reg_data/2, reg_data);
+
+	max77833_read_fg(fuelgauge->i2c, REMCAP_MIX_REG, &reg_data);
+	pr_info("%s: REMCAP_MIX(%d), data(0x%04x)\n", __func__,
+			reg_data/2, reg_data);
+
+	max77833_read_fg(fuelgauge->i2c, REMCAP_AV_REG, &reg_data);
+	pr_info("%s: REMCAP_AV(%d), data(0x%04x)\n", __func__,
+			reg_data/2, reg_data);
+
+	max77833_read_fg(fuelgauge->i2c, CONFIG_REG, &reg_data);
+	pr_info("%s: CONFIG_REG(0x%02x), data(0x%04x)\n", __func__,
+			CONFIG_REG, reg_data);
+#endif
+
+	max77833_fg_read_time(fuelgauge);
+}
+
+static void max77833_fg_periodic_read(struct max77833_fuelgauge_data *fuelgauge)
+{
+	u8 reg;
+	int i;
+	u16 data[0x10];
+	char *str = NULL;
+
+	str = kzalloc(sizeof(char)*1024, GFP_KERNEL);
+	if (!str)
+		return;
+
+	for (i = 0; i < 16; i++) {
+		for (reg = 0; reg < 0x10; reg++) {
+			max77833_read_fg(fuelgauge->i2c, reg + i * 0x10, &data[reg]);
+			if (data[reg] < 0) {
+				kfree(str);
+				return;
+			}
+		}
+		if (i == 12)
+			continue;
+		sprintf(str+strlen(str),
+			"%04xh,%04xh,%04xh,%04xh,%04xh,%04xh,%04xh,%04xh,",
+			data[0x00], data[0x01], data[0x02], data[0x03],
+			data[0x04], data[0x05], data[0x06], data[0x07]);
+		sprintf(str+strlen(str),
+			"%04xh,%04xh,%04xh,%04xh,%04xh,%04xh,%04xh,%04xh,",
+			data[0x08], data[0x09], data[0x0a], data[0x0b],
+			data[0x0c], data[0x0d], data[0x0e], data[0x0f]);
+		if (i == 4)
+			i = 10;
+	}
+
+	pr_info("[FG] %s\n", str);
+
+	kfree(str);
+}
+#endif
+
+static int max77833_fg_read_vcell(struct max77833_fuelgauge_data *fuelgauge)
+{
+	u16 data;
+	u32 vcell;
+	u32 temp;
+	u32 temp2;
+
+	if (max77833_read_fg(fuelgauge->i2c, VCELL_REG, &data) < 0) {
+		pr_err("%s: Failed to read VCELL\n", __func__);
+		return -1;
+	}
+
+	temp = (data & 0xFFF) * 78125;
+	vcell = temp / 1000000;
+
+	temp = ((data & 0xF000) >> 4) * 78125;
+	temp2 = temp / 1000000;
+	vcell += (temp2 << 4);
+
+	if (!(fuelgauge->info.pr_cnt++ % PRINT_COUNT)) {
+		fuelgauge->info.pr_cnt = 1;
+		pr_info("%s: VCELL(%d), data(0x%04x)\n",
+			__func__, vcell, data);
+	}
+
+	return vcell;
+}
+
+static int max77833_fg_read_vfocv(struct max77833_fuelgauge_data *fuelgauge)
+{
+	u16 data;
+	u32 vfocv = 0;
+	u32 temp;
+	u32 temp2;
+
+	if (max77833_read_fg(fuelgauge->i2c, VFOCV_REG, &data) < 0) {
+		pr_err("%s: Failed to read VFOCV\n", __func__);
+		return -1;
+	}
+
+	temp = (data & 0xFFF) * 78125;
+	vfocv = temp / 1000000;
+
+	temp = ((data & 0xF000) >> 4) * 78125;
+	temp2 = temp / 1000000;
+	vfocv += (temp2 << 4);
+
+#if !defined(CONFIG_SEC_FACTORY)
+	max77833_fg_test_print(fuelgauge);
+	max77833_fg_periodic_read(fuelgauge);
+#endif
+
+	return vfocv;
+}
+
+static int max77833_fg_read_avg_vcell(struct max77833_fuelgauge_data *fuelgauge)
+{
+	u32 avg_vcell = 0;
+	u16 data;
+	u32 temp;
+	u32 temp2;
+
+	if (max77833_read_fg(fuelgauge->i2c, AVR_VCELL_REG, &data) < 0) {
+		pr_err("%s: Failed to read AVG_VCELL\n", __func__);
+		return -1;
+	}
+
+	temp = (data & 0xFFF) * 78125;
+	avg_vcell = temp / 1000000;
+
+	temp = ((data & 0xF000) >> 4) * 78125;
+	temp2 = temp / 1000000;
+	avg_vcell += (temp2 << 4);
+
+	return avg_vcell;
+}
+
+static int max77833_fg_check_battery_present(struct max77833_fuelgauge_data *fuelgauge)
+{
+	u16 status_data;
+	int ret = 1;
+
+	/* 1. Check Bst bit */
+	if (max77833_read_fg(fuelgauge->i2c, STATUS_REG, &status_data) < 0) {
+		pr_err("%s: Failed to read STATUS_REG\n", __func__);
+		return 0;
+	}
+
+	if (status_data & (0x1 << 3)) {
+		pr_info("%s: addr(0x01), data(0x%04x)\n", __func__,
+			status_data);
+		pr_info("%s: battery is absent!!\n", __func__);
+		ret = 0;
+	}
+
+	return ret;
+}
+
+static int max77833_fg_write_temp(struct max77833_fuelgauge_data *fuelgauge,
+			 int temperature)
+{
+	u8 data[2];
+	u8 reg_data;
+
+	data[0] = (temperature%10) * 1000 / 39;
+	data[1] = temperature / 10;
+
+	reg_data = (data[1] << 8) | data[0];
+	max77833_write_fg(fuelgauge->i2c, TEMPERATURE_REG, reg_data);
+
+	pr_debug("%s: temperature to (%d, 0x%04x)\n",
+		__func__, temperature, reg_data);
+
+	return temperature;
+}
+
+static int max77833_fg_read_temp(struct max77833_fuelgauge_data *fuelgauge)
+{
+	u8 data[2] = {0, 0};
+	u16 reg_data;
+	int temper = 0;
+
+	if (max77833_fg_check_battery_present(fuelgauge)) {
+		if (max77833_read_fg(fuelgauge->i2c, TEMPERATURE_REG, &reg_data) < 0) {
+			pr_err("%s: Failed to read TEMPERATURE_REG\n",
+				__func__);
+			return -1;
+		}
+
+		data[1] = (reg_data >> 8);
+		data[0] = (reg_data & 0xFF);
+
+		if (data[1]&(0x1 << 7)) {
+			temper = ((~(data[1]))&0xFF)+1;
+			temper *= (-1000);
+			temper -= ((~((int)data[0]))+1) * 39 / 10;
+		} else {
+			temper = data[1] & 0x7f;
+			temper *= 1000;
+			temper += data[0] * 39 / 10;
+		}
+	} else
+		temper = 20000;
+
+	if (!(fuelgauge->info.pr_cnt % PRINT_COUNT))
+		pr_info("%s: TEMPERATURE(%d), data(0x%04x)\n",
+			__func__, temper, (data[1]<<8) | data[0]);
+
+	return temper/100;
+}
+
+/* soc should be 0.1% unit */
+static int max77833_fg_read_vfsoc(struct max77833_fuelgauge_data *fuelgauge)
+{
+	u16 reg_data;
+	u8 data[2];
+	int soc;
+
+	if (max77833_read_fg(fuelgauge->i2c, VFSOC_REG, &reg_data) < 0) {
+		pr_err("%s: Failed to read VFSOC\n", __func__);
+		return -1;
+	}
+
+	data[1] = (reg_data >> 8);
+	data[0] = (reg_data & 0xFF);
+	soc = ((data[1] * 100) + (data[0] * 100 / 256)) / 10;
+
+	return min(soc, 1000);
+}
+
+/* soc should be 0.1% unit */
+static int max77833_fg_read_avsoc(struct max77833_fuelgauge_data *fuelgauge)
+{
+	u16 reg_data;
+	u8 data[2];
+	int soc;
+
+	if (max77833_read_fg(fuelgauge->i2c, SOCAV_REG, &reg_data) < 0) {
+		pr_err("%s: Failed to read AVSOC\n", __func__);
+		return -1;
+	}
+
+	data[1] = (reg_data >> 8);
+	data[0] = (reg_data & 0xFF);
+	soc = ((data[1] * 100) + (data[0] * 100 / 256)) / 10;
+
+	return min(soc, 1000);
+}
+
+/* soc should be 0.1% unit */
+static int max77833_fg_read_soc(struct max77833_fuelgauge_data *fuelgauge)
+{
+	u16 reg_data;
+	u8 data[2];
+	int soc, vf_soc;
+
+	if (max77833_read_fg(fuelgauge->i2c, SOCREP_REG, &reg_data) < 0) {
+		pr_err("%s: Failed to read SOCREP\n", __func__);
+		return -1;
+	}
+
+	data[1] = (reg_data >> 8);
+	data[0] = (reg_data & 0xFF);
+	soc = ((data[1] * 100) + (data[0] * 100 / 256)) / 10;
+	vf_soc = max77833_fg_read_vfsoc(fuelgauge);
+
+#ifdef BATTERY_LOG_MESSAGE
+	pr_debug("%s: raw capacity (%d)\n", __func__, soc);
+
+	if (!(fuelgauge->info.pr_cnt % PRINT_COUNT)) {
+		pr_debug("%s: raw capacity (%d), data(0x%04x)\n",
+			 __func__, soc, (data[1]<<8) | data[0]);
+		pr_debug("%s: REPSOC (%d), VFSOC (%d), data(0x%04x)\n",
+				__func__, soc/10, vf_soc/10, (data[1]<<8) | data[0]);
+	}
+#endif
+
+	return min(soc, 1000);
+}
+
+/* soc should be 0.01% unit */
+static int max77833_fg_read_rawsoc(struct max77833_fuelgauge_data *fuelgauge)
+{
+	u16 reg_data;
+	u8 data[2];
+	int soc;
+
+	if (max77833_read_fg(fuelgauge->i2c, SOCREP_REG, &reg_data) < 0) {
+		pr_err("%s: Failed to read SOCREP\n", __func__);
+		return -1;
+	}
+
+	data[1] = (reg_data >> 8);
+	data[0] = (reg_data & 0xFF);
+	soc = (data[1] * 100) + (data[0] * 100 / 256);
+
+	pr_debug("%s: raw capacity (0.01%%) (%d)\n",
+		 __func__, soc);
+
+	if (!(fuelgauge->info.pr_cnt % PRINT_COUNT))
+		pr_debug("%s: raw capacity (%d), data(0x%04x)\n",
+			 __func__, soc, (data[1]<<8) | data[0]);
+
+	return min(soc, 10000);
+}
+
+static int max77833_fg_read_fullcap(struct max77833_fuelgauge_data *fuelgauge)
+{
+	u16 data;
+
+	if (max77833_read_fg(fuelgauge->i2c, FULLCAP_REG, &data) < 0) {
+		pr_err("%s: Failed to read FULLCAP\n", __func__);
+		return -1;
+	}
+
+	return (int)data;
+}
+
+static int max77833_fg_read_fullcaprep(struct max77833_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	int ret;
+
+	if (max77833_bulk_read(fuelgauge->i2c, FULLCAPREP_REG,
+			       2, data) < 0) {
+		pr_err("%s: Failed to read FULLCAP\n", __func__);
+		return -1;
+	}
+
+	ret = (data[1] << 8) + data[0];
+
+	return ret;
+}
+
+
+static int max77833_fg_read_fullcapnom(struct max77833_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	int ret;
+
+	if (max77833_bulk_read(fuelgauge->i2c, FULLCAP_NOM_REG,
+			       2, data) < 0) {
+		pr_err("%s: Failed to read FULLCAP\n", __func__);
+		return -1;
+	}
+
+	ret = (data[1] << 8) + data[0];
+
+	return ret;
+}
+
+static int max77833_fg_read_mixcap(struct max77833_fuelgauge_data *fuelgauge)
+{
+	u16 data;
+
+	if (max77833_read_fg(fuelgauge->i2c, REMCAP_MIX_REG, &data) <  0) {
+		pr_err("%s: Failed to read REMCAP_MIX_REG\n",
+		       __func__);
+		return -1;
+	}
+
+	return (int)data;
+}
+
+static int max77833_fg_read_avcap(struct max77833_fuelgauge_data *fuelgauge)
+{
+	u16 data;
+
+	if (max77833_read_fg(fuelgauge->i2c, REMCAP_AV_REG, &data) < 0) {
+		pr_err("%s: Failed to read REMCAP_AV_REG\n",
+		       __func__);
+		return -1;
+	}
+
+	return (int)data;
+}
+
+static int max77833_fg_read_repcap(struct max77833_fuelgauge_data *fuelgauge)
+{
+	u16 data;
+
+	if (max77833_read_fg(fuelgauge->i2c, REMCAP_REP_REG, &data) < 0) {
+		pr_err("%s: Failed to read REMCAP_REP_REG\n",
+		       __func__);
+		return -1;
+	}
+
+	return (int)data;
+}
+
+static int max77833_fg_read_current(struct max77833_fuelgauge_data *fuelgauge, int unit)
+{
+	u16 data1;
+	u32 temp, sign;
+	s32 i_current;
+
+	if (max77833_read_fg(fuelgauge->i2c, CURRENT_REG, &data1) <0) {
+		pr_err("%s: Failed to read CURRENT\n", __func__);
+		return -1;
+	}
+
+	temp = data1 & 0xFFFF;
+	/* Debug log for abnormal current case */
+	if (temp & (0x1 << 15)) {
+		sign = MAX77833_NEGATIVE;
+		temp = (~temp & 0xFFFF) + 1;
+	} else
+		sign = MAX77833_POSITIVE;
+
+	/* 1.5625uV/0.0O5hm(Rsense) = 312.5uA */
+	switch (unit) {
+	case SEC_BATTERY_CURRENT_UA:
+		i_current = temp * 15625 / 50;
+		break;
+	case SEC_BATTERY_CURRENT_MA:
+	default:
+		i_current = temp * 15625 / 50000;
+	}
+
+	if (sign)
+		i_current *= -1;
+
+	return i_current;
+}
+
+static int max77833_fg_read_avg_current(struct max77833_fuelgauge_data *fuelgauge, int unit)
+{
+	u16  data2;
+	u32 temp, sign;
+	s32 avg_current;
+	int vcell;
+	static int cnt;
+
+	if (max77833_read_fg(fuelgauge->i2c, AVG_CURRENT_REG, &data2) < 0) {
+		pr_err("%s: Failed to read AVERAGE CURRENT\n",
+		       __func__);
+		return -1;
+	}
+
+	temp = data2 & 0xFFFF;
+	if (temp & (0x1 << 15)) {
+		sign = MAX77833_NEGATIVE;
+		temp = (~temp & 0xFFFF) + 1;
+	} else
+		sign = MAX77833_POSITIVE;
+
+	/* 1.5625uV/0.005hm(Rsense) = 312.5uA */
+	switch (unit) {
+	case SEC_BATTERY_CURRENT_UA:
+		avg_current = temp * 15625 / 50;
+		break;
+	case SEC_BATTERY_CURRENT_MA:
+	default:
+		avg_current = temp * 15625 / 50000;
+	}
+
+	if (sign)
+		avg_current *= -1;
+
+	vcell = max77833_fg_read_vcell(fuelgauge);
+	if ((vcell < 3500) && (cnt < 10) && (avg_current < 0) &&
+	    fuelgauge->is_charging) {
+		avg_current = 1;
+		cnt++;
+	}
+
+	return avg_current;
+}
+
+static int max77833_fg_read_cycle(struct max77833_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	int ret;
+
+	if (max77833_bulk_read(fuelgauge->i2c, CYCLES_REG,
+			       2, data) < 0) {
+		pr_err("%s: Failed to read FULLCAPCYCLE\n", __func__);
+		return -1;
+	}
+
+	ret = (data[1] << 8) + data[0];
+
+	return ret;
+}
+
+int max77833_fg_reset_soc(struct max77833_fuelgauge_data *fuelgauge)
+{
+	u16 reg_data, fullcap;
+	int vfocv;
+
+	/* delay for current stablization */
+	msleep(500);
+
+	pr_info("%s: Before quick-start - VCELL(%d), VFOCV(%d), VfSOC(%d), RepSOC(%d)\n",
+		__func__, max77833_fg_read_vcell(fuelgauge), max77833_fg_read_vfocv(fuelgauge),
+		max77833_fg_read_vfsoc(fuelgauge), max77833_fg_read_soc(fuelgauge));
+	pr_info("%s: Before quick-start - current(%d), avg current(%d)\n",
+		__func__, max77833_fg_read_current(fuelgauge, SEC_BATTERY_CURRENT_MA),
+		max77833_fg_read_avg_current(fuelgauge, SEC_BATTERY_CURRENT_MA));
+
+	if (fuelgauge->pdata->check_jig_status &&
+	    !fuelgauge->pdata->check_jig_status()) {
+		pr_info("%s : Return by No JIG_ON signal\n", __func__);
+		return 0;
+	}
+
+	max77833_write_fg(fuelgauge->i2c, CYCLES_REG, 0);
+
+	if (max77833_read_fg(fuelgauge->i2c, MISCCFG_REG, &reg_data) < 0) {
+		pr_err("%s: Failed to read MiscCFG\n", __func__);
+		return -1;
+	}
+
+	reg_data |= (0x1 << 10);
+	if (max77833_write_fg(fuelgauge->i2c, MISCCFG_REG, reg_data) < 0) {
+		pr_err("%s: Failed to write MiscCFG\n", __func__);
+		return -1;
+	}
+
+	msleep(250);
+	max77833_write_fg(fuelgauge->i2c, FULLCAP_REG,
+			  fuelgauge->battery_data->Capacity);
+	msleep(500);
+
+	pr_info("%s: After quick-start - VCELL(%d), VFOCV(%d), VfSOC(%d), RepSOC(%d)\n",
+		__func__, max77833_fg_read_vcell(fuelgauge), max77833_fg_read_vfocv(fuelgauge),
+		max77833_fg_read_vfsoc(fuelgauge), max77833_fg_read_soc(fuelgauge));
+	pr_info("%s: After quick-start - current(%d), avg current(%d)\n",
+		__func__, max77833_fg_read_current(fuelgauge, SEC_BATTERY_CURRENT_MA),
+		max77833_fg_read_avg_current(fuelgauge, SEC_BATTERY_CURRENT_MA));
+
+	max77833_write_fg(fuelgauge->i2c, CYCLES_REG, 0x00A0);
+
+/* P8 is not turned off by Quickstart @3.4V
+ * (It's not a problem, depend on mode data)
+ * Power off for factory test(File system, etc..) */
+	vfocv = max77833_fg_read_vfocv(fuelgauge);
+	if (vfocv < POWER_OFF_VOLTAGE_LOW_MARGIN) {
+		pr_info("%s: Power off condition(%d)\n", __func__, vfocv);
+
+		max77833_read_fg(fuelgauge->i2c, FULLCAP_REG, &fullcap);
+
+		/* FullCAP * 0.009 */
+		max77833_write_fg(fuelgauge->i2c, REMCAP_REP_REG, (fullcap * 9 / 1000));
+		msleep(200);
+		pr_info("%s: new soc=%d, vfocv=%d\n", __func__,
+			max77833_fg_read_soc(fuelgauge), vfocv);
+	}
+
+	pr_info("%s: Additional step - VfOCV(%d), VfSOC(%d), RepSOC(%d)\n",
+		__func__, max77833_fg_read_vfocv(fuelgauge),
+		max77833_fg_read_vfsoc(fuelgauge), max77833_fg_read_soc(fuelgauge));
+
+	return 0;
+}
+
+int max77833_fg_reset_capacity_by_jig_connection(struct max77833_fuelgauge_data *fuelgauge)
+{
+
+	pr_info("%s: DesignCap = Capacity - 1 (Jig Connection)\n", __func__);
+
+	return max77833_write_fg(fuelgauge->i2c, DESIGNCAP_REG,
+				 fuelgauge->battery_data->Capacity-1);
+}
+
+void max77833_fg_low_batt_compensation(struct max77833_fuelgauge_data *fuelgauge,
+				       u32 level)
+{
+	u16 read_val;
+	u32 temp;
+
+	pr_info("%s: Adjust SOCrep to %d!!\n", __func__, level);
+
+	max77833_read_fg(fuelgauge->i2c, FULLCAP_REG, &read_val);
+	/* RemCapREP (05h) = FullCap(10h) x 0.0090 */
+	temp = read_val * (level*90) / 10000;
+	max77833_write_fg(fuelgauge->i2c, REMCAP_REP_REG,
+			  (u16)temp);
+}
+
+static int max77833_fg_check_status_reg(struct max77833_fuelgauge_data *fuelgauge)
+{
+	u16 status_data;
+	int ret = 0;
+
+	/* 1. Check Smn was generatedread */
+	if (max77833_read_fg(fuelgauge->i2c, STATUS_REG, &status_data) < 0) {
+		pr_err("%s: Failed to read STATUS_REG\n", __func__);
+		return -1;
+	}
+
+#ifdef BATTERY_LOG_MESSAGE
+	pr_info("%s: addr(0x00), data(0x%04x)\n", __func__,
+		status_data);
+#endif
+
+	if (status_data & (0x1 << 10))
+		ret = 1;
+
+	/* 2. clear Status reg */
+	status_data |= 0x0F;
+	if (max77833_write_fg(fuelgauge->i2c, STATUS_REG, status_data) < 0) {
+		pr_info("%s: Failed to write STATUS_REG\n", __func__);
+		return -1;
+	}
+
+	return ret;
+}
+
+int max77833_get_fuelgauge_value(struct max77833_fuelgauge_data *fuelgauge, int data)
+{
+	int ret;
+
+	switch (data) {
+	case MAX77833_FG_LEVEL:
+		ret = max77833_fg_read_soc(fuelgauge);
+		break;
+
+	case MAX77833_FG_TEMPERATURE:
+		ret = max77833_fg_read_temp(fuelgauge);
+		break;
+
+	case MAX77833_FG_VOLTAGE:
+		ret = max77833_fg_read_vcell(fuelgauge);
+		break;
+
+	case MAX77833_FG_CURRENT:
+		ret = max77833_fg_read_current(fuelgauge, SEC_BATTERY_CURRENT_MA);
+		break;
+
+	case MAX77833_FG_CURRENT_AVG:
+		ret = max77833_fg_read_avg_current(fuelgauge, SEC_BATTERY_CURRENT_MA);
+		break;
+
+	case MAX77833_FG_CHECK_STATUS:
+		ret = max77833_fg_check_status_reg(fuelgauge);
+		break;
+
+	case MAX77833_FG_RAW_SOC:
+		ret = max77833_fg_read_rawsoc(fuelgauge);
+		break;
+
+	case MAX77833_FG_VF_SOC:
+		ret = max77833_fg_read_vfsoc(fuelgauge);
+		break;
+
+	case MAX77833_FG_AV_SOC:
+		ret = max77833_fg_read_avsoc(fuelgauge);
+		break;
+
+	case MAX77833_FG_FULLCAP:
+		ret = max77833_fg_read_fullcap(fuelgauge);
+		break;
+
+	case MAX77833_FG_FULLCAPNOM:
+		ret = max77833_fg_read_fullcapnom(fuelgauge);
+		break;
+
+	case MAX77833_FG_FULLCAPREP:
+		ret = max77833_fg_read_fullcaprep(fuelgauge);
+		break;
+
+	case MAX77833_FG_MIXCAP:
+		ret = max77833_fg_read_mixcap(fuelgauge);
+		break;
+
+	case MAX77833_FG_AVCAP:
+		ret = max77833_fg_read_avcap(fuelgauge);
+		break;
+
+	case MAX77833_FG_REPCAP:
+		ret = max77833_fg_read_repcap(fuelgauge);
+		break;
+
+	case MAX77833_FG_CYCLE:
+		ret = max77833_fg_read_cycle(fuelgauge);
+		break;
+
+	default:
+		ret = -1;
+		break;
+	}
+
+	return ret;
+}
+
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+int max77833_get_age_forecast(struct max77833_fuelgauge_data *fuelgauge)
+{
+	int fullcapnom = 0;
+	int cycle = 0;
+	int chg_float_voltage = 0;
+
+	fullcapnom = max77833_get_fuelgauge_value(fuelgauge, MAX77833_FG_FULLCAPNOM);
+	fullcapnom = fullcapnom / 2;
+	cycle = max77833_get_fuelgauge_value(fuelgauge, MAX77833_FG_CYCLE);
+	cycle = cycle / 100;
+
+	pr_info("%s [FG] : cycle(%d), fullcapnom(%d)\n",
+		 __func__, cycle, fullcapnom);
+
+	if (cycle < 50) {
+		return 4400;
+	} else if (fullcapnom > 2545) {
+		return 4400;
+	} else if (fullcapnom > 2475) {
+		chg_float_voltage = 4375;
+	} else if (fullcapnom > 2360) {
+		chg_float_voltage = 4350;
+	} else if (fullcapnom > 2246) {
+		chg_float_voltage = 4325;
+	} else if (fullcapnom > 2132) {
+		chg_float_voltage = 4300;
+	} else if (fullcapnom > 2017) {
+		chg_float_voltage = 4275;
+	} else {
+		chg_float_voltage = 4250;
+	}
+
+	pr_info("%s [FG] : chg_float_voltage(%d)\n",
+		 __func__, chg_float_voltage);
+
+	return chg_float_voltage;
+}
+#endif
+
+int max77833_fg_alert_init(struct max77833_fuelgauge_data *fuelgauge, int soc)
+{
+#if 0
+	u16 misccfg_data;
+	u16 salrt_data;
+	u16 config_data;
+	u16 valrt_data;
+	u16 talrt_data;
+	u16 read_data = 0;
+
+	fuelgauge->is_fuel_alerted = false;
+
+	/* Using RepSOC */
+	if (max77833_read_fg(fuelgauge->i2c, MISCCFG_REG, &misccfg_data) < 0) {
+		pr_err("%s: Failed to read MISCCFG_REG\n", __func__);
+		return -1;
+	}
+	misccgf_data[0] = misccgf_data[0] & ~(0x03);
+
+	if (max77833_bulk_write(fuelgauge->i2c, MISCCFG_REG,
+				2, misccgf_data) < 0) {
+		pr_info("%s: Failed to write MISCCFG_REG\n", __func__);
+		return -1;
+	}
+
+	/* SALRT Threshold setting */
+	salrt_data[1] = 0xff;
+	salrt_data[0] = soc;
+	if (max77833_bulk_write(fuelgauge->i2c, SALRT_THRESHOLD_REG,
+				2, salrt_data) < 0) {
+		pr_info("%s: Failed to write SALRT_THRESHOLD_REG\n", __func__);
+		return -1;
+	}
+
+	/* Reset VALRT Threshold setting (disable) */
+	valrt_data[1] = 0xFF;
+	valrt_data[0] = 0x00;
+	if (max77833_bulk_write(fuelgauge->i2c, VALRT_THRESHOLD_REG,
+				2, valrt_data) < 0) {
+		pr_info("%s: Failed to write VALRT_THRESHOLD_REG\n", __func__);
+		return -1;
+	}
+
+	read_data = max77833_read_word(fuelgauge->i2c, (u8)VALRT_THRESHOLD_REG);
+	if (read_data != 0xff00)
+		pr_err("%s: VALRT_THRESHOLD_REG is not valid (0x%x)\n",
+			__func__, read_data);
+
+	/* Reset TALRT Threshold setting (disable) */
+	talrt_data[1] = 0x7F;
+	talrt_data[0] = 0x80;
+	if (max77833_bulk_write(fuelgauge->i2c, TALRT_THRESHOLD_REG,
+				2, talrt_data) < 0) {
+		pr_info("%s: Failed to write TALRT_THRESHOLD_REG\n", __func__);
+		return -1;
+	}
+
+	read_data = max77833_read_word(fuelgauge->i2c, (u8)TALRT_THRESHOLD_REG);
+	if (read_data != 0x7f80)
+		pr_err("%s: TALRT_THRESHOLD_REG is not valid (0x%x)\n",
+			__func__, read_data);
+
+	/*mdelay(100);*/
+
+	/* Enable SOC alerts */
+	if (max77833_bulk_read(fuelgauge->i2c, CONFIG_REG,
+			       2, config_data) < 0) {
+		pr_err("%s: Failed to read CONFIG_REG\n", __func__);
+		return -1;
+	}
+	config_data[0] = config_data[0] | (0x1 << 2);
+
+	if (max77833_bulk_write(fuelgauge->i2c, CONFIG_REG,
+				2, config_data) < 0) {
+		pr_info("%s: Failed to write CONFIG_REG\n", __func__);
+		return -1;
+	}
+
+	max77833_update_reg(fuelgauge->pmic,
+			    MAX77833_PMIC_REG_INTSRC_MASK,
+			    ~MAX77833_IRQSRC_FG,
+			    MAX77833_IRQSRC_FG);
+
+	pr_info("[%s] SALRT(0x%02x%02x), VALRT(0x%02x%02x), CONFIG(0x%02x%02x)\n",
+		__func__,
+		salrt_data[1], salrt_data[0],
+		valrt_data[1], valrt_data[0],
+		config_data[1], config_data[0]);
+
+#endif
+	return 1;
+}
+
+static void max77833_display_low_batt_comp_cnt(struct max77833_fuelgauge_data *fuelgauge)
+{
+	pr_info("Check Array(%s): [%d, %d], [%d, %d], ",
+			fuelgauge->battery_data->type_str,
+			fuelgauge->info.low_batt_comp_cnt[0][0],
+			fuelgauge->info.low_batt_comp_cnt[0][1],
+			fuelgauge->info.low_batt_comp_cnt[1][0],
+			fuelgauge->info.low_batt_comp_cnt[1][1]);
+	pr_info("[%d, %d], [%d, %d], [%d, %d]\n",
+			fuelgauge->info.low_batt_comp_cnt[2][0],
+			fuelgauge->info.low_batt_comp_cnt[2][1],
+			fuelgauge->info.low_batt_comp_cnt[3][0],
+			fuelgauge->info.low_batt_comp_cnt[3][1],
+			fuelgauge->info.low_batt_comp_cnt[4][0],
+			fuelgauge->info.low_batt_comp_cnt[4][1]);
+}
+
+static void max77833_add_low_batt_comp_cnt(struct max77833_fuelgauge_data *fuelgauge,
+				int range, int level)
+{
+	int i;
+	int j;
+
+	/* Increase the requested count value, and reset others. */
+	fuelgauge->info.low_batt_comp_cnt[range-1][level/2]++;
+
+	for (i = 0; i < LOW_BATT_COMP_RANGE_NUM; i++) {
+		for (j = 0; j < LOW_BATT_COMP_LEVEL_NUM; j++) {
+			if (i == range-1 && j == level/2)
+				continue;
+			else
+				fuelgauge->info.low_batt_comp_cnt[i][j] = 0;
+		}
+	}
+}
+
+void max77833_prevent_early_poweroff(struct max77833_fuelgauge_data *fuelgauge,
+	int vcell, int *fg_soc)
+{
+	int soc = 0;
+	u16 read_val;
+
+	soc = max77833_fg_read_soc(fuelgauge);
+
+	/* No need to write REMCAP_REP in below normal cases */
+	if (soc > POWER_OFF_SOC_HIGH_MARGIN ||
+	    vcell > fuelgauge->battery_data->low_battery_comp_voltage)
+		return;
+
+	pr_info("%s: soc=%d, vcell=%d\n", __func__, soc, vcell);
+
+	if (vcell > POWER_OFF_VOLTAGE_HIGH_MARGIN) {
+		max77833_read_fg(fuelgauge->i2c, FULLCAP_REG, &read_val);
+		/* FullCAP * 0.013 */
+		max77833_write_fg(fuelgauge->i2c, REMCAP_REP_REG, (read_val * 13 / 1000));
+		msleep(200);
+		*fg_soc = max77833_fg_read_soc(fuelgauge);
+		pr_info("%s: new soc=%d, vcell=%d\n", __func__, *fg_soc, vcell);
+	}
+}
+
+void max77833_reset_low_batt_comp_cnt(struct max77833_fuelgauge_data *fuelgauge)
+{
+	memset(fuelgauge->info.low_batt_comp_cnt, 0,
+		sizeof(fuelgauge->info.low_batt_comp_cnt));
+}
+
+static int max77833_check_low_batt_comp_condition(
+	struct max77833_fuelgauge_data *fuelgauge,
+	int *nLevel)
+{
+	int i;
+	int j;
+	int ret = 0;
+
+	for (i = 0; i < LOW_BATT_COMP_RANGE_NUM; i++) {
+		for (j = 0; j < LOW_BATT_COMP_LEVEL_NUM; j++) {
+			if (fuelgauge->info.low_batt_comp_cnt[i][j] >=
+				MAX_LOW_BATT_CHECK_CNT) {
+				max77833_display_low_batt_comp_cnt(fuelgauge);
+				ret = 1;
+				*nLevel = j*2 + 1;
+				break;
+			}
+		}
+	}
+
+	return ret;
+}
+
+static int max77833_get_low_batt_threshold(struct max77833_fuelgauge_data *fuelgauge,
+				int range, int nCurrent, int level)
+{
+	int ret = 0;
+
+	ret = fuelgauge->battery_data->low_battery_table[range][MAX77833_OFFSET] +
+		((nCurrent *
+		fuelgauge->battery_data->low_battery_table[range][MAX77833_SLOPE]) /
+		1000);
+
+	return ret;
+}
+
+int max77833_low_batt_compensation(struct max77833_fuelgauge_data *fuelgauge,
+		int fg_soc, int fg_vcell, int fg_current)
+{
+	int fg_avg_current = 0;
+	int fg_min_current = 0;
+	int new_level = 0;
+	int i, table_size;
+
+	/* Not charging, Under low battery comp voltage */
+	if (fg_vcell <= fuelgauge->battery_data->low_battery_comp_voltage) {
+		fg_avg_current = max77833_fg_read_avg_current(fuelgauge,
+			SEC_BATTERY_CURRENT_MA);
+		fg_min_current = min(fg_avg_current, fg_current);
+
+		table_size =
+			sizeof(fuelgauge->battery_data->low_battery_table) /
+			(sizeof(s16)*MAX77833_TABLE_MAX);
+
+		for (i = 1; i < CURRENT_RANGE_MAX_NUM; i++) {
+			if ((fg_min_current >= fuelgauge->battery_data->
+				low_battery_table[i-1][MAX77833_RANGE]) &&
+				(fg_min_current < fuelgauge->battery_data->
+				low_battery_table[i][MAX77833_RANGE])) {
+				if (fg_soc >= 10 && fg_vcell <
+					max77833_get_low_batt_threshold(fuelgauge,
+					i, fg_min_current, 1)) {
+					max77833_add_low_batt_comp_cnt(
+						fuelgauge, i, 1);
+				} else {
+					max77833_reset_low_batt_comp_cnt(fuelgauge);
+				}
+			}
+		}
+
+		if (max77833_check_low_batt_comp_condition(fuelgauge, &new_level)) {
+			max77833_fg_low_batt_compensation(fuelgauge, new_level);
+			max77833_reset_low_batt_comp_cnt(fuelgauge);
+
+			/* Do not update soc right after
+			 * low battery compensation
+			 * to prevent from powering-off suddenly
+			 */
+			pr_info("%s: SOC is set to %d by low compensation!!\n",
+				__func__, max77833_fg_read_soc(fuelgauge));
+		}
+	}
+
+	/* Prevent power off over 3500mV */
+	max77833_prevent_early_poweroff(fuelgauge, fg_vcell, &fg_soc);
+
+	return fg_soc;
+}
+
+static bool max77833_fuelgauge_recovery_handler(struct max77833_fuelgauge_data *fuelgauge)
+{
+	if (fuelgauge->info.soc < LOW_BATTERY_SOC_REDUCE_UNIT) {
+		fuelgauge->info.is_low_batt_alarm = false;
+	} else {
+		pr_err("%s: Reduce the Reported SOC by 1%%\n",
+			__func__);
+
+		fuelgauge->info.soc -=
+			LOW_BATTERY_SOC_REDUCE_UNIT;
+		pr_err("%s: New Reduced RepSOC (%d)\n",
+			__func__, fuelgauge->info.soc);
+	}
+
+	return fuelgauge->info.is_low_batt_alarm;
+}
+
+static int max77833_get_fuelgauge_soc(struct max77833_fuelgauge_data *fuelgauge)
+{
+	union power_supply_propval value;
+	int fg_soc = 0;
+	int fg_vfsoc;
+	int fg_vcell;
+	int fg_current;
+	int avg_current;
+
+	if (fuelgauge->info.is_low_batt_alarm)
+		if (max77833_fuelgauge_recovery_handler(fuelgauge)) {
+			fg_soc = fuelgauge->info.soc;
+			goto return_soc;
+		}
+
+	fg_soc = max77833_get_fuelgauge_value(fuelgauge, MAX77833_FG_LEVEL);
+	if (fg_soc < 0) {
+		pr_info("Can't read soc!!!");
+		fg_soc = fuelgauge->info.soc;
+	}
+
+	fg_vcell = max77833_get_fuelgauge_value(fuelgauge, MAX77833_FG_VOLTAGE);
+	fg_current = max77833_get_fuelgauge_value(fuelgauge, MAX77833_FG_CURRENT);
+	avg_current = max77833_get_fuelgauge_value(fuelgauge, MAX77833_FG_CURRENT_AVG);
+	fg_vfsoc = max77833_get_fuelgauge_value(fuelgauge, MAX77833_FG_VF_SOC);
+
+	psy_do_property("battery", get,
+		POWER_SUPPLY_PROP_STATUS, value);
+
+	/*  Checks vcell level and tries to compensate SOC if needed.*/
+	/*  If jig cable is connected, then skip low batt compensation check. */
+	if (fuelgauge->pdata->check_jig_status &&
+	    !fuelgauge->pdata->check_jig_status() &&
+		value.intval == POWER_SUPPLY_STATUS_DISCHARGING)
+		fg_soc = max77833_low_batt_compensation(
+			fuelgauge, fg_soc, fg_vcell, fg_current);
+
+	if (fuelgauge->info.is_first_check)
+		fuelgauge->info.is_first_check = false;
+
+	if ((fg_vcell < 3400) && (avg_current < 0) && (fg_soc <= 10))
+		fg_soc = 0;
+
+	fuelgauge->info.soc = fg_soc;
+
+return_soc:
+	pr_debug("%s: soc(%d), low_batt_alarm(%d)\n",
+		__func__, fuelgauge->info.soc,
+		fuelgauge->info.is_low_batt_alarm);
+
+	return fg_soc;
+}
+
+static irqreturn_t max77833_jig_irq_thread(int irq, void *irq_data)
+{
+	struct max77833_fuelgauge_data *fuelgauge = irq_data;
+
+	if (fuelgauge->pdata->check_jig_status &&
+	    fuelgauge->pdata->check_jig_status())
+		max77833_fg_reset_capacity_by_jig_connection(fuelgauge);
+	else
+		pr_info("%s: jig removed\n", __func__);
+	return IRQ_HANDLED;
+}
+
+bool max77833_fg_init(struct max77833_fuelgauge_data *fuelgauge)
+{
+	ktime_t	current_time;
+	struct timespec ts;
+	u16 data;
+
+#if defined(ANDROID_ALARM_ACTIVATED)
+	current_time = alarm_get_elapsed_realtime();
+	ts = ktime_to_timespec(current_time);
+#else
+	current_time = ktime_get_boottime();
+	ts = ktime_to_timespec(current_time);
+#endif
+
+	fuelgauge->info.fullcap_check_interval = ts.tv_sec;
+
+	fuelgauge->info.is_low_batt_alarm = false;
+	fuelgauge->info.is_first_check = true;
+
+	/* Init parameters to prevent wrong compensation. */
+	fuelgauge->info.previous_fullcap =
+		max77833_read_word(fuelgauge->i2c, FULLCAP_REG);
+	fuelgauge->info.previous_vffullcap =
+		max77833_read_word(fuelgauge->i2c, FULLCAP_NOM_REG);
+
+	if (fuelgauge->pdata->check_jig_status &&
+	    fuelgauge->pdata->check_jig_status())
+		max77833_fg_reset_capacity_by_jig_connection(fuelgauge);
+	else {
+		if (fuelgauge->pdata->jig_irq) {
+			int ret;
+			ret = request_threaded_irq(fuelgauge->pdata->jig_irq,
+					NULL, max77833_jig_irq_thread,
+					fuelgauge->pdata->jig_irq_attr,
+					"jig-irq", fuelgauge);
+			if (ret) {
+				pr_info("%s: Failed to Request IRQ\n",
+					__func__);
+			}
+		}
+	}
+
+	/* NOT using FG for temperature */
+	if (fuelgauge->pdata->thermal_source != SEC_BATTERY_THERMAL_SOURCE_FG) {
+		if (max77833_read_fg(fuelgauge->i2c, CONFIG_REG, &data) < 0) {
+			pr_err ("%s : Failed to read CONFIG_REG\n", __func__);
+			return false;
+		}
+		data |= 0x10;
+		if (max77833_write_fg(fuelgauge->i2c, CONFIG_REG, data) < 0) {
+			pr_info("%s : Failed to write CONFIG_REG\n", __func__);
+			return false;
+		}
+	}
+
+	/* Enable OCP (0xFF : 10.24A/256) */
+	data = 0x00FF;
+	max77833_write_fg(fuelgauge->i2c, ISYSTH_REG, data);
+	pr_info("%s: Enable OCP - IsysTH 0x%x\n", __func__, data);
+
+	return true;
+}
+
+bool max77833_fg_fuelalert_init(struct max77833_fuelgauge_data *fuelgauge,
+				int soc)
+{
+	/* 1. Set max77833 alert configuration. */
+	if (max77833_fg_alert_init(fuelgauge, soc) > 0)
+		return true;
+	else
+		return false;
+}
+
+void max77833_fg_fuelalert_set(struct max77833_fuelgauge_data *fuelgauge,
+			       int enable)
+{
+	u16 config_data;
+
+	if (max77833_read_fg(fuelgauge->i2c, CONFIG_REG, &config_data) < 0)
+		pr_err("%s: Failed to read CONFIG_REG\n", __func__);
+
+	if (enable)
+		config_data |= ALERT_EN;
+	else
+		config_data &= ~ALERT_EN;
+
+	pr_info("%s : CONIFG(0x%04x)\n", __func__, config_data);
+
+	if (max77833_write_fg(fuelgauge->i2c, CONFIG_REG, config_data) < 0)
+		pr_info("%s: Failed to write CONFIG_REG\n", __func__);
+
+}
+
+bool max77833_fg_fuelalert_process(void *irq_data)
+{
+	struct max77833_fuelgauge_data *fuelgauge =
+		(struct max77833_fuelgauge_data *)irq_data;
+
+	max77833_fg_fuelalert_set(fuelgauge, 0);
+
+	return true;
+}
+
+bool max77833_fg_reset(struct max77833_fuelgauge_data *fuelgauge)
+{
+	if (!max77833_fg_reset_soc(fuelgauge))
+		return true;
+	else
+		return false;
+}
+
+#define CAPACITY_MAX_CONTROL_THRESHOLD 300
+
+static void max77833_fg_get_scaled_capacity(
+	struct max77833_fuelgauge_data *fuelgauge,
+	union power_supply_propval *val)
+{
+	union power_supply_propval value, chg_val, chg_val2;
+	int max_temp;
+
+	psy_do_property("battery", get, POWER_SUPPLY_PROP_ONLINE, value);
+	psy_do_property("max77833-charger", get, POWER_SUPPLY_PROP_CURRENT_NOW,
+			chg_val);
+	psy_do_property("max77833-charger", get, POWER_SUPPLY_PROP_CHARGE_NOW,
+			chg_val2);
+	pr_info("%s : CABLE TYPE(%d) INPUT CURRENT(%d) CHARGINGE MODE(%s)\n",
+		__func__, value.intval, chg_val.intval, chg_val2.strval);
+
+	max_temp = fuelgauge->capacity_max;
+
+	if ((value.intval != POWER_SUPPLY_TYPE_BATTERY) &&
+	    (!strcmp(chg_val2.strval, "CV Mode")) &&
+	    (chg_val.intval >= 1000)) {
+		int temp, sample;
+		int curr;
+		int topoff;
+		int capacity_threshold;
+		static int cnt;
+
+		curr = max77833_get_fuelgauge_value(fuelgauge, MAX77833_FG_CURRENT_AVG);
+		topoff = fuelgauge->pdata->charging_current[value.intval].full_check_current_1st;
+		capacity_threshold = topoff + CAPACITY_MAX_CONTROL_THRESHOLD;
+
+		pr_info("%s : curr(%d) topoff(%d) capacity_max(%d)\n", __func__, curr, topoff, max_temp);
+
+		if ((curr < capacity_threshold) && (curr > topoff)) {
+			if (!cnt) {
+				cnt = 1;
+				fuelgauge->standard_capacity = (val->intval < fuelgauge->pdata->capacity_min) ?
+					0 : ((val->intval - fuelgauge->pdata->capacity_min) * 999 /
+					     (fuelgauge->capacity_max - fuelgauge->pdata->capacity_min));
+			} else if (fuelgauge->standard_capacity < 999) {
+				temp = (val->intval < fuelgauge->pdata->capacity_min) ?
+					0 : ((val->intval - fuelgauge->pdata->capacity_min) * 999 /
+					     (fuelgauge->capacity_max - fuelgauge->pdata->capacity_min));
+
+				sample = ((capacity_threshold - curr) * (999 - fuelgauge->standard_capacity)) /
+					(capacity_threshold - topoff);
+
+				pr_info("%s : %d = ((%d - %d) * (999 - %d)) / (%d - %d)\n",
+					__func__,
+					sample, capacity_threshold, curr, fuelgauge->standard_capacity,
+					capacity_threshold, topoff);
+
+				if ((temp - fuelgauge->standard_capacity) >= sample) {
+					pr_info("%s : TEMP > SAMPLE\n", __func__);
+				} else if ((sample - (temp - fuelgauge->standard_capacity)) < 5) {
+					pr_info("%s : TEMP < SAMPLE && GAP UNDER 5\n", __func__);
+					max_temp -= (sample - (temp - fuelgauge->standard_capacity));
+				} else {
+					pr_info("%s : TEMP > SAMPLE && GAP OVER 5\n", __func__);
+					max_temp -= 5;
+				}
+				pr_info("%s : TEMP(%d) SAMPLE(%d) CAPACITY_MAX(%d)\n",
+					__func__, temp, sample, fuelgauge->capacity_max);
+			}
+		} else {
+			cnt = 0;
+		}
+	}
+
+	if (max_temp <
+		fuelgauge->pdata->capacity_max -
+		fuelgauge->pdata->capacity_max_margin) {
+		fuelgauge->capacity_max =
+			fuelgauge->pdata->capacity_max -
+			fuelgauge->pdata->capacity_max_margin;
+		pr_debug("%s: capacity_max (%d)", __func__,
+			 fuelgauge->capacity_max);
+	} else {
+		fuelgauge->capacity_max =
+			(max_temp >
+			fuelgauge->pdata->capacity_max +
+			fuelgauge->pdata->capacity_max_margin) ?
+			(fuelgauge->pdata->capacity_max +
+			fuelgauge->pdata->capacity_max_margin) :
+			max_temp;
+		pr_debug("%s: capacity_max (%d)", __func__,
+			 fuelgauge->capacity_max);
+	}
+
+	val->intval = (val->intval < fuelgauge->pdata->capacity_min) ?
+		0 : ((val->intval - fuelgauge->pdata->capacity_min) * 1000 /
+		     (fuelgauge->capacity_max - fuelgauge->pdata->capacity_min));
+
+	pr_info("%s: scaled capacity (%d.%d)\n",
+		 __func__, val->intval/10, val->intval%10);
+}
+
+/* capacity is integer */
+static void max77833_fg_get_atomic_capacity(
+	struct max77833_fuelgauge_data *fuelgauge,
+	union power_supply_propval *val)
+{
+
+	pr_info("%s : NOW(%d), OLD(%d)\n",
+		__func__, val->intval, fuelgauge->capacity_old);
+
+	if (fuelgauge->pdata->capacity_calculation_type &
+		SEC_FUELGAUGE_CAPACITY_TYPE_ATOMIC) {
+	if (fuelgauge->capacity_old < val->intval)
+		val->intval = fuelgauge->capacity_old + 1;
+	else if (fuelgauge->capacity_old > val->intval)
+		val->intval = fuelgauge->capacity_old - 1;
+	}
+
+	/* keep SOC stable in abnormal status */
+	if (fuelgauge->pdata->capacity_calculation_type &
+		SEC_FUELGAUGE_CAPACITY_TYPE_SKIP_ABNORMAL) {
+		if (!fuelgauge->is_charging &&
+			fuelgauge->capacity_old < val->intval) {
+			pr_err("%s: capacity (old %d : new %d)\n",
+				__func__, fuelgauge->capacity_old, val->intval);
+			val->intval = fuelgauge->capacity_old;
+		}
+	}
+
+	/* updated old capacity */
+	fuelgauge->capacity_old = val->intval;
+}
+
+static int max77833_fg_calculate_dynamic_scale(
+	struct max77833_fuelgauge_data *fuelgauge, int capacity)
+{
+	union power_supply_propval raw_soc_val;
+	raw_soc_val.intval = max77833_get_fuelgauge_value(fuelgauge,
+						 MAX77833_FG_RAW_SOC) / 10;
+
+	if (raw_soc_val.intval <
+		fuelgauge->pdata->capacity_max -
+		fuelgauge->pdata->capacity_max_margin) {
+		fuelgauge->capacity_max =
+			fuelgauge->pdata->capacity_max -
+			fuelgauge->pdata->capacity_max_margin;
+		pr_debug("%s: capacity_max (%d)", __func__,
+			 fuelgauge->capacity_max);
+	} else {
+		fuelgauge->capacity_max =
+			(raw_soc_val.intval >
+			fuelgauge->pdata->capacity_max +
+			fuelgauge->pdata->capacity_max_margin) ?
+			(fuelgauge->pdata->capacity_max +
+			fuelgauge->pdata->capacity_max_margin) :
+			raw_soc_val.intval;
+		pr_debug("%s: raw soc (%d)", __func__,
+			 fuelgauge->capacity_max);
+	}
+
+	if (capacity != 100) {
+		fuelgauge->capacity_max =
+			(fuelgauge->capacity_max * 100 / capacity);
+		fuelgauge->capacity_old = capacity;
+	} else {
+		fuelgauge->capacity_max =
+			(fuelgauge->capacity_max * 99 / 100);
+		fuelgauge->capacity_old = 100;
+	}
+
+	pr_info("%s: %d is used for capacity_max, capacity(%d)\n",
+		__func__, fuelgauge->capacity_max, capacity);
+
+	return fuelgauge->capacity_max;
+}
+
+static void max77833_fg_check_qrtable(struct max77833_fuelgauge_data *fuelgauge)
+{
+	u16 qrtable20, qrtable30;
+
+	max77833_read_fg(fuelgauge->i2c, QRTABLE20_REG, &qrtable20);
+	if (qrtable20 != fuelgauge->battery_data->QResidual20) {
+		if (max77833_write_fg(fuelgauge->i2c, QRTABLE20_REG,
+				      fuelgauge->battery_data->QResidual20) < 0)
+			pr_err("%s: Failed to write QRTABLE20\n", __func__);
+	}
+	max77833_read_fg(fuelgauge->i2c, QRTABLE30_REG, &qrtable30);
+	if (qrtable30 != fuelgauge->battery_data->QResidual30) {
+		if (max77833_write_fg(fuelgauge->i2c, QRTABLE30_REG, 
+				      fuelgauge->battery_data->QResidual30) < 0)
+			pr_err("%s: Failed to write QRTABLE30\n", __func__);
+	}
+	pr_info("%s: QRTABLE20_REG(0x%04x), QRTABLE30_REG(0x%04x)\n", __func__,
+		qrtable20, qrtable30);
+}
+
+#if defined(CONFIG_EN_OOPS)
+static void max77833_set_full_value(struct max77833_fuelgauge_data *fuelgauge,
+				    int cable_type)
+{
+	u16 ichgterm, misccfg, fullsocthr;
+
+	if ((cable_type == POWER_SUPPLY_TYPE_HV_MAINS) ||
+	    (cable_type == POWER_SUPPLY_TYPE_HV_ERR)) {
+		ichgterm = fuelgauge->battery_data->ichgterm_2nd;
+		misccfg = fuelgauge->battery_data->misccfg_2nd;
+		fullsocthr = fuelgauge->battery_data->fullsocthr_2nd;
+	} else {
+		ichgterm = fuelgauge->battery_data->ichgterm;
+		misccfg = fuelgauge->battery_data->misccfg;
+		fullsocthr = fuelgauge->battery_data->fullsocthr;
+	}
+
+	max77833_write_fg(fuelgauge->i2c, ICHGTERM_REG, ichgterm);
+	max77833_write_fg(fuelgauge->i2c, MISCCFG_REG, misccfg);
+	max77833_write_fg(fuelgauge->i2c, FULLSOCTHR_REG, fullsocthr);
+
+	pr_info("%s : ICHGTERM(0x%04x) FULLSOCTHR(0x%04x), MISCCFG(0x%04x)\n",
+		__func__, ichgterm, misccfg, fullsocthr);
+}
+#endif
+
+static int calc_ttf(struct max77833_fuelgauge_data *fuelgauge, union power_supply_propval *val)
+{
+	union power_supply_propval chg_val2;
+	int i;
+	int cc_time = 0;
+
+	int soc = fuelgauge->raw_capacity;
+	int current_now = fuelgauge->current_now;
+	int current_avg = fuelgauge->current_avg;
+	int charge_current = (current_avg > 0)? current_avg : current_now;
+	struct cv_slope *cv_data = fuelgauge->cv_data;
+	int design_cap = fuelgauge->battery_data->Capacity / 2;
+
+	if(!cv_data || (val->intval <= 0)) {
+		pr_info("%s: no cv_data or val: %d\n", __func__, val->intval);
+		return -1;
+	}
+	/* To prevent overflow if charge current is 30 under, change value*/
+	if (charge_current <= 30) {
+#if 1
+		charge_current = val->intval;
+#else
+		pr_info("%s: current: %d, current_avg: %d \n", __func__, current_now, current_avg);
+		return -1;
+#endif
+
+	}
+	psy_do_property("max77833-charger", get, POWER_SUPPLY_PROP_CHARGE_NOW,
+			chg_val2);
+	if (!strcmp(chg_val2.strval, "CC Mode") || !strcmp(chg_val2.strval, "NONE")) { //CC mode || NONE
+		charge_current = val->intval;
+	}
+	for (i = 0; i < fuelgauge->cv_data_lenth ;i++) {
+		if (charge_current >= cv_data[i].fg_current)
+			break;
+	}
+	if (cv_data[i].soc  < soc) {
+		for (i = 0; i < fuelgauge->cv_data_lenth; i++) {
+			if (soc <= cv_data[i].soc)
+				break;
+		}
+	} else if (!strcmp(chg_val2.strval, "CC Mode") || !strcmp(chg_val2.strval, "NONE")) { //CC mode || NONE
+		cc_time = design_cap * (cv_data[i].soc - soc)\
+				/ val->intval * 3600 / 1000;
+		pr_debug("%s: cc_time: %d\n", __func__, cc_time);
+		if (cc_time < 0) {
+
+			cc_time = 0;
+		}
+	}
+
+	pr_debug("%s: soc: %4d, T: %6d, now: %4d, avg: %4d, cv soc: %4d, i: %4d, val: %d, %s\n",
+	 __func__, soc,	cv_data[i].time + cc_time, current_now, current_avg, cv_data[i].soc, i, val->intval, chg_val2.strval);
+	return cv_data[i].time + cc_time + 60; //minimum 1minutes
+}
+
+static int max77833_fg_get_property(struct power_supply *psy,
+			     enum power_supply_property psp,
+			     union power_supply_propval *val)
+{
+	struct max77833_fuelgauge_data *fuelgauge =
+		container_of(psy, struct max77833_fuelgauge_data, psy_fg);
+	static int abnormal_current_cnt = 0;
+	union power_supply_propval value;
+	u16 data;
+
+	unsigned int cnt = 0 ;
+
+	switch (psp) {
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:
+		val->intval = max77833_get_age_forecast(fuelgauge);
+		break;
+#endif
+		/* Cell voltage (VCELL, mV) */
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = max77833_get_fuelgauge_value(fuelgauge, MAX77833_FG_VOLTAGE);
+		break;
+		/* Additional Voltage Information (mV) */
+	case POWER_SUPPLY_PROP_VOLTAGE_AVG:
+		switch (val->intval) {
+		case SEC_BATTERY_VOLTAGE_OCV:
+			val->intval = max77833_fg_read_vfocv(fuelgauge);
+			break;
+		case SEC_BATTERY_VOLTAGE_AVERAGE:
+		default:
+			val->intval = max77833_fg_read_avg_vcell(fuelgauge);
+			break;
+		}
+		break;
+		/* Current */
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		switch (val->intval) {
+		case SEC_BATTERY_CURRENT_UA:
+			val->intval =
+				max77833_fg_read_current(fuelgauge,
+						SEC_BATTERY_CURRENT_UA);
+			break;
+		case SEC_BATTERY_CURRENT_MA:
+		default:
+			/* Print System current use Isys, AvgISys register */
+			if (max77833_read_fg(fuelgauge->i2c, ISYS_REG, &data) < 0)
+					pr_err("%s: Failed to read ISYS_REG\n", __func__);
+			pr_info("%s: System current - ISYS_REG(0x%x, %d)\n", __func__, data, data);
+			if (max77833_read_fg(fuelgauge->i2c, AVGISYS_REG, &data) < 0)
+					pr_err("%s: Failed to read AVGISYS_REG\n", __func__);
+			pr_info("%s: System current - AVGISYS_REG(0x%x, %d)\n", __func__, data, data);
+
+			fuelgauge->current_now = val->intval = max77833_get_fuelgauge_value(fuelgauge,
+							  MAX77833_FG_CURRENT);
+			psy_do_property("battery", get,
+					POWER_SUPPLY_PROP_STATUS, value);
+			/* To save log for abnormal case */
+			if (value.intval == POWER_SUPPLY_STATUS_DISCHARGING && val->intval > 0) {
+				abnormal_current_cnt++;
+				if (abnormal_current_cnt >= 5) {
+					pr_info("%s : Inow is increasing in not charging status\n",
+						__func__);
+					value.intval = fuelgauge->capacity_old + 15;
+					psy_do_property("battery", set,
+							POWER_SUPPLY_PROP_CAPACITY, value);
+					abnormal_current_cnt = 0;
+					value.intval = fuelgauge->capacity_old;
+					psy_do_property("battery", set,
+							POWER_SUPPLY_PROP_CAPACITY, value);
+				}
+			} else {
+				abnormal_current_cnt = 0;
+			}
+			break;
+		}
+		break;
+		/* Average Current */
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+		switch (val->intval) {
+		case SEC_BATTERY_CURRENT_UA:
+			val->intval =
+				max77833_fg_read_avg_current(fuelgauge,
+						    SEC_BATTERY_CURRENT_UA);
+			break;
+		case SEC_BATTERY_CURRENT_MA:
+		default:
+			val->intval =
+				max77833_get_fuelgauge_value(fuelgauge,
+						    MAX77833_FG_CURRENT_AVG);
+			break;
+		}
+		break;
+		/* Full Capacity */
+	case POWER_SUPPLY_PROP_ENERGY_NOW:
+		switch (val->intval) {
+		case SEC_BATTERY_CAPACITY_DESIGNED:
+			val->intval = max77833_get_fuelgauge_value(fuelgauge,
+								   MAX77833_FG_FULLCAP);
+			break;
+		case SEC_BATTERY_CAPACITY_ABSOLUTE:
+			val->intval = max77833_get_fuelgauge_value(fuelgauge,
+								   MAX77833_FG_MIXCAP);
+			break;
+		case SEC_BATTERY_CAPACITY_TEMPERARY:
+			val->intval = max77833_get_fuelgauge_value(fuelgauge,
+								   MAX77833_FG_AVCAP);
+			break;
+		case SEC_BATTERY_CAPACITY_CURRENT:
+			val->intval = max77833_get_fuelgauge_value(fuelgauge,
+								   MAX77833_FG_REPCAP);
+			break;
+		case SEC_BATTERY_CAPACITY_AGEDCELL:
+			val->intval = max77833_get_fuelgauge_value(fuelgauge,
+							  MAX77833_FG_FULLCAPNOM);
+			break;
+		case SEC_BATTERY_CAPACITY_CYCLE:
+			val->intval = max77833_get_fuelgauge_value(fuelgauge,
+							  MAX77833_FG_CYCLE);
+			break;
+		}
+		break;
+		/* SOC (%) */
+	case POWER_SUPPLY_PROP_CAPACITY:
+		if (val->intval == SEC_FUELGAUGE_CAPACITY_TYPE_RAW) {
+			val->intval = max77833_get_fuelgauge_value(fuelgauge,
+								   MAX77833_FG_RAW_SOC);
+			while(val->intval == 0){
+				pr_info(" %s: Battery level is 0 : cnt:%d \n",__func__, cnt);
+				val->intval = max77833_get_fuelgauge_value(fuelgauge,
+								   MAX77833_FG_RAW_SOC);
+				cnt++;
+				if(cnt > 3)
+					break;
+			}
+
+			if(val->intval < 5) {
+				pr_info("%s	: CAPACITY_TYPE_RAW: Battery is too low!!! 	:%d\n",
+						__func__,val->intval);
+			}
+		} else {
+			val->intval = max77833_get_fuelgauge_soc(fuelgauge);
+
+			fuelgauge->raw_capacity = val->intval;
+
+			if (fuelgauge->pdata->capacity_calculation_type &
+			    (SEC_FUELGAUGE_CAPACITY_TYPE_SCALE |
+			     SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE))
+				max77833_fg_get_scaled_capacity(fuelgauge, val);
+
+			/* capacity should be between 0% and 100%
+			 * (0.1% degree)
+			 */
+			if (val->intval > 1000)
+				val->intval = 1000;
+			if (val->intval < 0)
+				val->intval = 0;
+
+			while(val->intval == 0){
+				pr_info(" %s: Battery level is 0 : cnt:%d \n",__func__, cnt);
+				val->intval = max77833_get_fuelgauge_soc(fuelgauge);
+
+				fuelgauge->raw_capacity = val->intval;
+
+				if (fuelgauge->pdata->capacity_calculation_type &
+				    (SEC_FUELGAUGE_CAPACITY_TYPE_SCALE |
+				     SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE))
+					max77833_fg_get_scaled_capacity(fuelgauge, val);
+
+				/* capacity should be between 0% and 100%
+				 * (0.1% degree)
+				*/
+				if (val->intval > 1000)
+					val->intval = 1000;
+				if (val->intval < 0)
+					val->intval = 0;
+
+				cnt++;
+				if(cnt > 3)
+					break;
+			}
+
+			if(val->intval < 5) {
+				pr_info("%s	: Battery is too low!!! 	:%d\n",
+						__func__,val->intval);
+			}
+
+			/* get only integer part */
+			val->intval /= 10;
+
+			/* check whether doing the wake_unlock */
+			if ((val->intval > fuelgauge->pdata->fuel_alert_soc) &&
+			    fuelgauge->is_fuel_alerted) {
+				wake_unlock(&fuelgauge->fuel_alert_wake_lock);
+				max77833_fg_fuelalert_init(fuelgauge,
+					  fuelgauge->pdata->fuel_alert_soc);
+			}
+
+			/* (Only for atomic capacity)
+			 * In initial time, capacity_old is 0.
+			 * and in resume from sleep,
+			 * capacity_old is too different from actual soc.
+			 * should update capacity_old
+			 * by val->intval in booting or resume.
+			 */
+			if (fuelgauge->initial_update_of_soc) {
+				/* updated old capacity */
+				fuelgauge->capacity_old = val->intval;
+				fuelgauge->initial_update_of_soc = false;
+				break;
+			}
+
+			if (fuelgauge->pdata->capacity_calculation_type &
+			    (SEC_FUELGAUGE_CAPACITY_TYPE_ATOMIC |
+			     SEC_FUELGAUGE_CAPACITY_TYPE_SKIP_ABNORMAL))
+				max77833_fg_get_atomic_capacity(fuelgauge, val);
+		}
+		break;
+		/* Battery Temperature */
+	case POWER_SUPPLY_PROP_TEMP:
+		/* Target Temperature */
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		val->intval = max77833_get_fuelgauge_value(fuelgauge,
+							   MAX77833_FG_TEMPERATURE);
+		break;
+#if defined(CONFIG_EN_OOPS)
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+		return -ENODATA;
+#endif
+	case POWER_SUPPLY_PROP_ENERGY_FULL:
+		{
+			int fullcap = max77833_get_fuelgauge_value(fuelgauge, MAX77833_FG_FULLCAPNOM);
+			val->intval = fullcap * 100 / fuelgauge->battery_data->Capacity;
+			pr_info("%s: asoc(%d), fullcap(0x%x)\n",
+				__func__, val->intval, fullcap);
+#if !defined(CONFIG_SEC_FACTORY)
+			max77833_fg_periodic_read(fuelgauge);
+#endif
+		}
+		break;
+	case POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:
+		val->intval = fuelgauge->capacity_max;
+		break;
+	case POWER_SUPPLY_PROP_TIME_TO_FULL_NOW:
+		val->intval = calc_ttf(fuelgauge, val);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int max77833_fg_set_property(struct power_supply *psy,
+			     enum power_supply_property psp,
+			     const union power_supply_propval *val)
+{
+	struct max77833_fuelgauge_data *fuelgauge =
+		container_of(psy, struct max77833_fuelgauge_data, psy_fg);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		break;
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:
+		break;
+#endif
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+		if (fuelgauge->pdata->capacity_calculation_type &
+			SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE) {
+#if defined(CONFIG_AFC_CHARGER_MODE)
+		max77833_fg_calculate_dynamic_scale(fuelgauge, val->intval);
+#else
+		max77833_fg_calculate_dynamic_scale(fuelgauge, 100);
+#endif
+		}
+		break;
+#if defined(CONFIG_EN_OOPS)
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+		max77833_set_full_value(fuelgauge, val->intval);
+		break;
+#endif
+	case POWER_SUPPLY_PROP_ONLINE:
+		fuelgauge->cable_type = val->intval;
+		if (val->intval == POWER_SUPPLY_TYPE_BATTERY) {
+			fuelgauge->is_charging = false;
+		} else {
+			fuelgauge->is_charging = true;
+
+			if (fuelgauge->info.is_low_batt_alarm) {
+				pr_info("%s: Reset low_batt_alarm\n",
+					 __func__);
+				fuelgauge->info.is_low_batt_alarm = false;
+			}
+
+			max77833_reset_low_batt_comp_cnt(fuelgauge);
+		}
+		break;
+		/* Battery Temperature */
+	case POWER_SUPPLY_PROP_CAPACITY:
+		if (val->intval == SEC_FUELGAUGE_CAPACITY_TYPE_RESET) {
+			fuelgauge->initial_update_of_soc = true;
+			if (!max77833_fg_reset(fuelgauge))
+				return -EINVAL;
+			else
+				break;
+		}
+	case POWER_SUPPLY_PROP_TEMP:
+		max77833_fg_write_temp(fuelgauge, val->intval);
+		max77833_fg_check_qrtable(fuelgauge);
+		break;
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		break;
+	case POWER_SUPPLY_PROP_ENERGY_NOW:
+		max77833_fg_reset_capacity_by_jig_connection(fuelgauge);
+		break;
+	case POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:
+		pr_info("%s: capacity_max changed, %d -> %d\n",
+			__func__, fuelgauge->capacity_max, val->intval);
+		fuelgauge->capacity_max = val->intval;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static void max77833_fg_isr_work(struct work_struct *work)
+{
+	struct max77833_fuelgauge_data *fuelgauge =
+		container_of(work, struct max77833_fuelgauge_data, isr_work.work);
+
+	/* process for fuel gauge chip */
+	max77833_fg_fuelalert_process(fuelgauge);
+
+	wake_unlock(&fuelgauge->fuel_alert_wake_lock);
+}
+
+static irqreturn_t max77833_fg_irq_thread(int irq, void *irq_data)
+{
+	struct max77833_fuelgauge_data *fuelgauge = irq_data;
+
+	max77833_update_reg(fuelgauge->pmic,
+			    MAX77833_PMIC_REG_INTSRC_MASK,
+			    MAX77833_IRQSRC_FG,
+			    MAX77833_IRQSRC_FG);
+
+	pr_info("%s\n", __func__);
+
+	if (fuelgauge->is_fuel_alerted) {
+		return IRQ_HANDLED;
+	} else {
+		wake_lock(&fuelgauge->fuel_alert_wake_lock);
+		fuelgauge->is_fuel_alerted = true;
+		schedule_delayed_work(&fuelgauge->isr_work, 0);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int max77833_fuelgauge_debugfs_show(struct seq_file *s, void *data)
+{
+	seq_printf(s, "MAX77833 FUELGAUGE IC :\n");
+	seq_printf(s, "===================\n");
+	seq_printf(s, "\n");
+	return 0;
+}
+
+static int max77833_fuelgauge_debugfs_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, max77833_fuelgauge_debugfs_show, inode->i_private);
+}
+
+static const struct file_operations max77833_fuelgauge_debugfs_fops = {
+	.open           = max77833_fuelgauge_debugfs_open,
+	.read           = seq_read,
+	.llseek         = seq_lseek,
+	.release        = single_release,
+};
+
+#ifdef CONFIG_OF
+static int max77833_fuelgauge_parse_dt(struct max77833_fuelgauge_data *fuelgauge)
+{
+	struct device_node *np = of_find_node_by_name(NULL, "max77833-fuelgauge");
+	sec_fuelgauge_platform_data_t *pdata = fuelgauge->pdata;
+	int ret;
+	int i, len;
+	const u32 *p;
+
+	/* reset, irq gpio info */
+	if (np == NULL) {
+		pr_err("%s np NULL\n", __func__);
+	} else {
+		ret = of_property_read_u32(np, "fuelgauge,capacity_max",
+				&pdata->capacity_max);
+		if (ret < 0)
+			pr_err("%s error reading capacity_max %d\n", __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_max_margin",
+				&pdata->capacity_max_margin);
+		if (ret < 0)
+			pr_err("%s error reading capacity_max_margin %d\n", __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_min",
+				&pdata->capacity_min);
+		if (ret < 0)
+			pr_err("%s error reading capacity_min %d\n", __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_calculation_type",
+				&pdata->capacity_calculation_type);
+		if (ret < 0)
+			pr_err("%s error reading capacity_calculation_type %d\n",
+					__func__, ret);
+		ret = of_property_read_u32(np, "fuelgauge,fuel_alert_soc",
+				&pdata->fuel_alert_soc);
+		if (ret < 0)
+			pr_err("%s error reading pdata->fuel_alert_soc %d\n",
+					__func__, ret);
+		pdata->repeated_fuelalert = of_property_read_bool(np,
+				"fuelgauge,repeated_fuelalert");
+
+		ret = of_property_read_u32(np, "fuelgauge,qrtable20",
+					   &fuelgauge->battery_data->QResidual20);
+		if (ret < 0)
+			pr_err("%s error reading qrtable20 %d\n",
+					__func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,qrtable30",
+					   &fuelgauge->battery_data->QResidual30);
+		if (ret < 0)
+			pr_err("%s error reading qrtabel30 %d\n",
+					__func__, ret);
+
+#if defined(CONFIG_EN_OOPS)
+		ret = of_property_read_u32(np, "fuelgauge,ichgterm",
+					   &fuelgauge->battery_data->ichgterm);
+		if (ret < 0)
+			pr_err("%s error reading ichgterm %d\n",
+					__func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,ichgterm_2nd",
+					   &fuelgauge->battery_data->ichgterm_2nd);
+		if (ret < 0)
+			pr_err("%s error reading ichgterm_2nd %d\n",
+					__func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,misccfg",
+					   &fuelgauge->battery_data->misccfg);
+		if (ret < 0)
+			pr_err("%s error reading misccfg %d\n",
+					__func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,misccfg_2nd",
+					   &fuelgauge->battery_data->misccfg_2nd);
+		if (ret < 0)
+			pr_err("%s error reading misccfg_2nd %d\n",
+					__func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,fullsocthr",
+					   &fuelgauge->battery_data->fullsocthr);
+		if (ret < 0)
+			pr_err("%s error reading fullsocthr %d\n",
+					__func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,fullsocthr_2nd",
+					   &fuelgauge->battery_data->fullsocthr_2nd);
+		if (ret < 0)
+			pr_err("%s error reading fullsocthr_2nd %d\n",
+					__func__, ret);
+#endif
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity",
+					   &fuelgauge->battery_data->Capacity);
+		if (ret < 0)
+			pr_err("%s error reading capacity_calculation_type %d\n",
+					__func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,low_battery_comp_voltage",
+			   &fuelgauge->battery_data->low_battery_comp_voltage);
+		if (ret < 0)
+			pr_err("%s error reading capacity_calculation_type %d\n",
+					__func__, ret);
+
+		for(i = 0; i < (CURRENT_RANGE_MAX_NUM * MAX77833_TABLE_MAX); i++) {
+			ret = of_property_read_u32_index(np,
+					 "fuelgauge,low_battery_table",
+					 i,
+					 &fuelgauge->battery_data->low_battery_table[i/3][i%3]);
+			pr_info("[%d]",
+				fuelgauge->battery_data->low_battery_table[i/3][i%3]);
+			if ((i%3) == 2)
+				pr_info("\n");
+		}
+		p = of_get_property(np, "fuelgauge,cv_data", &len);
+		if (p) {
+			fuelgauge->cv_data = kzalloc(len,
+						  GFP_KERNEL);
+			fuelgauge->cv_data_lenth = len / sizeof(struct cv_slope);
+			pr_err("%s len: %ld, lenth: %d, %d\n",
+					__func__, sizeof(int) * len, len, fuelgauge->cv_data_lenth);
+			ret = of_property_read_u32_array(np, "fuelgauge,cv_data",
+					 (u32 *)fuelgauge->cv_data, len/sizeof(u32));
+			for(i = 0; i < fuelgauge->cv_data_lenth; i++) {
+				pr_err("%s  %5d, %5d, %5d\n",
+						__func__, fuelgauge->cv_data[i].fg_current,
+						fuelgauge->cv_data[i].soc, fuelgauge->cv_data[i].time);
+			}
+			if (ret) {
+				pr_err("%s failed to read fuelgauge->cv_data: %d\n",
+						__func__, ret);
+				kfree(fuelgauge->cv_data);
+				fuelgauge->cv_data = NULL;
+			}
+		} else {
+			pr_err("%s there is not cv_data\n", __func__);
+		}
+
+		np = of_find_node_by_name(NULL, "battery");
+		ret = of_property_read_u32(np, "battery,thermal_source",
+					   &pdata->thermal_source);
+		if (ret < 0) {
+			pr_err("%s error reading pdata->thermal_source %d\n",
+			       __func__, ret);
+		}
+
+		p = of_get_property(np, "battery,input_current_limit", &len);
+		if (!p)
+			return 1;
+		len = len / sizeof(u32);
+
+		pdata->charging_current = kzalloc(sizeof(sec_charging_current_t) * len,
+						  GFP_KERNEL);
+
+		for(i = 0; i < len; i++) {
+			ret = of_property_read_u32_index(np,
+				 "battery,input_current_limit", i,
+				 &pdata->charging_current[i].input_current_limit);
+			ret = of_property_read_u32_index(np,
+				 "battery,fast_charging_current", i,
+				 &pdata->charging_current[i].fast_charging_current);
+			ret = of_property_read_u32_index(np,
+				 "battery,full_check_current_1st", i,
+				 &pdata->charging_current[i].full_check_current_1st);
+			ret = of_property_read_u32_index(np,
+				 "battery,full_check_current_2nd", i,
+				 &pdata->charging_current[i].full_check_current_2nd);
+		}
+
+		pr_info("%s fg_irq: %d, capacity_max: %d\n"
+			"qrtable20: 0x%x, qrtable30 : 0x%x\n"
+			"capacity_max_margin: %d, capacity_min: %d\n"
+			"calculation_type: 0x%x, fuel_alert_soc: %d,\n"
+			"repeated_fuelalert: %d\n",
+			__func__, pdata->fg_irq, pdata->capacity_max,
+			fuelgauge->battery_data->QResidual20,
+			fuelgauge->battery_data->QResidual30,
+			pdata->capacity_max_margin, pdata->capacity_min,
+			pdata->capacity_calculation_type, pdata->fuel_alert_soc,
+			pdata->repeated_fuelalert);
+	}
+
+	pr_info("[%s][%d][%d]\n",
+		__func__, fuelgauge->battery_data->Capacity,
+	        fuelgauge->battery_data->low_battery_comp_voltage);
+
+	return 0;
+}
+#endif
+
+static int __devinit max77833_fuelgauge_probe(struct platform_device *pdev)
+{
+	struct max77833_dev *max77833 = dev_get_drvdata(pdev->dev.parent);
+	struct max77833_platform_data *pdata = dev_get_platdata(max77833->dev);
+	struct max77833_fuelgauge_data *fuelgauge;
+	int ret = 0;
+	union power_supply_propval raw_soc_val;
+
+	pr_info("%s: MAX77833 Fuelgauge Driver Loading\n", __func__);
+
+	fuelgauge = kzalloc(sizeof(*fuelgauge), GFP_KERNEL);
+	if (!fuelgauge)
+		return -ENOMEM;
+
+	pdata->fuelgauge_data = kzalloc(sizeof(sec_fuelgauge_platform_data_t), GFP_KERNEL);
+	if (!pdata->fuelgauge_data) {
+		ret = -ENOMEM;
+		goto err_free;
+	}
+
+	mutex_init(&fuelgauge->fg_lock);
+
+	fuelgauge->dev = &pdev->dev;
+	fuelgauge->pdata = pdata->fuelgauge_data;
+	fuelgauge->i2c = max77833->fuelgauge;
+	fuelgauge->pmic = max77833->i2c;
+	fuelgauge->max77833_pdata = pdata;
+
+#if defined(CONFIG_OF)
+	fuelgauge->battery_data = kzalloc(sizeof(struct battery_data_t),
+					  GFP_KERNEL);
+	if(!fuelgauge->battery_data) {
+		pr_err("Failed to allocate memory\n");
+		ret = -ENOMEM;
+		goto err_pdata_free;
+	}
+	ret = max77833_fuelgauge_parse_dt(fuelgauge);
+	if (ret < 0) {
+		pr_err("%s not found charger dt! ret[%d]\n",
+		       __func__, ret);
+	}
+#endif
+
+	platform_set_drvdata(pdev, fuelgauge);
+
+	fuelgauge->psy_fg.name		= "max77833-fuelgauge";
+	fuelgauge->psy_fg.type		= POWER_SUPPLY_TYPE_UNKNOWN;
+	fuelgauge->psy_fg.get_property	= max77833_fg_get_property;
+	fuelgauge->psy_fg.set_property	= max77833_fg_set_property;
+	fuelgauge->psy_fg.properties	= max77833_fuelgauge_props;
+	fuelgauge->psy_fg.num_properties =
+		ARRAY_SIZE(max77833_fuelgauge_props);
+	fuelgauge->capacity_max = fuelgauge->pdata->capacity_max;
+	raw_soc_val.intval = max77833_get_fuelgauge_value(fuelgauge, MAX77833_FG_RAW_SOC) / 10;
+
+	if (raw_soc_val.intval > fuelgauge->capacity_max)
+		max77833_fg_calculate_dynamic_scale(fuelgauge, 100);
+
+	(void) debugfs_create_file("max77833-fuelgauge-regs",
+		S_IRUGO, NULL, (void *)fuelgauge, &max77833_fuelgauge_debugfs_fops);
+
+	if (!max77833_fg_init(fuelgauge)) {
+		pr_err("%s: Failed to Initialize Fuelgauge\n", __func__);
+		goto err_data_free;
+	}
+
+	ret = power_supply_register(&pdev->dev, &fuelgauge->psy_fg);
+	if (ret) {
+		pr_err("%s: Failed to Register psy_fg\n", __func__);
+		goto err_data_free;
+	}
+
+	fuelgauge->fg_irq = pdata->irq_base + MAX77833_FG_IRQ_ALERT;
+	pr_info("[%s]IRQ_BASE(%d) FG_IRQ(%d)\n",
+		__func__, pdata->irq_base, fuelgauge->fg_irq);
+
+	fuelgauge->is_fuel_alerted = false;
+	if (fuelgauge->pdata->fuel_alert_soc >= 0) {
+		if (max77833_fg_fuelalert_init(fuelgauge,
+				       fuelgauge->pdata->fuel_alert_soc)) {
+			wake_lock_init(&fuelgauge->fuel_alert_wake_lock,
+				       WAKE_LOCK_SUSPEND, "fuel_alerted");
+			if (fuelgauge->fg_irq) {
+				INIT_DELAYED_WORK(&fuelgauge->isr_work, max77833_fg_isr_work);
+
+				ret = request_threaded_irq(fuelgauge->fg_irq,
+					   NULL, max77833_fg_irq_thread,
+					   IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+					   "fuelgauge-irq", fuelgauge);
+				if (ret) {
+					pr_err("%s: Failed to Request IRQ\n", __func__);
+					goto err_supply_unreg;
+				}
+			}
+		} else {
+			pr_err("%s: Failed to Initialize Fuel-alert\n",
+			       __func__);
+			goto err_supply_unreg;
+		}
+	}
+
+	fuelgauge->initial_update_of_soc = true;
+
+	//Temporary Code - In Rev00 CL33, SOC is 0 even if Vcell is high enough.
+	if (max77833_fg_read_vcell(fuelgauge) >= 3500 && max77833_fg_read_soc(fuelgauge) == 0)
+	{
+		if (max77833_fg_reset(fuelgauge))
+			pr_err("%s: FG Reset Done!!!!\n", __func__);
+		else
+			pr_err("%s: FG Reset Failed!!!!\n", __func__);
+	}
+
+	pr_info("%s: MAX77833 Fuelgauge Driver Loaded\n", __func__);
+	return 0;
+
+err_supply_unreg:
+	power_supply_unregister(&fuelgauge->psy_fg);
+err_data_free:
+#if defined(CONFIG_OF)
+	kfree(fuelgauge->battery_data);
+#endif
+err_pdata_free:
+	kfree(pdata->fuelgauge_data);
+	mutex_destroy(&fuelgauge->fg_lock);
+err_free:
+	kfree(fuelgauge);
+
+	return ret;
+}
+
+static int __devexit max77833_fuelgauge_remove(struct platform_device *pdev)
+{
+	struct max77833_fuelgauge_data *fuelgauge =
+		platform_get_drvdata(pdev);
+
+	if (fuelgauge->pdata->fuel_alert_soc >= 0)
+		wake_lock_destroy(&fuelgauge->fuel_alert_wake_lock);
+
+	return 0;
+}
+
+static int max77833_fuelgauge_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int max77833_fuelgauge_resume(struct device *dev)
+{
+	struct max77833_fuelgauge_data *fuelgauge = dev_get_drvdata(dev);
+
+	fuelgauge->initial_update_of_soc = true;
+
+	return 0;
+}
+
+static void max77833_fuelgauge_shutdown(struct device *dev)
+{
+}
+
+static SIMPLE_DEV_PM_OPS(max77833_fuelgauge_pm_ops, max77833_fuelgauge_suspend,
+			 max77833_fuelgauge_resume);
+
+static struct platform_driver max77833_fuelgauge_driver = {
+	.driver = {
+		   .name = "max77833-fuelgauge",
+		   .owner = THIS_MODULE,
+#ifdef CONFIG_PM
+		   .pm = &max77833_fuelgauge_pm_ops,
+#endif
+		.shutdown = max77833_fuelgauge_shutdown,
+	},
+	.probe	= max77833_fuelgauge_probe,
+	.remove	= __devexit_p(max77833_fuelgauge_remove),
+};
+
+static int __init max77833_fuelgauge_init(void)
+{
+	pr_info("%s: \n", __func__);
+	return platform_driver_register(&max77833_fuelgauge_driver);
+}
+
+static void __exit max77833_fuelgauge_exit(void)
+{
+	platform_driver_unregister(&max77833_fuelgauge_driver);
+}
+module_init(max77833_fuelgauge_init);
+module_exit(max77833_fuelgauge_exit);
+
+MODULE_DESCRIPTION("Samsung MAX77833 Fuel Gauge Driver");
+MODULE_AUTHOR("Samsung Electronics");
+MODULE_LICENSE("GPL");
diff -Naur linux-3.18.14/drivers/battery/max77843_charger.c samsung/drivers/battery/max77843_charger.c
--- linux-3.18.14/drivers/battery/max77843_charger.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery/max77843_charger.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,1844 @@
+/*
+ *  max77843_charger.c
+ *  Samsung MAX77843 Charger Driver
+ *
+ *  Copyright (C) 2012 Samsung Electronics
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#define DEBUG
+
+#include <linux/mfd/max77843-private.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/power_supply.h>
+#include <linux/battery/sec_charger.h>
+#include <linux/mfd/max77843.h>
+#ifdef CONFIG_USB_HOST_NOTIFY
+#include <linux/usb_notify.h>
+#endif
+
+#define ENABLE 1
+#define DISABLE 0
+
+static enum power_supply_property max77843_charger_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_CHARGE_TYPE,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_CURRENT_MAX,
+	POWER_SUPPLY_PROP_CURRENT_AVG,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
+	POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL,
+	POWER_SUPPLY_PROP_USB_HC,
+#if defined(CONFIG_BATTERY_SWELLING)
+	POWER_SUPPLY_PROP_VOLTAGE_MAX,
+#endif
+#if defined(CONFIG_AFC_CHARGER_MODE)
+	POWER_SUPPLY_PROP_AFC_CHARGER_MODE,
+#endif
+};
+
+static struct device_attribute max77843_charger_attrs[] = {
+	SEC_CHARGER_ATTR(chip_id),
+};
+
+static void max77843_charger_initialize(struct max77843_charger_data *charger);
+static int max77843_get_vbus_state(struct max77843_charger_data *charger);
+static int max77843_get_charger_state(struct max77843_charger_data *charger);
+static void max77843_set_charger_state(struct max77843_charger_data *charger,
+				       int enable);
+static bool max77843_charger_unlock(struct max77843_charger_data *charger)
+{
+	u8 reg_data;
+	u8 chgprot;
+	int retry_cnt = 0;
+	bool need_init = false;
+
+	do {
+		max77843_read_reg(charger->i2c, MAX77843_CHG_REG_CNFG_06, &reg_data);
+		chgprot = ((reg_data & 0x0C) >> 2);
+		if (chgprot != 0x03) {
+			pr_err("%s: unlock err, chgprot(0x%x), retry(%d)\n",
+					__func__, chgprot, retry_cnt);
+			max77843_write_reg(charger->i2c, MAX77843_CHG_REG_CNFG_06,
+					   (0x03 << 2));
+			need_init = true;
+			msleep(20);
+		} else {
+			pr_debug("%s: unlock success, chgprot(0x%x)\n",
+				__func__, chgprot);
+			break;
+		}
+	} while ((chgprot != 0x03) && (++retry_cnt < 10));
+
+	return need_init;
+}
+
+static void check_charger_unlock_state(struct max77843_charger_data *charger)
+{
+	bool need_reg_init;
+	pr_debug("%s\n", __func__);
+
+	need_reg_init = max77843_charger_unlock(charger);
+	if (need_reg_init) {
+		pr_err("%s: charger locked state, reg init\n", __func__);
+		max77843_charger_initialize(charger);
+	}
+}
+
+static void max77843_test_read(struct max77843_charger_data *charger)
+{
+	u8 data = 0;
+	u32 addr = 0;
+	for (addr = 0xB0; addr <= 0xC3; addr++) {
+		max77843_read_reg(charger->i2c, addr, &data);
+		pr_debug("MAX77843 addr : 0x%02x data : 0x%02x\n", addr, data);
+	}
+}
+
+static int max77843_get_vbus_state(struct max77843_charger_data *charger)
+{
+	u8 reg_data;
+
+	max77843_read_reg(charger->i2c,
+			  MAX77843_CHG_REG_DETAILS_00, &reg_data);
+
+	if (charger->cable_type == POWER_SUPPLY_TYPE_WIRELESS)
+		reg_data = ((reg_data & MAX77843_WCIN_DTLS) >>
+			    MAX77843_WCIN_DTLS_SHIFT);
+	else
+		reg_data = ((reg_data & MAX77843_CHGIN_DTLS) >>
+			    MAX77843_CHGIN_DTLS_SHIFT);
+
+	switch (reg_data) {
+	case 0x00:
+		pr_info("%s: VBUS is invalid. CHGIN < CHGIN_UVLO\n",
+			__func__);
+		break;
+	case 0x01:
+		pr_info("%s: VBUS is invalid. CHGIN < MBAT+CHGIN2SYS" \
+			"and CHGIN > CHGIN_UVLO\n", __func__);
+		break;
+	case 0x02:
+		pr_info("%s: VBUS is invalid. CHGIN > CHGIN_OVLO",
+			__func__);
+		break;
+	case 0x03:
+		pr_info("%s: VBUS is valid. CHGIN < CHGIN_OVLO", __func__);
+		break;
+	default:
+		break;
+	}
+
+	return reg_data;
+}
+
+static int max77843_get_charger_state(struct max77843_charger_data *charger)
+{
+	int status = POWER_SUPPLY_STATUS_UNKNOWN;
+	u8 reg_data;
+
+	max77843_read_reg(charger->i2c,
+			  MAX77843_CHG_REG_DETAILS_01, &reg_data);
+
+	pr_info("%s : charger status (0x%02x)\n", __func__, reg_data);
+
+	reg_data &= 0x0f;
+
+	switch (reg_data)
+	{
+	case 0x00:
+	case 0x01:
+	case 0x02:
+		status = POWER_SUPPLY_STATUS_CHARGING;
+		break;
+	case 0x03:
+	case 0x04:
+		status = POWER_SUPPLY_STATUS_FULL;
+		break;
+	case 0x05:
+	case 0x06:
+	case 0x07:
+		status = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		break;
+	case 0x08:
+	case 0xA:
+	case 0xB:
+		status = POWER_SUPPLY_STATUS_DISCHARGING;
+		break;
+	default:
+		status = POWER_SUPPLY_STATUS_UNKNOWN;
+		break;
+	}
+
+	return (int)status;
+}
+
+static int max77843_get_charging_health(struct max77843_charger_data *charger)
+{
+	int state;
+	int vbus_state;
+	int retry_cnt;
+	u8 chg_dtls_00, chg_dtls, reg_data;
+	u8 chg_cnfg_00, chg_cnfg_01 ,chg_cnfg_02, chg_cnfg_04, chg_cnfg_09, chg_cnfg_12;
+
+	max77843_read_reg(charger->i2c,
+			  MAX77843_CHG_REG_DETAILS_01, &reg_data);
+	reg_data = ((reg_data & MAX77843_BAT_DTLS) >> MAX77843_BAT_DTLS_SHIFT);
+
+	pr_info("%s: reg_data(0x%x)\n", __func__, reg_data);
+	switch (reg_data) {
+	case 0x00:
+		pr_info("%s: No battery and the charger is suspended\n",
+			__func__);
+		state = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;
+		break;
+	case 0x01:
+		pr_info("%s: battery is okay "
+			"but its voltage is low(~VPQLB)\n", __func__);
+		state = POWER_SUPPLY_HEALTH_GOOD;
+		break;
+	case 0x02:
+		pr_info("%s: battery dead\n", __func__);
+		state = POWER_SUPPLY_HEALTH_DEAD;
+		break;
+	case 0x03:
+		state = POWER_SUPPLY_HEALTH_GOOD;
+		break;
+	case 0x04:
+		pr_info("%s: battery is okay" \
+			"but its voltage is low\n", __func__);
+		state = POWER_SUPPLY_HEALTH_GOOD;
+		break;
+	case 0x05:
+		pr_info("%s: battery ovp\n", __func__);
+		state = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+		break;
+	default:
+		pr_info("%s: battery unknown : 0x%d\n", __func__, reg_data);
+		state = POWER_SUPPLY_HEALTH_UNKNOWN;
+		break;
+	}
+
+	if (state == POWER_SUPPLY_HEALTH_GOOD) {
+		union power_supply_propval value;
+		psy_do_property("battery", get,
+				POWER_SUPPLY_PROP_HEALTH, value);
+		/* VBUS OVP state return battery OVP state */
+		vbus_state = max77843_get_vbus_state(charger);
+		/* read CHG_DTLS and detecting battery terminal error */
+		max77843_read_reg(charger->i2c,
+				  MAX77843_CHG_REG_DETAILS_01, &chg_dtls);
+		chg_dtls = ((chg_dtls & MAX77843_CHG_DTLS) >>
+			    MAX77843_CHG_DTLS_SHIFT);
+		max77843_read_reg(charger->i2c,
+				  MAX77843_CHG_REG_CNFG_00, &chg_cnfg_00);
+
+		/* print the log at the abnormal case */
+		if((charger->is_charging == 1) && (chg_dtls & 0x08)) {
+			max77843_read_reg(charger->i2c,
+				MAX77843_CHG_REG_DETAILS_00, &chg_dtls_00);
+			max77843_read_reg(charger->i2c,
+				MAX77843_CHG_REG_CNFG_01, &chg_cnfg_01);
+			max77843_read_reg(charger->i2c,
+				MAX77843_CHG_REG_CNFG_02, &chg_cnfg_02);
+			max77843_read_reg(charger->i2c,
+				MAX77843_CHG_REG_CNFG_04, &chg_cnfg_04);
+			max77843_read_reg(charger->i2c,
+					MAX77843_CHG_REG_CNFG_09, &chg_cnfg_09);
+			max77843_read_reg(charger->i2c,
+					MAX77843_CHG_REG_CNFG_12, &chg_cnfg_12);
+
+			pr_info("%s: CHG_DTLS_00(0x%x), CHG_DTLS_01(0x%x), CHG_CNFG_00(0x%x)\n",
+				__func__, chg_dtls_00, chg_dtls, chg_cnfg_00);
+			pr_info("%s:  CHG_CNFG_01(0x%x), CHG_CNFG_02(0x%x), CHG_CNFG_04(0x%x)\n",
+				__func__, chg_cnfg_01, chg_cnfg_02, chg_cnfg_04);
+			pr_info("%s:  CHG_CNFG_09(0x%x), CHG_CNFG_12(0x%x)\n",
+				__func__, chg_cnfg_09, chg_cnfg_12);
+			max77843_set_charger_state(charger, 0);
+			max77843_set_charger_state(charger, 1);
+		}
+
+		pr_info("%s: vbus_state : 0x%d, chg_dtls : 0x%d\n", __func__, vbus_state, chg_dtls);
+		/*  OVP is higher priority */
+		if (vbus_state == 0x02) { /*  CHGIN_OVLO */
+			pr_info("%s: vbus ovp\n", __func__);
+			state = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+			if (charger->cable_type == POWER_SUPPLY_TYPE_WIRELESS) {
+				retry_cnt = 0;
+				do {
+					msleep(50);
+					vbus_state = max77843_get_vbus_state(charger);
+				} while((retry_cnt++ < 2) && (vbus_state == 0x02));
+				if (vbus_state == 0x02) {
+					state = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+					pr_info("%s: wpc and over-voltage\n", __func__);
+				} else
+					state = POWER_SUPPLY_HEALTH_GOOD;
+			}
+		} else if (((vbus_state == 0x0) || (vbus_state == 0x01)) &&(chg_dtls & 0x08) && \
+				(chg_cnfg_00 & MAX77843_MODE_BUCK) && \
+				(chg_cnfg_00 & MAX77843_MODE_CHGR) && \
+				(charger->cable_type != POWER_SUPPLY_TYPE_WIRELESS)) {
+			pr_info("%s: vbus is under\n", __func__);
+			state = POWER_SUPPLY_HEALTH_UNDERVOLTAGE;
+		}
+	}
+
+	return (int)state;
+}
+
+static u8 max77843_get_float_voltage_data(int float_voltage)
+{
+	int voltage = 3650;
+	int i;
+
+	for (i = 0; voltage <= 4700; i++) {
+		if (float_voltage <= voltage)
+			break;
+		voltage += 25;
+	}
+
+	if (float_voltage <= 4340)
+		return i;
+	else
+		return (i+1);
+}
+
+static int max77843_get_input_current(struct max77843_charger_data *charger)
+{
+	u8 reg_data;
+	int get_current = 0;
+
+	if (charger->cable_type == POWER_SUPPLY_TYPE_WIRELESS) {
+		max77843_read_reg(charger->i2c,
+			MAX77843_CHG_REG_CNFG_10, &reg_data);
+		/* AND operation for removing the formal 2bit  */
+		reg_data = reg_data & 0x3F;
+
+		if (reg_data <= 0x3)
+			get_current = 60;
+		else
+			get_current = reg_data * 20;
+	} else {
+		max77843_read_reg(charger->i2c,
+			MAX77843_CHG_REG_CNFG_09, &reg_data);
+		/* AND operation for removing the formal 1bit  */
+		reg_data = reg_data & 0x7F;
+
+		if (reg_data <= 0x3) {
+			get_current = 100;
+		} else if (reg_data >= 0x78) {
+			get_current = 4000;
+		} else {
+			int quotient, remainder;
+			quotient = reg_data / 3;
+			remainder = reg_data % 3;
+			if (remainder == 0)
+				get_current = quotient * 100;
+			else if (remainder == 1)
+				get_current = quotient * 100 + 33;
+			else
+				get_current = quotient * 100 + 67;
+		}
+	}
+
+	return get_current;
+}
+
+static bool max77843_check_battery(struct max77843_charger_data *charger)
+{
+	u8 reg_data;
+	u8 reg_data2;
+
+	max77843_read_reg(charger->i2c,
+			  MAX77843_CHG_REG_INT_OK, &reg_data);
+
+	pr_info("%s : CHG_INT_OK(0x%x)\n", __func__, reg_data);
+
+	max77843_read_reg(charger->i2c,
+			  MAX77843_CHG_REG_DETAILS_00, &reg_data2);
+
+	pr_info("%s : CHG_DETAILS00(0x%x)\n", __func__, reg_data2);
+
+	if ((reg_data & MAX77843_BATP_OK) ||
+	    !(reg_data2 & MAX77843_BATP_DTLS))
+		return true;
+	else
+		return false;
+}
+
+static void max77843_set_buck(struct max77843_charger_data *charger,
+		int enable)
+{
+	u8 reg_data;
+
+	if (enable) {
+		max77843_update_reg(charger->i2c, MAX77843_CHG_REG_CNFG_00,
+				CHG_CNFG_00_BUCK_MASK,   CHG_CNFG_00_OTG_CTRL | CHG_CNFG_00_BUCK_MASK);
+	} else {
+		max77843_update_reg(charger->i2c, MAX77843_CHG_REG_CNFG_00,
+				0, CHG_CNFG_00_BUCK_MASK);
+	}
+	max77843_read_reg(charger->i2c, MAX77843_CHG_REG_CNFG_00, &reg_data);
+	pr_debug("%s : CHG_CNFG_00(0x%02x)\n", __func__, reg_data);
+
+}
+
+static void max77843_set_input_current(struct max77843_charger_data *charger,
+				       int input_current)
+{
+	int quotient, remainder;
+	u8 set_reg, reg_data;
+
+	if (charger->cable_type == POWER_SUPPLY_TYPE_WIRELESS) {
+		set_reg = MAX77843_CHG_REG_CNFG_10;
+		max77843_read_reg(charger->i2c,
+				  set_reg, &reg_data);
+		reg_data &= ~MAX77843_CHG_WCIN_LIM;
+	} else {
+		set_reg = MAX77843_CHG_REG_CNFG_09;
+		max77843_read_reg(charger->i2c,
+				  set_reg, &reg_data);
+		reg_data &= ~MAX77843_CHG_CHGIN_LIM;
+	}
+
+	if (input_current <= 0)
+		max77843_set_buck(charger, DISABLE);
+	else
+		max77843_set_buck(charger, ENABLE);
+
+	if (!input_current) {
+		max77843_write_reg(charger->i2c,
+				   set_reg, reg_data);
+	} else if(charger->cable_type == POWER_SUPPLY_TYPE_WIRELESS) {
+		quotient = input_current / 20;
+
+		reg_data |= quotient;
+
+		max77843_write_reg(charger->i2c,
+				   set_reg, reg_data);
+	} else {
+		quotient = input_current / 100;
+		remainder = input_current % 100;
+
+		if (remainder >= 67)
+			reg_data |= (quotient * 3) + 2;
+		else if (remainder >= 33)
+			reg_data |= (quotient * 3) + 1;
+		else if (remainder < 33)
+			reg_data |= quotient * 3;
+
+		max77843_write_reg(charger->i2c,
+				   set_reg, reg_data);
+	}
+
+	pr_info("[%s] REG(0x%02x) DATA(0x%02x)\n",
+		__func__, set_reg, reg_data);
+}
+
+static void afc_detect_work(struct work_struct *work)
+{
+	struct max77843_charger_data *charger = container_of(work,
+							     struct max77843_charger_data,
+							     afc_work.work);
+	int set_input_current;
+
+	pr_info("%s\n", __func__);
+
+	if (charger->cable_type == POWER_SUPPLY_TYPE_MAINS) {
+		charger->afc_detect = false;
+		if (charger->siop_level < 100)
+			set_input_current = SIOP_INPUT_LIMIT_CURRENT;
+		else
+			set_input_current = charger->charging_current_max;
+
+		max77843_set_input_current(charger, set_input_current);
+	}
+}
+
+static void max77843_set_charge_current(struct max77843_charger_data *charger,
+					int fast_charging_current)
+{
+	int curr_step = 50;
+	u8 reg_data;
+
+	max77843_read_reg(charger->i2c,
+			  MAX77843_CHG_REG_CNFG_02, &reg_data);
+	reg_data &= ~MAX77843_CHG_CC;
+
+	if (!fast_charging_current) {
+		max77843_write_reg(charger->i2c,
+				   MAX77843_CHG_REG_CNFG_02, reg_data);
+	} else {
+		reg_data |= (fast_charging_current / curr_step);
+
+		max77843_write_reg(charger->i2c,MAX77843_CHG_REG_CNFG_02, reg_data);
+	}
+
+	pr_info("[%s] REG(0x%02x) DATA(0x%02x), CURRENT(%d)\n",
+		__func__, MAX77843_CHG_REG_CNFG_02,
+		reg_data, fast_charging_current);
+}
+
+static void max77843_set_topoff_current(struct max77843_charger_data *charger,
+					int termination_current,
+					int termination_time)
+{
+	int curr_base, curr_step;
+	u8 reg_data;
+
+	if (charger->pmic_ver >= 0x2) {
+		curr_base = 125;
+		curr_step = 75;
+		if (termination_current < curr_base)
+			termination_current = curr_base;
+		else if (termination_current > 650)
+			termination_current = 650;
+	} else {
+		curr_base = 100;
+		curr_step = 50;
+		if (termination_current < curr_base)
+			termination_current = curr_base;
+		else if (termination_current > 450)
+			termination_current = 450;
+	}
+	reg_data = (termination_current - curr_base) / curr_step;
+	max77843_update_reg(charger->i2c, MAX77843_CHG_REG_CNFG_03,
+		reg_data, 0x7);
+
+	pr_info("%s: reg_data(0x%02x), topoff(%d)\n",
+		__func__, reg_data, termination_current);
+}
+
+static void max77843_set_charger_state(struct max77843_charger_data *charger,
+	int enable)
+{
+	u8 reg_data;
+
+	max77843_read_reg(charger->i2c, MAX77843_CHG_REG_CNFG_00, &reg_data);
+
+	if (enable) {
+		max77843_update_reg(charger->i2c, MAX77843_CHG_REG_CNFG_00,
+				CHG_CNFG_00_CHG_MASK, CHG_CNFG_00_OTG_CTRL | CHG_CNFG_00_CHG_MASK);
+	} else {
+		max77843_update_reg(charger->i2c, MAX77843_CHG_REG_CNFG_00,
+				0, CHG_CNFG_00_CHG_MASK);
+	}
+	max77843_read_reg(charger->i2c, MAX77843_CHG_REG_CNFG_00, &reg_data);
+	pr_debug("%s : CHG_CNFG_00(0x%02x)\n", __func__, reg_data);
+}
+
+
+
+static void max77843_charger_function_control(
+				struct max77843_charger_data *charger)
+{
+	const int usb_charging_current = charger->pdata->charging_current[
+		POWER_SUPPLY_TYPE_USB].fast_charging_current;
+	int set_charging_current, set_charging_current_max;
+	u8 chg_cnfg_00 = 0, chg_cnfg_01 = 0;
+	union power_supply_propval value;
+	union power_supply_propval chg_mode;
+
+	psy_do_property("battery", get, POWER_SUPPLY_PROP_HEALTH, value);
+
+	if (charger->cable_type == POWER_SUPPLY_TYPE_BATTERY ||
+	    charger->cable_type == POWER_SUPPLY_TYPE_OTG) {
+		charger->is_charging = false;
+		charger->afc_detect = false;
+		charger->aicl_on = false;
+		charger->is_mdock = false;
+		set_charging_current = 0;
+		set_charging_current_max =
+			charger->pdata->charging_current[
+				POWER_SUPPLY_TYPE_USB].input_current_limit;
+
+		if (charger->cable_type == POWER_SUPPLY_TYPE_OTG) {
+			chg_cnfg_00 |= (CHG_CNFG_00_OTG_MASK
+					| CHG_CNFG_00_BOOST_MASK);
+
+			chg_cnfg_00 &= ~(CHG_CNFG_00_BUCK_MASK);
+
+			max77843_update_reg(charger->i2c,
+					    MAX77843_CHG_REG_CNFG_00,
+					    chg_cnfg_00,
+					    (CHG_CNFG_00_OTG_MASK |
+					     CHG_CNFG_00_BOOST_MASK |
+					     CHG_CNFG_00_BUCK_MASK));
+		} else {
+			chg_cnfg_00 &= ~(CHG_CNFG_00_CHG_MASK
+					 | CHG_CNFG_00_OTG_MASK
+					 | CHG_CNFG_00_BOOST_MASK);
+
+			max77843_update_reg(charger->i2c,
+					    MAX77843_CHG_REG_CNFG_00,
+					    chg_cnfg_00,
+					    (CHG_CNFG_00_CHG_MASK |
+					     CHG_CNFG_00_OTG_MASK |
+					     CHG_CNFG_00_BOOST_MASK));
+
+			set_charging_current_max =
+				charger->pdata->charging_current[
+					POWER_SUPPLY_TYPE_USB].input_current_limit;
+		}
+	} else {
+		charger->is_charging = true;
+		charger->afc_detect = false;
+		charger->charging_current_max =
+			charger->pdata->charging_current
+			[charger->cable_type].input_current_limit;
+		charger->charging_current =
+			charger->pdata->charging_current
+			[charger->cable_type].fast_charging_current;
+		if (charger->is_mdock) { /* if mdock was alread inserted, then check OTG, or NOTG state */
+			if (charger->cable_type == POWER_SUPPLY_TYPE_SMART_NOTG) {
+				charger->charging_current =
+					charger->pdata->charging_current
+					[POWER_SUPPLY_TYPE_MDOCK_TA].fast_charging_current;
+				charger->charging_current_max =
+					charger->pdata->charging_current
+					[POWER_SUPPLY_TYPE_MDOCK_TA].input_current_limit;
+			} else if (charger->cable_type == POWER_SUPPLY_TYPE_SMART_OTG) {
+				charger->charging_current =
+					charger->pdata->charging_current
+					[POWER_SUPPLY_TYPE_MDOCK_TA].fast_charging_current - 500;
+				charger->charging_current_max =
+					charger->pdata->charging_current
+					[POWER_SUPPLY_TYPE_MDOCK_TA].input_current_limit - 500;
+			}
+		} else { /*if mdock wasn't inserted, then check mdock state*/
+			if (charger->cable_type == POWER_SUPPLY_TYPE_MDOCK_TA)
+				charger->is_mdock = true;
+		}
+
+		/* decrease the charging current according to siop level */
+		set_charging_current =
+			charger->charging_current * charger->siop_level / 100;
+		if (set_charging_current > 0 &&
+		    set_charging_current < usb_charging_current)
+			set_charging_current = usb_charging_current;
+
+		set_charging_current_max =
+			charger->charging_current_max;
+
+		if (charger->siop_level < 100) {
+			if (charger->cable_type == POWER_SUPPLY_TYPE_WIRELESS) {
+				if (set_charging_current_max > SIOP_WIRELESS_INPUT_LIMIT_CURRENT) {
+					set_charging_current_max = SIOP_WIRELESS_INPUT_LIMIT_CURRENT;
+					if (set_charging_current > SIOP_WIRELESS_CHARGING_LIMIT_CURRENT)
+						set_charging_current = SIOP_WIRELESS_CHARGING_LIMIT_CURRENT;
+				}
+			} else {
+				if (set_charging_current_max > SIOP_INPUT_LIMIT_CURRENT) {
+					set_charging_current_max = SIOP_INPUT_LIMIT_CURRENT;
+					if (set_charging_current > SIOP_CHARGING_LIMIT_CURRENT)
+						set_charging_current = SIOP_CHARGING_LIMIT_CURRENT;
+				}
+			}
+		}
+	}
+
+	if (charger->pdata->full_check_type_2nd == SEC_BATTERY_FULLCHARGED_CHGPSY) {
+		psy_do_property("battery", get,
+				POWER_SUPPLY_PROP_CHARGE_NOW,
+				chg_mode);
+
+		if (chg_mode.intval == SEC_BATTERY_CHARGING_2ND) {
+			max77843_set_charger_state(charger, 0);
+			max77843_set_topoff_current(charger,
+						    charger->pdata->charging_current[
+							    charger->cable_type].full_check_current_2nd,
+						    (70 * 60));
+		} else {
+			max77843_set_topoff_current(charger,
+						    charger->pdata->charging_current[
+							    charger->cable_type].full_check_current_1st,
+						    (70 * 60));
+		}
+	} else {
+		max77843_set_topoff_current(charger,
+					    charger->pdata->charging_current[
+						    charger->cable_type].full_check_current_1st,
+					    charger->pdata->charging_current[
+						    charger->cable_type].full_check_current_2nd);
+	}
+
+	max77843_set_charger_state(charger, charger->is_charging);
+
+	/* if battery full, only disable charging  */
+	if ((charger->status == POWER_SUPPLY_STATUS_CHARGING) ||
+	    (charger->status == POWER_SUPPLY_STATUS_DISCHARGING) ||
+	    (value.intval == POWER_SUPPLY_HEALTH_UNSPEC_FAILURE) ||
+	    (value.intval == POWER_SUPPLY_HEALTH_OVERHEATLIMIT)) {
+		/* current setting */
+		max77843_set_charge_current(charger,
+					    set_charging_current);
+		/* if battery is removed, disable input current and reenable input current
+		 *  to enable buck always */
+		if ((value.intval == POWER_SUPPLY_HEALTH_UNSPEC_FAILURE) ||
+		    (value.intval == POWER_SUPPLY_HEALTH_OVERHEATLIMIT)) {
+			max77843_set_input_current(charger, 0);
+		} else if (charger->cable_type == POWER_SUPPLY_TYPE_MAINS) {
+			pr_info("TA!!!\n");
+			charger->afc_detect = true;
+			max77843_set_input_current(charger, 1000);
+			queue_delayed_work(charger->wqueue, &charger->afc_work,
+					   msecs_to_jiffies(2000));
+		} else {
+			max77843_set_input_current(charger,
+						   set_charging_current_max);
+		}
+	}
+
+	max77843_read_reg(charger->i2c, MAX77843_CHG_REG_CNFG_01, &chg_cnfg_01);
+
+	if (((charger->cable_type == POWER_SUPPLY_TYPE_HV_MAINS) ||
+	     (charger->cable_type == POWER_SUPPLY_TYPE_HV_ERR)) &&
+	    !(chg_cnfg_01 & 0x08)) {
+		chg_cnfg_01 |= MAX77843_CHG_FQ_2MHz;
+		max77843_write_reg(charger->i2c, MAX77843_CHG_REG_CNFG_01,
+				   chg_cnfg_01);
+	} else if (((charger->cable_type != POWER_SUPPLY_TYPE_HV_MAINS) &&
+		    (charger->cable_type != POWER_SUPPLY_TYPE_HV_ERR)) &&
+		   (chg_cnfg_01 & 0x08)) {
+		chg_cnfg_01 &= ~(MAX77843_CHG_FQ_2MHz);
+		max77843_write_reg(charger->i2c, MAX77843_CHG_REG_CNFG_01,
+				   chg_cnfg_01);
+	}
+
+	pr_info("%s : CNFG01(0x%02x)\n", __func__, chg_cnfg_01);
+	pr_info("charging = %d, fc = %d, il = %d, t1 = %d, t2 = %d, cable = %d\n",
+		charger->is_charging,
+		charger->charging_current,
+		charger->charging_current_max,
+		charger->pdata->charging_current[charger->cable_type].full_check_current_1st,
+		charger->pdata->charging_current[charger->cable_type].full_check_current_2nd,
+		charger->cable_type);
+
+	max77843_test_read(charger);
+
+}
+
+static void max77843_charger_initialize(struct max77843_charger_data *charger)
+{
+	u8 reg_data;
+	pr_info("%s\n", __func__);
+
+	/* unmasked: CHGIN_I, WCIN_I, BATP_I, BYP_I	*/
+	/*max77843_write_reg(charger->i2c, MAX77843_CHG_REG_INT_MASK, 0x9a);*/
+
+	/* unlock charger setting protect */
+	reg_data = (0x03 << 2);
+	max77843_write_reg(charger->i2c, MAX77843_CHG_REG_CNFG_06, reg_data);
+
+	/*
+	 * fast charge timer disable
+	 * restart threshold disable
+	 * pre-qual charge enable(default)
+	 */
+	reg_data = (0x03 << 4);
+	max77843_write_reg(charger->i2c, MAX77843_CHG_REG_CNFG_01, reg_data);
+
+	/*
+	 * charge current 466mA(default)
+	 * otg current limit 1200mA
+	 */
+	max77843_read_reg(charger->i2c, MAX77843_CHG_REG_CNFG_02, &reg_data);
+	reg_data |= (1 << 7);
+	max77843_write_reg(charger->i2c, MAX77843_CHG_REG_CNFG_02, reg_data);
+
+	/*
+	 * top off current 100mA
+	 * top off timer 70min
+	 */
+	reg_data = 0x38;
+	max77843_write_reg(charger->i2c, MAX77843_CHG_REG_CNFG_03, reg_data);
+
+	/*
+	 * cv voltage 4.2V or 4.35V
+	 * MINVSYS 3.6V(default)
+	 */
+	reg_data = max77843_get_float_voltage_data(charger->pdata->chg_float_voltage);
+	max77843_update_reg(charger->i2c, MAX77843_CHG_REG_CNFG_04,
+			(reg_data << CHG_CNFG_04_CHG_CV_PRM_SHIFT),
+			CHG_CNFG_04_CHG_CV_PRM_MASK);
+	max77843_read_reg(charger->i2c, MAX77843_CHG_REG_CNFG_04, &reg_data);
+	pr_info("%s: battery cv voltage 0x%x\n", __func__, reg_data);
+
+	max77843_test_read(charger);
+}
+
+#if defined(CONFIG_BATTERY_SWELLING)
+static void max77843_set_float_voltage(struct max77843_charger_data *charger, int float_voltage)
+{
+	u8 reg_data = 0;
+
+	reg_data = max77843_get_float_voltage_data(float_voltage);
+	max77843_update_reg(charger->i2c, MAX77843_CHG_REG_CNFG_04,
+			(reg_data << CHG_CNFG_04_CHG_CV_PRM_SHIFT),
+			CHG_CNFG_04_CHG_CV_PRM_MASK);
+	max77843_read_reg(charger->i2c, MAX77843_CHG_REG_CNFG_04, &reg_data);
+	pr_info("%s: battery cv voltage 0x%x\n", __func__, reg_data);
+}
+
+static u8 max77843_get_float_voltage(struct max77843_charger_data *charger)
+{
+	u8 reg_data = 0;
+
+	max77843_read_reg(charger->i2c, MAX77843_CHG_REG_CNFG_04, &reg_data);
+	reg_data &= 0x3F;
+	pr_info("%s: battery cv voltage 0x%x\n", __func__, reg_data);
+	return reg_data;
+}
+
+#endif
+
+static int max77843_chg_create_attrs(struct device *dev)
+{
+	int i, rc;
+
+	for (i = 0; i < ARRAY_SIZE(max77843_charger_attrs); i++) {
+		rc = device_create_file(dev, &max77843_charger_attrs[i]);
+		if (rc)
+			goto create_attrs_failed;
+	}
+	return rc;
+
+create_attrs_failed:
+	dev_err(dev, "%s: failed (%d)\n", __func__, rc);
+	while (i--)
+		device_remove_file(dev, &max77843_charger_attrs[i]);
+	return rc;
+}
+
+ssize_t sec_chg_show_attrs(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct max77843_charger_data *charger =
+		container_of(psy, struct max77843_charger_data, psy_chg);
+	const ptrdiff_t offset = attr - max77843_charger_attrs;
+	int i = 0;
+
+	switch(offset) {
+	case CHIP_ID:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%s\n",
+			       (charger->pmic_ver >= 0x1 && charger->pmic_ver <= 0x03) ?
+			       "MAX77843" : "Unknown");
+		break;
+	default:
+		return -EINVAL;
+	}
+	return i;
+}
+
+ssize_t sec_chg_store_attrs(struct device *dev,
+			    struct device_attribute *attr,
+			    const char *buf, size_t count)
+{
+	const ptrdiff_t offset = attr - max77843_charger_attrs;
+	int ret = 0;
+
+	switch(offset) {
+	case CHIP_ID:
+		ret = count;
+		break;
+	default:
+		ret = -EINVAL;
+	}
+	return ret;
+}
+
+static int max77843_chg_get_property(struct power_supply *psy,
+			      enum power_supply_property psp,
+			      union power_supply_propval *val)
+{
+	struct max77843_charger_data *charger =
+		container_of(psy, struct max77843_charger_data, psy_chg);
+	u8 reg_data;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = POWER_SUPPLY_TYPE_BATTERY;
+		if (max77843_read_reg(charger->i2c,
+			MAX77843_CHG_REG_INT_OK, &reg_data) == 0) {
+			if (reg_data & MAX77843_WCIN_OK) {
+				val->intval = POWER_SUPPLY_TYPE_WIRELESS;
+				charger->wc_w_state = 1;
+			} else if (reg_data & MAX77843_CHGIN_OK) {
+				val->intval = POWER_SUPPLY_TYPE_MAINS;
+			}
+		}
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = max77843_check_battery(charger);
+		break;
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = max77843_get_charger_state(charger);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+		if (!charger->is_charging)
+			val->intval = POWER_SUPPLY_CHARGE_TYPE_NONE;
+		else if (charger->aicl_on)
+		{
+			val->intval = POWER_SUPPLY_CHARGE_TYPE_SLOW;
+			pr_info("%s: slow-charging mode\n", __func__);
+		}
+		else
+			val->intval = POWER_SUPPLY_CHARGE_TYPE_FAST;
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = max77843_get_charging_health(charger);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		val->intval = charger->charging_current_max;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+		val->intval = max77843_get_input_current(charger);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = max77843_get_input_current(charger);
+		pr_debug("%s : set-current(%dmA), current now(%dmA)\n",
+			__func__, charger->charging_current, val->intval);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+		break;
+#if defined(CONFIG_BATTERY_SWELLING)
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+		val->intval = max77843_get_float_voltage(charger);
+		break;
+#endif
+#if defined(CONFIG_AFC_CHARGER_MODE)
+	case POWER_SUPPLY_PROP_AFC_CHARGER_MODE:
+		return -ENODATA;
+#endif
+	case POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL:
+		return -ENODATA;
+	case POWER_SUPPLY_PROP_USB_HC:
+		return -ENODATA;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int max77843_chg_set_property(struct power_supply *psy,
+			  enum power_supply_property psp,
+			  const union power_supply_propval *val)
+{
+	struct max77843_charger_data *charger =
+		container_of(psy, struct max77843_charger_data, psy_chg);
+	union power_supply_propval value;
+	int set_charging_current_max;
+	const int usb_charging_current = charger->pdata->charging_current[
+		POWER_SUPPLY_TYPE_USB].fast_charging_current;
+	u8 chg_cnfg_00 = 0;
+
+	switch (psp) {
+	/* val->intval : type */
+	case POWER_SUPPLY_PROP_STATUS:
+		charger->status = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		/* check and unlock */
+		check_charger_unlock_state(charger);
+		if (val->intval == POWER_SUPPLY_TYPE_POWER_SHARING) {
+			psy_do_property("ps", get,
+				POWER_SUPPLY_PROP_STATUS, value);
+			if (value.intval) {
+				max77843_update_reg(charger->i2c, MAX77843_CHG_REG_CNFG_00,
+					CHG_CNFG_00_OTG_CTRL, CHG_CNFG_00_OTG_CTRL);
+			} else {
+				max77843_update_reg(charger->i2c, MAX77843_CHG_REG_CNFG_00,
+					0, CHG_CNFG_00_OTG_CTRL);
+			}
+			break;
+		}
+
+		charger->cable_type = val->intval;
+		max77843_charger_function_control(charger);
+		break;
+	/* val->intval : input charging current */
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		charger->charging_current_max = val->intval;
+		max77843_set_input_current(charger, val->intval);
+		break;
+	/*  val->intval : charging current */
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+		charger->charging_current = val->intval;
+		max77843_set_charge_current(charger,
+			val->intval);
+		break;
+	/* val->intval : charging current */
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		max77843_set_charge_current(charger,
+			val->intval);
+		max77843_set_input_current(charger,
+			val->intval);
+		break;
+#if defined(CONFIG_AFC_CHARGER_MODE)
+	case POWER_SUPPLY_PROP_AFC_CHARGER_MODE:
+//		max77843_hv_muic_charger_init();
+		break;
+#endif
+#if defined(CONFIG_BATTERY_SWELLING)
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+		pr_info("%s: float voltage(%d)\n", __func__, val->intval);
+		max77843_set_float_voltage(charger, val->intval);
+		break;
+#endif
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+		charger->siop_level = val->intval;
+		if (charger->is_charging) {
+			/* decrease the charging current according to siop level */
+			int current_now =
+				charger->charging_current * val->intval / 100;
+
+			/* do forced set charging current */
+			if (current_now > 0 &&
+					current_now < usb_charging_current)
+				current_now = usb_charging_current;
+
+			if ((charger->cable_type == POWER_SUPPLY_TYPE_MAINS) ||
+			    (charger->cable_type == POWER_SUPPLY_TYPE_HV_MAINS) ||
+			    (charger->cable_type == POWER_SUPPLY_TYPE_HV_ERR)) {
+				if (charger->afc_detect)
+					set_charging_current_max = 1000;
+				else if (charger->siop_level < 100 )
+					set_charging_current_max = SIOP_INPUT_LIMIT_CURRENT;
+				else
+					set_charging_current_max =
+						charger->charging_current_max;
+
+				pr_info("%s: siop_level=%d, afc_detec=%d, current_max=%d, current_now=%d\n",
+					__func__,
+					charger->siop_level, charger->afc_detect,
+					set_charging_current_max, current_now);
+				if (charger->siop_level < 100 &&
+				    current_now > SIOP_CHARGING_LIMIT_CURRENT)
+					current_now = SIOP_CHARGING_LIMIT_CURRENT;
+				max77843_set_input_current(charger,
+						   set_charging_current_max);
+			} else if (charger->cable_type == POWER_SUPPLY_TYPE_WIRELESS) {
+				if (charger->siop_level < 100)
+					set_charging_current_max = SIOP_WIRELESS_INPUT_LIMIT_CURRENT;
+				else
+					set_charging_current_max = charger->charging_current_max;
+
+				if (charger->siop_level < 100 &&
+				    current_now > SIOP_WIRELESS_CHARGING_LIMIT_CURRENT)
+					current_now = SIOP_WIRELESS_CHARGING_LIMIT_CURRENT;
+
+				max77843_set_input_current(charger,
+						   set_charging_current_max);
+			} else {
+				if (charger->siop_level < 100) {
+					set_charging_current_max =
+						charger->charging_current_max * val->intval / 100;
+					if (set_charging_current_max > SIOP_INPUT_LIMIT_CURRENT) {
+						set_charging_current_max = SIOP_INPUT_LIMIT_CURRENT;
+						if (current_now > SIOP_CHARGING_LIMIT_CURRENT)
+							current_now = SIOP_CHARGING_LIMIT_CURRENT;
+					}
+				} else {
+					set_charging_current_max =
+						charger->charging_current_max;
+				}
+				max77843_set_input_current(charger,
+						set_charging_current_max);
+			}
+
+			max77843_set_charge_current(charger, current_now);
+
+		}
+		break;
+	case POWER_SUPPLY_PROP_USB_HC:
+		/* set input/charging current for usb up to TA's current */
+		if (val->intval) {
+			charger->pdata->charging_current[
+				POWER_SUPPLY_TYPE_USB].fast_charging_current =
+			charger->pdata->charging_current[
+				POWER_SUPPLY_TYPE_MAINS].fast_charging_current;
+			charger->pdata->charging_current[
+				POWER_SUPPLY_TYPE_USB].input_current_limit =
+			charger->pdata->charging_current[
+				POWER_SUPPLY_TYPE_MAINS].input_current_limit;
+		/* restore input/charging current for usb */
+		} else {
+			charger->pdata->charging_current[
+				POWER_SUPPLY_TYPE_USB].fast_charging_current =
+			charger->pdata->charging_current[
+				POWER_SUPPLY_TYPE_BATTERY].input_current_limit;
+			charger->pdata->charging_current[
+				POWER_SUPPLY_TYPE_USB].input_current_limit =
+			charger->pdata->charging_current[
+				POWER_SUPPLY_TYPE_BATTERY].input_current_limit;
+		}
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL:
+		if (val->intval) {
+			chg_cnfg_00 &= ~(CHG_CNFG_00_CHG_MASK
+					 | CHG_CNFG_00_BUCK_MASK);
+			chg_cnfg_00 |= (CHG_CNFG_00_OTG_MASK
+					| CHG_CNFG_00_BOOST_MASK);
+			max77843_update_reg(charger->i2c,
+					    MAX77843_CHG_REG_CNFG_00,
+					    chg_cnfg_00,
+					    (CHG_CNFG_00_CHG_MASK
+					     | CHG_CNFG_00_OTG_MASK
+					     | CHG_CNFG_00_BUCK_MASK
+					     | CHG_CNFG_00_BOOST_MASK));
+		} else {
+			chg_cnfg_00 = ~(CHG_CNFG_00_OTG_MASK
+					| CHG_CNFG_00_BOOST_MASK);
+			chg_cnfg_00 |= CHG_CNFG_00_BUCK_MASK;
+			max77843_update_reg(charger->i2c,
+					    MAX77843_CHG_REG_CNFG_00,
+					    chg_cnfg_00,
+					    (CHG_CNFG_00_OTG_MASK
+					     | CHG_CNFG_00_BUCK_MASK
+					     | CHG_CNFG_00_BOOST_MASK));
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int max77843_debugfs_show(struct seq_file *s, void *data)
+{
+	struct max77843_charger_data *charger = s->private;
+	u8 reg;
+	u8 reg_data;
+
+	seq_printf(s, "MAX77843 CHARGER IC :\n");
+	seq_printf(s, "===================\n");
+	for (reg = 0xB0; reg <= 0xC3; reg++) {
+		max77843_read_reg(charger->i2c, reg, &reg_data);
+		seq_printf(s, "0x%02x:\t0x%02x\n", reg, reg_data);
+	}
+
+	seq_printf(s, "\n");
+	return 0;
+}
+
+static int max77843_debugfs_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, max77843_debugfs_show, inode->i_private);
+}
+
+static const struct file_operations max77843_debugfs_fops = {
+	.open           = max77843_debugfs_open,
+	.read           = seq_read,
+	.llseek         = seq_lseek,
+	.release        = single_release,
+};
+
+static void max77843_chg_isr_work(struct work_struct *work)
+{
+	struct max77843_charger_data *charger =
+		container_of(work, struct max77843_charger_data, isr_work.work);
+
+	union power_supply_propval val;
+
+	if (charger->pdata->full_check_type ==
+	    SEC_BATTERY_FULLCHARGED_CHGINT) {
+
+		val.intval = max77843_get_charger_state(charger);
+
+		switch (val.intval) {
+		case POWER_SUPPLY_STATUS_DISCHARGING:
+			pr_err("%s: Interrupted but Discharging\n", __func__);
+			break;
+
+		case POWER_SUPPLY_STATUS_NOT_CHARGING:
+			pr_err("%s: Interrupted but NOT Charging\n", __func__);
+			break;
+
+		case POWER_SUPPLY_STATUS_FULL:
+			pr_info("%s: Interrupted by Full\n", __func__);
+			psy_do_property("battery", set,
+				POWER_SUPPLY_PROP_STATUS, val);
+			break;
+
+		case POWER_SUPPLY_STATUS_CHARGING:
+			pr_err("%s: Interrupted but Charging\n", __func__);
+			break;
+
+		case POWER_SUPPLY_STATUS_UNKNOWN:
+		default:
+			pr_err("%s: Invalid Charger Status\n", __func__);
+			break;
+		}
+	}
+
+	if (charger->pdata->ovp_uvlo_check_type ==
+		SEC_BATTERY_OVP_UVLO_CHGINT) {
+		val.intval = max77843_get_charging_health(charger);
+		switch (val.intval) {
+		case POWER_SUPPLY_HEALTH_OVERHEAT:
+		case POWER_SUPPLY_HEALTH_COLD:
+			pr_err("%s: Interrupted but Hot/Cold\n", __func__);
+			break;
+
+		case POWER_SUPPLY_HEALTH_DEAD:
+			pr_err("%s: Interrupted but Dead\n", __func__);
+			break;
+
+		case POWER_SUPPLY_HEALTH_OVERVOLTAGE:
+		case POWER_SUPPLY_HEALTH_UNDERVOLTAGE:
+			pr_info("%s: Interrupted by OVP/UVLO\n", __func__);
+			psy_do_property("battery", set,
+				POWER_SUPPLY_PROP_HEALTH, val);
+			break;
+
+		case POWER_SUPPLY_HEALTH_UNSPEC_FAILURE:
+			pr_err("%s: Interrupted but Unspec\n", __func__);
+			break;
+
+		case POWER_SUPPLY_HEALTH_GOOD:
+			pr_err("%s: Interrupted but Good\n", __func__);
+			break;
+
+		case POWER_SUPPLY_HEALTH_UNKNOWN:
+		default:
+			pr_err("%s: Invalid Charger Health\n", __func__);
+			break;
+		}
+	}
+}
+
+static irqreturn_t max77843_chg_irq_thread(int irq, void *irq_data)
+{
+	struct max77843_charger_data *charger = irq_data;
+
+	pr_info("%s: Charger interrupt occured\n", __func__);
+
+	if ((charger->pdata->full_check_type ==
+	     SEC_BATTERY_FULLCHARGED_CHGINT) ||
+	    (charger->pdata->ovp_uvlo_check_type ==
+	     SEC_BATTERY_OVP_UVLO_CHGINT))
+		schedule_delayed_work(&charger->isr_work, 0);
+
+	return IRQ_HANDLED;
+}
+
+static void wpc_detect_work(struct work_struct *work)
+{
+	struct max77843_charger_data *charger = container_of(work,
+						struct max77843_charger_data,
+						wpc_work.work);
+	int wc_w_state;
+	int retry_cnt;
+	union power_supply_propval value;
+	u8 reg_data;
+
+	pr_info("%s\n", __func__);
+
+	max77843_update_reg(charger->i2c,
+		MAX77843_CHG_REG_INT_MASK, 0, MAX77843_WCIN_IM);
+
+	/* check and unlock */
+	check_charger_unlock_state(charger);
+
+	retry_cnt = 0;
+	do {
+		max77843_read_reg(charger->i2c,
+				  MAX77843_CHG_REG_INT_OK, &reg_data);
+		wc_w_state = (reg_data & MAX77843_WCIN_OK)
+			>> MAX77843_WCIN_OK_SHIFT;
+		msleep(50);
+	} while((retry_cnt++ < 2) && (wc_w_state == 0));
+
+	if ((charger->wc_w_state == 0) && (wc_w_state == 1)) {
+		value.intval = 1;
+		psy_do_property("wireless", set,
+				POWER_SUPPLY_PROP_ONLINE, value);
+		value.intval = POWER_SUPPLY_TYPE_WIRELESS;
+		pr_info("%s: wpc activated, set V_INT as PN\n",
+				__func__);
+	} else if ((charger->wc_w_state == 1) && (wc_w_state == 0)) {
+		if (!charger->is_charging)
+			max77843_set_charger_state(charger, true);
+
+		retry_cnt = 0;
+		do {
+			max77843_read_reg(charger->i2c,
+					  MAX77843_CHG_REG_DETAILS_01, &reg_data);
+			reg_data = ((reg_data & MAX77843_CHG_DTLS)
+				    >> MAX77843_CHG_DTLS_SHIFT);
+			msleep(50);
+		} while((retry_cnt++ < 2) && (reg_data == 0x8));
+		pr_info("%s: reg_data: 0x%x, charging: %d\n", __func__,
+			reg_data, charger->is_charging);
+		if (!charger->is_charging)
+			max77843_set_charger_state(charger, false);
+		if ((reg_data != 0x08)
+		    && (charger->cable_type == POWER_SUPPLY_TYPE_WIRELESS)) {
+			pr_info("%s: wpc uvlo, but charging\n", __func__);
+			queue_delayed_work(charger->wqueue, &charger->wpc_work,
+					   msecs_to_jiffies(500));
+			return;
+		} else {
+			value.intval = 0;
+			psy_do_property("wireless", set,
+					POWER_SUPPLY_PROP_ONLINE, value);
+			pr_info("%s: wpc deactivated, set V_INT as PD\n",
+					__func__);
+		}
+	}
+	pr_info("%s: w(%d to %d)\n", __func__,
+		charger->wc_w_state, wc_w_state);
+
+	charger->wc_w_state = wc_w_state;
+
+	/* Do unmask again. (for frequent wcin irq problem) */
+	max77843_update_reg(charger->i2c,
+		MAX77843_CHG_REG_INT_MASK, 0, MAX77843_WCIN_IM);
+
+	wake_unlock(&charger->wpc_wake_lock);
+}
+
+static irqreturn_t wpc_charger_irq(int irq, void *data)
+{
+	struct max77843_charger_data *charger = data;
+	unsigned long delay;
+	u8 reg_data;
+
+	max77843_read_reg(charger->i2c,
+		MAX77843_CHG_REG_INT_MASK, &reg_data);
+	reg_data |= (1 << 5);
+	max77843_write_reg(charger->i2c,
+		MAX77843_CHG_REG_INT_MASK, reg_data);
+
+	wake_lock(&charger->wpc_wake_lock);
+#ifdef CONFIG_SAMSUNG_BATTERY_FACTORY
+	delay = msecs_to_jiffies(0);
+#else
+	if (charger->wc_w_state)
+		delay = msecs_to_jiffies(500);
+	else
+		delay = msecs_to_jiffies(0);
+#endif
+	queue_delayed_work(charger->wqueue, &charger->wpc_work,
+			delay);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t max77843_batp_irq(int irq, void *data)
+{
+	struct max77843_charger_data *charger = data;
+	union power_supply_propval value;
+	u8 reg_data;
+
+	pr_info("%s : irq(%d)\n", __func__, irq);
+
+	max77843_read_reg(charger->i2c,
+			  MAX77843_CHG_REG_INT_MASK, &reg_data);
+	reg_data |= (1 << 2);
+	max77843_write_reg(charger->i2c,
+		MAX77843_CHG_REG_INT_MASK, reg_data);
+
+	check_charger_unlock_state(charger);
+
+	max77843_read_reg(charger->i2c,
+			  MAX77843_CHG_REG_INT_OK,
+			  &reg_data);
+
+	if (!(reg_data & MAX77843_BATP_OK))
+		psy_do_property("battery", set, POWER_SUPPLY_PROP_PRESENT, value);
+
+	max77843_read_reg(charger->i2c,
+			  MAX77843_CHG_REG_INT_MASK, &reg_data);
+	reg_data &= ~(1 << 2);
+	max77843_write_reg(charger->i2c,
+			   MAX77843_CHG_REG_INT_MASK, reg_data);
+
+	return IRQ_HANDLED;
+}
+
+
+static irqreturn_t max77843_bypass_irq(int irq, void *data)
+{
+	struct max77843_charger_data *charger = data;
+	u8 dtls_02;
+	u8 byp_dtls;
+	u8 chg_cnfg_00;
+	u8 vbus_state;
+#ifdef CONFIG_USB_HOST_NOTIFY
+	struct otg_notify *o_notify;
+
+	o_notify = get_otg_notify();
+#endif
+
+	pr_info("%s: irq(%d)\n", __func__, irq);
+
+	/* check and unlock */
+	check_charger_unlock_state(charger);
+
+	max77843_read_reg(charger->i2c,
+			  MAX77843_CHG_REG_DETAILS_02,
+			  &dtls_02);
+
+	byp_dtls = ((dtls_02 & MAX77843_BYP_DTLS) >>
+				MAX77843_BYP_DTLS_SHIFT);
+	pr_info("%s: BYP_DTLS(0x%02x)\n", __func__, byp_dtls);
+	vbus_state = max77843_get_vbus_state(charger);
+
+	if (byp_dtls & 0x1) {
+		pr_info("%s: bypass overcurrent limit\n", __func__);
+#ifdef CONFIG_USB_HOST_NOTIFY
+		send_otg_notify(o_notify, NOTIFY_EVENT_OVERCURRENT, 0);
+#endif
+		/* disable the register values just related to OTG and
+		   keep the values about the charging */
+		max77843_read_reg(charger->i2c,
+				  MAX77843_CHG_REG_CNFG_00, &chg_cnfg_00);
+		chg_cnfg_00 &= ~(CHG_CNFG_00_OTG_MASK
+				| CHG_CNFG_00_BOOST_MASK);
+		max77843_write_reg(charger->i2c,
+				   MAX77843_CHG_REG_CNFG_00,
+				   chg_cnfg_00);
+	}
+	return IRQ_HANDLED;
+}
+
+static void max77843_chgin_isr_work(struct work_struct *work)
+{
+	struct max77843_charger_data *charger = container_of(work,
+				     struct max77843_charger_data, chgin_work);
+	u8 chgin_dtls, chg_dtls, chg_cnfg_00, reg_data;
+	u8 prev_chgin_dtls = 0xff;
+	int battery_health;
+	union power_supply_propval value;
+	int stable_count = 0;
+
+	wake_lock(&charger->chgin_wake_lock);
+
+	max77843_read_reg(charger->i2c,
+			  MAX77843_CHG_REG_INT_MASK, &reg_data);
+	reg_data |= (1 << 6);
+	max77843_write_reg(charger->i2c,
+		MAX77843_CHG_REG_INT_MASK, reg_data);
+
+	while (1) {
+		psy_do_property("battery", get,
+				POWER_SUPPLY_PROP_HEALTH, value);
+		battery_health = value.intval;
+
+		max77843_read_reg(charger->i2c,
+				MAX77843_CHG_REG_DETAILS_00,
+				&chgin_dtls);
+		chgin_dtls = ((chgin_dtls & MAX77843_CHGIN_DTLS) >>
+				MAX77843_CHGIN_DTLS_SHIFT);
+		max77843_read_reg(charger->i2c,
+				MAX77843_CHG_REG_DETAILS_01, &chg_dtls);
+		chg_dtls = ((chg_dtls & MAX77843_CHG_DTLS) >>
+				MAX77843_CHG_DTLS_SHIFT);
+		max77843_read_reg(charger->i2c,
+			MAX77843_CHG_REG_CNFG_00, &chg_cnfg_00);
+
+		if (prev_chgin_dtls == chgin_dtls)
+			stable_count++;
+		else
+			stable_count = 0;
+		if (stable_count > 10) {
+			pr_info("%s: irq(%d), chgin(0x%x), chg_dtls(0x%x) prev 0x%x\n",
+					__func__, charger->irq_chgin,
+					chgin_dtls, chg_dtls, prev_chgin_dtls);
+			if (charger->is_charging) {
+				if ((chgin_dtls == 0x02) && \
+					(battery_health != POWER_SUPPLY_HEALTH_OVERVOLTAGE)) {
+					pr_info("%s: charger is over voltage\n",
+							__func__);
+					value.intval = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+					psy_do_property("battery", set,
+						POWER_SUPPLY_PROP_HEALTH, value);
+				} else if (((chgin_dtls == 0x0) || (chgin_dtls == 0x01)) &&(chg_dtls & 0x08) && \
+						(chg_cnfg_00 & MAX77843_MODE_BUCK) && \
+						(chg_cnfg_00 & MAX77843_MODE_CHGR) && \
+						(battery_health != POWER_SUPPLY_HEALTH_UNDERVOLTAGE) && \
+						(charger->cable_type != POWER_SUPPLY_TYPE_WIRELESS)) {
+					pr_info("%s, vbus_state : 0x%d, chg_state : 0x%d\n", __func__, chgin_dtls, chg_dtls);
+					pr_info("%s: vBus is undervoltage\n", __func__);
+					value.intval = POWER_SUPPLY_HEALTH_UNDERVOLTAGE;
+					psy_do_property("battery", set,
+							POWER_SUPPLY_PROP_HEALTH, value);
+				}
+			} else {
+				if ((battery_health == \
+							POWER_SUPPLY_HEALTH_OVERVOLTAGE) &&
+						(chgin_dtls != 0x02)) {
+					pr_info("%s: vbus_state : 0x%d, chg_state : 0x%d\n", __func__, chgin_dtls, chg_dtls);
+					pr_info("%s: overvoltage->normal\n", __func__);
+					value.intval = POWER_SUPPLY_HEALTH_GOOD;
+					psy_do_property("battery", set,
+							POWER_SUPPLY_PROP_HEALTH, value);
+				} else if ((battery_health == \
+							POWER_SUPPLY_HEALTH_UNDERVOLTAGE) &&
+						!((chgin_dtls == 0x0) || (chgin_dtls == 0x01))){
+					pr_info("%s: vbus_state : 0x%d, chg_state : 0x%d\n", __func__, chgin_dtls, chg_dtls);
+					pr_info("%s: undervoltage->normal\n", __func__);
+					value.intval = POWER_SUPPLY_HEALTH_GOOD;
+					psy_do_property("battery", set,
+							POWER_SUPPLY_PROP_HEALTH, value);
+					max77843_set_input_current(charger,
+							charger->charging_current_max);
+				}
+			}
+			break;
+		}
+
+		prev_chgin_dtls = chgin_dtls;
+		msleep(100);
+	}
+	max77843_read_reg(charger->i2c,
+		MAX77843_CHG_REG_INT_MASK, &reg_data);
+	reg_data &= ~(1 << 6);
+	max77843_write_reg(charger->i2c,
+		MAX77843_CHG_REG_INT_MASK, reg_data);
+	wake_unlock(&charger->chgin_wake_lock);
+}
+
+static irqreturn_t max77843_chgin_irq(int irq, void *data)
+{
+	struct max77843_charger_data *charger = data;
+	queue_work(charger->wqueue, &charger->chgin_work);
+
+	return IRQ_HANDLED;
+}
+
+/* register chgin isr after sec_battery_probe */
+static void max77843_chgin_init_work(struct work_struct *work)
+{
+	struct max77843_charger_data *charger = container_of(work,
+						struct max77843_charger_data,
+						chgin_init_work.work);
+	int ret;
+
+	pr_info("%s \n", __func__);
+	ret = request_threaded_irq(charger->irq_chgin, NULL,
+			max77843_chgin_irq, 0, "chgin-irq", charger);
+	if (ret < 0) {
+		pr_err("%s: fail to request chgin IRQ: %d: %d\n",
+				__func__, charger->irq_chgin, ret);
+	} else {
+		max77843_update_reg(charger->i2c,
+			MAX77843_CHG_REG_INT_MASK, 0, MAX77843_CHGIN_IM);
+	}
+}
+
+#ifdef CONFIG_OF
+static int max77843_charger_parse_dt(struct max77843_charger_data *charger)
+{
+	struct device_node *np = of_find_node_by_name(NULL, "max77843-charger");
+	sec_battery_platform_data_t *pdata = charger->pdata;
+	int ret = 0;
+	int i, len;
+	const u32 *p;
+
+	if (np == NULL) {
+		pr_err("%s np NULL\n", __func__);
+	} else {
+		ret = of_property_read_u32(np, "battery,chg_float_voltage",
+					   &pdata->chg_float_voltage);
+	}
+
+	np = of_find_node_by_name(NULL, "battery");
+	if (!np) {
+		pr_err("%s np NULL\n", __func__);
+	} else {
+		ret = of_property_read_u32(np, "battery,full_check_type_2nd",
+					&pdata->full_check_type_2nd);
+		if (ret)
+			pr_info("%s : Full check type 2nd is Empty\n", __func__);
+
+		p = of_get_property(np, "battery,input_current_limit", &len);
+		if (!p)
+			return 1;
+
+		len = len / sizeof(u32);
+
+		pdata->charging_current = kzalloc(sizeof(sec_charging_current_t) * len,
+						  GFP_KERNEL);
+
+		for(i = 0; i < len; i++) {
+			ret = of_property_read_u32_index(np,
+				 "battery,input_current_limit", i,
+				 &pdata->charging_current[i].input_current_limit);
+			ret = of_property_read_u32_index(np,
+				 "battery,fast_charging_current", i,
+				 &pdata->charging_current[i].fast_charging_current);
+			ret = of_property_read_u32_index(np,
+				 "battery,full_check_current_1st", i,
+				 &pdata->charging_current[i].full_check_current_1st);
+			ret = of_property_read_u32_index(np,
+				 "battery,full_check_current_2nd", i,
+				 &pdata->charging_current[i].full_check_current_2nd);
+		}
+	}
+	return ret;
+}
+#endif
+
+static int __devinit max77843_charger_probe(struct platform_device *pdev)
+{
+	struct max77843_dev *max77843 = dev_get_drvdata(pdev->dev.parent);
+	struct max77843_platform_data *pdata = dev_get_platdata(max77843->dev);
+	struct max77843_charger_data *charger;
+	int ret = 0;
+	u8 reg_data;
+
+	pr_info("%s: Max77843 Charger Driver Loading\n", __func__);
+
+	charger = kzalloc(sizeof(*charger), GFP_KERNEL);
+	if (!charger)
+		return -ENOMEM;
+
+	pdata->charger_data = kzalloc(sizeof(sec_battery_platform_data_t), GFP_KERNEL);
+	if (!pdata->charger_data) {
+		ret = -ENOMEM;
+		goto err_free;
+	}
+
+	mutex_init(&charger->charger_mutex);
+
+	charger->dev = &pdev->dev;
+	charger->i2c = max77843->charger;
+	charger->pmic_i2c = max77843->i2c;
+	charger->pdata = pdata->charger_data;
+	charger->aicl_on = false;
+	charger->afc_detect = false;
+	charger->is_mdock = false;
+	charger->siop_level = 100;
+	charger->max77843_pdata = pdata;
+
+#if defined(CONFIG_OF)
+	ret = max77843_charger_parse_dt(charger);
+	if (ret < 0) {
+		pr_err("%s not found charger dt! ret[%d]\n",
+		       __func__, ret);
+	}
+#endif
+
+	platform_set_drvdata(pdev, charger);
+
+	charger->psy_chg.name		= "max77843-charger";
+	charger->psy_chg.type		= POWER_SUPPLY_TYPE_UNKNOWN;
+	charger->psy_chg.get_property	= max77843_chg_get_property;
+	charger->psy_chg.set_property	= max77843_chg_set_property;
+	charger->psy_chg.properties	= max77843_charger_props;
+	charger->psy_chg.num_properties	= ARRAY_SIZE(max77843_charger_props);
+
+	max77843_charger_initialize(charger);
+
+	if (max77843_read_reg(max77843->i2c, MAX77843_PMIC_REG_PMICREV, &reg_data) < 0) {
+		pr_err("device not found on this channel (this is not an error)\n");
+		ret = -ENOMEM;
+		goto err_pdata_free;
+	} else {
+		charger->pmic_ver = (reg_data & 0x7);
+		pr_info("%s : device found : ver.0x%x\n", __func__, charger->pmic_ver);
+	}
+
+	(void) debugfs_create_file("max77843-regs",
+		S_IRUGO, NULL, (void *)charger, &max77843_debugfs_fops);
+
+	charger->wqueue =
+	    create_singlethread_workqueue(dev_name(&pdev->dev));
+	if (!charger->wqueue) {
+		pr_err("%s: Fail to Create Workqueue\n", __func__);
+		goto err_pdata_free;
+	}
+	wake_lock_init(&charger->chgin_wake_lock, WAKE_LOCK_SUSPEND,
+		       "charger->chgin");
+	INIT_WORK(&charger->chgin_work, max77843_chgin_isr_work);
+	INIT_DELAYED_WORK(&charger->chgin_init_work, max77843_chgin_init_work);
+	wake_lock_init(&charger->wpc_wake_lock, WAKE_LOCK_SUSPEND,
+					       "charger-wpc");
+	INIT_DELAYED_WORK(&charger->wpc_work, wpc_detect_work);
+	INIT_DELAYED_WORK(&charger->afc_work, afc_detect_work);
+
+	ret = power_supply_register(&pdev->dev, &charger->psy_chg);
+	if (ret) {
+		pr_err("%s: Failed to Register psy_chg\n", __func__);
+		goto err_power_supply_register;
+	}
+
+	if (charger->pdata->chg_irq) {
+		INIT_DELAYED_WORK(&charger->isr_work, max77843_chg_isr_work);
+
+		ret = request_threaded_irq(charger->pdata->chg_irq,
+				NULL, max77843_chg_irq_thread,
+				charger->pdata->chg_irq_attr,
+				"charger-irq", charger);
+		if (ret) {
+			pr_err("%s: Failed to Request IRQ\n", __func__);
+			goto err_irq;
+		}
+
+			ret = enable_irq_wake(charger->pdata->chg_irq);
+			if (ret < 0)
+				pr_err("%s: Failed to Enable Wakeup Source(%d)\n",
+					__func__, ret);
+		}
+
+	charger->wc_w_irq = pdata->irq_base + MAX77843_CHG_IRQ_WCIN_I;
+	ret = request_threaded_irq(charger->wc_w_irq,
+				   NULL, wpc_charger_irq,
+				   IRQF_TRIGGER_FALLING,
+				   "wpc-int", charger);
+	if (ret) {
+		pr_err("%s: Failed to Request IRQ\n", __func__);
+		goto err_wc_irq;
+	}
+
+	max77843_read_reg(charger->i2c,
+			  MAX77843_CHG_REG_INT_OK, &reg_data);
+	charger->wc_w_state = (reg_data & MAX77843_WCIN_OK)
+		>> MAX77843_WCIN_OK_SHIFT;
+
+	charger->irq_chgin = pdata->irq_base + MAX77843_CHG_IRQ_CHGIN_I;
+	/* enable chgin irq after sec_battery_probe */
+	queue_delayed_work(charger->wqueue, &charger->chgin_init_work,
+			msecs_to_jiffies(3000));
+
+	charger->irq_bypass = pdata->irq_base + MAX77843_CHG_IRQ_BYP_I;
+	ret = request_threaded_irq(charger->irq_bypass, NULL,
+			max77843_bypass_irq, 0, "bypass-irq", charger);
+	if (ret < 0) {
+		pr_err("%s: fail to request bypass IRQ: %d: %d\n",
+				__func__, charger->irq_bypass, ret);
+	} else {
+		max77843_update_reg(charger->i2c,
+			MAX77843_CHG_REG_INT_MASK, 0, MAX77843_BYP_IM);
+	}
+
+	charger->irq_batp = pdata->irq_base + MAX77843_CHG_IRQ_BATP_I;
+	ret = request_threaded_irq(charger->irq_batp, NULL,
+				   max77843_batp_irq, 0,
+				   "batp-irq", charger);
+	if (ret < 0)
+		pr_err("%s: fail to request bypass IRQ: %d: %d\n",
+		       __func__, charger->irq_batp, ret);
+
+	ret = max77843_chg_create_attrs(charger->psy_chg.dev);
+	if (ret) {
+		dev_err(charger->dev,
+			"%s : Failed to create_attrs\n", __func__);
+		goto err_wc_irq;
+	}
+	pr_info("%s: MAX77843 Charger Driver Loaded\n", __func__);
+
+	return 0;
+
+err_wc_irq:
+	free_irq(charger->pdata->chg_irq, NULL);
+err_irq:
+	power_supply_unregister(&charger->psy_chg);
+err_power_supply_register:
+	destroy_workqueue(charger->wqueue);
+err_pdata_free:
+	kfree(pdata->charger_data);
+err_free:
+	kfree(charger);
+
+	return ret;
+}
+
+static int __devexit max77843_charger_remove(struct platform_device *pdev)
+{
+	struct max77843_charger_data *charger =
+		platform_get_drvdata(pdev);
+
+	destroy_workqueue(charger->wqueue);
+	free_irq(charger->wc_w_irq, NULL);
+	free_irq(charger->pdata->chg_irq, NULL);
+	power_supply_unregister(&charger->psy_chg);
+	kfree(charger);
+
+	return 0;
+}
+
+#if defined CONFIG_PM
+static int max77843_charger_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int max77843_charger_resume(struct device *dev)
+{
+	return 0;
+}
+#else
+#define max77843_charger_suspend NULL
+#define max77843_charger_resume NULL
+#endif
+
+static void max77843_charger_shutdown(struct device *dev)
+{
+	struct max77843_charger_data *charger =
+				dev_get_drvdata(dev);
+	u8 reg_data;
+
+	pr_info("%s: MAX77843 Charger driver shutdown\n", __func__);
+	if (!charger->i2c) {
+		pr_err("%s: no max77843 i2c client\n", __func__);
+		return;
+	}
+	reg_data = 0x04;
+	max77843_write_reg(charger->i2c,
+		MAX77843_CHG_REG_CNFG_00, reg_data);
+	reg_data = 0x0F;
+	max77843_write_reg(charger->i2c,
+		MAX77843_CHG_REG_CNFG_09, reg_data);
+	reg_data = 0x19;
+	max77843_write_reg(charger->i2c,
+		MAX77843_CHG_REG_CNFG_10, reg_data);
+	reg_data = 0x67;
+	max77843_write_reg(charger->i2c,
+		MAX77843_CHG_REG_CNFG_12, reg_data);
+	pr_info("func:%s \n", __func__);
+}
+
+static SIMPLE_DEV_PM_OPS(max77843_charger_pm_ops, max77843_charger_suspend,
+			 max77843_charger_resume);
+
+static struct platform_driver max77843_charger_driver = {
+	.driver = {
+		.name = "max77843-charger",
+		.owner = THIS_MODULE,
+#ifdef CONFIG_PM
+		.pm = &max77843_charger_pm_ops,
+#endif
+		.shutdown = max77843_charger_shutdown,
+	},
+	.probe = max77843_charger_probe,
+	.remove = __devexit_p(max77843_charger_remove),
+};
+
+static int __init max77843_charger_init(void)
+{
+	pr_info("%s : \n", __func__);
+	return platform_driver_register(&max77843_charger_driver);
+}
+
+static void __exit max77843_charger_exit(void)
+{
+	platform_driver_unregister(&max77843_charger_driver);
+}
+
+module_init(max77843_charger_init);
+module_exit(max77843_charger_exit);
+
+MODULE_DESCRIPTION("Samsung MAX77843 Charger Driver");
+MODULE_AUTHOR("Samsung Electronics");
+MODULE_LICENSE("GPL");
diff -Naur linux-3.18.14/drivers/battery/max77843_fuelgauge.c samsung/drivers/battery/max77843_fuelgauge.c
--- linux-3.18.14/drivers/battery/max77843_fuelgauge.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery/max77843_fuelgauge.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,2096 @@
+/*
+ *  max77843_fuelgauge.c
+ *  Samsung MAX77843 Fuel Gauge Driver
+ *
+ *  Copyright (C) 2012 Samsung Electronics
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#define DEBUG
+/* #define BATTERY_LOG_MESSAGE */
+
+#include <linux/mfd/max77843-private.h>
+#include <linux/of_gpio.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+
+static enum power_supply_property max77843_fuelgauge_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_VOLTAGE_AVG,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CURRENT_AVG,
+	POWER_SUPPLY_PROP_CHARGE_FULL,
+	POWER_SUPPLY_PROP_ENERGY_NOW,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_TEMP_AMBIENT,
+#if defined(CONFIG_EN_OOPS)
+	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
+#endif
+};
+
+#if !defined(CONFIG_SEC_FACTORY)
+static void max77843_fg_read_time(struct max77843_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	int lsb, msb, time;
+
+	if (max77843_bulk_read(fuelgauge->i2c,
+		TIME_TO_FULL_REG, 2, data) < 0) {
+		pr_err("%s: Failed to read TTF\n", __func__);
+		return;
+	}
+
+	lsb = data[0] & 0x1f;
+	msb = ((data[1] << 3) + ((data[0] & 0xe0) >> 5));
+	time = msb * 180 + (lsb * 5625) / 1000;
+
+	pr_info("[Time-to-FULL] %d(secs), %d(mins)\n", time, time / 60);
+
+	if (max77843_bulk_read(fuelgauge->i2c,
+		TIME_TO_EMPTY_REG, 2, data) < 0) {
+		pr_err("%s: Failed to read TTE\n", __func__);
+		return;
+	}
+
+	lsb = data[0] & 0x1f;
+	msb = ((data[1] << 3) + ((data[0] & 0xe0) >> 5));
+	time = msb * 180 + (lsb * 5625) / 1000;
+
+	pr_info("[Time-to-EMPTY] %d(secs), %d(mins)\n", time, time / 60);
+}
+
+static void max77843_fg_test_print(struct max77843_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u32 average_vcell;
+	u16 w_data;
+	u32 temp;
+	u32 temp2;
+#ifdef BATTERY_LOG_MESSAGE
+	u16 reg_data;
+#endif
+
+	if (max77843_bulk_read(fuelgauge->i2c,
+				AVR_VCELL_REG, 2, data) < 0) {
+		pr_err("%s: Failed to read VCELL\n", __func__);
+		return;
+	}
+
+	w_data = (data[1]<<8) | data[0];
+
+	temp = (w_data & 0xFFF) * 78125;
+	average_vcell = temp / 1000000;
+
+	temp = ((w_data & 0xF000) >> 4) * 78125;
+	temp2 = temp / 1000000;
+	average_vcell += (temp2 << 4);
+
+#ifdef BATTERY_LOG_MESSAGE
+	pr_info("%s: AVG_VCELL(%d), data(0x%04x)\n", __func__,
+		average_vcell, (data[1]<<8) | data[0]);
+
+	reg_data = max77843_read_word(fuelgauge->i2c, FULLCAP_REG);
+	pr_info("%s: FULLCAP(%d), data(0x%04x)\n", __func__,
+		reg_data/2, reg_data);
+
+	reg_data = max77843_read_word(fuelgauge->i2c, REMCAP_REP_REG);
+	pr_info("%s: REMCAP_REP(%d), data(0x%04x)\n", __func__,
+		reg_data/2, reg_data);
+
+	reg_data = max77843_read_word(fuelgauge->i2c, REMCAP_MIX_REG);
+	pr_info("%s: REMCAP_MIX(%d), data(0x%04x)\n", __func__,
+		reg_data/2, reg_data);
+
+	reg_data = max77843_read_word(fuelgauge->i2c, REMCAP_AV_REG);
+	pr_info("%s: REMCAP_AV(%d), data(0x%04x)\n", __func__,
+		reg_data/2, reg_data);
+
+	reg_data = max77843_read_word(fuelgauge->i2c, CONFIG_REG);
+	pr_info("%s: CONFIG_REG(0x%02x), data(0x%04x)\n", __func__,
+		CONFIG_REG, reg_data);
+#endif
+
+	max77843_fg_read_time(fuelgauge);
+}
+
+static void max77843_fg_periodic_read(struct max77843_fuelgauge_data *fuelgauge)
+{
+	u8 reg;
+	int i;
+	int data[0x10];
+	char *str = NULL;
+
+	str = kzalloc(sizeof(char)*1024, GFP_KERNEL);
+	if (!str)
+		return;
+
+	for (i = 0; i < 16; i++) {
+		for (reg = 0; reg < 0x10; reg++) {
+			data[reg] = max77843_read_word(fuelgauge->i2c, reg + i * 0x10);
+			if (data[reg] < 0) {
+				kfree(str);
+				return;
+			}
+		}
+		if (i == 12)
+			continue;
+		sprintf(str+strlen(str),
+			"%04xh,%04xh,%04xh,%04xh,%04xh,%04xh,%04xh,%04xh,",
+			data[0x00], data[0x01], data[0x02], data[0x03],
+			data[0x04], data[0x05], data[0x06], data[0x07]);
+		sprintf(str+strlen(str),
+			"%04xh,%04xh,%04xh,%04xh,%04xh,%04xh,%04xh,%04xh,",
+			data[0x08], data[0x09], data[0x0a], data[0x0b],
+			data[0x0c], data[0x0d], data[0x0e], data[0x0f]);
+		if (i == 4)
+			i = 10;
+	}
+
+	pr_info("[FG] %s\n", str);
+
+	kfree(str);
+}
+#endif
+
+static int max77843_fg_read_vcell(struct max77843_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u32 vcell;
+	u16 w_data;
+	u32 temp;
+	u32 temp2;
+
+	if (max77843_bulk_read(fuelgauge->i2c, VCELL_REG, 2, data) < 0) {
+		pr_err("%s: Failed to read VCELL\n", __func__);
+		return -1;
+	}
+
+	w_data = (data[1]<<8) | data[0];
+
+	temp = (w_data & 0xFFF) * 78125;
+	vcell = temp / 1000000;
+
+	temp = ((w_data & 0xF000) >> 4) * 78125;
+	temp2 = temp / 1000000;
+	vcell += (temp2 << 4);
+
+	if (!(fuelgauge->info.pr_cnt % PRINT_COUNT))
+		pr_info("%s: VCELL(%d), data(0x%04x)\n",
+			__func__, vcell, (data[1]<<8) | data[0]);
+
+	return vcell;
+}
+
+static int max77843_fg_read_vfocv(struct max77843_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u32 vfocv = 0;
+	u16 w_data;
+	u32 temp;
+	u32 temp2;
+
+	if (max77843_bulk_read(fuelgauge->i2c, VFOCV_REG, 2, data) < 0) {
+		pr_err("%s: Failed to read VFOCV\n", __func__);
+		return -1;
+	}
+
+	w_data = (data[1]<<8) | data[0];
+
+	temp = (w_data & 0xFFF) * 78125;
+	vfocv = temp / 1000000;
+
+	temp = ((w_data & 0xF000) >> 4) * 78125;
+	temp2 = temp / 1000000;
+	vfocv += (temp2 << 4);
+
+	return vfocv;
+}
+
+static int max77843_fg_read_avg_vcell(struct max77843_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u32 avg_vcell = 0;
+	u16 w_data;
+	u32 temp;
+	u32 temp2;
+
+	if (max77843_bulk_read(fuelgauge->i2c, AVR_VCELL_REG,
+			       2, data) < 0) {
+		pr_err("%s: Failed to read AVG_VCELL\n", __func__);
+		return -1;
+	}
+
+	w_data = (data[1]<<8) | data[0];
+
+	temp = (w_data & 0xFFF) * 78125;
+	avg_vcell = temp / 1000000;
+
+	temp = ((w_data & 0xF000) >> 4) * 78125;
+	temp2 = temp / 1000000;
+	avg_vcell += (temp2 << 4);
+
+	return avg_vcell;
+}
+
+static int max77843_fg_check_battery_present(struct max77843_fuelgauge_data *fuelgauge)
+{
+	u8 status_data[2];
+	int ret = 1;
+
+	/* 1. Check Bst bit */
+	if (max77843_bulk_read(fuelgauge->i2c, STATUS_REG,
+			       2, status_data) < 0) {
+		pr_err("%s: Failed to read STATUS_REG\n", __func__);
+		return 0;
+	}
+
+	if (status_data[0] & (0x1 << 3)) {
+		pr_info("%s: addr(0x01), data(0x%04x)\n", __func__,
+			(status_data[1]<<8) | status_data[0]);
+		pr_info("%s: battery is absent!!\n", __func__);
+		ret = 0;
+	}
+
+	return ret;
+}
+
+static int max77843_fg_write_temp(struct max77843_fuelgauge_data *fuelgauge,
+			 int temperature)
+{
+	u8 data[2];
+
+	data[0] = (temperature%10) * 1000 / 39;
+	data[1] = temperature / 10;
+	max77843_bulk_write(fuelgauge->i2c, TEMPERATURE_REG, 2, data);
+
+	pr_debug("%s: temperature to (%d, 0x%02x%02x)\n",
+		__func__, temperature, data[1], data[0]);
+
+	return temperature;
+}
+
+static int max77843_fg_read_temp(struct max77843_fuelgauge_data *fuelgauge)
+{
+	u8 data[2] = {0, 0};
+	int temper = 0;
+
+	if (max77843_fg_check_battery_present(fuelgauge)) {
+		if (max77843_bulk_read(fuelgauge->i2c,
+				       TEMPERATURE_REG, 2, data) < 0) {
+			pr_err("%s: Failed to read TEMPERATURE_REG\n",
+				__func__);
+			return -1;
+		}
+
+		if (data[1]&(0x1 << 7)) {
+			temper = ((~(data[1]))&0xFF)+1;
+			temper *= (-1000);
+			temper -= ((~((int)data[0]))+1) * 39 / 10;
+		} else {
+			temper = data[1] & 0x7f;
+			temper *= 1000;
+			temper += data[0] * 39 / 10;
+		}
+	} else
+		temper = 20000;
+
+	if (!(fuelgauge->info.pr_cnt % PRINT_COUNT))
+		pr_info("%s: TEMPERATURE(%d), data(0x%04x)\n",
+			__func__, temper, (data[1]<<8) | data[0]);
+
+	return temper/100;
+}
+
+/* soc should be 0.1% unit */
+static int max77843_fg_read_vfsoc(struct max77843_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	int soc;
+
+	if (max77843_bulk_read(fuelgauge->i2c, VFSOC_REG,
+			       2, data) < 0) {
+		pr_err("%s: Failed to read VFSOC\n", __func__);
+		return -1;
+	}
+
+	soc = ((data[1] * 100) + (data[0] * 100 / 256)) / 10;
+
+	return min(soc, 1000);
+}
+
+/* soc should be 0.1% unit */
+static int max77843_fg_read_avsoc(struct max77843_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	int soc;
+
+	if (max77843_bulk_read(fuelgauge->i2c, SOCAV_REG,
+			       2, data) < 0) {
+		pr_err("%s: Failed to read AVSOC\n", __func__);
+		return -1;
+	}
+
+	soc = ((data[1] * 100) + (data[0] * 100 / 256)) / 10;
+
+	return min(soc, 1000);
+}
+
+/* soc should be 0.1% unit */
+static int max77843_fg_read_soc(struct max77843_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	int soc, vf_soc;
+
+	if (max77843_bulk_read(fuelgauge->i2c, SOCREP_REG, 2, data) < 0) {
+		pr_err("%s: Failed to read SOCREP\n", __func__);
+		return -1;
+	}
+
+	soc = ((data[1] * 100) + (data[0] * 100 / 256)) / 10;
+	vf_soc = max77843_fg_read_vfsoc(fuelgauge);
+
+#ifdef BATTERY_LOG_MESSAGE
+	pr_debug("%s: raw capacity (%d)\n", __func__, soc);
+
+	if (!(fuelgauge->info.pr_cnt % PRINT_COUNT)) {
+		pr_debug("%s: raw capacity (%d), data(0x%04x)\n",
+			 __func__, soc, (data[1]<<8) | data[0]);
+		pr_debug("%s: REPSOC (%d), VFSOC (%d), data(0x%04x)\n",
+				__func__, soc/10, vf_soc/10, (data[1]<<8) | data[0]);
+	}
+#endif
+
+	return min(soc, 1000);
+}
+
+/* soc should be 0.01% unit */
+static int max77843_fg_read_rawsoc(struct max77843_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	int soc;
+
+	if (max77843_bulk_read(fuelgauge->i2c, SOCREP_REG,
+			       2, data) < 0) {
+		pr_err("%s: Failed to read SOCREP\n", __func__);
+		return -1;
+	}
+
+	soc = (data[1] * 100) + (data[0] * 100 / 256);
+
+	pr_debug("%s: raw capacity (0.01%%) (%d)\n",
+		 __func__, soc);
+
+	if (!(fuelgauge->info.pr_cnt % PRINT_COUNT))
+		pr_debug("%s: raw capacity (%d), data(0x%04x)\n",
+			 __func__, soc, (data[1]<<8) | data[0]);
+
+	return min(soc, 10000);
+}
+
+static int max77843_fg_read_fullcap(struct max77843_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	int ret;
+
+	if (max77843_bulk_read(fuelgauge->i2c, FULLCAP_REG,
+			       2, data) < 0) {
+		pr_err("%s: Failed to read FULLCAP\n", __func__);
+		return -1;
+	}
+
+	ret = (data[1] << 8) + data[0];
+
+	return ret;
+}
+
+static int max77843_fg_read_mixcap(struct max77843_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	int ret;
+
+	if (max77843_bulk_read(fuelgauge->i2c, REMCAP_MIX_REG,
+			       2, data) < 0) {
+		pr_err("%s: Failed to read REMCAP_MIX_REG\n",
+		       __func__);
+		return -1;
+	}
+
+	ret = (data[1] << 8) + data[0];
+
+	return ret;
+}
+
+static int max77843_fg_read_avcap(struct max77843_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	int ret;
+
+	if (max77843_bulk_read(fuelgauge->i2c, REMCAP_AV_REG,
+			       2, data) < 0) {
+		pr_err("%s: Failed to read REMCAP_AV_REG\n",
+		       __func__);
+		return -1;
+	}
+
+	ret = (data[1] << 8) + data[0];
+
+	return ret;
+}
+
+static int max77843_fg_read_repcap(struct max77843_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	int ret;
+
+	if (max77843_bulk_read(fuelgauge->i2c, REMCAP_REP_REG,
+			       2, data) < 0) {
+		pr_err("%s: Failed to read REMCAP_REP_REG\n",
+		       __func__);
+		return -1;
+	}
+
+	ret = (data[1] << 8) + data[0];
+
+	return ret;
+}
+
+static int max77843_fg_read_current(struct max77843_fuelgauge_data *fuelgauge, int unit)
+{
+	u8 data1[2], data2[2];
+	u32 temp, sign;
+	s32 i_current;
+	s32 avg_current;
+	int vcell;
+	static int cnt;
+
+	if (max77843_bulk_read(fuelgauge->i2c, CURRENT_REG,
+			      2, data1) < 0) {
+		pr_err("%s: Failed to read CURRENT\n", __func__);
+		return -1;
+	}
+
+	if (max77843_bulk_read(fuelgauge->i2c, AVG_CURRENT_REG,
+			       2, data2) < 0) {
+		pr_err("%s: Failed to read AVERAGE CURRENT\n", __func__);
+		return -1;
+	}
+
+	temp = ((data1[1]<<8) | data1[0]) & 0xFFFF;
+	/* Debug log for abnormal current case */
+	pr_info("%s: CURRENT_REG(0x%04x)\n", __func__, temp);
+	if (temp & (0x1 << 15)) {
+		sign = NEGATIVE;
+		temp = (~temp & 0xFFFF) + 1;
+	} else
+		sign = POSITIVE;
+
+	/* 1.5625uV/0.01Ohm(Rsense) = 156.25uA */
+	switch (unit) {
+	case SEC_BATTEY_CURRENT_UA:
+		i_current = temp * 15625 / 100;
+		break;
+	case SEC_BATTEY_CURRENT_MA:
+	default:
+		i_current = temp * 15625 / 100000;
+	}
+
+	if (sign)
+		i_current *= -1;
+
+	temp = ((data2[1]<<8) | data2[0]) & 0xFFFF;
+	if (temp & (0x1 << 15)) {
+		sign = NEGATIVE;
+		temp = (~temp & 0xFFFF) + 1;
+	} else
+		sign = POSITIVE;
+
+	/* 1.5625uV/0.01Ohm(Rsense) = 156.25uA */
+	avg_current = temp * 15625 / 100000;
+	if (sign)
+		avg_current *= -1;
+
+	vcell = max77843_fg_read_vcell(fuelgauge);
+	if ((vcell < 3500) && (cnt < 10) && (i_current < 0) &&
+			fuelgauge->is_charging) {
+		i_current = 1;
+		cnt++;
+	}
+
+#if !defined(CONFIG_SEC_FACTORY)
+	max77843_fg_test_print(fuelgauge);
+	max77843_fg_periodic_read(fuelgauge);
+#endif
+	return i_current;
+}
+
+static int max77843_fg_read_avg_current(struct max77843_fuelgauge_data *fuelgauge, int unit)
+{
+	u8  data2[2];
+	u32 temp, sign;
+	s32 avg_current;
+	int vcell;
+	static int cnt;
+
+	if (max77843_bulk_read(fuelgauge->i2c, AVG_CURRENT_REG,
+			       2, data2) < 0) {
+		pr_err("%s: Failed to read AVERAGE CURRENT\n",
+		       __func__);
+		return -1;
+	}
+
+	temp = ((data2[1]<<8) | data2[0]) & 0xFFFF;
+	if (temp & (0x1 << 15)) {
+		sign = NEGATIVE;
+		temp = (~temp & 0xFFFF) + 1;
+	} else
+		sign = POSITIVE;
+
+	/* 1.5625uV/0.01Ohm(Rsense) = 156.25uA */
+	switch (unit) {
+	case SEC_BATTEY_CURRENT_UA:
+		avg_current = temp * 15625 / 100;
+		break;
+	case SEC_BATTEY_CURRENT_MA:
+	default:
+		avg_current = temp * 15625 / 100000;
+	}
+
+	if (sign)
+		avg_current *= -1;
+
+	vcell = max77843_fg_read_vcell(fuelgauge);
+	if ((vcell < 3500) && (cnt < 10) && (avg_current < 0) &&
+	    fuelgauge->is_charging) {
+		avg_current = 1;
+		cnt++;
+	}
+
+	return avg_current;
+}
+
+int max77843_fg_reset_soc(struct max77843_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	int vfocv, fullcap;
+
+	/* delay for current stablization */
+	msleep(500);
+
+	pr_info("%s: Before quick-start - VCELL(%d), VFOCV(%d), VfSOC(%d), RepSOC(%d)\n",
+		__func__, max77843_fg_read_vcell(fuelgauge), max77843_fg_read_vfocv(fuelgauge),
+		max77843_fg_read_vfsoc(fuelgauge), max77843_fg_read_soc(fuelgauge));
+	pr_info("%s: Before quick-start - current(%d), avg current(%d)\n",
+		__func__, max77843_fg_read_current(fuelgauge, SEC_BATTEY_CURRENT_MA),
+		max77843_fg_read_avg_current(fuelgauge, SEC_BATTEY_CURRENT_MA));
+
+	if (fuelgauge->pdata->check_jig_status &&
+	    !fuelgauge->pdata->check_jig_status()) {
+		pr_info("%s : Return by No JIG_ON signal\n", __func__);
+		return 0;
+	}
+
+	max77843_write_word(fuelgauge->i2c, CYCLES_REG, 0);
+
+	if (max77843_bulk_read(fuelgauge->i2c, MISCCFG_REG,
+			       2, data) < 0) {
+		pr_err("%s: Failed to read MiscCFG\n", __func__);
+		return -1;
+	}
+
+	data[1] |= (0x1 << 2);
+	if (max77843_bulk_write(fuelgauge->i2c, MISCCFG_REG,
+				2, data) < 0) {
+		pr_err("%s: Failed to write MiscCFG\n", __func__);
+		return -1;
+	}
+
+	msleep(250);
+	max77843_write_word(fuelgauge->i2c, FULLCAP_REG,
+			    fuelgauge->battery_data->Capacity);
+	msleep(500);
+
+	pr_info("%s: After quick-start - VCELL(%d), VFOCV(%d), VfSOC(%d), RepSOC(%d)\n",
+		__func__, max77843_fg_read_vcell(fuelgauge), max77843_fg_read_vfocv(fuelgauge),
+		max77843_fg_read_vfsoc(fuelgauge), max77843_fg_read_soc(fuelgauge));
+	pr_info("%s: After quick-start - current(%d), avg current(%d)\n",
+		__func__, max77843_fg_read_current(fuelgauge, SEC_BATTEY_CURRENT_MA),
+		max77843_fg_read_avg_current(fuelgauge, SEC_BATTEY_CURRENT_MA));
+
+	max77843_write_word(fuelgauge->i2c, CYCLES_REG, 0x00a0);
+
+/* P8 is not turned off by Quickstart @3.4V
+ * (It's not a problem, depend on mode data)
+ * Power off for factory test(File system, etc..) */
+	vfocv = max77843_fg_read_vfocv(fuelgauge);
+	if (vfocv < POWER_OFF_VOLTAGE_LOW_MARGIN) {
+		pr_info("%s: Power off condition(%d)\n", __func__, vfocv);
+
+		fullcap = max77843_read_word(fuelgauge->i2c, FULLCAP_REG);
+
+		/* FullCAP * 0.009 */
+		max77843_write_word(fuelgauge->i2c, REMCAP_REP_REG,
+				    (u16)(fullcap * 9 / 1000));
+		msleep(200);
+		pr_info("%s: new soc=%d, vfocv=%d\n", __func__,
+			max77843_fg_read_soc(fuelgauge), vfocv);
+	}
+
+	pr_info("%s: Additional step - VfOCV(%d), VfSOC(%d), RepSOC(%d)\n",
+		__func__, max77843_fg_read_vfocv(fuelgauge),
+		max77843_fg_read_vfsoc(fuelgauge), max77843_fg_read_soc(fuelgauge));
+
+	return 0;
+}
+
+int max77843_fg_reset_capacity_by_jig_connection(struct max77843_fuelgauge_data *fuelgauge)
+{
+
+	pr_info("%s: DesignCap = Capacity - 1 (Jig Connection)\n", __func__);
+
+	return max77843_write_word(fuelgauge->i2c, DESIGNCAP_REG,
+				   fuelgauge->battery_data->Capacity-1);
+}
+
+void max77843_fg_low_batt_compensation(struct max77843_fuelgauge_data *fuelgauge,
+			      u32 level)
+{
+	int read_val;
+	u32 temp;
+
+	pr_info("%s: Adjust SOCrep to %d!!\n", __func__, level);
+
+	read_val = max77843_read_word(fuelgauge->i2c, FULLCAP_REG);
+	/* RemCapREP (05h) = FullCap(10h) x 0.0090 */
+	temp = read_val * (level*90) / 10000;
+	max77843_write_word(fuelgauge->i2c, REMCAP_REP_REG,
+			    (u16)temp);
+}
+
+static int max77843_fg_check_status_reg(struct max77843_fuelgauge_data *fuelgauge)
+{
+	u8 status_data[2];
+	int ret = 0;
+
+	/* 1. Check Smn was generatedread */
+	if (max77843_bulk_read(fuelgauge->i2c, STATUS_REG,
+			       2, status_data) < 0) {
+		pr_err("%s: Failed to read STATUS_REG\n", __func__);
+		return -1;
+	}
+
+#ifdef BATTERY_LOG_MESSAGE
+	pr_info("%s: addr(0x00), data(0x%04x)\n", __func__,
+		(status_data[1]<<8) | status_data[0]);
+#endif
+
+	if (status_data[1] & (0x1 << 2))
+		ret = 1;
+
+	/* 2. clear Status reg */
+	status_data[1] = 0;
+	if (max77843_bulk_write(fuelgauge->i2c, STATUS_REG,
+				2, status_data) < 0) {
+		pr_info("%s: Failed to write STATUS_REG\n", __func__);
+		return -1;
+	}
+
+	return ret;
+}
+
+int max77843_get_fuelgauge_value(struct max77843_fuelgauge_data *fuelgauge, int data)
+{
+	int ret;
+
+	switch (data) {
+	case FG_LEVEL:
+		ret = max77843_fg_read_soc(fuelgauge);
+		break;
+
+	case FG_TEMPERATURE:
+		ret = max77843_fg_read_temp(fuelgauge);
+		break;
+
+	case FG_VOLTAGE:
+		ret = max77843_fg_read_vcell(fuelgauge);
+		break;
+
+	case FG_CURRENT:
+		ret = max77843_fg_read_current(fuelgauge, SEC_BATTEY_CURRENT_MA);
+		break;
+
+	case FG_CURRENT_AVG:
+		ret = max77843_fg_read_avg_current(fuelgauge, SEC_BATTEY_CURRENT_MA);
+		break;
+
+	case FG_CHECK_STATUS:
+		ret = max77843_fg_check_status_reg(fuelgauge);
+		break;
+
+	case FG_RAW_SOC:
+		ret = max77843_fg_read_rawsoc(fuelgauge);
+		break;
+
+	case FG_VF_SOC:
+		ret = max77843_fg_read_vfsoc(fuelgauge);
+		break;
+
+	case FG_AV_SOC:
+		ret = max77843_fg_read_avsoc(fuelgauge);
+		break;
+
+	case FG_FULLCAP:
+		ret = max77843_fg_read_fullcap(fuelgauge);
+		break;
+
+	case FG_MIXCAP:
+		ret = max77843_fg_read_mixcap(fuelgauge);
+		break;
+
+	case FG_AVCAP:
+		ret = max77843_fg_read_avcap(fuelgauge);
+		break;
+
+	case FG_REPCAP:
+		ret = max77843_fg_read_repcap(fuelgauge);
+		break;
+
+	default:
+		ret = -1;
+		break;
+	}
+
+	return ret;
+}
+
+int max77843_fg_alert_init(struct max77843_fuelgauge_data *fuelgauge, int soc)
+{
+	u8 misccgf_data[2];
+	u8 salrt_data[2];
+	u8 config_data[2];
+	u8 valrt_data[2];
+	u8 talrt_data[2];
+	u16 read_data = 0;
+
+	fuelgauge->is_fuel_alerted = false;
+
+	/* Using RepSOC */
+	if (max77843_bulk_read(fuelgauge->i2c, MISCCFG_REG, 2,
+			       misccgf_data) < 0) {
+		pr_err("%s: Failed to read MISCCFG_REG\n", __func__);
+		return -1;
+	}
+	misccgf_data[0] = misccgf_data[0] & ~(0x03);
+
+	if (max77843_bulk_write(fuelgauge->i2c, MISCCFG_REG,
+				2, misccgf_data) < 0) {
+		pr_info("%s: Failed to write MISCCFG_REG\n", __func__);
+		return -1;
+	}
+
+	/* SALRT Threshold setting */
+	salrt_data[1] = 0xff;
+	salrt_data[0] = soc;
+	if (max77843_bulk_write(fuelgauge->i2c, SALRT_THRESHOLD_REG,
+				2, salrt_data) < 0) {
+		pr_info("%s: Failed to write SALRT_THRESHOLD_REG\n", __func__);
+		return -1;
+	}
+
+	/* Reset VALRT Threshold setting (disable) */
+	valrt_data[1] = 0xFF;
+	valrt_data[0] = 0x00;
+	if (max77843_bulk_write(fuelgauge->i2c, VALRT_THRESHOLD_REG,
+				2, valrt_data) < 0) {
+		pr_info("%s: Failed to write VALRT_THRESHOLD_REG\n", __func__);
+		return -1;
+	}
+
+	read_data = max77843_read_word(fuelgauge->i2c, (u8)VALRT_THRESHOLD_REG);
+	if (read_data != 0xff00)
+		pr_err("%s: VALRT_THRESHOLD_REG is not valid (0x%x)\n",
+			__func__, read_data);
+
+	/* Reset TALRT Threshold setting (disable) */
+	talrt_data[1] = 0x7F;
+	talrt_data[0] = 0x80;
+	if (max77843_bulk_write(fuelgauge->i2c, TALRT_THRESHOLD_REG,
+				2, talrt_data) < 0) {
+		pr_info("%s: Failed to write TALRT_THRESHOLD_REG\n", __func__);
+		return -1;
+	}
+
+	read_data = max77843_read_word(fuelgauge->i2c, (u8)TALRT_THRESHOLD_REG);
+	if (read_data != 0x7f80)
+		pr_err("%s: TALRT_THRESHOLD_REG is not valid (0x%x)\n",
+			__func__, read_data);
+
+	/*mdelay(100);*/
+
+	/* Enable SOC alerts */
+	if (max77843_bulk_read(fuelgauge->i2c, CONFIG_REG,
+			       2, config_data) < 0) {
+		pr_err("%s: Failed to read CONFIG_REG\n", __func__);
+		return -1;
+	}
+	config_data[0] = config_data[0] | (0x1 << 2);
+
+	if (max77843_bulk_write(fuelgauge->i2c, CONFIG_REG,
+				2, config_data) < 0) {
+		pr_info("%s: Failed to write CONFIG_REG\n", __func__);
+		return -1;
+	}
+
+	max77843_update_reg(fuelgauge->pmic,
+			    MAX77843_PMIC_REG_INTSRC_MASK,
+			    ~MAX77843_IRQSRC_FG,
+			    MAX77843_IRQSRC_FG);
+
+	pr_info("[%s] SALRT(0x%02x%02x), VALRT(0x%02x%02x), CONFIG(0x%02x%02x)\n",
+		__func__,
+		salrt_data[1], salrt_data[0],
+		valrt_data[1], valrt_data[0],
+		config_data[1], config_data[0]);
+
+	return 1;
+}
+
+static void max77843_display_low_batt_comp_cnt(struct max77843_fuelgauge_data *fuelgauge)
+{
+	pr_info("Check Array(%s): [%d, %d], [%d, %d], ",
+			fuelgauge->battery_data->type_str,
+			fuelgauge->info.low_batt_comp_cnt[0][0],
+			fuelgauge->info.low_batt_comp_cnt[0][1],
+			fuelgauge->info.low_batt_comp_cnt[1][0],
+			fuelgauge->info.low_batt_comp_cnt[1][1]);
+	pr_info("[%d, %d], [%d, %d], [%d, %d]\n",
+			fuelgauge->info.low_batt_comp_cnt[2][0],
+			fuelgauge->info.low_batt_comp_cnt[2][1],
+			fuelgauge->info.low_batt_comp_cnt[3][0],
+			fuelgauge->info.low_batt_comp_cnt[3][1],
+			fuelgauge->info.low_batt_comp_cnt[4][0],
+			fuelgauge->info.low_batt_comp_cnt[4][1]);
+}
+
+static void max77843_add_low_batt_comp_cnt(struct max77843_fuelgauge_data *fuelgauge,
+				int range, int level)
+{
+	int i;
+	int j;
+
+	/* Increase the requested count value, and reset others. */
+	fuelgauge->info.low_batt_comp_cnt[range-1][level/2]++;
+
+	for (i = 0; i < LOW_BATT_COMP_RANGE_NUM; i++) {
+		for (j = 0; j < LOW_BATT_COMP_LEVEL_NUM; j++) {
+			if (i == range-1 && j == level/2)
+				continue;
+			else
+				fuelgauge->info.low_batt_comp_cnt[i][j] = 0;
+		}
+	}
+}
+
+void max77843_prevent_early_poweroff(struct max77843_fuelgauge_data *fuelgauge,
+	int vcell, int *fg_soc)
+{
+	int soc = 0;
+	int read_val;
+
+	soc = max77843_fg_read_soc(fuelgauge);
+
+	/* No need to write REMCAP_REP in below normal cases */
+	if (soc > POWER_OFF_SOC_HIGH_MARGIN ||
+	    vcell > fuelgauge->battery_data->low_battery_comp_voltage)
+		return;
+
+	pr_info("%s: soc=%d, vcell=%d\n", __func__, soc, vcell);
+
+	if (vcell > POWER_OFF_VOLTAGE_HIGH_MARGIN) {
+		read_val = max77843_read_word(fuelgauge->i2c, FULLCAP_REG);
+		/* FullCAP * 0.013 */
+		max77843_write_word(fuelgauge->i2c, REMCAP_REP_REG,
+		(u16)(read_val * 13 / 1000));
+		msleep(200);
+		*fg_soc = max77843_fg_read_soc(fuelgauge);
+		pr_info("%s: new soc=%d, vcell=%d\n", __func__, *fg_soc, vcell);
+	}
+}
+
+void max77843_reset_low_batt_comp_cnt(struct max77843_fuelgauge_data *fuelgauge)
+{
+	memset(fuelgauge->info.low_batt_comp_cnt, 0,
+		sizeof(fuelgauge->info.low_batt_comp_cnt));
+}
+
+static int max77843_check_low_batt_comp_condition(
+	struct max77843_fuelgauge_data *fuelgauge,
+	int *nLevel)
+{
+	int i;
+	int j;
+	int ret = 0;
+
+	for (i = 0; i < LOW_BATT_COMP_RANGE_NUM; i++) {
+		for (j = 0; j < LOW_BATT_COMP_LEVEL_NUM; j++) {
+			if (fuelgauge->info.low_batt_comp_cnt[i][j] >=
+				MAX_LOW_BATT_CHECK_CNT) {
+				max77843_display_low_batt_comp_cnt(fuelgauge);
+				ret = 1;
+				*nLevel = j*2 + 1;
+				break;
+			}
+		}
+	}
+
+	return ret;
+}
+
+static int max77843_get_low_batt_threshold(struct max77843_fuelgauge_data *fuelgauge,
+				int range, int nCurrent, int level)
+{
+	int ret = 0;
+
+	ret = fuelgauge->battery_data->low_battery_table[range][OFFSET] +
+		((nCurrent *
+		fuelgauge->battery_data->low_battery_table[range][SLOPE]) /
+		1000);
+
+	return ret;
+}
+
+int max77843_low_batt_compensation(struct max77843_fuelgauge_data *fuelgauge,
+		int fg_soc, int fg_vcell, int fg_current)
+{
+	int fg_avg_current = 0;
+	int fg_min_current = 0;
+	int new_level = 0;
+	int i, table_size;
+
+	/* Not charging, Under low battery comp voltage */
+	if (fg_vcell <= fuelgauge->battery_data->low_battery_comp_voltage) {
+		fg_avg_current = max77843_fg_read_avg_current(fuelgauge,
+			SEC_BATTEY_CURRENT_MA);
+		fg_min_current = min(fg_avg_current, fg_current);
+
+		table_size =
+			sizeof(fuelgauge->battery_data->low_battery_table) /
+			(sizeof(s16)*TABLE_MAX);
+
+		for (i = 1; i < CURRENT_RANGE_MAX_NUM; i++) {
+			if ((fg_min_current >= fuelgauge->battery_data->
+				low_battery_table[i-1][RANGE]) &&
+				(fg_min_current < fuelgauge->battery_data->
+				low_battery_table[i][RANGE])) {
+				if (fg_soc >= 10 && fg_vcell <
+					max77843_get_low_batt_threshold(fuelgauge,
+					i, fg_min_current, 1)) {
+					max77843_add_low_batt_comp_cnt(
+						fuelgauge, i, 1);
+				} else {
+					max77843_reset_low_batt_comp_cnt(fuelgauge);
+				}
+			}
+		}
+
+		if (max77843_check_low_batt_comp_condition(fuelgauge, &new_level)) {
+			max77843_fg_low_batt_compensation(fuelgauge, new_level);
+			max77843_reset_low_batt_comp_cnt(fuelgauge);
+
+			/* Do not update soc right after
+			 * low battery compensation
+			 * to prevent from powering-off suddenly
+			 */
+			pr_info("%s: SOC is set to %d by low compensation!!\n",
+				__func__, max77843_fg_read_soc(fuelgauge));
+		}
+	}
+
+	/* Prevent power off over 3500mV */
+	max77843_prevent_early_poweroff(fuelgauge, fg_vcell, &fg_soc);
+
+	return fg_soc;
+}
+
+static bool max77843_fuelgauge_recovery_handler(struct max77843_fuelgauge_data *fuelgauge)
+{
+	if (fuelgauge->info.soc < LOW_BATTERY_SOC_REDUCE_UNIT) {
+		fuelgauge->info.is_low_batt_alarm = false;
+	} else {
+		pr_err("%s: Reduce the Reported SOC by 1%%\n",
+			__func__);
+
+		fuelgauge->info.soc -=
+			LOW_BATTERY_SOC_REDUCE_UNIT;
+		pr_err("%s: New Reduced RepSOC (%d)\n",
+			__func__, fuelgauge->info.soc);
+	}
+
+	return fuelgauge->info.is_low_batt_alarm;
+}
+
+static int max77843_get_fuelgauge_soc(struct max77843_fuelgauge_data *fuelgauge)
+{
+	union power_supply_propval value;
+	int fg_soc = 0;
+	int fg_vfsoc;
+	int fg_vcell;
+	int fg_current;
+	int avg_current;
+
+	if (fuelgauge->info.is_low_batt_alarm)
+		if (max77843_fuelgauge_recovery_handler(fuelgauge)) {
+			fg_soc = fuelgauge->info.soc;
+			goto return_soc;
+		}
+
+	fg_soc = max77843_get_fuelgauge_value(fuelgauge, FG_LEVEL);
+	if (fg_soc < 0) {
+		pr_info("Can't read soc!!!");
+		fg_soc = fuelgauge->info.soc;
+	}
+
+	fg_vcell = max77843_get_fuelgauge_value(fuelgauge, FG_VOLTAGE);
+	fg_current = max77843_get_fuelgauge_value(fuelgauge, FG_CURRENT);
+	avg_current = max77843_get_fuelgauge_value(fuelgauge, FG_CURRENT_AVG);
+	fg_vfsoc = max77843_get_fuelgauge_value(fuelgauge, FG_VF_SOC);
+
+	psy_do_property("battery", get,
+		POWER_SUPPLY_PROP_STATUS, value);
+
+	/*  Checks vcell level and tries to compensate SOC if needed.*/
+	/*  If jig cable is connected, then skip low batt compensation check. */
+	if (fuelgauge->pdata->check_jig_status &&
+	    !fuelgauge->pdata->check_jig_status() &&
+		value.intval == POWER_SUPPLY_STATUS_DISCHARGING)
+		fg_soc = max77843_low_batt_compensation(
+			fuelgauge, fg_soc, fg_vcell, fg_current);
+
+	if (fuelgauge->info.is_first_check)
+		fuelgauge->info.is_first_check = false;
+
+	if ((fg_vcell < 3400) && (avg_current < 0) && (fg_soc <= 10))
+		fg_soc = 0;
+
+	fuelgauge->info.soc = fg_soc;
+
+return_soc:
+	pr_debug("%s: soc(%d), low_batt_alarm(%d)\n",
+		__func__, fuelgauge->info.soc,
+		fuelgauge->info.is_low_batt_alarm);
+
+	return fg_soc;
+}
+
+static irqreturn_t max77843_jig_irq_thread(int irq, void *irq_data)
+{
+	struct max77843_fuelgauge_data *fuelgauge = irq_data;
+
+	if (fuelgauge->pdata->check_jig_status &&
+	    fuelgauge->pdata->check_jig_status())
+		max77843_fg_reset_capacity_by_jig_connection(fuelgauge);
+	else
+		pr_info("%s: jig removed\n", __func__);
+	return IRQ_HANDLED;
+}
+
+bool max77843_fg_init(struct max77843_fuelgauge_data *fuelgauge)
+{
+	ktime_t	current_time;
+	struct timespec ts;
+	u8 data[2] = {0, 0};
+
+#if defined(ANDROID_ALARM_ACTIVATED)
+	current_time = alarm_get_elapsed_realtime();
+	ts = ktime_to_timespec(current_time);
+#else
+	current_time = ktime_get_boottime();
+	ts = ktime_to_timespec(current_time);
+#endif
+
+	fuelgauge->info.fullcap_check_interval = ts.tv_sec;
+
+	fuelgauge->info.is_low_batt_alarm = false;
+	fuelgauge->info.is_first_check = true;
+
+	/* Init parameters to prevent wrong compensation. */
+	fuelgauge->info.previous_fullcap =
+		max77843_read_word(fuelgauge->i2c, FULLCAP_REG);
+	fuelgauge->info.previous_vffullcap =
+		max77843_read_word(fuelgauge->i2c, FULLCAP_NOM_REG);
+
+	if (fuelgauge->pdata->check_jig_status &&
+	    fuelgauge->pdata->check_jig_status())
+		max77843_fg_reset_capacity_by_jig_connection(fuelgauge);
+	else {
+		if (fuelgauge->pdata->jig_irq) {
+			int ret;
+			ret = request_threaded_irq(fuelgauge->pdata->jig_irq,
+					NULL, max77843_jig_irq_thread,
+					fuelgauge->pdata->jig_irq_attr,
+					"jig-irq", fuelgauge);
+			if (ret) {
+				pr_info("%s: Failed to Request IRQ\n",
+					__func__);
+			}
+		}
+	}
+
+	/* NOT using FG for temperature */
+	if (fuelgauge->pdata->thermal_source != SEC_BATTERY_THERMAL_SOURCE_FG) {
+		if (max77843_bulk_read(fuelgauge->i2c, CONFIG_REG,
+				       2, data) < 0) {
+			pr_err ("%s : Failed to read CONFIG_REG\n", __func__);
+			return false;
+		}
+		data[1] |= 0x1;
+
+		if (max77843_bulk_write(fuelgauge->i2c, CONFIG_REG,
+					2, data) < 0) {
+			pr_info("%s : Failed to write CONFIG_REG\n", __func__);
+			return false;
+		}
+	}
+
+	return true;
+}
+
+bool max77843_fg_fuelalert_init(struct max77843_fuelgauge_data *fuelgauge,
+				int soc)
+{
+	/* 1. Set max77843 alert configuration. */
+	if (max77843_fg_alert_init(fuelgauge, soc) > 0)
+		return true;
+	else
+		return false;
+}
+
+void max77843_fg_fuelalert_set(struct max77843_fuelgauge_data *fuelgauge,
+			       int enable)
+{
+	u8 config_data[2];
+
+	if (max77843_bulk_read(fuelgauge->i2c, CONFIG_REG,
+			       2, config_data) < 0)
+		pr_err("%s: Failed to read CONFIG_REG\n", __func__);
+
+	if (enable)
+		config_data[0] |= ALERT_EN;
+	else
+		config_data[0] &= ~ALERT_EN;
+
+	pr_info("%s : CONIFG(0x%02x%02x)\n", __func__, config_data[1], config_data[0]);
+
+	if (max77843_bulk_write(fuelgauge->i2c, CONFIG_REG,
+				2, config_data) < 0)
+		pr_info("%s: Failed to write CONFIG_REG\n", __func__);
+
+}
+
+
+bool max77843_fg_fuelalert_process(void *irq_data)
+{
+	struct max77843_fuelgauge_data *fuelgauge =
+		(struct max77843_fuelgauge_data *)irq_data;
+
+	max77843_fg_fuelalert_set(fuelgauge, 0);
+
+	return true;
+}
+
+bool max77843_fg_reset(struct max77843_fuelgauge_data *fuelgauge)
+{
+	if (!max77843_fg_reset_soc(fuelgauge))
+		return true;
+	else
+		return false;
+}
+
+#define CAPACITY_MAX_CONTROL_THRESHOLD 300
+
+static void max77843_fg_get_scaled_capacity(
+	struct max77843_fuelgauge_data *fuelgauge,
+	union power_supply_propval *val)
+{
+	u16 reg_data;
+	union power_supply_propval value;
+
+	psy_do_property("battery", get, POWER_SUPPLY_PROP_ONLINE, value);
+	pr_info("%s : CABLE TYPE(%d)\n", __func__, value.intval);
+
+	if (value.intval != POWER_SUPPLY_TYPE_BATTERY) {
+		int temp, sample;
+		int curr;
+		int topoff;
+		int capacity_threshold;
+		static int cnt;
+
+		curr = max77843_get_fuelgauge_value(fuelgauge, FG_CURRENT_AVG);
+		topoff = fuelgauge->pdata->charging_current[value.intval].full_check_current_1st;
+		capacity_threshold = topoff + CAPACITY_MAX_CONTROL_THRESHOLD;
+
+		pr_info("%s : curr(%d) topoff(%d)\n", __func__, curr, topoff);
+
+		if ((curr < capacity_threshold) && (curr > topoff)) {
+			if (!cnt) {
+				cnt = 1;
+				val->intval = (val->intval < fuelgauge->pdata->capacity_min) ?
+					0 : ((val->intval - fuelgauge->pdata->capacity_min) * 1000 /
+					     (fuelgauge->capacity_max - fuelgauge->pdata->capacity_min));
+				fuelgauge->standard_capacity = val->intval;
+			} else {
+				temp = (val->intval < fuelgauge->pdata->capacity_min) ?
+					0 : ((val->intval - fuelgauge->pdata->capacity_min) * 1000 /
+					     (fuelgauge->capacity_max - fuelgauge->pdata->capacity_min));
+
+				sample = ((capacity_threshold - curr) * (1000 - fuelgauge->standard_capacity)) /
+					(capacity_threshold - topoff);
+
+				pr_info("%s : %d = ((%d - %d) * (1000 - %d)) / (%d - %d)\n",
+					__func__,
+					sample, capacity_threshold, curr, fuelgauge->standard_capacity,
+					capacity_threshold, topoff);
+
+				if ((temp - fuelgauge->standard_capacity) >= sample) {
+					pr_info("%s : TEMP > SAMPLE\n", __func__);
+					val->intval = temp;
+				} else if ((sample - (temp - fuelgauge->standard_capacity)) < 5) {
+					pr_info("%s : TEMP < SAMPLE && GAP UNDER 5\n", __func__);
+					fuelgauge->capacity_max -= (sample - (temp - fuelgauge->standard_capacity));
+					val->intval = (val->intval < fuelgauge->pdata->capacity_min) ?
+						0 : ((val->intval - fuelgauge->pdata->capacity_min) * 1000 /
+						     (fuelgauge->capacity_max - fuelgauge->pdata->capacity_min));
+				} else {
+					pr_info("%s : TEMP > SAMPLE && GAP OVER 5\n", __func__);
+					fuelgauge->capacity_max -= 5;
+					val->intval = (val->intval < fuelgauge->pdata->capacity_min) ?
+						0 : ((val->intval - fuelgauge->pdata->capacity_min) * 1000 /
+						     (fuelgauge->capacity_max - fuelgauge->pdata->capacity_min));
+				}
+
+				pr_info("%s : TEMP(%d) SAMPLE(%d) CPAPCITY_MAX(%d)\n",
+					__func__, temp, sample, fuelgauge->capacity_max);
+			}
+		} else {
+			cnt = 0;
+			val->intval = (val->intval < fuelgauge->pdata->capacity_min) ?
+				0 : ((val->intval - fuelgauge->pdata->capacity_min) * 1000 /
+				     (fuelgauge->capacity_max - fuelgauge->pdata->capacity_min));
+		}
+	} else {
+		val->intval = (val->intval < fuelgauge->pdata->capacity_min) ?
+			0 : ((val->intval - fuelgauge->pdata->capacity_min) * 1000 /
+			     (fuelgauge->capacity_max - fuelgauge->pdata->capacity_min));
+	}
+
+	reg_data = max77843_read_word(fuelgauge->i2c, 0xD0);
+	if (reg_data != fuelgauge->capacity_max) {
+		pr_info("%s : 0xD0 Register Update (%d) -> (%d)\n",
+			__func__, reg_data, fuelgauge->capacity_max);
+		reg_data = fuelgauge->capacity_max;
+		max77843_write_word(fuelgauge->i2c, 0xD0, reg_data);
+	}
+
+	pr_info("%s : PRE SOC(%d), SOC(%d)\n",
+		__func__, fuelgauge->pre_soc, val->intval);
+
+	fuelgauge->pre_soc = val->intval;
+
+	pr_info("%s: scaled capacity (%d.%d)\n",
+		 __func__, val->intval/10, val->intval%10);
+}
+
+/* capacity is integer */
+static void max77843_fg_get_atomic_capacity(
+	struct max77843_fuelgauge_data *fuelgauge,
+	union power_supply_propval *val)
+{
+
+	pr_info("%s : NOW(%d), OLD(%d)\n",
+		__func__, val->intval, fuelgauge->capacity_old);
+
+	if (fuelgauge->pdata->capacity_calculation_type &
+		SEC_FUELGAUGE_CAPACITY_TYPE_ATOMIC) {
+	if (fuelgauge->capacity_old < val->intval)
+		val->intval = fuelgauge->capacity_old + 1;
+	else if (fuelgauge->capacity_old > val->intval)
+		val->intval = fuelgauge->capacity_old - 1;
+	}
+
+	/* keep SOC stable in abnormal status */
+	if (fuelgauge->pdata->capacity_calculation_type &
+		SEC_FUELGAUGE_CAPACITY_TYPE_SKIP_ABNORMAL) {
+		if (!fuelgauge->is_charging &&
+			fuelgauge->capacity_old < val->intval) {
+			pr_err("%s: capacity (old %d : new %d)\n",
+				__func__, fuelgauge->capacity_old, val->intval);
+			val->intval = fuelgauge->capacity_old;
+		}
+	}
+
+	/* updated old capacity */
+	fuelgauge->capacity_old = val->intval;
+}
+
+static int max77843_fg_calculate_dynamic_scale(
+	struct max77843_fuelgauge_data *fuelgauge, int capacity)
+{
+	union power_supply_propval raw_soc_val;
+	raw_soc_val.intval = max77843_get_fuelgauge_value(fuelgauge,
+						 FG_RAW_SOC) / 10;
+
+	if (raw_soc_val.intval <
+		fuelgauge->pdata->capacity_max -
+		fuelgauge->pdata->capacity_max_margin) {
+		fuelgauge->capacity_max =
+			fuelgauge->pdata->capacity_max -
+			fuelgauge->pdata->capacity_max_margin;
+		pr_debug("%s: capacity_max (%d)", __func__,
+			 fuelgauge->capacity_max);
+	} else {
+		fuelgauge->capacity_max =
+			(raw_soc_val.intval >
+			fuelgauge->pdata->capacity_max +
+			fuelgauge->pdata->capacity_max_margin) ?
+			(fuelgauge->pdata->capacity_max +
+			fuelgauge->pdata->capacity_max_margin) :
+			raw_soc_val.intval;
+		pr_debug("%s: raw soc (%d)", __func__,
+			 fuelgauge->capacity_max);
+	}
+
+	if (capacity != 100) {
+		fuelgauge->capacity_max =
+			(fuelgauge->capacity_max * 100 / capacity);
+		fuelgauge->capacity_old = capacity;
+	} else {
+		fuelgauge->capacity_max =
+			(fuelgauge->capacity_max * 99 / 100);
+		fuelgauge->capacity_old = 100;
+	}
+
+	pr_info("%s: %d is used for capacity_max, capacity(%d)\n",
+		__func__, fuelgauge->capacity_max, capacity);
+
+	return fuelgauge->capacity_max;
+}
+
+static void max77843_fg_check_qrtable(struct max77843_fuelgauge_data *fuelgauge)
+{
+	u16 qrtable20, qrtable30;
+
+	qrtable20 = max77843_read_word(fuelgauge->i2c, QRTABLE20_REG);
+	if (qrtable20 != fuelgauge->battery_data->QResidual20) {
+		if (max77843_write_word(fuelgauge->i2c, QRTABLE20_REG,
+			fuelgauge->battery_data->QResidual20) < 0)
+			pr_err("%s: Failed to write QRTABLE20\n", __func__);
+	}
+	qrtable30 = max77843_read_word(fuelgauge->i2c, QRTABLE30_REG);
+	if (qrtable30 != fuelgauge->battery_data->QResidual30) {
+		if (max77843_write_word(fuelgauge->i2c, QRTABLE30_REG,
+			fuelgauge->battery_data->QResidual30) < 0)
+			pr_err("%s: Failed to write QRTABLE30\n", __func__);
+	}
+	pr_info("%s: QRTABLE20_REG(0x%04x), QRTABLE30_REG(0x%04x)\n", __func__,
+		qrtable20, qrtable30);
+}
+
+#if defined(CONFIG_EN_OOPS)
+static void max77843_set_full_value(struct max77843_fuelgauge_data *fuelgauge,
+				    int cable_type)
+{
+	u16 ichgterm, misccfg, fullsocthr;
+
+	if ((cable_type == POWER_SUPPLY_TYPE_HV_MAINS) ||
+	    (cable_type == POWER_SUPPLY_TYPE_HV_ERR)) {
+		ichgterm = fuelgauge->battery_data->ichgterm_2nd;
+		misccfg = fuelgauge->battery_data->misccfg_2nd;
+		fullsocthr = fuelgauge->battery_data->fullsocthr_2nd;
+	} else {
+		ichgterm = fuelgauge->battery_data->ichgterm;
+		misccfg = fuelgauge->battery_data->misccfg;
+		fullsocthr = fuelgauge->battery_data->fullsocthr;
+	}
+
+	max77843_write_word(fuelgauge->i2c, ICHGTERM_REG, ichgterm);
+	max77843_write_word(fuelgauge->i2c, MISCCFG_REG, misccfg);
+	max77843_write_word(fuelgauge->i2c, FULLSOCTHR_REG, fullsocthr);
+
+	pr_info("%s : ICHGTERM(0x%04x) FULLSOCTHR(0x%04x), MISCCFG(0x%04x)\n",
+		__func__, ichgterm, misccfg, fullsocthr);
+}
+#endif
+
+static int max77843_fg_get_property(struct power_supply *psy,
+			     enum power_supply_property psp,
+			     union power_supply_propval *val)
+{
+	struct max77843_fuelgauge_data *fuelgauge =
+		container_of(psy, struct max77843_fuelgauge_data, psy_fg);
+	static int abnormal_current_cnt = 0;
+	union power_supply_propval value;
+
+	pr_info("%s : %d(%d)\n", __func__, psp, val->intval);
+
+	switch (psp) {
+		/* Cell voltage (VCELL, mV) */
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = max77843_get_fuelgauge_value(fuelgauge, FG_VOLTAGE);
+		break;
+		/* Additional Voltage Information (mV) */
+	case POWER_SUPPLY_PROP_VOLTAGE_AVG:
+		switch (val->intval) {
+		case SEC_BATTEY_VOLTAGE_OCV:
+			val->intval = max77843_fg_read_vfocv(fuelgauge);
+			break;
+		case SEC_BATTEY_VOLTAGE_AVERAGE:
+		default:
+			val->intval = max77843_fg_read_avg_vcell(fuelgauge);
+			break;
+		}
+		break;
+		/* Current */
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		switch (val->intval) {
+		case SEC_BATTEY_CURRENT_UA:
+			val->intval =
+				max77843_fg_read_current(fuelgauge,
+						SEC_BATTEY_CURRENT_UA);
+			break;
+		case SEC_BATTEY_CURRENT_MA:
+		default:
+			val->intval = max77843_get_fuelgauge_value(fuelgauge,
+							  FG_CURRENT);
+			psy_do_property("battery", get,
+					POWER_SUPPLY_PROP_STATUS, value);
+			/* To save log for abnormal case */
+			if (value.intval == POWER_SUPPLY_STATUS_DISCHARGING && val->intval > 0) {
+				abnormal_current_cnt++;
+				if (abnormal_current_cnt >= 5) {
+					pr_info("%s : Inow is increasing in not charging status\n",
+						__func__);
+					value.intval = fuelgauge->capacity_old + 15;
+					psy_do_property("battery", set,
+							POWER_SUPPLY_PROP_CAPACITY, value);
+					abnormal_current_cnt = 0;
+					value.intval = fuelgauge->capacity_old;
+					psy_do_property("battery", set,
+							POWER_SUPPLY_PROP_CAPACITY, value);
+				}
+			} else {
+				abnormal_current_cnt = 0;
+			}
+			break;
+		}
+		break;
+		/* Average Current */
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+		switch (val->intval) {
+		case SEC_BATTEY_CURRENT_UA:
+			val->intval =
+				max77843_fg_read_avg_current(fuelgauge,
+						    SEC_BATTEY_CURRENT_UA);
+			break;
+		case SEC_BATTEY_CURRENT_MA:
+		default:
+			val->intval =
+				max77843_get_fuelgauge_value(fuelgauge,
+						    FG_CURRENT_AVG);
+			break;
+		}
+		break;
+		/* Full Capacity */
+	case POWER_SUPPLY_PROP_ENERGY_NOW:
+		switch (val->intval) {
+		case SEC_BATTEY_CAPACITY_DESIGNED:
+			val->intval = max77843_get_fuelgauge_value(fuelgauge,
+							  FG_FULLCAP);
+			break;
+		case SEC_BATTEY_CAPACITY_ABSOLUTE:
+			val->intval = max77843_get_fuelgauge_value(fuelgauge,
+							  FG_MIXCAP);
+			break;
+		case SEC_BATTEY_CAPACITY_TEMPERARY:
+			val->intval = max77843_get_fuelgauge_value(fuelgauge,
+							  FG_AVCAP);
+			break;
+		case SEC_BATTEY_CAPACITY_CURRENT:
+			val->intval = max77843_get_fuelgauge_value(fuelgauge,
+							  FG_REPCAP);
+			break;
+		}
+		break;
+		/* SOC (%) */
+	case POWER_SUPPLY_PROP_CAPACITY:
+		if (val->intval == SEC_FUELGAUGE_CAPACITY_TYPE_RAW) {
+			val->intval = max77843_get_fuelgauge_value(fuelgauge,
+							  FG_RAW_SOC);
+		} else {
+			val->intval = max77843_get_fuelgauge_soc(fuelgauge);
+
+			if (fuelgauge->pdata->capacity_calculation_type &
+			    (SEC_FUELGAUGE_CAPACITY_TYPE_SCALE |
+			     SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE))
+				max77843_fg_get_scaled_capacity(fuelgauge, val);
+
+			/* capacity should be between 0% and 100%
+			 * (0.1% degree)
+			 */
+			if (val->intval > 1000)
+				val->intval = 1000;
+			if (val->intval < 0)
+				val->intval = 0;
+
+			/* get only integer part */
+			val->intval /= 10;
+
+			/* check whether doing the wake_unlock */
+			if ((val->intval > fuelgauge->pdata->fuel_alert_soc) &&
+			    fuelgauge->is_fuel_alerted) {
+				wake_unlock(&fuelgauge->fuel_alert_wake_lock);
+				max77843_fg_fuelalert_init(fuelgauge,
+					  fuelgauge->pdata->fuel_alert_soc);
+			}
+
+			/* (Only for atomic capacity)
+			 * In initial time, capacity_old is 0.
+			 * and in resume from sleep,
+			 * capacity_old is too different from actual soc.
+			 * should update capacity_old
+			 * by val->intval in booting or resume.
+			 */
+			if (fuelgauge->initial_update_of_soc) {
+				/* updated old capacity */
+				fuelgauge->capacity_old = val->intval;
+				fuelgauge->initial_update_of_soc = false;
+				break;
+			}
+
+			if (fuelgauge->pdata->capacity_calculation_type &
+			    (SEC_FUELGAUGE_CAPACITY_TYPE_ATOMIC |
+			     SEC_FUELGAUGE_CAPACITY_TYPE_SKIP_ABNORMAL))
+				max77843_fg_get_atomic_capacity(fuelgauge, val);
+		}
+		break;
+		/* Battery Temperature */
+	case POWER_SUPPLY_PROP_TEMP:
+		/* Target Temperature */
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		val->intval = max77843_get_fuelgauge_value(fuelgauge,
+						  FG_TEMPERATURE);
+		break;
+#if defined(CONFIG_EN_OOPS)
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+		return -ENODATA;
+#endif
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int max77843_fg_set_property(struct power_supply *psy,
+			     enum power_supply_property psp,
+			     const union power_supply_propval *val)
+{
+	struct max77843_fuelgauge_data *fuelgauge =
+		container_of(psy, struct max77843_fuelgauge_data, psy_fg);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+		if (fuelgauge->pdata->capacity_calculation_type &
+			SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE) {
+#if defined(CONFIG_AFC_CHARGER_MODE)
+		max77843_fg_calculate_dynamic_scale(fuelgauge, val->intval);
+#else
+		max77843_fg_calculate_dynamic_scale(fuelgauge, 100);
+#endif
+		}
+		break;
+#if defined(CONFIG_EN_OOPS)
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+		max77843_set_full_value(fuelgauge, val->intval);
+		break;
+#endif
+	case POWER_SUPPLY_PROP_ONLINE:
+		fuelgauge->cable_type = val->intval;
+		if (val->intval == POWER_SUPPLY_TYPE_BATTERY) {
+			fuelgauge->is_charging = false;
+		} else {
+			fuelgauge->is_charging = true;
+
+			if (fuelgauge->info.is_low_batt_alarm) {
+				pr_info("%s: Reset low_batt_alarm\n",
+					 __func__);
+				fuelgauge->info.is_low_batt_alarm = false;
+			}
+
+			max77843_reset_low_batt_comp_cnt(fuelgauge);
+		}
+		break;
+		/* Battery Temperature */
+	case POWER_SUPPLY_PROP_CAPACITY:
+		if (val->intval == SEC_FUELGAUGE_CAPACITY_TYPE_RESET) {
+			fuelgauge->initial_update_of_soc = true;
+			if (!max77843_fg_reset(fuelgauge))
+				return -EINVAL;
+			else
+				break;
+		}
+	case POWER_SUPPLY_PROP_TEMP:
+		max77843_fg_write_temp(fuelgauge, val->intval);
+		max77843_fg_check_qrtable(fuelgauge);
+		break;
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		break;
+	case POWER_SUPPLY_PROP_ENERGY_NOW:
+		max77843_fg_reset_capacity_by_jig_connection(fuelgauge);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static void max77843_fg_isr_work(struct work_struct *work)
+{
+	struct max77843_fuelgauge_data *fuelgauge =
+		container_of(work, struct max77843_fuelgauge_data, isr_work.work);
+
+	/* process for fuel gauge chip */
+	max77843_fg_fuelalert_process(fuelgauge);
+
+	wake_unlock(&fuelgauge->fuel_alert_wake_lock);
+}
+
+static irqreturn_t max77843_fg_irq_thread(int irq, void *irq_data)
+{
+	struct max77843_fuelgauge_data *fuelgauge = irq_data;
+
+	max77843_update_reg(fuelgauge->pmic,
+			    MAX77843_PMIC_REG_INTSRC_MASK,
+			    MAX77843_IRQSRC_FG,
+			    MAX77843_IRQSRC_FG);
+
+	pr_info("%s\n", __func__);
+
+	if (fuelgauge->is_fuel_alerted) {
+		return IRQ_HANDLED;
+	} else {
+		wake_lock(&fuelgauge->fuel_alert_wake_lock);
+		fuelgauge->is_fuel_alerted = true;
+		schedule_delayed_work(&fuelgauge->isr_work, 0);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int max77843_fuelgauge_debugfs_show(struct seq_file *s, void *data)
+{
+	struct max77843_fuelgauge_data *fuelgauge = s->private;
+	int i;
+	u8 reg;
+	u8 reg_data;
+
+	seq_printf(s, "MAX77843 FUELGAUGE IC :\n");
+	seq_printf(s, "===================\n");
+	for (i = 0; i < 16; i++) {
+		if (i == 12)
+			continue;
+		for (reg = 0; reg < 0x10; reg++) {
+			reg_data = max77843_read_word(fuelgauge->i2c, reg + i * 0x10);
+			seq_printf(s, "0x%02x:\t0x%04x\n", reg + i * 0x10, reg_data);
+		}
+		if (i == 4)
+			i = 10;
+	}
+	seq_printf(s, "\n");
+	return 0;
+}
+
+static int max77843_fuelgauge_debugfs_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, max77843_fuelgauge_debugfs_show, inode->i_private);
+}
+
+static const struct file_operations max77843_fuelgauge_debugfs_fops = {
+	.open           = max77843_fuelgauge_debugfs_open,
+	.read           = seq_read,
+	.llseek         = seq_lseek,
+	.release        = single_release,
+};
+
+#ifdef CONFIG_OF
+static int max77843_fuelgauge_parse_dt(struct max77843_fuelgauge_data *fuelgauge)
+{
+	struct device_node *np = of_find_node_by_name(NULL, "max77843-fuelgauge");
+	sec_battery_platform_data_t *pdata = fuelgauge->pdata;
+	int ret;
+	int i, len;
+	const u32 *p;
+
+	/* reset, irq gpio info */
+	if (np == NULL) {
+		pr_err("%s np NULL\n", __func__);
+	} else {
+		ret = of_property_read_u32(np, "fuelgauge,capacity_max",
+				&pdata->capacity_max);
+		if (ret < 0)
+			pr_err("%s error reading capacity_max %d\n", __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_max_hv",
+				&pdata->capacity_max_hv);
+		if (ret < 0) {
+			pr_err("%s error reading capacity_max_hv %d\n", __func__, ret);
+			fuelgauge->pdata->capacity_max_hv = fuelgauge->pdata->capacity_max;
+		}
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_max_margin",
+				&pdata->capacity_max_margin);
+		if (ret < 0)
+			pr_err("%s error reading capacity_max_margin %d\n", __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_min",
+				&pdata->capacity_min);
+		if (ret < 0)
+			pr_err("%s error reading capacity_min %d\n", __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_calculation_type",
+				&pdata->capacity_calculation_type);
+		if (ret < 0)
+			pr_err("%s error reading capacity_calculation_type %d\n",
+					__func__, ret);
+		ret = of_property_read_u32(np, "fuelgauge,fuel_alert_soc",
+				&pdata->fuel_alert_soc);
+		if (ret < 0)
+			pr_err("%s error reading pdata->fuel_alert_soc %d\n",
+					__func__, ret);
+		pdata->repeated_fuelalert = of_property_read_bool(np,
+				"fuelgauge,repeated_fuelalert");
+
+		ret = of_property_read_u32(np, "fuelgauge,qrtable20",
+					   &fuelgauge->battery_data->QResidual20);
+		if (ret < 0)
+			pr_err("%s error reading qrtable20 %d\n",
+					__func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,qrtable30",
+					   &fuelgauge->battery_data->QResidual30);
+		if (ret < 0)
+			pr_err("%s error reading qrtabel30 %d\n",
+					__func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,ichgterm",
+					   &fuelgauge->battery_data->ichgterm);
+		if (ret < 0)
+			pr_err("%s error reading ichgterm %d\n",
+					__func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,ichgterm_2nd",
+					   &fuelgauge->battery_data->ichgterm_2nd);
+		if (ret < 0)
+			pr_err("%s error reading ichgterm_2nd %d\n",
+					__func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,misccfg",
+					   &fuelgauge->battery_data->misccfg);
+		if (ret < 0)
+			pr_err("%s error reading misccfg %d\n",
+					__func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,misccfg_2nd",
+					   &fuelgauge->battery_data->misccfg_2nd);
+		if (ret < 0)
+			pr_err("%s error reading misccfg_2nd %d\n",
+					__func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,fullsocthr",
+					   &fuelgauge->battery_data->fullsocthr);
+		if (ret < 0)
+			pr_err("%s error reading fullsocthr %d\n",
+					__func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,fullsocthr_2nd",
+					   &fuelgauge->battery_data->fullsocthr_2nd);
+		if (ret < 0)
+			pr_err("%s error reading fullsocthr_2nd %d\n",
+					__func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity",
+					   &fuelgauge->battery_data->Capacity);
+		if (ret < 0)
+			pr_err("%s error reading capacity_calculation_type %d\n",
+					__func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,low_battery_comp_voltage",
+			   &fuelgauge->battery_data->low_battery_comp_voltage);
+		if (ret < 0)
+			pr_err("%s error reading capacity_calculation_type %d\n",
+					__func__, ret);
+
+		for(i = 0; i < (CURRENT_RANGE_MAX_NUM * TABLE_MAX); i++) {
+			ret = of_property_read_u32_index(np,
+					 "fuelgauge,low_battery_table",
+					 i,
+					 &fuelgauge->battery_data->low_battery_table[i/3][i%3]);
+			pr_info("[%d]",
+				fuelgauge->battery_data->low_battery_table[i/3][i%3]);
+			if ((i%3) == 2)
+				pr_info("\n");
+		}
+
+		np = of_find_node_by_name(NULL, "battery");
+		ret = of_property_read_u32(np, "battery,thermal_source",
+					   &pdata->thermal_source);
+		if (ret < 0) {
+			pr_err("%s error reading pdata->thermal_source %d\n",
+			       __func__, ret);
+		}
+
+		p = of_get_property(np, "battery,input_current_limit", &len);
+		if (!p)
+			return 1;
+		len = len / sizeof(u32);
+
+		pdata->charging_current = kzalloc(sizeof(sec_charging_current_t) * len,
+						  GFP_KERNEL);
+
+		for(i = 0; i < len; i++) {
+			ret = of_property_read_u32_index(np,
+				 "battery,input_current_limit", i,
+				 &pdata->charging_current[i].input_current_limit);
+			ret = of_property_read_u32_index(np,
+				 "battery,fast_charging_current", i,
+				 &pdata->charging_current[i].fast_charging_current);
+			ret = of_property_read_u32_index(np,
+				 "battery,full_check_current_1st", i,
+				 &pdata->charging_current[i].full_check_current_1st);
+			ret = of_property_read_u32_index(np,
+				 "battery,full_check_current_2nd", i,
+				 &pdata->charging_current[i].full_check_current_2nd);
+		}
+
+		pr_info("%s fg_irq: %d, capacity_max: %d\n"
+			"qrtable20: 0x%x, qrtable30 : 0x%x\n"
+			"cpacity_max_margin: %d, capacity_min: %d\n"
+			"calculation_type: 0x%x, fuel_alert_soc: %d,\n"
+			"repeated_fuelalert: %d\n",
+			__func__, pdata->fg_irq, pdata->capacity_max,
+			fuelgauge->battery_data->QResidual20,
+			fuelgauge->battery_data->QResidual30,
+			pdata->capacity_max_margin, pdata->capacity_min,
+			pdata->capacity_calculation_type, pdata->fuel_alert_soc,
+			pdata->repeated_fuelalert);
+	}
+
+	pr_info("[%s][%d][%d]\n",
+		__func__, fuelgauge->battery_data->Capacity,
+	        fuelgauge->battery_data->low_battery_comp_voltage);
+
+	return 0;
+}
+#endif
+
+static int __devinit max77843_fuelgauge_probe(struct platform_device *pdev)
+{
+	struct max77843_dev *max77843 = dev_get_drvdata(pdev->dev.parent);
+	struct max77843_platform_data *pdata = dev_get_platdata(max77843->dev);
+	struct max77843_fuelgauge_data *fuelgauge;
+	int ret = 0;
+	union power_supply_propval raw_soc_val;
+	u16 reg_data;
+
+	pr_info("%s: MAX77843 Fuelgauge Driver Loading\n", __func__);
+
+	fuelgauge = kzalloc(sizeof(*fuelgauge), GFP_KERNEL);
+	if (!fuelgauge)
+		return -ENOMEM;
+
+	pdata->fuelgauge_data = kzalloc(sizeof(sec_battery_platform_data_t), GFP_KERNEL);
+	if (!pdata->fuelgauge_data) {
+		ret = -ENOMEM;
+		goto err_free;
+	}
+
+	mutex_init(&fuelgauge->fg_lock);
+
+	fuelgauge->dev = &pdev->dev;
+	fuelgauge->pdata = pdata->fuelgauge_data;
+	fuelgauge->i2c = max77843->fuelgauge;
+	fuelgauge->pmic = max77843->i2c;
+	fuelgauge->max77843_pdata = pdata;
+
+#if defined(CONFIG_OF)
+	fuelgauge->battery_data = kzalloc(sizeof(struct battery_data_t),
+					  GFP_KERNEL);
+	if(!fuelgauge->battery_data) {
+		pr_err("Failed to allocate memory\n");
+		ret = -ENOMEM;
+		goto err_pdata_free;
+	}
+	ret = max77843_fuelgauge_parse_dt(fuelgauge);
+	if (ret < 0) {
+		pr_err("%s not found charger dt! ret[%d]\n",
+		       __func__, ret);
+	}
+#endif
+
+	platform_set_drvdata(pdev, fuelgauge);
+
+	fuelgauge->psy_fg.name		= "max77843-fuelgauge";
+	fuelgauge->psy_fg.type		= POWER_SUPPLY_TYPE_UNKNOWN;
+	fuelgauge->psy_fg.get_property	= max77843_fg_get_property;
+	fuelgauge->psy_fg.set_property	= max77843_fg_set_property;
+	fuelgauge->psy_fg.properties	= max77843_fuelgauge_props;
+	fuelgauge->psy_fg.num_properties =
+		ARRAY_SIZE(max77843_fuelgauge_props);
+	fuelgauge->capacity_max = fuelgauge->pdata->capacity_max;
+	raw_soc_val.intval = max77843_get_fuelgauge_value(fuelgauge, FG_RAW_SOC) / 10;
+
+	reg_data = max77843_read_word(fuelgauge->i2c, 0xD0);
+
+	if (reg_data >= 900 && reg_data <= 1000 && reg_data != fuelgauge->capacity_max) {
+		pr_info("%s : Capacity Max Update (%d) -> (%d)\n",
+			__func__, fuelgauge->capacity_max, reg_data);
+		fuelgauge->capacity_max = reg_data;
+	} else {
+		pr_info("%s : 0xD0 Register Update (%d) -> (%d)\n",
+			__func__, reg_data, fuelgauge->capacity_max);
+		reg_data = fuelgauge->capacity_max;
+		max77843_write_word(fuelgauge->i2c, 0xD0, reg_data);
+	}
+
+	if (raw_soc_val.intval > fuelgauge->capacity_max)
+		max77843_fg_calculate_dynamic_scale(fuelgauge, 100);
+
+	(void) debugfs_create_file("max77843-fuelgauge-regs",
+		S_IRUGO, NULL, (void *)fuelgauge, &max77843_fuelgauge_debugfs_fops);
+
+	if (!max77843_fg_init(fuelgauge)) {
+		pr_err("%s: Failed to Initialize Fuelgauge\n", __func__);
+		goto err_data_free;
+	}
+
+	ret = power_supply_register(&pdev->dev, &fuelgauge->psy_fg);
+	if (ret) {
+		pr_err("%s: Failed to Register psy_fg\n", __func__);
+		goto err_data_free;
+	}
+
+	fuelgauge->fg_irq = pdata->irq_base + MAX77843_FG_IRQ_ALERT;
+	pr_info("[%s]IRQ_BASE(%d) FG_IRQ(%d)\n",
+		__func__, pdata->irq_base, fuelgauge->fg_irq);
+
+	fuelgauge->is_fuel_alerted = false;
+	if (fuelgauge->pdata->fuel_alert_soc >= 0) {
+		if (max77843_fg_fuelalert_init(fuelgauge,
+				       fuelgauge->pdata->fuel_alert_soc)) {
+			wake_lock_init(&fuelgauge->fuel_alert_wake_lock,
+				       WAKE_LOCK_SUSPEND, "fuel_alerted");
+			if (fuelgauge->fg_irq) {
+				INIT_DELAYED_WORK(&fuelgauge->isr_work, max77843_fg_isr_work);
+
+				ret = request_threaded_irq(fuelgauge->fg_irq,
+					   NULL, max77843_fg_irq_thread,
+					   IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+					   "fuelgauge-irq", fuelgauge);
+				if (ret) {
+					pr_err("%s: Failed to Request IRQ\n", __func__);
+					goto err_supply_unreg;
+				}
+			}
+		} else {
+			pr_err("%s: Failed to Initialize Fuel-alert\n",
+			       __func__);
+			goto err_supply_unreg;
+		}
+	}
+
+	fuelgauge->initial_update_of_soc = true;
+
+	pr_info("%s: MAX77843 Fuelgauge Driver Loaded\n", __func__);
+	return 0;
+
+err_supply_unreg:
+	power_supply_unregister(&fuelgauge->psy_fg);
+err_data_free:
+#if defined(CONFIG_OF)
+	kfree(fuelgauge->battery_data);
+#endif
+err_pdata_free:
+	kfree(pdata->fuelgauge_data);
+	mutex_destroy(&fuelgauge->fg_lock);
+err_free:
+	kfree(fuelgauge);
+
+	return ret;
+}
+
+static int __devexit max77843_fuelgauge_remove(struct platform_device *pdev)
+{
+	struct max77843_fuelgauge_data *fuelgauge =
+		platform_get_drvdata(pdev);
+
+	if (fuelgauge->pdata->fuel_alert_soc >= 0)
+		wake_lock_destroy(&fuelgauge->fuel_alert_wake_lock);
+
+	return 0;
+}
+
+static int max77843_fuelgauge_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int max77843_fuelgauge_resume(struct device *dev)
+{
+	struct max77843_fuelgauge_data *fuelgauge = dev_get_drvdata(dev);
+
+	fuelgauge->initial_update_of_soc = true;
+
+	return 0;
+}
+
+static void max77843_fuelgauge_shutdown(struct device *dev)
+{
+}
+
+static SIMPLE_DEV_PM_OPS(max77843_fuelgauge_pm_ops, max77843_fuelgauge_suspend,
+			 max77843_fuelgauge_resume);
+
+static struct platform_driver max77843_fuelgauge_driver = {
+	.driver = {
+		   .name = "max77843-fuelgauge",
+		   .owner = THIS_MODULE,
+#ifdef CONFIG_PM
+		   .pm = &max77843_fuelgauge_pm_ops,
+#endif
+		.shutdown = max77843_fuelgauge_shutdown,
+	},
+	.probe	= max77843_fuelgauge_probe,
+	.remove	= __devexit_p(max77843_fuelgauge_remove),
+};
+
+static int __init max77843_fuelgauge_init(void)
+{
+	pr_info("%s: \n", __func__);
+	return platform_driver_register(&max77843_fuelgauge_driver);
+}
+
+static void __exit max77843_fuelgauge_exit(void)
+{
+	platform_driver_unregister(&max77843_fuelgauge_driver);
+}
+module_init(max77843_fuelgauge_init);
+module_exit(max77843_fuelgauge_exit);
+
+MODULE_DESCRIPTION("Samsung MAX77843 Fuel Gauge Driver");
+MODULE_AUTHOR("Samsung Electronics");
+MODULE_LICENSE("GPL");
diff -Naur linux-3.18.14/drivers/battery/s2mu003_charger.c samsung/drivers/battery/s2mu003_charger.c
--- linux-3.18.14/drivers/battery/s2mu003_charger.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery/s2mu003_charger.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,1124 @@
+/* drivers/battery/s2mu003_charger.c
+ * S2MU003 Charger Driver
+ *
+ * Copyright (C) 2013
+ * Author: Patrick Chang <patrick_chang@richtek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ */
+
+#include <linux/mfd/samsung/s2mu003.h>
+#include <linux/battery/charger/s2mu003_charger.h>
+#include <linux/version.h>
+
+#define ENABLE_MIVR 0
+
+#define EN_OVP_IRQ 1
+#define EN_IEOC_IRQ 1
+#define EN_RECHG_REQ_IRQ 0
+#define EN_TR_IRQ 0
+#define EN_MIVR_SW_REGULATION 0
+#define EN_BST_IRQ 0
+#define MINVAL(a, b) ((a <= b) ? a : b)
+
+#define EOC_DEBOUNCE_CNT 2
+#define HEALTH_DEBOUNCE_CNT 3
+
+#define EOC_SLEEP 200
+#define EOC_TIMEOUT (EOC_SLEEP * 6)
+#ifndef EN_TEST_READ
+#define EN_TEST_READ 0
+#endif
+
+static int s2mu003_reg_map[] = {
+	S2MU003_CHG_STATUS1,
+	S2MU003_CHG_CTRL1,
+	S2MU003_CHG_CTRL2,
+	S2MU003_CHG_CTRL3,
+	S2MU003_CHG_CTRL4,
+	S2MU003_CHG_CTRL5,
+	S2MU003_SOFTRESET,
+	S2MU003_CHG_CTRL6,
+	S2MU003_CHG_CTRL7,
+	S2MU003_CHG_CTRL8,
+	S2MU003_CHG_STATUS2,
+	S2MU003_CHG_STATUS3,
+	S2MU003_CHG_STATUS4,
+	S2MU003_CHG_CTRL9,
+};
+
+struct s2mu003_charger_data {
+	struct i2c_client       *client;
+	s2mu003_mfd_chip_t	*s2mu003;
+	struct power_supply	psy_chg;
+	s2mu003_charger_platform_data_t *pdata;
+	int charging_current;
+	int siop_level;
+	int cable_type;
+	bool is_charging;
+	struct mutex io_lock;
+
+	/* register programming */
+	int reg_addr;
+	int reg_data;
+
+	bool full_charged;
+	bool ovp;
+	int unhealth_cnt;
+	int status;
+};
+
+static enum power_supply_property sec_charger_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_CHARGE_TYPE,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_CURRENT_MAX,
+	POWER_SUPPLY_PROP_CURRENT_AVG,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL,
+};
+
+static int s2mu003_get_charging_health(struct s2mu003_charger_data *charger);
+
+static void s2mu003_read_regs(struct i2c_client *i2c, char *str)
+{
+	u8 data = 0;
+	int i = 0;
+	for (i = 0; i < ARRAY_SIZE(s2mu003_reg_map); i++) {
+		data = s2mu003_reg_read(i2c, s2mu003_reg_map[i]);
+		sprintf(str+strlen(str), "0x%02x, ", data);
+	}
+}
+
+static void s2mu003_test_read(struct i2c_client *i2c)
+{
+	int data;
+	char str[1024] = {0,};
+	int i;
+
+	/* S2MU003 REG: 0x00 ~ 0x08 */
+	for (i = 0x0; i <= 0x0E; i++) {
+		data = s2mu003_reg_read(i2c, i);
+		sprintf(str+strlen(str), "0x%02x, ", data);
+	}
+
+	pr_info("%s: %s\n", __func__, str);
+}
+
+static void s2mu003_charger_otg_control(struct s2mu003_charger_data *charger,
+		bool enable)
+{
+	pr_info("%s: called charger otg control : %s\n", __func__,
+			enable ? "on" : "off");
+
+	if (!enable) {
+		/* turn off OTG */
+		s2mu003_clr_bits(charger->client, S2MU003_CHG_CTRL1, S2MU003_OPAMODE_MASK);
+		s2mu003_clr_bits(charger->client, S2MU003_CHG_CTRL8, 0x80);
+	} else {
+		/* Set OTG boost vout = 5V, turn on OTG */
+		s2mu003_assign_bits(charger->client,
+				S2MU003_CHG_CTRL2, S2MU003_VOREG_MASK,
+				0x23 << S2MU003_VOREG_SHIFT);
+		s2mu003_set_bits(charger->client,
+				S2MU003_CHG_CTRL1, S2MU003_OPAMODE_MASK);
+		s2mu003_set_bits(charger->client, S2MU003_CHG_CTRL8, 0x80);
+		charger->cable_type = POWER_SUPPLY_TYPE_OTG;
+	}
+}
+
+/* this function will work well on CHIP_REV = 3 or later */
+static void s2mu003_enable_charger_switch(struct s2mu003_charger_data *charger,
+		int onoff)
+{
+	int prev_charging_status = charger->is_charging;
+	union power_supply_propval val;
+
+	charger->is_charging = onoff ? true : false;
+	if ((onoff > 0) && (prev_charging_status == false)) {
+		pr_info("%s: turn on charger\n", __func__);
+		s2mu003_set_bits(charger->client, S2MU003_CHG_CTRL3, S2MU003_CHG_EN_MASK);
+	} else if (onoff == 0) {
+		psy_do_property("battery", get,
+				POWER_SUPPLY_PROP_STATUS, val);
+		if (val.intval != POWER_SUPPLY_STATUS_FULL)
+			charger->full_charged = false;
+		pr_info("%s: turn off charger\n", __func__);
+		charger->charging_current = 0;
+		s2mu003_clr_bits(charger->client, S2MU003_CHG_CTRL3, S2MU003_CHG_EN_MASK);
+	} else {
+		pr_info("%s: repeated to set charger switch(%d), prev stat = %d\n",
+				__func__, onoff, prev_charging_status ? 1 : 0);
+	}
+}
+
+static void s2mu003_enable_charging_termination(struct i2c_client *i2c,
+		int onoff)
+{
+	pr_info("%s:[BATT] Do termination set(%d)\n", __func__, onoff);
+	if (onoff)
+		s2mu003_set_bits(i2c, S2MU003_CHG_CTRL1, S2MU003_TEEN_MASK);
+	else
+		s2mu003_clr_bits(i2c, S2MU003_CHG_CTRL1, S2MU003_TEEN_MASK);
+}
+
+static int s2mu003_input_current_limit[] = {
+	100,
+	500,
+	700,
+	900,
+	1000,
+	1500,
+	2000,
+};
+
+static void s2mu003_set_input_current_limit(struct s2mu003_charger_data *charger,
+		int current_limit)
+{
+	int i = 0, curr_reg = 0;
+
+	for (i = 0; i < ARRAY_SIZE(s2mu003_input_current_limit); i++) {
+		if (current_limit <= s2mu003_input_current_limit[i])
+			curr_reg = i+1;
+	}
+
+	if (curr_reg < 0)
+		curr_reg = 0;
+	mutex_lock(&charger->io_lock);
+	s2mu003_assign_bits(charger->client, S2MU003_CHG_CTRL1, S2MU003_AICR_LIMIT_MASK,
+			curr_reg << S2MU003_AICR_LIMIT_SHIFT);
+	mutex_unlock(&charger->io_lock);
+}
+
+static int s2mu003_get_input_current_limit(struct i2c_client *i2c)
+{
+	int ret;
+	ret = s2mu003_reg_read(i2c, S2MU003_CHG_CTRL1);
+	if (ret < 0)
+		return ret;
+	ret &= S2MU003_AICR_LIMIT_MASK;
+	ret >>= S2MU003_AICR_LIMIT_SHIFT;
+	if (ret == 0)
+		return 2000 + 1; /* no limitation */
+
+	return s2mu003_input_current_limit[ret - 1];
+}
+
+static void s2mu003_set_regulation_voltage(struct s2mu003_charger_data *charger,
+		int float_voltage)
+{
+	int data;
+
+	if (float_voltage < 3650)
+		data = 0;
+	else if (float_voltage >= 3650 && float_voltage <= 4375)
+		data = (float_voltage - 3650) / 25;
+	else
+		data = 0x23;
+
+	mutex_lock(&charger->io_lock);
+	s2mu003_assign_bits(charger->client,
+			S2MU003_CHG_CTRL2, S2MU003_VOREG_MASK,
+			data << S2MU003_VOREG_SHIFT);
+	mutex_unlock(&charger->io_lock);
+}
+
+static void s2mu003_set_fast_charging_current(struct i2c_client *i2c,
+		int charging_current)
+{
+	int data;
+
+	if (charging_current < 700)
+		data = 0;
+	else if (charging_current >= 700 && charging_current <= 2000)
+		data = (charging_current - 700) / 100;
+	else
+		data = 0xd;
+
+	s2mu003_assign_bits(i2c, S2MU003_CHG_CTRL5, S2MU003_ICHRG_MASK,
+			data << S2MU003_ICHRG_SHIFT);
+}
+
+static int s2mu003_eoc_level[] = {
+	0,
+	150,
+	200,
+	250,
+	300,
+	400,
+	500,
+	600,
+};
+
+static int s2mu003_get_eoc_level(int eoc_current)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(s2mu003_eoc_level); i++) {
+		if (eoc_current < s2mu003_eoc_level[i]) {
+			if (i == 0)
+				return 0;
+			return i - 1;
+		}
+	}
+
+	return ARRAY_SIZE(s2mu003_eoc_level) - 1;
+}
+
+static int s2mu003_get_current_eoc_setting(struct s2mu003_charger_data *charger)
+{
+	int ret;
+	mutex_lock(&charger->io_lock);
+	ret = s2mu003_reg_read(charger->client, S2MU003_CHG_CTRL4);
+	mutex_unlock(&charger->io_lock);
+	if (ret < 0) {
+		pr_info("%s: warning --> fail to read i2c register(%d)\n", __func__, ret);
+		return ret;
+	}
+	return s2mu003_eoc_level[(S2MU003_IEOC_MASK & ret) >> S2MU003_IEOC_SHIFT];
+}
+
+static int s2mu003_get_fast_charging_current(struct i2c_client *i2c)
+{
+	int data = s2mu003_reg_read(i2c, S2MU003_CHG_CTRL5);
+	if (data < 0)
+		return data;
+
+	data = (data >> 4) & 0x0f;
+
+	if (data > 0xd)
+		data = 0xd;
+	return data * 100 + 700;
+}
+
+static void s2mu003_set_termination_current_limit(struct i2c_client *i2c,
+		int current_limit)
+{
+	int data = s2mu003_get_eoc_level(current_limit);
+	int ret;
+
+	pr_info("%s : Set Termination\n", __func__);
+
+	ret = s2mu003_assign_bits(i2c, S2MU003_CHG_CTRL4, S2MU003_IEOC_MASK,
+			data << S2MU003_IEOC_SHIFT);
+	/* reset chg_en */
+	s2mu003_clr_bits(i2c, S2MU003_CHG_CTRL3, S2MU003_CHG_EN_MASK);
+	s2mu003_set_bits(i2c, S2MU003_CHG_CTRL3, S2MU003_CHG_EN_MASK);
+}
+/* eoc re set */
+static void s2mu003_set_charging_current(struct s2mu003_charger_data *charger,
+		int eoc)
+{
+	int adj_current = 0;
+
+	adj_current = charger->charging_current * charger->siop_level / 100;
+	mutex_lock(&charger->io_lock);
+	s2mu003_set_fast_charging_current(charger->client,
+			adj_current);
+	if (eoc) {
+		/* set EOC RESET */
+		s2mu003_set_termination_current_limit(charger->client, eoc);
+	}
+	mutex_unlock(&charger->io_lock);
+}
+
+enum {
+	S2MU003_MIVR_DISABLE = 0,
+	S2MU003_MIVR_4200MV,
+	S2MU003_MIVR_4300MV,
+	S2MU003_MIVR_4400MV,
+	S2MU003_MIVR_4500MV,
+	S2MU003_MIVR_4600MV,
+	S2MU003_MIVR_4700MV,
+	S2MU003_MIVR_4800MV,
+};
+
+#if ENABLE_MIVR
+/* charger input regulation voltage setting */
+static void s2mu003_set_mivr_level(struct s2mu003_charger_data *charger)
+{
+	int mivr;
+
+	switch (charger->cable_type) {
+	case POWER_SUPPLY_TYPE_USB ... POWER_SUPPLY_TYPE_USB_ACA:
+		mivr = S2MU003_MIVR_4600MV;
+		break;
+	default:
+		mivr = S2MU003_MIVR_DISABLE;
+	}
+	mutex_lock(&charger->io_lock);
+	s2mu003_assign_bits(charger->i2c_client,
+			S2MU003_CHG_CTRL4, S2MU003_MIVR_MASK, mivr << S2MU003_MIVR_SHIFT);
+	mutex_unlock(&charger->io_lock);
+}
+#endif /*ENABLE_MIVR*/
+
+static void s2mu003_configure_charger(struct s2mu003_charger_data *charger)
+{
+
+	int eoc;
+	union power_supply_propval val;
+
+	pr_info("%s : Set config charging\n", __func__);
+	if (charger->charging_current < 0) {
+		pr_info("%s : OTG is activated. Ignore command!\n",
+				__func__);
+		return;
+	}
+
+#if ENABLE_MIVR
+	s2mu003_set_mivr_level(charger);
+#endif /*DISABLE_MIVR*/
+	psy_do_property("battery", get,
+			POWER_SUPPLY_PROP_CHARGE_NOW, val);
+
+	/* TEMP_TEST : disable charging current termination for 2nd charging */
+	/* s2mu003_enable_charging_termination(charger->s2mu003->i2c_client, 1);*/
+
+	/* Input current limit */
+	pr_info("%s : input current (%dmA)\n",
+			__func__, charger->pdata->charging_current_table
+			[charger->cable_type].input_current_limit);
+
+	s2mu003_set_input_current_limit(charger,
+			charger->pdata->charging_current_table
+			[charger->cable_type].input_current_limit);
+
+	/* Float voltage */
+	pr_info("%s : float voltage (%dmV)\n",
+			__func__, charger->pdata->chg_float_voltage);
+
+	s2mu003_set_regulation_voltage(charger,
+			charger->pdata->chg_float_voltage);
+
+	charger->charging_current = charger->pdata->charging_current_table
+		[charger->cable_type].fast_charging_current;
+	eoc = charger->pdata->charging_current_table
+		[charger->cable_type].full_check_current_1st;
+	/* Fast charge and Termination current */
+	pr_info("%s : fast charging current (%dmA)\n",
+			__func__, charger->charging_current);
+
+	pr_info("%s : termination current (%dmA)\n",
+			__func__, eoc);
+
+	s2mu003_set_charging_current(charger, eoc);
+	s2mu003_enable_charger_switch(charger, 1);
+}
+
+/* here is set init charger data */
+static bool s2mu003_chg_init(struct s2mu003_charger_data *charger)
+{
+	int ret = 0, rev_id;
+
+	s2mu003_set_bits(charger->client, 0x6b, 0x01);
+	/* delay 100 us to wait for normal read (from e-fuse) */
+	msleep(20);
+	ret = s2mu003_reg_read(charger->client, 0x03);
+	s2mu003_clr_bits(charger->client, 0x6b, 0x01);
+	if (ret < 0)
+		pr_err("%s : failed to read revision ID\n", __func__);
+
+	rev_id = ret & 0x0f;
+
+	ret = s2mu003_set_bits(charger->client, S2MU003_CHG_CTRL1,
+			       S2MU003_SEL_SWFREQ_MASK);
+
+	/* Disable Timer function (Charging timeout fault) */
+	s2mu003_clr_bits(charger->client,
+			S2MU003_CHG_CTRL3, S2MU003_TIMEREN_MASK);
+	s2mu003_clr_bits(charger->client, S2MU003_CHG_CTRL3, S2MU003_CHG_EN_MASK);
+	s2mu003_set_bits(charger->client, S2MU003_CHG_CTRL3, S2MU003_CHG_EN_MASK);
+
+	/* Disable TE */
+	s2mu003_enable_charging_termination(charger->client, 0);
+
+	/* EMI improvement , let reg0x18 bit2~5 be 1100*/
+	/* s2mu003_assign_bits(charger->s2mu003->i2c_client, 0x18, 0x3C, 0x30); */
+
+	/* MUST set correct regulation voltage first
+	 * Before MUIC pass cable type information to charger
+	 * charger would be already enabled (default setting)
+	 * it might cause EOC event by incorrect regulation voltage */
+	s2mu003_set_regulation_voltage(charger,
+			charger->pdata->chg_float_voltage);
+#if !(ENABLE_MIVR)
+	s2mu003_assign_bits(charger->client,
+			S2MU003_CHG_CTRL4, S2MU003_MIVR_MASK,
+			S2MU003_MIVR_DISABLE << S2MU003_MIVR_SHIFT);
+#endif
+	return true;
+}
+
+static int s2mu003_get_charging_status(struct s2mu003_charger_data *charger)
+{
+	int status = POWER_SUPPLY_STATUS_UNKNOWN;
+	int ret;
+
+	ret = s2mu003_reg_read(charger->client, S2MU003_CHG_STATUS1);
+	if (ret < 0) {
+		pr_info("Error : can't get charging status (%d)\n", ret);
+
+	}
+
+	if (charger->full_charged)
+		return POWER_SUPPLY_STATUS_FULL;
+
+	switch (ret & 0x30) {
+	case 0x00:
+		status = POWER_SUPPLY_STATUS_DISCHARGING;
+		break;
+	case 0x20:
+	case 0x10:
+		status = POWER_SUPPLY_STATUS_CHARGING;
+		break;
+	case 0x30:
+		status = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		break;
+	}
+
+	/* TEMP_TEST : when OTG is enabled(charging_current -1), handle OTG func. */
+	if (charger->charging_current < 0) {
+		/* For OTG mode, S2MU003 would still report "charging" */
+		status = POWER_SUPPLY_STATUS_DISCHARGING;
+		ret = s2mu003_reg_read(charger->client, S2MU003_CHG_IRQ3);
+		if (ret & 0x80) {
+			pr_info("%s: otg overcurrent limit\n", __func__);
+			s2mu003_charger_otg_control(charger, false);
+		}
+
+	}
+
+	return status;
+}
+
+static int s2mu003_get_charge_type(struct i2c_client *iic)
+{
+	int status = POWER_SUPPLY_CHARGE_TYPE_UNKNOWN;
+	int ret;
+
+	ret = s2mu003_reg_read(iic, S2MU003_CHG_STATUS1);
+	if (ret < 0)
+		dev_err(&iic->dev, "%s fail\n", __func__);
+
+	switch (ret&0x40) {
+	case 0x40:
+		status = POWER_SUPPLY_CHARGE_TYPE_FAST;
+		break;
+	default:
+		/* pre-charge mode */
+		status = POWER_SUPPLY_CHARGE_TYPE_UNKNOWN;
+		break;
+	}
+
+	return status;
+}
+
+static bool s2mu003_get_batt_present(struct i2c_client *iic)
+{
+	int ret = s2mu003_reg_read(iic, S2MU003_CHG_STATUS2);
+	if (ret < 0)
+		return false;
+	return (ret & 0x08) ? false : true;
+}
+
+static int s2mu003_get_charging_health(struct s2mu003_charger_data *charger)
+{
+	int ret = s2mu003_reg_read(charger->client, S2MU003_CHG_STATUS1);
+
+	if (ret < 0)
+		return POWER_SUPPLY_HEALTH_UNKNOWN;
+
+	if (ret & (0x03 << 2)) {
+		charger->ovp = false;
+		charger->unhealth_cnt = 0;
+		return POWER_SUPPLY_HEALTH_GOOD;
+	}
+	charger->unhealth_cnt++;
+	if (charger->unhealth_cnt < HEALTH_DEBOUNCE_CNT)
+		return POWER_SUPPLY_HEALTH_GOOD;
+
+	charger->unhealth_cnt = HEALTH_DEBOUNCE_CNT;
+	if (charger->ovp)
+		return POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+	return POWER_SUPPLY_HEALTH_UNDERVOLTAGE;
+}
+
+static int sec_chg_get_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		union power_supply_propval *val)
+{
+	int chg_curr, aicr;
+	struct s2mu003_charger_data *charger =
+		container_of(psy, struct s2mu003_charger_data, psy_chg);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = charger->charging_current ? 1 : 0;
+		break;
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = s2mu003_get_charging_status(charger);
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = s2mu003_get_charging_health(charger);
+		s2mu003_test_read(charger->client);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		val->intval = 2000;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		if (charger->charging_current) {
+			aicr = s2mu003_get_input_current_limit(charger->client);
+			chg_curr = s2mu003_get_fast_charging_current(charger->client);
+			val->intval = MINVAL(aicr, chg_curr);
+		} else
+			val->intval = 0;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+		val->intval = s2mu003_get_charge_type(charger->client);
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = s2mu003_get_batt_present(charger->client);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sec_chg_set_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		const union power_supply_propval *val)
+{
+	struct s2mu003_charger_data *charger =
+		container_of(psy, struct s2mu003_charger_data, psy_chg);
+
+	int eoc;
+	int previous_cable_type = charger->cable_type;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		charger->status = val->intval;
+		break;
+		/* val->intval : type */
+	case POWER_SUPPLY_PROP_ONLINE:
+		charger->cable_type = val->intval;
+		if (charger->cable_type == POWER_SUPPLY_TYPE_BATTERY ||
+				charger->cable_type == POWER_SUPPLY_TYPE_UNKNOWN) {
+			pr_info("%s:[BATT] Type Battery\n", __func__);
+			s2mu003_enable_charger_switch(charger, 0);
+
+			if (previous_cable_type == POWER_SUPPLY_TYPE_OTG)
+				s2mu003_charger_otg_control(charger, false);
+		} else if (charger->cable_type == POWER_SUPPLY_TYPE_OTG) {
+			pr_info("%s: OTG mode\n", __func__);
+			s2mu003_charger_otg_control(charger, true);
+		} else {
+			pr_info("%s:[BATT] Set charging"
+					", Cable type = %d\n", __func__, charger->cable_type);
+			/* Enable charger */
+			s2mu003_configure_charger(charger);
+		}
+#if EN_TEST_READ
+		msleep(100);
+		s2mu003_test_read(charger->s2mu003->i2c_client);
+#endif
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		/* set charging current */
+		if (charger->is_charging) {
+			/* decrease the charging current according to siop level */
+			charger->siop_level = val->intval;
+			pr_info("%s:SIOP level = %d, chg current = %d\n", __func__,
+					val->intval, charger->charging_current);
+			eoc = s2mu003_get_current_eoc_setting(charger);
+			s2mu003_set_charging_current(charger, 0);
+		}
+		break;
+	case POWER_SUPPLY_PROP_POWER_NOW:
+		eoc = s2mu003_get_current_eoc_setting(charger);
+		pr_info("%s:Set Power Now -> chg current = %d mA, eoc = %d mA\n", __func__,
+				val->intval, eoc);
+		s2mu003_set_charging_current(charger, 0);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL:
+		s2mu003_charger_otg_control(charger, val->intval);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+ssize_t s2mu003_chg_show_attrs(struct device *dev,
+		const ptrdiff_t offset, char *buf)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct s2mu003_charger_data *charger =
+		container_of(psy, struct s2mu003_charger_data, psy_chg);
+	int i = 0;
+	char *str = NULL;
+
+	switch (offset) {
+	case CHG_REG:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%x\n",
+				charger->reg_addr);
+		break;
+	case CHG_DATA:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%x\n",
+				charger->reg_data);
+		break;
+	case CHG_REGS:
+		str = kzalloc(sizeof(char) * 256, GFP_KERNEL);
+		if (!str)
+			return -ENOMEM;
+
+		s2mu003_read_regs(charger->client, str);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%s\n",
+				str);
+
+		kfree(str);
+		break;
+	default:
+		i = -EINVAL;
+		break;
+	}
+
+	return i;
+}
+
+ssize_t s2mu003_chg_store_attrs(struct device *dev,
+		const ptrdiff_t offset,
+		const char *buf, size_t count)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct s2mu003_charger_data *charger =
+		container_of(psy, struct s2mu003_charger_data, psy_chg);
+
+	int ret = 0;
+	int x = 0;
+	uint8_t data = 0;
+
+	switch (offset) {
+	case CHG_REG:
+		if (sscanf(buf, "%x\n", &x) == 1) {
+			charger->reg_addr = x;
+			data = s2mu003_reg_read(charger->client,
+					charger->reg_addr);
+			charger->reg_data = data;
+			dev_dbg(dev, "%s: (read) addr = 0x%x, data = 0x%x\n",
+					__func__, charger->reg_addr, charger->reg_data);
+			ret = count;
+		}
+		break;
+	case CHG_DATA:
+		if (sscanf(buf, "%x\n", &x) == 1) {
+			data = (u8)x;
+
+			dev_dbg(dev, "%s: (write) addr = 0x%x, data = 0x%x\n",
+					__func__, charger->reg_addr, data);
+			ret = s2mu003_reg_write(charger->client,
+					charger->reg_addr, data);
+			if (ret < 0) {
+				dev_dbg(dev, "I2C write fail Reg0x%x = 0x%x\n",
+						(int)charger->reg_addr, (int)data);
+			}
+			ret = count;
+		}
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+struct s2mu003_chg_irq_handler {
+	char *name;
+	int irq_index;
+	irqreturn_t (*handler)(int irq, void *data);
+};
+
+#if EN_OVP_IRQ
+static irqreturn_t s2mu003_chg_vin_ovp_irq_handler(int irq, void *data)
+{
+	struct s2mu003_charger_data *charger = data;
+	union power_supply_propval value;
+	int status;
+
+	/* Delay 100ms for debounce */
+	msleep(100);
+	status = s2mu003_reg_read(charger->client, S2MU003_CHG_STATUS1);
+
+	/* PWR ready = 0*/
+	if ((status & (0x04)) == 0) {
+		/* No need to disable charger,
+		 * H/W will do it automatically */
+		charger->unhealth_cnt = HEALTH_DEBOUNCE_CNT;
+		charger->ovp = true;
+		pr_info("%s: OVP triggered\n", __func__);
+		value.intval = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+		psy_do_property("battery", set,
+				POWER_SUPPLY_PROP_HEALTH, value);
+	} else {
+		charger->unhealth_cnt = 0;
+		charger->ovp = false;
+	}
+
+	return IRQ_HANDLED;
+}
+#endif /* EN_OVP_IRQ */
+
+#if EN_IEOC_IRQ
+static irqreturn_t s2mu003_chg_ieoc_irq_handler(int irq, void *data)
+{
+	struct s2mu003_charger_data *charger = data;
+
+	pr_info("%s : Full charged\n", __func__);
+	charger->full_charged = true;
+	return IRQ_HANDLED;
+}
+#endif /* EN_IEOC_IRQ */
+
+#if EN_RECHG_REQ_IRQ
+static irqreturn_t s2mu003_chg_rechg_request_irq_handler(int irq, void *data)
+{
+	struct s2mu003_charger_data *charger = data;
+	pr_info("%s: Recharging requesting\n", __func__);
+
+	charger->full_charged = false;
+
+	return IRQ_HANDLED;
+}
+#endif /* EN_RECHG_REQ_IRQ */
+
+#if EN_TR_IRQ
+static irqreturn_t s2mu003_chg_otp_tr_irq_handler(int irq, void *data)
+{
+	pr_info("%s : Over temperature : thermal regulation loop active\n",
+			__func__);
+	/* if needs callback, do it here */
+	return IRQ_HANDLED;
+}
+#endif
+
+const struct s2mu003_chg_irq_handler s2mu003_chg_irq_handlers[] = {
+#if EN_OVP_IRQ
+	{
+		.name = "chg_cinovp",
+		.handler = s2mu003_chg_vin_ovp_irq_handler,
+		.irq_index = S2MU003_CINOVP_IRQ,
+	},
+#endif /* EN_OVP_IRQ */
+#if EN_IEOC_IRQ
+	{
+		.name = "chg_eoc",
+		.handler = s2mu003_chg_ieoc_irq_handler,
+		.irq_index = S2MU003_EOC_IRQ,
+	},
+#endif /* EN_IEOC_IRQ */
+#if EN_RECHG_REQ_IRQ
+	{
+		.name = "chg_rechg",
+		.handler = s2mu003_chg_rechg_request_irq_handler,
+		.irq_index = S2MU003_RECHG_IRQ,
+	},
+#endif /* EN_RECHG_REQ_IRQ*/
+#if EN_TR_IRQ
+	{
+		.name = "chg_chgtr",
+		.handler = s2mu003_chg_otp_tr_irq_handler,
+		.irq_index = S2MU003_CHGTR_IRQ,
+	},
+#endif /* EN_TR_IRQ */
+
+#if EN_MIVR_SW_REGULATION
+	{
+		.name = "chg_chgvinvr",
+		.handler = s2mu003_chg_mivr_irq_handler,
+		.irq_index = S2MU003_CHGVINVR_IRQ,
+	},
+#endif /* EN_MIVR_SW_REGULATION */
+#if EN_BST_IRQ
+	{
+		.name = "chg_bstinlv",
+		.handler = s2mu003_chg_otg_fail_irq_handler,
+		.irq_index = S2MU003_BSTINLV_IRQ,
+	},
+	{
+		.name = "chg_bstilim",
+		.handler = s2mu003_chg_otg_fail_irq_handler,
+		.irq_index = S2MU003_BSTILIM_IRQ,
+	},
+	{
+		.name = "chg_vmidovp",
+		.handler = s2mu003_chg_otg_fail_irq_handler,
+		.irq_index = S2MU003_VMIDOVP_IRQ,
+	},
+#endif /* EN_BST_IRQ */
+};
+
+static int register_irq(struct platform_device *pdev,
+		struct s2mu003_charger_data *charger)
+{
+	int irq;
+	int i, j;
+	int ret;
+	const struct s2mu003_chg_irq_handler *irq_handler = s2mu003_chg_irq_handlers;
+	const char *irq_name;
+	for (i = 0; i < ARRAY_SIZE(s2mu003_chg_irq_handlers); i++) {
+		irq_name = s2mu003_get_irq_name_by_index(irq_handler[i].irq_index);
+		irq = platform_get_irq_byname(pdev, irq_name);
+		ret = request_threaded_irq(irq, NULL, irq_handler[i].handler,
+				IRQF_ONESHOT | IRQF_TRIGGER_RISING |
+				IRQF_NO_SUSPEND, irq_name, charger);
+		if (ret < 0) {
+			pr_err("%s : Failed to request IRQ (%s): #%d: %d\n",
+					__func__, irq_name, irq, ret);
+			goto err_irq;
+		}
+
+		pr_info("%s : Register IRQ%d(%s) successfully\n",
+				__func__, irq, irq_name);
+	}
+
+	return 0;
+err_irq:
+	for (j = 0; j < i; j++) {
+		irq_name = s2mu003_get_irq_name_by_index(irq_handler[j].irq_index);
+		irq = platform_get_irq_byname(pdev, irq_name);
+		free_irq(irq, charger);
+	}
+
+	return ret;
+}
+
+static void unregister_irq(struct platform_device *pdev,
+		struct s2mu003_charger_data *charger)
+{
+	int irq;
+	int i;
+	const char *irq_name;
+	const struct s2mu003_chg_irq_handler *irq_handler = s2mu003_chg_irq_handlers;
+
+	for (i = 0; i < ARRAY_SIZE(s2mu003_chg_irq_handlers); i++) {
+		irq_name = s2mu003_get_irq_name_by_index(irq_handler[i].irq_index);
+		irq = platform_get_irq_byname(pdev, irq_name);
+		free_irq(irq, charger);
+	}
+}
+
+
+#ifdef CONFIG_OF
+static int s2mu003_charger_parse_dt(struct device *dev,
+		struct s2mu003_charger_platform_data *pdata)
+{
+	struct device_node *np = of_find_node_by_name(NULL, "s2mu003-charger");
+	const u32 *p;
+	int ret, i, len;
+
+	pr_info("%s : is_fixed_switching = %d\n", __func__,
+			pdata->is_fixed_switching);
+
+	if (np == NULL) {
+		pr_err("%s np NULL\n", __func__);
+	} else {
+		ret = of_property_read_u32(np, "battery,chg_float_voltage",
+				&pdata->chg_float_voltage);
+	}
+
+	np = of_find_node_by_name(NULL, "battery");
+	if (!np) {
+		pr_err("%s np NULL\n", __func__);
+	} else {
+		ret = of_property_read_string(np,
+				"battery,charger_name", (char const **)&pdata->charger_name);
+
+		p = of_get_property(np, "battery,input_current_limit", &len);
+		if (!p)
+			return 1;
+
+		len = len / sizeof(u32);
+
+		pdata->charging_current_table = kzalloc(sizeof(sec_charging_current_t) * len,
+				GFP_KERNEL);
+
+		for (i = 0; i < len; i++) {
+			ret = of_property_read_u32_index(np,
+					"battery,input_current_limit", i,
+					&pdata->charging_current_table[i].input_current_limit);
+			ret = of_property_read_u32_index(np,
+					"battery,fast_charging_current", i,
+					&pdata->charging_current_table[i].fast_charging_current);
+			ret = of_property_read_u32_index(np,
+					"battery,full_check_current_1st", i,
+					&pdata->charging_current_table[i].full_check_current_1st);
+			ret = of_property_read_u32_index(np,
+					"battery,full_check_current_2nd", i,
+					&pdata->charging_current_table[i].full_check_current_2nd);
+		}
+	}
+
+	dev_info(dev, "s2mu003 charger parse dt retval = %d\n", ret);
+	return ret;
+}
+
+static struct of_device_id s2mu003_charger_match_table[] = {
+	{ .compatible = "samsung,s2mu003-charger",},
+	{},
+};
+#else
+static int s2mu003_charger_parse_dt(struct device *dev,
+		struct s2mu003_charger_platform_data *pdata)
+{
+	return -ENOSYS;
+}
+
+#define s2mu003_charger_match_table NULL
+#endif /* CONFIG_OF */
+
+static int s2mu003_charger_probe(struct platform_device *pdev)
+{
+	s2mu003_mfd_chip_t *chip = dev_get_drvdata(pdev->dev.parent);
+#ifndef CONFIG_OF
+	struct s2mu003_mfd_platform_data *mfd_pdata = dev_get_platdata(chip->dev);
+#endif
+	struct s2mu003_charger_data *charger;
+	int ret = 0;
+
+	pr_info("%s:[BATT] S2MU003 Charger driver probe\n", __func__);
+	charger = kzalloc(sizeof(*charger), GFP_KERNEL);
+	if (!charger)
+		return -ENOMEM;
+
+	mutex_init(&charger->io_lock);
+
+	charger->s2mu003 = chip;
+	charger->client = chip->i2c_client;
+
+#ifdef CONFIG_OF
+	charger->pdata = devm_kzalloc(&pdev->dev, sizeof(*(charger->pdata)),
+			GFP_KERNEL);
+	if (!charger->pdata) {
+		dev_err(&pdev->dev, "Failed to allocate memory\n");
+		ret = -ENOMEM;
+		goto err_parse_dt_nomem;
+	}
+	ret = s2mu003_charger_parse_dt(&pdev->dev, charger->pdata);
+	if (ret < 0)
+		goto err_parse_dt;
+#else
+	charger->pdata = mfd_pdata->charger_platform_data;
+#endif
+
+	platform_set_drvdata(pdev, charger);
+
+	if (charger->pdata->charger_name == NULL)
+		charger->pdata->charger_name = "sec-charger";
+
+	charger->psy_chg.name           = charger->pdata->charger_name;
+	charger->psy_chg.type           = POWER_SUPPLY_TYPE_UNKNOWN;
+	charger->psy_chg.get_property   = sec_chg_get_property;
+	charger->psy_chg.set_property   = sec_chg_set_property;
+	charger->psy_chg.properties     = sec_charger_props;
+	charger->psy_chg.num_properties = ARRAY_SIZE(sec_charger_props);
+
+	charger->siop_level = 100;
+	s2mu003_chg_init(charger);
+
+	ret = power_supply_register(&pdev->dev, &charger->psy_chg);
+	if (ret) {
+		pr_err("%s: Failed to Register psy_chg\n", __func__);
+		goto err_power_supply_register;
+	}
+	ret = register_irq(pdev, charger);
+	if (ret < 0)
+		goto err_reg_irq;
+
+	s2mu003_test_read(charger->client);
+	pr_info("%s:[BATT] S2MU003 charger driver loaded OK\n", __func__);
+
+	return 0;
+err_reg_irq:
+	power_supply_unregister(&charger->psy_chg);
+err_power_supply_register:
+err_parse_dt:
+err_parse_dt_nomem:
+	mutex_destroy(&charger->io_lock);
+	kfree(charger);
+	return ret;
+}
+
+static int s2mu003_charger_remove(struct platform_device *pdev)
+{
+	struct s2mu003_charger_data *charger =
+		platform_get_drvdata(pdev);
+
+	unregister_irq(pdev, charger);
+	power_supply_unregister(&charger->psy_chg);
+	mutex_destroy(&charger->io_lock);
+	kfree(charger);
+	return 0;
+}
+
+#if defined CONFIG_PM
+static int s2mu003_charger_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int s2mu003_charger_resume(struct device *dev)
+{
+	return 0;
+}
+#else
+#define s2mu003_charger_suspend NULL
+#define s2mu003_charger_resume NULL
+#endif
+
+static void s2mu003_charger_shutdown(struct device *dev)
+{
+	pr_info("%s: S2MU003 Charger driver shutdown\n", __func__);
+}
+
+static SIMPLE_DEV_PM_OPS(s2mu003_charger_pm_ops, s2mu003_charger_suspend,
+		s2mu003_charger_resume);
+
+static struct platform_driver s2mu003_charger_driver = {
+	.driver         = {
+		.name   = "s2mu003-charger",
+		.owner  = THIS_MODULE,
+		.of_match_table = s2mu003_charger_match_table,
+		.pm     = &s2mu003_charger_pm_ops,
+		.shutdown = s2mu003_charger_shutdown,
+	},
+	.probe          = s2mu003_charger_probe,
+	.remove		= s2mu003_charger_remove,
+};
+
+static int __init s2mu003_charger_init(void)
+{
+	int ret = 0;
+
+	ret = platform_driver_register(&s2mu003_charger_driver);
+
+	return ret;
+}
+subsys_initcall(s2mu003_charger_init);
+
+static void __exit s2mu003_charger_exit(void)
+{
+	platform_driver_unregister(&s2mu003_charger_driver);
+}
+module_exit(s2mu003_charger_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Patrick Chang <patrick_chang@richtek.com");
+MODULE_DESCRIPTION("Charger driver for S2MU003");
diff -Naur linux-3.18.14/drivers/battery/s2mu003_fuelgauge.c samsung/drivers/battery/s2mu003_fuelgauge.c
--- linux-3.18.14/drivers/battery/s2mu003_fuelgauge.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery/s2mu003_fuelgauge.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,759 @@
+/*
+ *  Samsung S2MU003 Fuel Gauge Driver
+ *
+ * Copyright (c) 2015 Samsung Electronics Co., Ltd.
+ *		http://www.samsung.com
+ * Author: Junhan Bae <junhan84.bae@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/mfd/samsung/s2mu003.h>
+#include <linux/power/s2mu003_fuelgauge.h>
+#include <linux/of_gpio.h>
+
+static enum power_supply_property s2mu003_fuelgauge_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_VOLTAGE_AVG,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CURRENT_AVG,
+	POWER_SUPPLY_PROP_CHARGE_FULL,
+	POWER_SUPPLY_PROP_ENERGY_NOW,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_TEMP_AMBIENT,
+};
+
+static int s2mu003_init_regs(struct s2mu003_fuelgauge_data *fuelgauge)
+{
+	int ret = 0;
+	u8 data;
+
+	pr_info("%s: s2mu003 fuelgauge initialize\n", __func__);
+
+	data = i2c_smbus_read_byte_data(fuelgauge->i2c, 0x2e);
+	data &= ~(0x01 << 3);
+	ret = i2c_smbus_write_byte_data(fuelgauge->i2c, 0x2e, data);
+
+	data = i2c_smbus_read_byte_data(fuelgauge->i2c, 0x1A);
+	data |= 0x03;
+	ret = i2c_smbus_write_byte_data(fuelgauge->i2c, 0x1A, data);
+
+	if (ret < 0)
+		dev_err(&fuelgauge->i2c->dev, "%s: Error(%d)\n", __func__, ret);
+
+	return ret;
+}
+
+static void s2mu003_alert_init(struct s2mu003_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+
+	/* VBAT Threshold setting */
+	data[0] = 0x00 & 0x0f;
+
+	/* SOC Threshold setting */
+	data[0] = data[0] | (fuelgauge->pdata->fuel_alert_soc << 4);
+
+	data[1] = 0x00;
+	i2c_smbus_write_i2c_block_data(fuelgauge->i2c,
+			S2MU003_REG_IRQ_LVL, 2, data);
+}
+
+static bool s2mu003_check_status(struct i2c_client *client)
+{
+	u8 data[2];
+	bool ret = false;
+
+	/* check if Smn was generated */
+	if (i2c_smbus_read_i2c_block_data(client, S2MU003_REG_STATUS, 2, data) < 0)
+		return ret;
+
+	dev_dbg(&client->dev, "%s: status to (%02x%02x)\n",
+		__func__, data[1], data[0]);
+
+	if (data[1] & (0x1 << 1))
+		return true;
+	else
+		return false;
+}
+
+static int s2mu003_set_temperature(struct s2mu003_fuelgauge_data *fuelgauge,
+			int temperature)
+{
+	u8 data[2];
+	char val;
+
+	val = temperature / 10;
+
+	if (val < -5)
+		val = 0xf6;
+	else if (val >= -5 && val < 5)
+		val = 0x00;
+	else if (val >= 5 && val < 15)
+		val = 0x0a;
+	else if (val >= 15 && val < 35)
+		val = 0x19;
+	else if (val >= 35)
+		val = 0x28;
+	data[0] = val;
+	data[1] = 0x00;
+#if 0
+	s2mu003_block_write_device(fuelgauge->i2c, S2MU003_REG_RTEMP, 2, data);
+#endif
+	dev_dbg(&fuelgauge->i2c->dev, "%s: temperature to (%d)\n",
+		__func__, temperature);
+
+	return temperature;
+}
+
+static int s2mu003_get_temperature(struct s2mu003_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	s32 temperature = 0;
+
+	if (i2c_smbus_read_i2c_block_data(fuelgauge->i2c,
+			S2MU003_REG_RTEMP, 2, data) < 0)
+		return -ERANGE;
+
+	/* data[] store 2's compliment format number */
+	if (data[0] & (0x1 << 7)) {
+		/* Negative */
+		temperature = ((~(data[0])) & 0xFF) + 1;
+		temperature *= -10;
+	} else {
+		temperature = data[0] & 0x7F;
+		temperature *= 10;
+	}
+
+	dev_dbg(&fuelgauge->i2c->dev, "%s: temperature (%d)\n",
+		__func__, temperature);
+
+	return temperature;
+}
+
+/* soc should be 0.01% unit */
+static int s2mu003_get_soc(struct s2mu003_fuelgauge_data *fuelgauge)
+{
+	u8 data[2], check_data[2];
+	u16 compliment;
+	int rsoc, i;
+
+	for (i = 0; i < 50; i++) {
+		if (i2c_smbus_read_i2c_block_data(fuelgauge->i2c,
+				S2MU003_REG_RSOC, 2, data) < 0)
+			return -EINVAL;
+		if (i2c_smbus_read_i2c_block_data(fuelgauge->i2c,
+				S2MU003_REG_RSOC, 2, check_data) < 0)
+			return -EINVAL;
+		if ((data[0] == check_data[0]) && (data[1] == check_data[1]))
+			break;
+	}
+
+	compliment = (data[1] << 8) | (data[0]);
+
+	/* data[] store 2's compliment format number */
+	if (compliment & (0x1 << 15)) {
+		/* Negative */
+		rsoc = ((~compliment) & 0xFFFF) + 1;
+		rsoc = (rsoc * (-10000)) / (0x1 << 12);
+	} else {
+		rsoc = compliment & 0x7FFF;
+		rsoc = ((rsoc * 10000) / (0x1 << 12));
+	}
+
+	dev_info(&fuelgauge->i2c->dev, "%s: raw capacity (0x%x:%d)\n", __func__,
+		compliment, rsoc);
+
+	return min(rsoc, 10000) / 10;
+}
+
+static int s2mu003_get_rawsoc(struct s2mu003_fuelgauge_data *fuelgauge)
+{
+	u8 data[2], check_data[2];
+	u16 compliment;
+	int rsoc, i;
+
+	for (i = 0; i < 50; i++) {
+		if (i2c_smbus_read_i2c_block_data(fuelgauge->i2c,
+				S2MU003_REG_RSOC, 2, data) < 0)
+			return -EINVAL;
+		if (i2c_smbus_read_i2c_block_data(fuelgauge->i2c,
+				S2MU003_REG_RSOC, 2, check_data) < 0)
+			return -EINVAL;
+		if ((data[0] == check_data[0]) && (data[1] == check_data[1]))
+			break;
+	}
+
+	compliment = (data[1] << 8) | (data[0]);
+
+	/* data[] store 2's compliment format number */
+	if (compliment & (0x1 << 15)) {
+		/* Negative */
+		rsoc = ((~compliment) & 0xFFFF) + 1;
+		rsoc = (rsoc * (-10000)) / (0x1 << 12);
+	} else {
+		rsoc = compliment & 0x7FFF;
+		rsoc = ((rsoc * 10000) / (0x1 << 12));
+	}
+
+	dev_info(&fuelgauge->i2c->dev, "%s: raw capacity (0x%x:%d)\n", __func__,
+			compliment, rsoc);
+
+	return min(rsoc, 10000);
+}
+
+static int s2mu003_get_ocv(struct s2mu003_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u32 rocv = 0;
+
+	if (i2c_smbus_read_i2c_block_data(fuelgauge->i2c,
+			S2MU003_REG_ROCV, 2, data) < 0)
+		return -EINVAL;
+
+	rocv = ((data[0] + (data[1] << 8)) * 1000) >> 13;
+
+	dev_dbg(&fuelgauge->i2c->dev, "%s: rocv (%d)\n", __func__, rocv);
+
+	return rocv;
+}
+
+static int s2mu003_get_vbat(struct s2mu003_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u32 vbat = 0;
+
+	if (i2c_smbus_read_i2c_block_data(fuelgauge->i2c,
+			S2MU003_REG_RVBAT, 2, data) < 0)
+		return -EINVAL;
+	vbat = ((data[0] + (data[1] << 8)) * 1000) >> 13;
+
+	dev_dbg(&fuelgauge->i2c->dev, "%s: vbat (%d)\n", __func__, vbat);
+
+	return vbat;
+}
+
+static int s2mu003_get_avgvbat(struct s2mu003_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u32 new_vbat, old_vbat = 0;
+	int cnt;
+
+	for (cnt = 0; cnt < 5; cnt++) {
+		if (i2c_smbus_read_i2c_block_data(fuelgauge->i2c,
+			S2MU003_REG_RVBAT, 2, data) < 0)
+			return -EINVAL;
+
+		new_vbat = ((data[0] + (data[1] << 8)) * 1000) >> 13;
+
+		if (cnt == 0)
+			old_vbat = new_vbat;
+		else
+			old_vbat = new_vbat / 2 + old_vbat / 2;
+	}
+
+	dev_dbg(&fuelgauge->i2c->dev, "%s: avgvbat (%d)\n", __func__, old_vbat);
+
+	return old_vbat;
+}
+
+/* capacity is  0.1% unit */
+static void s2mu003_fg_get_scaled_capacity(
+		struct s2mu003_fuelgauge_data *fuelgauge,
+		union power_supply_propval *val)
+{
+	val->intval = (val->intval < fuelgauge->pdata->capacity_min) ?
+		0 : ((val->intval - fuelgauge->pdata->capacity_min) * 1000 /
+		(fuelgauge->capacity_max - fuelgauge->pdata->capacity_min));
+
+	dev_dbg(&fuelgauge->i2c->dev,
+			"%s: scaled capacity (%d.%d)\n",
+			__func__, val->intval/10, val->intval%10);
+}
+
+/* capacity is integer */
+static void s2mu003_fg_get_atomic_capacity(
+		struct s2mu003_fuelgauge_data *fuelgauge,
+		union power_supply_propval *val)
+{
+	if (fuelgauge->pdata->capacity_calculation_type &
+			SEC_FUELGAUGE_CAPACITY_TYPE_ATOMIC) {
+		if (fuelgauge->capacity_old < val->intval)
+			val->intval = fuelgauge->capacity_old + 1;
+		else if (fuelgauge->capacity_old > val->intval)
+			val->intval = fuelgauge->capacity_old - 1;
+	}
+
+	/* updated old capacity */
+	fuelgauge->capacity_old = val->intval;
+}
+
+static int s2mu003_fg_calculate_dynamic_scale(
+		struct s2mu003_fuelgauge_data *fuelgauge, int capacity)
+{
+	union power_supply_propval raw_soc_val;
+	raw_soc_val.intval = s2mu003_get_rawsoc(fuelgauge) / 10;
+
+	if (raw_soc_val.intval <
+			fuelgauge->pdata->capacity_max -
+			fuelgauge->pdata->capacity_max_margin) {
+		fuelgauge->capacity_max =
+			fuelgauge->pdata->capacity_max -
+			fuelgauge->pdata->capacity_max_margin;
+		pr_debug("%s: capacity_max (%d)", __func__,
+				fuelgauge->capacity_max);
+	} else {
+		fuelgauge->capacity_max =
+			(raw_soc_val.intval >
+			 fuelgauge->pdata->capacity_max +
+			 fuelgauge->pdata->capacity_max_margin) ?
+			(fuelgauge->pdata->capacity_max +
+			 fuelgauge->pdata->capacity_max_margin) :
+			raw_soc_val.intval;
+		pr_debug("%s: raw soc (%d)", __func__,
+				fuelgauge->capacity_max);
+	}
+
+	if (capacity != 100) {
+		fuelgauge->capacity_max =
+			(fuelgauge->capacity_max * 100 / capacity);
+		fuelgauge->capacity_old = capacity;
+	} else {
+		fuelgauge->capacity_max =
+			(fuelgauge->capacity_max * 99 / 100);
+		fuelgauge->capacity_old = 100;
+	}
+
+	pr_info("%s: %d is used for capacity_max, capacity(%d)\n",
+			__func__, fuelgauge->capacity_max, capacity);
+
+	return fuelgauge->capacity_max;
+}
+
+bool s2mu003_fuelgauge_fuelalert_init(struct i2c_client *client, int soc)
+{
+	struct s2mu003_fuelgauge_data *fuelgauge = i2c_get_clientdata(client);
+	u8 data[2];
+
+	/* 1. Set s2mu003 alert configuration. */
+	s2mu003_alert_init(fuelgauge);
+
+	if (i2c_smbus_read_i2c_block_data(client, S2MU003_REG_IRQ, 2, data) < 0)
+		return -1;
+
+	/*Enable VBAT, SOC */
+	data[1] &= 0xfc;
+
+	/*Disable IDLE_ST, INIT)ST */
+	data[1] |= 0x0c;
+
+	i2c_smbus_write_i2c_block_data(client, S2MU003_REG_IRQ, 2, data);
+
+	dev_dbg(&client->dev, "%s: irq_reg(%02x%02x) irq(%d)\n",
+			__func__, data[1], data[0], fuelgauge->pdata->fg_irq);
+
+	return true;
+}
+
+bool s2mu003_fuelgauge_is_fuelalerted(struct s2mu003_fuelgauge_data *fuelgauge)
+{
+	return s2mu003_check_status(fuelgauge->i2c);
+}
+
+bool s2mu003_hal_fg_fuelalert_process(void *irq_data, bool is_fuel_alerted)
+{
+	struct s2mu003_fuelgauge_data *fuelgauge = irq_data;
+	int ret;
+
+	ret = i2c_smbus_write_byte_data(fuelgauge->i2c, S2MU003_REG_IRQ, 0x00);
+	if (ret < 0)
+		dev_err(&fuelgauge->i2c->dev, "%s: Error(%d)\n", __func__, ret);
+
+	return ret;
+}
+
+bool s2mu003_hal_fg_full_charged(struct i2c_client *client)
+{
+	return true;
+}
+
+static int s2mu003_fg_get_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		union power_supply_propval *val)
+{
+	struct s2mu003_fuelgauge_data *fuelgauge =
+		container_of(psy, struct s2mu003_fuelgauge_data, psy_fg);
+
+	switch (psp) {
+		/* Cell voltage (VCELL, mV) */
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = s2mu003_get_vbat(fuelgauge);
+		break;
+		/* Additional Voltage Information (mV) */
+	case POWER_SUPPLY_PROP_VOLTAGE_AVG:
+		switch (val->intval) {
+		case SEC_BATTERY_VOLTAGE_AVERAGE:
+			val->intval = s2mu003_get_avgvbat(fuelgauge);
+			break;
+		case SEC_BATTERY_VOLTAGE_OCV:
+			val->intval = s2mu003_get_ocv(fuelgauge);
+			break;
+		}
+		break;
+		/* Current (mA) */
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = 0;
+		break;
+		/* Average Current (mA) */
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+		val->intval = 0;
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		if (val->intval == SEC_FUELGAUGE_CAPACITY_TYPE_RAW) {
+			val->intval = s2mu003_get_rawsoc(fuelgauge);
+		} else {
+			val->intval = s2mu003_get_soc(fuelgauge);
+
+			if (fuelgauge->pdata->capacity_calculation_type &
+				(SEC_FUELGAUGE_CAPACITY_TYPE_SCALE |
+				SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE))
+				s2mu003_fg_get_scaled_capacity(fuelgauge, val);
+
+			/* capacity should be between 0% and 100%
+			 * (0.1% degree)
+			 */
+			if (val->intval > 1000)
+				val->intval = 1000;
+			if (val->intval < 0)
+				val->intval = 0;
+
+			/* get only integer part */
+			val->intval /= 10;
+
+			/* check whether doing the wake_unlock */
+			if ((val->intval > fuelgauge->pdata->fuel_alert_soc) &&
+					fuelgauge->is_fuel_alerted) {
+				wake_unlock(&fuelgauge->fuel_alert_wake_lock);
+				s2mu003_fuelgauge_fuelalert_init(fuelgauge
+				->i2c, fuelgauge->pdata->fuel_alert_soc);
+			}
+
+			/* (Only for atomic capacity)
+			 * In initial time, capacity_old is 0.
+			 * and in resume from sleep,
+			 * capacity_old is too different from actual soc.
+			 * should update capacity_old
+			 * by val->intval in booting or resume.
+			 */
+			if (fuelgauge->initial_update_of_soc) {
+				/* updated old capacity */
+				fuelgauge->capacity_old = val->intval;
+				fuelgauge->initial_update_of_soc = false;
+				break;
+			}
+
+			if (fuelgauge->pdata->capacity_calculation_type &
+				(SEC_FUELGAUGE_CAPACITY_TYPE_ATOMIC |
+				SEC_FUELGAUGE_CAPACITY_TYPE_SKIP_ABNORMAL))
+				s2mu003_fg_get_atomic_capacity(fuelgauge, val);
+		}
+
+		break;
+	/* Battery Temperature */
+	case POWER_SUPPLY_PROP_TEMP:
+	/* Target Temperature */
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		val->intval = s2mu003_get_temperature(fuelgauge);
+		break;
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = POWER_SUPPLY_STATUS_UNKNOWN;
+		break;
+	default:
+		return false;
+	}
+	return true;
+}
+
+static int s2mu003_fg_set_property(struct power_supply *psy,
+			enum power_supply_property psp,
+			const union power_supply_propval *val)
+{
+	struct s2mu003_fuelgauge_data *fuelgauge =
+		container_of(psy, struct s2mu003_fuelgauge_data, psy_fg);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_TEMP:
+		/* Target Temperature */
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		s2mu003_set_temperature(fuelgauge, val->intval);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static int s2mu003_fuelgauge_parse_dt(struct s2mu003_fuelgauge_data *fuelgauge)
+{
+
+	struct device_node *np =
+		of_find_node_by_name(NULL, "s2mu003-fuelgauge");
+	int ret;
+	int i, len;
+	const u32 *p;
+
+	/* reset, irq gpio info */
+	if (np == NULL) {
+		pr_err("%s np NULL1\n", __func__);
+	} else {
+		ret = of_property_read_u32(np, "fuelgauge,capacity_max",
+				&fuelgauge->pdata->capacity_max);
+		if (ret < 0)
+			pr_err("%s error reading capacity_max %d\n",
+							__func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_max_margin",
+				&fuelgauge->pdata->capacity_max_margin);
+		if (ret < 0)
+			pr_err("%s error reading capacity_max_margin %d\n",
+								__func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_min",
+				&fuelgauge->pdata->capacity_min);
+		if (ret < 0)
+			pr_err("%s error reading capacity_min %d\n",
+								__func__, ret);
+
+		ret = of_property_read_u32(np,
+				"fuelgauge,capacity_calculation_type",
+				&fuelgauge->pdata->capacity_calculation_type);
+		if (ret < 0)
+			pr_err("%s error reading capacity_calculation_type %d\n",
+					__func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,fuel_alert_soc",
+				&fuelgauge->pdata->fuel_alert_soc);
+		if (ret < 0)
+			pr_err("%s error reading pdata->fuel_alert_soc %d\n",
+					__func__, ret);
+		fuelgauge->pdata->repeated_fuelalert = of_property_read_bool(np,
+				"fuelgauge,repeated_fuelalert");
+
+		np = of_find_node_by_name(NULL, "battery");
+		if (!np) {
+			pr_err("%s np NULL2\n", __func__);
+			return 1;
+		} else {
+			ret = of_property_read_string(np,
+				"battery,fuelgauge_name",
+				(char const **)&fuelgauge->
+					pdata->fuelgauge_name);
+			p = of_get_property(np,
+					"battery,input_current_limit", &len);
+			if (!p)
+				return 1;
+
+			len = len / sizeof(u32);
+			fuelgauge->pdata->charging_current =
+				kzalloc(sizeof(struct sec_charging_current)
+							* len, GFP_KERNEL);
+
+			for (i = 0; i < len; i++) {
+				ret = of_property_read_u32_index(np,
+					"battery,input_current_limit", i,
+				&fuelgauge->pdata->charging_current[i].
+							input_current_limit);
+				ret = of_property_read_u32_index(np,
+					"battery,fast_charging_current", i,
+				&fuelgauge->pdata->charging_current[i].
+							fast_charging_current);
+				ret = of_property_read_u32_index(np,
+					"battery,full_check_current_1st", i,
+				&fuelgauge->pdata->charging_current[i].
+							full_check_current_1st);
+				ret = of_property_read_u32_index(np,
+					"battery,full_check_current_2nd", i,
+					&fuelgauge->pdata->charging_current[i].
+							full_check_current_2nd);
+			}
+		}
+	}
+
+	return 0;
+}
+
+static struct of_device_id s2mu003_fuelgauge_match_table[] = {
+	{ .compatible = "samsung,s2mu003-fuelgauge",},
+	{},
+};
+#else
+static int s2mu003_fuelgauge_parse_dt(struct s2mu003_fuelgauge_data *fuelgauge)
+{
+	return -ENOSYS;
+}
+
+#define s2mu003_fuelgauge_match_table NULL
+#endif /* CONFIG_OF */
+
+static int s2mu003_fuelgauge_probe(struct i2c_client *client,
+						const struct i2c_device_id *id)
+{
+	struct s2mu003_fuelgauge_data *fuelgauge;
+	union power_supply_propval raw_soc_val;
+	int ret = 0;
+
+	pr_info("%s: S2MU003 Fuelgauge Driver Loading\n", __func__);
+
+	fuelgauge = kzalloc(sizeof(*fuelgauge), GFP_KERNEL);
+	if (!fuelgauge)
+		return -ENOMEM;
+
+	mutex_init(&fuelgauge->fg_lock);
+
+	fuelgauge->i2c = client;
+
+#ifdef CONFIG_OF
+	fuelgauge->pdata = devm_kzalloc(&client->dev,
+			sizeof(*(fuelgauge->pdata)), GFP_KERNEL);
+	if (!fuelgauge->pdata) {
+		dev_err(&client->dev, "Failed to allocate memory\n");
+		ret = -ENOMEM;
+		goto err_parse_dt_nomem;
+	}
+	ret = s2mu003_fuelgauge_parse_dt(fuelgauge);
+	if (ret < 0)
+		goto err_parse_dt;
+#else
+		fuelgauge->pdata = mfd_pdata->charger_platform_data;
+#endif
+
+	i2c_set_clientdata(client, fuelgauge);
+
+	if (fuelgauge->pdata->fuelgauge_name == NULL)
+		fuelgauge->pdata->fuelgauge_name = "sec-fuelgauge";
+
+	fuelgauge->psy_fg.name          = fuelgauge->pdata->fuelgauge_name;
+	fuelgauge->psy_fg.type          = POWER_SUPPLY_TYPE_UNKNOWN;
+	fuelgauge->psy_fg.get_property  = s2mu003_fg_get_property;
+	fuelgauge->psy_fg.set_property  = s2mu003_fg_set_property;
+	fuelgauge->psy_fg.properties    = s2mu003_fuelgauge_props;
+	fuelgauge->psy_fg.num_properties =
+			ARRAY_SIZE(s2mu003_fuelgauge_props);
+
+	fuelgauge->capacity_max = fuelgauge->pdata->capacity_max;
+	raw_soc_val.intval = s2mu003_get_rawsoc(fuelgauge) / 10;
+
+	if (raw_soc_val.intval > fuelgauge->capacity_max)
+		s2mu003_fg_calculate_dynamic_scale(fuelgauge, 100);
+
+	ret = s2mu003_init_regs(fuelgauge);
+	if (ret < 0) {
+		pr_err("%s: Failed to Initialize Fuelgauge\n", __func__);
+		/* goto err_data_free; */
+	}
+
+	ret = power_supply_register(&client->dev, &fuelgauge->psy_fg);
+	if (ret) {
+		pr_err("%s: Failed to Register psy_fg\n", __func__);
+		goto err_data_free;
+	}
+
+	fuelgauge->initial_update_of_soc = true;
+
+	pr_info("%s: S2MU003 Fuelgauge Driver Loaded\n", __func__);
+	return 0;
+
+err_data_free:
+	if (client->dev.of_node)
+		kfree(fuelgauge->pdata);
+
+err_parse_dt:
+err_parse_dt_nomem:
+	mutex_destroy(&fuelgauge->fg_lock);
+	kfree(fuelgauge);
+
+	return ret;
+}
+
+static void s2mu003_fuelgauge_shutdown(struct i2c_client *i2c)
+{
+}
+
+static int s2mu003_fuelgauge_remove(struct i2c_client *i2c)
+{
+	struct s2mu003_fuelgauge_data *fuelgauge =
+				i2c_get_clientdata(i2c);
+
+	if (fuelgauge->pdata->fuel_alert_soc >= 0)
+		wake_lock_destroy(&fuelgauge->fuel_alert_wake_lock);
+
+	return 0;
+}
+
+#if defined CONFIG_PM
+static int s2mu003_fuelgauge_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int s2mu003_fuelgauge_resume(struct device *dev)
+{
+	struct i2c_client *i2c =
+		container_of(dev, struct i2c_client, dev);
+	struct s2mu003_fuelgauge_data *fuelgauge =
+				i2c_get_clientdata(i2c);
+	fuelgauge->initial_update_of_soc = true;
+
+	return 0;
+}
+#else
+#define s2mu003_fuelgauge_suspend NULL
+#define s2mu003_fuelgauge_resume NULL
+#endif
+
+static const struct i2c_device_id s2mu003_fuelgauge_id[] = {
+	{"s2mu003-fuelgauge", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, s2mu003_fuelgauge_id);
+
+static SIMPLE_DEV_PM_OPS(s2mu003_fuelgauge_pm_ops, s2mu003_fuelgauge_suspend,
+		s2mu003_fuelgauge_resume);
+
+static struct i2c_driver s2mu003_fuelgauge_driver = {
+	.driver = {
+		.name = "s2mu003-fuelgauge",
+		.owner = THIS_MODULE,
+		.pm = &s2mu003_fuelgauge_pm_ops,
+		.of_match_table = s2mu003_fuelgauge_match_table,
+	},
+	.probe  = s2mu003_fuelgauge_probe,
+	.remove = s2mu003_fuelgauge_remove,
+	.shutdown   = s2mu003_fuelgauge_shutdown,
+	.id_table   = s2mu003_fuelgauge_id,
+};
+
+static int __init s2mu003_fuelgauge_init(void)
+{
+	int ret = 0;
+
+	ret = i2c_add_driver(&s2mu003_fuelgauge_driver);
+
+	return ret;
+}
+
+static void __exit s2mu003_fuelgauge_exit(void)
+{
+	i2c_del_driver(&s2mu003_fuelgauge_driver);
+}
+module_init(s2mu003_fuelgauge_init);
+module_exit(s2mu003_fuelgauge_exit);
+
+MODULE_DESCRIPTION("Samsung S2MU003 Fuel Gauge Driver");
+MODULE_AUTHOR("Samsung Electronics");
+MODULE_LICENSE("GPL");
diff -Naur linux-3.18.14/drivers/battery/s2mu005_charger.c samsung/drivers/battery/s2mu005_charger.c
--- linux-3.18.14/drivers/battery/s2mu005_charger.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery/s2mu005_charger.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,1438 @@
+/* drivers/battery/s2mu005_charger.c
+ * S2MU005 Charger Driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ */
+#include <linux/mfd/samsung/s2mu005.h>
+#include <linux/battery/charger/s2mu005_charger.h>
+#include <linux/version.h>
+#include <linux/sec_batt.h>
+
+#define ENABLE_MIVR 1
+
+#define EN_OVP_IRQ 1
+#define EN_IEOC_IRQ 1
+#define EN_TOPOFF_IRQ 1
+#define EN_RECHG_REQ_IRQ 0
+#define EN_TR_IRQ 0
+#define EN_MIVR_SW_REGULATION 0
+#define EN_BST_IRQ 0
+#define MINVAL(a, b) ((a <= b) ? a : b)
+
+#define EOC_DEBOUNCE_CNT 2
+#define HEALTH_DEBOUNCE_CNT 3
+#define DEFAULT_CHARGING_CURRENT 500
+
+#define EOC_SLEEP 200
+#define EOC_TIMEOUT (EOC_SLEEP * 6)
+#ifndef EN_TEST_READ
+#define EN_TEST_READ 1
+#endif
+
+#define ENABLE 1
+#define DISABLE 0
+
+struct s2mu005_charger_data {
+	struct i2c_client       *client;
+	struct device *dev;
+	struct s2mu005_platform_data *s2mu005_pdata;
+	struct delayed_work	charger_work;
+	struct delayed_work	det_bat_work;
+	struct workqueue_struct *charger_wqueue;
+	struct power_supply	psy_chg;
+	struct power_supply	psy_otg;
+	s2mu005_charger_platform_data_t *pdata;
+	int dev_id;
+	int input_current;
+	int charging_current;
+	int topoff_current;
+	int cable_type;
+	bool is_charging;
+	int charge_mode;
+	struct mutex io_lock;
+
+	/* register programming */
+	int reg_addr;
+	int reg_data;
+
+	bool ovp;
+	int unhealth_cnt;
+	int status;
+
+	/* s2mu005 */
+	int irq_det_bat;
+	int irq_chg;
+	u8 fg_clock;
+	int fg_mode;	
+};
+
+static enum power_supply_property sec_charger_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_CHARGE_TYPE,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_CURRENT_MAX,
+	POWER_SUPPLY_PROP_CURRENT_AVG,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL,
+	POWER_SUPPLY_PROP_CHARGING_ENABLED,
+	POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION,
+	POWER_SUPPLY_PROP_AUTHENTIC,
+};
+
+static enum power_supply_property s2mu005_otg_props[] = {
+	POWER_SUPPLY_PROP_ONLINE,
+};
+
+int otg_enable_flag;
+
+static void s2mu005_set_fast_charging_current(struct i2c_client *i2c,
+		int charging_current);
+static int s2mu005_get_charging_health(struct s2mu005_charger_data *charger);
+
+static void s2mu005_test_read(struct i2c_client *i2c)
+{
+	u8 data;
+	char str[1016] = {0,};
+	int i;
+
+	for (i = 0x8; i <= 0x1A; i++) {
+		s2mu005_read_reg(i2c, i, &data);
+
+		sprintf(str+strlen(str), "0x%02x:0x%02x, ", i, data);
+	}
+
+	pr_info("[DEBUG]%s: %s\n", __func__, str);
+}
+static BLOCKING_NOTIFIER_HEAD(s2m_acok_notifier_list);
+
+static int s2m_acok_register_notifier(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_register(&s2m_acok_notifier_list, nb);
+}
+
+static int s2m_acok_unregister_notifier(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_unregister(&s2m_acok_notifier_list, nb);
+}
+
+int s2m_acok_notify_call_chain(void)
+{
+	int ret = blocking_notifier_call_chain(&s2m_acok_notifier_list, 0, NULL);
+	return notifier_to_errno(ret);
+}
+EXPORT_SYMBOL(s2m_acok_notify_call_chain);
+
+static int s2m_acok_notifier_call(
+				struct notifier_block *notifer,
+				unsigned long event, void *v)
+{
+	struct power_supply *psy = get_power_supply_by_name("s2mu005-charger");
+	struct s2mu005_charger_data *charger =
+		container_of(psy, struct s2mu005_charger_data, psy_chg);
+	pr_info("s2m acok noti!!\n");
+	/* Delay 100ms for debounce */
+	queue_delayed_work(charger->charger_wqueue, &charger->charger_work, msecs_to_jiffies(100));
+	return true;
+}
+
+struct notifier_block s2m_acok_notifier = {
+	.notifier_call = s2m_acok_notifier_call,
+};
+
+static void s2mu005_charger_otg_control(struct s2mu005_charger_data *charger,
+		bool enable)
+{
+	otg_enable_flag = enable;
+
+	if (!enable) {
+		/* set mode to Charger mode */
+		s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL0,
+			2 << REG_MODE_SHIFT, REG_MODE_MASK);
+
+		/* OTG OCP debounce time 100usec->1msec, 0x88[3:2]=11 --> 10 */
+		s2mu005_update_reg(charger->client, 0x88,
+			0x8, 0xC);
+
+		/* mask VMID_INT */
+		s2mu005_update_reg(charger->client, S2MU005_REG_SC_INT_MASK,
+			1 << VMID_M_SHIFT, VMID_M_MASK);
+
+		pr_info("%s : Turn off OTG\n",	__func__);
+	} else {
+		/* unmask VMID_INT */
+		s2mu005_update_reg(charger->client, S2MU005_REG_SC_INT_MASK,
+			0 << VMID_M_SHIFT, VMID_M_MASK);
+
+		/* set mode to OTG */
+		s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL0,
+			4 << REG_MODE_SHIFT, REG_MODE_MASK);
+
+		/* OTG OCP debounce time 100usec->1msec, 0x88[3:2]=10 --> 11 */
+		s2mu005_update_reg(charger->client, 0x88,
+			0xC, 0xC);
+
+		/* set boost frequency to 1MHz */
+		s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL11,
+			2 << SET_OSC_BST_SHIFT, SET_OSC_BST_MASK);
+
+		/* set OTG current limit to 1.5 A */
+		s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL4,
+			3 << SET_OTG_OCP_SHIFT, SET_OTG_OCP_MASK);
+
+		/* VBUS switches are OFF when OTG over-current happen */
+		s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL4,
+			1 << OTG_OCP_SW_OFF_SHIFT, OTG_OCP_SW_OFF_MASK);
+
+		/* set OTG voltage to 5.1 V */
+		s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL5,
+			0x16 << SET_VF_VMID_BST_SHIFT, SET_VF_VMID_BST_MASK);
+
+		pr_info("%s : Turn on OTG\n",	__func__);
+	}
+#if EN_TEST_READ
+	s2mu005_test_read(charger->client);
+#endif
+}
+
+static void s2mu005_wdt_control(struct s2mu005_charger_data *charger,
+		int onoff)
+{
+	u8 temp;
+	
+	if (onoff > 0) {
+		s2mu005_read_reg(charger->client, 0x1A, &temp);
+		temp &= ~0x3;
+		temp |= 0x2;
+		s2mu005_write_reg(charger->client, 0x1A, temp);
+		pr_info("%s : Watchdog Timer Enabled,\n",	__func__);
+	} else {
+		s2mu005_read_reg(charger->client, 0x1A, &temp);
+		temp &= ~0x3;
+		temp |= 0x1;
+		s2mu005_write_reg(charger->client, 0x1A, temp);
+		pr_info("%s : Watchdog Timer Disabled,\n",	__func__);
+	}
+}
+
+static int s2mu005_get_charger_switch_status(struct s2mu005_charger_data *charger)
+{
+	u8 temp;
+	int ret;
+
+	ret = s2mu005_read_reg(charger->client, S2MU005_CHG_CTRL0, &temp);
+	if(ret < 0)
+		return ret;
+
+	ret = temp&0x07;
+	pr_info("%s : charger status 0x%x \n", __func__, ret);
+
+	return ret;
+}
+
+static void s2mu005_enable_charger_switch(struct s2mu005_charger_data *charger,
+		int onoff)
+{
+	if (factory_mode) {
+		pr_info("%s: Factory Mode Skip CHG_EN Control\n", __func__);
+		return;
+	}
+
+	/* prevent vsys drip, set full current at QBAT */
+	s2mu005_set_fast_charging_current(charger->client, 1700);
+	msleep(20);
+
+	if (onoff > 0) {
+		pr_info("[DEBUG]%s: turn on charger\n", __func__);
+		s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL0,
+			0 << REG_MODE_SHIFT, REG_MODE_MASK);
+		msleep(50);
+		s2mu005_update_reg(charger->client, 0x2A, 0 << 3, 0x08); // set async time 150msec
+		s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL0,
+			2 << REG_MODE_SHIFT, REG_MODE_MASK);
+		msleep(150);
+		s2mu005_update_reg(charger->client, 0x2A, 1 << 3, 0x08); // set async time 20msec recover
+		s2mu005_wdt_control(charger, 1); //watchdog timer enable
+	} else {
+		pr_info("[DEBUG] %s: turn off charger\n", __func__);
+		s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL0,
+			0 << REG_MODE_SHIFT, REG_MODE_MASK);
+		s2mu005_wdt_control(charger, 0); //watchdog timer disable
+	}
+}
+
+static void s2mu005_set_regulation_voltage(struct s2mu005_charger_data *charger,
+		int float_voltage)
+{
+	int data;
+
+	if (factory_mode)
+		return;
+
+	pr_info("[DEBUG]%s: float_voltage %d \n", __func__, float_voltage);
+	if (float_voltage <= 3900)
+		data = 0;
+	else if (float_voltage > 3900 && float_voltage <= 4400)
+		data = (float_voltage - 3900) / 10;
+	else
+		data = 0x32;
+
+	s2mu005_update_reg(charger->client,
+		S2MU005_CHG_CTRL8, data << SET_VF_VBAT_SHIFT, SET_VF_VBAT_MASK);
+}
+
+static void s2mu005_set_input_current_limit(struct s2mu005_charger_data *charger,
+		int charging_current)
+{
+	int data;
+
+	if (factory_mode)
+		return;
+
+	pr_info("[DEBUG]%s: current  %d \n", __func__, charging_current);
+	if (charging_current <= 100)
+		data = 0;
+	else if (charging_current >= 100 && charging_current <= 2600)
+		data = (charging_current - 100) / 50;
+	else
+		data = 0x3F;
+
+	s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL2, data << INPUT_CURRENT_LIMIT_SHIFT,
+			INPUT_CURRENT_LIMIT_MASK);
+#if EN_TEST_READ
+	s2mu005_test_read(charger->client);
+#endif
+}
+
+static int s2mu005_get_input_current_limit(struct i2c_client *i2c)
+{
+	u8 data;
+	int ret;
+
+	ret = s2mu005_read_reg(i2c, S2MU005_CHG_CTRL2, &data);
+	if (ret < 0)
+		return ret;
+
+	data = data & INPUT_CURRENT_LIMIT_MASK;
+
+	if (data > 0x3F)
+		data = 0x3F;
+	return  data * 50 + 100;
+
+}
+
+static void s2mu005_set_fast_charging_current(struct i2c_client *i2c,
+		int charging_current)
+{
+	int data;
+
+	if (factory_mode)
+		return;
+
+	pr_info("[DEBUG]%s: current  %d \n", __func__, charging_current);
+	if (charging_current <= 100)
+		data = 0;
+	else if (charging_current >= 100 && charging_current <= 2600)
+		data = ((charging_current - 100) / 50) + 1;
+	else
+		data = 0x33;
+
+	s2mu005_update_reg(i2c, S2MU005_CHG_CTRL7, data << FAST_CHARGING_CURRENT_SHIFT,
+			FAST_CHARGING_CURRENT_MASK);
+
+	/* work-around for unstable booting */
+	if (data > 0x13) data = 0x13; /* 0x13 : 1A */
+	s2mu005_update_reg(i2c, S2MU005_CHG_CTRL6, data << COOL_CHARGING_CURRENT_SHIFT,
+	COOL_CHARGING_CURRENT_MASK); /* set cool charging current with max limit 1A */
+
+#if EN_TEST_READ
+	s2mu005_test_read(i2c);
+#endif
+}
+
+static int s2mu005_get_fast_charging_current(struct i2c_client *i2c)
+{
+	u8 data;
+	int ret;
+
+	ret = s2mu005_read_reg(i2c, S2MU005_CHG_CTRL7, &data);
+	if (ret < 0)
+		return ret;
+
+	data = data & FAST_CHARGING_CURRENT_MASK;
+
+	if (data > 0x33)
+		data = 0x33;
+	return (data - 1 )* 50 + 100;
+}
+
+static int s2mu005_get_topoff_current(struct s2mu005_charger_data *charger)
+{
+	u8 data;
+	int ret;
+
+	ret = s2mu005_read_reg(charger->client, S2MU005_CHG_CTRL10, &data);
+	if (ret < 0)
+		return ret;
+
+	data = data & FIRST_TOPOFF_CURRENT_MASK;
+
+	if (data > 0x0F)
+		data = 0x0F;
+	return data * 25 + 100;
+}
+
+static void s2mu005_set_topoff_current(struct i2c_client *i2c,
+		int eoc_1st_2nd, int current_limit)
+{
+	int data;
+
+	pr_info("[DEBUG]%s: current  %d \n", __func__, current_limit);
+	if (current_limit <= 100)
+		data = 0;
+	else if (current_limit > 100 && current_limit <= 475)
+		data = (current_limit - 100) / 25;
+	else
+		data = 0x0F;
+
+	switch(eoc_1st_2nd) {
+	case 1:
+		s2mu005_update_reg(i2c, S2MU005_CHG_CTRL10, data << FIRST_TOPOFF_CURRENT_SHIFT,
+			FIRST_TOPOFF_CURRENT_MASK);
+		break;
+	case 2:
+		s2mu005_update_reg(i2c, S2MU005_CHG_CTRL10, data << SECOND_TOPOFF_CURRENT_SHIFT,
+			SECOND_TOPOFF_CURRENT_MASK);
+		break;
+	default:
+		break;
+	}
+}
+
+enum {
+	S2MU005_MIVR_4200MV = 0,
+	S2MU005_MIVR_4300MV,
+	S2MU005_MIVR_4400MV,
+	S2MU005_MIVR_4500MV,
+	S2MU005_MIVR_4600MV,
+	S2MU005_MIVR_4700MV,
+	S2MU005_MIVR_4800MV,
+	S2MU005_MIVR_4900MV,
+};
+
+#if ENABLE_MIVR
+/* charger input regulation voltage setting */
+static void s2mu005_set_mivr_level(struct s2mu005_charger_data *charger)
+{
+	int mivr = S2MU005_MIVR_4500MV;
+	u8 temp = 0;
+
+	s2mu005_read_reg(charger->client, 0x1A, &temp);
+	temp |= 0x80;
+	s2mu005_write_reg(charger->client, 0x1A, temp);
+
+	s2mu005_update_reg(charger->client,
+			S2MU005_CHG_CTRL1, mivr << SET_VIN_DROP_SHIFT, SET_VIN_DROP_MASK);
+}
+#endif /*ENABLE_MIVR*/
+
+/* here is set init charger data */
+#define S2MU003_MRSTB_CTRL 0X47
+static bool s2mu005_chg_init(struct s2mu005_charger_data *charger)
+{
+	u8 temp;
+	/* Read Charger IC Dev ID */
+	s2mu005_read_reg(charger->client, S2MU005_REG_REV_ID, &temp);
+	charger->dev_id = temp & 0x0F;
+
+	dev_info(charger->dev, "%s : DEV ID : 0x%x\n", __func__,
+			charger->dev_id);
+
+	/* ready for self-discharge */
+	s2mu005_update_reg(charger->client, S2MU005_REG_SELFDIS_CFG3,
+			SELF_DISCHG_MODE_MASK, SELF_DISCHG_MODE_MASK);
+
+	/* Buck switching mode frequency setting */
+
+	/* Disable Timer function (Charging timeout fault) */
+	// to be
+
+	/* Disable TE */
+	// to be
+
+	/* MUST set correct regulation voltage first
+	 * Before MUIC pass cable type information to charger
+	 * charger would be already enabled (default setting)
+	 * it might cause EOC event by incorrect regulation voltage */
+	// to be
+
+#if !(ENABLE_MIVR)
+	/* voltage regulatio disable does not exist mu005 */
+#endif
+	/* TOP-OFF debounce time set 256us */
+	// only 003 ? need to check
+
+	/* Disable (set 0min TOP OFF Timer) */
+	// to be
+
+	s2mu005_read_reg(charger->client, 0x7B, &temp);
+
+	s2mu005_update_reg(charger->client, 0x2A, 1 << 3, 0x08); // set async time 20msec recover
+
+	charger->fg_clock = temp;
+
+	s2mu005_read_reg(charger->client, 0x20, &temp); //topoff timer 90min, watchdog timer 80sec
+	temp &= ~0x3F;
+	temp |= 0x35;
+	s2mu005_write_reg(charger->client, 0x20, temp);
+
+	s2mu005_read_reg(charger->client, S2MU005_CHG_CTRL0, &temp); //Always CHG_EN is ENABLED
+	if( !(temp & 0x10) )
+	{
+		temp |= 0x10;
+		s2mu005_write_reg(charger->client, S2MU005_CHG_CTRL0, temp);
+		dev_info(charger->dev, "%s: CHG CTRL0 CHG EN : 0x%02x\n", __func__,temp);
+	}
+	
+	/* float voltage */
+	s2mu005_set_regulation_voltage(charger,
+			charger->pdata->chg_float_voltage);
+	
+	dev_info(charger->dev, "%s: set float voltage : %d\n", __func__,charger->pdata->chg_float_voltage);
+
+	s2mu005_read_reg(charger->client, 0x29, &temp); //Disable FC_CHG and PRE_CHG Timers
+	temp &= 0x7F;
+	s2mu005_write_reg(charger->client, 0x29, temp);
+
+	return true;
+}
+
+static void s2mu005_charger_initialize(struct s2mu005_charger_data *charger)
+{
+	u8 temp = 0;
+
+	s2mu005_read_reg(charger->client, 0x5A, &temp);
+	temp |= 0x80;
+	s2mu005_write_reg(charger->client, 0x5A, temp);
+
+	if(charger->dev_id == 0) {
+		s2mu005_write_reg(charger->client, 0x87, 0x00);
+		s2mu005_write_reg(charger->client, 0x92, 0xE5);
+		s2mu005_write_reg(charger->client, 0x97, 0x85);
+		s2mu005_write_reg(charger->client, 0x9A, 0x67);
+		s2mu005_write_reg(charger->client, 0x9C, 0xEA);
+		s2mu005_write_reg(charger->client, 0x9E, 0x6E);
+		s2mu005_write_reg(charger->client, 0xA1, 0x20);
+		s2mu005_write_reg(charger->client, 0xA4, 0x0A);
+		s2mu005_write_reg(charger->client, 0xA5, 0x45);
+
+		s2mu005_read_reg(charger->client, 0x51, &temp);
+		if(temp & 0x02) {
+			s2mu005_read_reg(charger->client, 0x49, &temp);
+			switch(temp & 0x1F) {
+				case 0x18:
+				case 0x19:
+				case 0x1C:
+				case 0x1D:
+					break;
+				default:
+					s2mu005_read_reg(charger->client, 0x89, &temp);
+					temp &= 0xFC;
+					temp |= 0x01;
+					s2mu005_write_reg(charger->client, 0x89, temp);
+					break;
+			}
+		}
+	}
+	/* set fastest speed for QBAT switch */
+	s2mu005_read_reg(charger->client, 0x87, &temp);
+	temp &= ~0xF0;
+	s2mu005_write_reg(charger->client, 0x87, temp);
+
+	s2mu005_write_reg(charger->client, 0x27, 0x51);
+	
+	s2mu005_read_reg(charger->client, 0x20, &temp); //topoff timer 90min, watchdog timer 80sec
+	temp &= ~0x3F;
+	temp |= 0x35;
+	s2mu005_write_reg(charger->client, 0x20, temp);
+	
+	s2mu005_write_reg(charger->client, 0x1A, 0x91);
+
+	s2mu005_read_reg(charger->client, 0x13, &temp);
+	temp &= ~0x60;
+	s2mu005_write_reg(charger->client, 0x13, temp);
+
+	s2mu005_read_reg(charger->client, 0xA8, &temp);
+	temp &= 0x7F;
+	temp |= 0x80;
+	s2mu005_write_reg(charger->client, 0xA8, temp);
+
+	s2mu005_write_reg(charger->client, 0x0F, 0x50);
+
+	s2mu005_read_reg(charger->client, 0x89, &temp);
+	temp &= ~0x80;
+	s2mu005_write_reg(charger->client, 0x89, temp);
+
+	s2mu005_read_reg(charger->client, 0xA5, &temp);
+	temp &= ~0x04;
+	s2mu005_write_reg(charger->client, 0xA5, temp);
+
+	s2mu005_read_reg(charger->client, 0x20, &temp); //topoff timer 90min
+	temp &= ~0x38;
+	temp |= 0x30;
+	s2mu005_write_reg(charger->client, 0x20, temp);
+
+#if ENABLE_MIVR
+	s2mu005_set_mivr_level(charger);
+#endif /*DISABLE_MIVR*/
+	/* float voltage */
+	s2mu005_set_regulation_voltage(charger,
+			charger->pdata->chg_float_voltage);
+	/* topoff current */
+	charger->topoff_current = 100;
+	s2mu005_set_topoff_current(charger->client, 1, charger->topoff_current);
+	if (charger->pdata->chg_eoc_dualpath) {
+		s2mu005_set_topoff_current(charger->client, 2, charger->topoff_current);
+	}
+
+	dev_info(charger->dev, "%s: Re-initialize Charger completely\n", __func__);
+}
+
+static int s2mu005_get_charging_status(struct s2mu005_charger_data *charger)
+{
+	int status = POWER_SUPPLY_STATUS_UNKNOWN;
+	int ret;
+	u8 chg_sts;
+	union power_supply_propval chg_mode;
+	union power_supply_propval value;
+
+	ret = s2mu005_read_reg(charger->client, S2MU005_CHG_STATUS0, &chg_sts);
+	psy_do_property("battery", get, POWER_SUPPLY_PROP_CHARGE_NOW, chg_mode);
+	psy_do_property("s2mu005-fuelgauge", get, POWER_SUPPLY_PROP_CURRENT_AVG, value);
+
+	if (ret < 0)
+		return status;
+
+	switch (chg_sts & 0x0F) {
+	case 0x00:	//charger is off
+		status = POWER_SUPPLY_STATUS_DISCHARGING;
+		break;
+	case 0x02:	//Pre-charge state
+	case 0x03:	//Cool-charge state
+	case 0x04:	//CC state
+	case 0x05:	//CV state
+		status = POWER_SUPPLY_STATUS_CHARGING;
+		break;
+	case 0x07:	//Top-off state
+	case 0x06:	//Done Flag
+	case 0x08:	//Done state
+		dev_info(charger->dev, "%s: full check curr_avg(%d), topoff_curr(%d)\n",
+			__func__, value.intval, charger->topoff_current);
+		if (value.intval < charger->topoff_current)
+			status = POWER_SUPPLY_STATUS_FULL;
+		else
+			status = POWER_SUPPLY_STATUS_CHARGING;
+		break;
+	case 0x0F:	//Input is invalid
+		status = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		break;
+	default:
+		break;
+	}
+
+#if EN_TEST_READ
+	s2mu005_test_read(charger->client);
+#endif
+	return status;
+}
+
+static int s2mu005_get_charge_type(struct i2c_client *iic)
+{
+	int status = POWER_SUPPLY_CHARGE_TYPE_UNKNOWN;
+	u8 ret;
+
+	s2mu005_read_reg(iic, S2MU005_CHG_STATUS0, &ret);
+	if (ret < 0)
+		dev_err(&iic->dev, "%s fail\n", __func__);
+
+	switch (ret & CHG_OK_MASK ) {
+	case CHG_OK_MASK:
+		status = POWER_SUPPLY_CHARGE_TYPE_FAST;
+		break;
+	default:
+		/* 005 does not need to do this */
+		/* pre-charge mode */
+		status = POWER_SUPPLY_CHARGE_TYPE_TRICKLE;
+		break;
+	}
+
+	return status;
+}
+
+static bool s2mu005_get_batt_present(struct i2c_client *iic)
+{
+	u8 ret;
+
+	s2mu005_read_reg(iic, S2MU005_CHG_STATUS1, &ret);
+	if (ret < 0)
+		return false;
+
+	return (ret & DET_BAT_STATUS_MASK) ? true : false;
+}
+
+static void s2mu005_wdt_clear(struct s2mu005_charger_data *charger)
+{
+	u8 status3;
+	u8 ctrl13;
+	
+	s2mu005_read_reg(charger->client, S2MU005_CHG_STATUS3, &status3);
+
+	s2mu005_read_reg(charger->client, S2MU005_CHG_CTRL13, &ctrl13);
+	ctrl13 &= ~0x1;
+	ctrl13 |= 0x1;
+	s2mu005_write_reg(charger->client, S2MU005_CHG_CTRL13, ctrl13); /* wdt clear */
+	
+	status3 &= 0x0f;
+
+	if (status3 == 0x05) {
+		dev_info(&charger->client->dev,
+			"%s: watchdog error status, enable charger\n", __func__);
+		s2mu005_enable_charger_switch(charger, charger->is_charging);
+	}
+}
+
+static int s2mu005_get_charging_health(struct s2mu005_charger_data *charger)
+{
+	u8 ret;
+
+	s2mu005_read_reg(charger->client, S2MU005_CHG_STATUS1, &ret);
+	
+	if(charger->is_charging) {
+		s2mu005_wdt_clear(charger);
+	}
+
+	if (ret < 0)
+		return POWER_SUPPLY_HEALTH_UNKNOWN;
+
+	ret = (ret & 0x70) >> 4;
+	switch (ret) {
+	case 0x03:
+	case 0x05:
+		charger->ovp = false;
+		charger->unhealth_cnt = 0;
+		return POWER_SUPPLY_HEALTH_GOOD;
+	default:
+		break;
+	}
+
+	charger->unhealth_cnt++;
+	if (charger->unhealth_cnt < HEALTH_DEBOUNCE_CNT)
+		return POWER_SUPPLY_HEALTH_GOOD;
+
+	/* 005 need to check ovp & health count */
+	charger->unhealth_cnt = HEALTH_DEBOUNCE_CNT;
+	if (charger->ovp)
+		return POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+	return POWER_SUPPLY_HEALTH_UNDERVOLTAGE;
+}
+
+static int sec_chg_get_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		union power_supply_propval *val)
+{
+	struct s2mu005_charger_data *charger =
+		container_of(psy, struct s2mu005_charger_data, psy_chg);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = charger->charging_current ? 1 : 0;
+		break;
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = s2mu005_get_charging_status(charger);
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = s2mu005_get_charging_health(charger);
+#if EN_TEST_READ
+		s2mu005_test_read(charger->client);
+#endif
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		val->intval = charger->input_current;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+		val->intval = s2mu005_get_input_current_limit(charger->client);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = s2mu005_get_fast_charging_current(charger->client);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_FULL:
+		val->intval = s2mu005_get_topoff_current(charger);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+		val->intval = s2mu005_get_charge_type(charger->client);
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+		val->intval = charger->pdata->chg_float_voltage;
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = s2mu005_get_batt_present(charger->client);
+		break;
+	case POWER_SUPPLY_PROP_CHARGING_ENABLED:
+		val->intval = charger->is_charging;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_NOW:
+		val->intval = s2mu005_get_charger_switch_status(charger);
+		break;
+	case POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sec_chg_set_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		const union power_supply_propval *val)
+{
+	struct s2mu005_charger_data *charger =
+		container_of(psy, struct s2mu005_charger_data, psy_chg);
+	int buck_state = ENABLE;
+	union power_supply_propval value;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		charger->status = val->intval;
+		break;
+		/* val->intval : type */
+	case POWER_SUPPLY_PROP_ONLINE:
+		charger->cable_type = val->intval;
+		charger->input_current =
+			charger->pdata->charging_current[charger->cable_type].input_current_limit;
+		pr_info("[DEBUG]%s:[BATT] cable_type(%d), input_current(%d)mA\n",
+			__func__, charger->cable_type, charger->input_current);
+
+		if (charger->cable_type != POWER_SUPPLY_TYPE_OTG) {
+			if (charger->cable_type == POWER_SUPPLY_TYPE_BATTERY ||
+					charger->cable_type == POWER_SUPPLY_TYPE_UNKNOWN) {
+				value.intval = 0;
+			} else {
+#if ENABLE_MIVR
+				s2mu005_set_mivr_level(charger);
+#endif 			/*DISABLE_MIVR*/
+				value.intval = 1;
+			}
+			psy_do_property("s2mu005-fuelgauge", set, POWER_SUPPLY_PROP_ENERGY_AVG, value);
+		}
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		{
+			int input_current = val->intval;
+			if (charger->input_current < input_current) {
+				input_current = charger->input_current;
+			}
+			s2mu005_set_input_current_limit(charger, input_current);
+		}
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		pr_info("[DEBUG] %s: is_charging %d\n", __func__, charger->is_charging);
+		charger->charging_current = val->intval;
+		/* set charging current */
+		if (charger->is_charging) {
+			/* decrease the charging current according to siop level */
+			s2mu005_set_fast_charging_current(charger->client, charger->charging_current);
+		}
+#if EN_TEST_READ
+		s2mu005_test_read(charger->client);
+#endif
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_FULL:
+		charger->topoff_current = val->intval;
+		if (charger->pdata->chg_eoc_dualpath) {
+			s2mu005_set_topoff_current(charger->client, 1, val->intval);
+			s2mu005_set_topoff_current(charger->client, 2, 100);
+		}
+		else
+			s2mu005_set_topoff_current(charger->client, 1, val->intval);
+		break;
+#if defined(CONFIG_BATTERY_SWELLING) || defined(CONFIG_BATTERY_SWELLING_SELF_DISCHARGING)
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+		pr_info("[DEBUG]%s: float voltage(%d)\n", __func__, val->intval);
+		charger->pdata->chg_float_voltage = val->intval;
+		s2mu005_set_regulation_voltage(charger,
+				charger->pdata->chg_float_voltage);
+		break;
+#endif
+	case POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL:
+		s2mu005_charger_otg_control(charger, val->intval);
+		break;
+	case POWER_SUPPLY_PROP_CHARGING_ENABLED:
+		charger->charge_mode = val->intval;
+		psy_do_property("battery", get, POWER_SUPPLY_PROP_ONLINE, value);
+		if (value.intval != POWER_SUPPLY_TYPE_OTG) {
+			pr_info("[DEBUG]%s: CHARGING_ENABLE\n", __func__);
+			switch (charger->charge_mode) {
+			case SEC_BAT_CHG_MODE_BUCK_OFF:
+				buck_state = DISABLE;
+			case SEC_BAT_CHG_MODE_CHARGING_OFF:
+				charger->is_charging = false;
+				break;
+			case SEC_BAT_CHG_MODE_CHARGING:
+				charger->is_charging = true;
+				break;
+			}
+			s2mu005_enable_charger_switch(charger, charger->is_charging);
+		} else {
+			pr_info("[DEBUG]%s: SKIP CHARGING CONTROL(%d)\n", __func__, value.intval);
+		}
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_ENABLED:
+		s2mu005_charger_initialize(charger);
+		break;
+	case POWER_SUPPLY_PROP_ENERGY_NOW:
+		/* Switch-off charger if JIG is connected */
+		if (val->intval && factory_mode) {
+			pr_info("%s: JIG Connection status: %d \n", __func__, val->intval);
+			s2mu005_enable_charger_switch(charger, false);
+		}
+		break;
+	case POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION:
+		if (val->intval) {
+			pr_info("%s: Relieve VBUS2BAT\n", __func__);
+			s2mu005_write_reg(charger->client, 0x26, 0x5D);
+		}
+		break;
+	case POWER_SUPPLY_PROP_AUTHENTIC:
+		if (val->intval) {
+			pr_info("%s: Bypass set\n", __func__);
+			s2mu005_write_reg(charger->client, 0x2A, 0x10);
+			s2mu005_write_reg(charger->client, 0x23, 0x15);
+			s2mu005_write_reg(charger->client, 0x24, 0x44);
+			s2mu005_update_reg(charger->client, 0xA1, 0, 0x01 << 6);
+		} else {
+			if (factory_mode)
+				s2mu005_update_reg(charger->client, 0xA1, 1, 0x01 << 6);
+		}
+		break;
+	case POWER_SUPPLY_PROP_RESISTANCE:
+		if(val->intval) {
+			s2mu005_update_reg(charger->client, S2MU005_REG_SELFDIS_CFG2,
+			FC_SELF_DISCHG_MASK, FC_SELF_DISCHG_MASK);
+		} else {
+			s2mu005_update_reg(charger->client, S2MU005_REG_SELFDIS_CFG2,
+			0, FC_SELF_DISCHG_MASK);
+		}
+		break;
+	case POWER_SUPPLY_PROP_SCOPE:
+		charger->fg_mode = val->intval;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int s2mu005_otg_get_property(struct power_supply *psy,
+				enum power_supply_property psp,
+				union power_supply_propval *val)
+{
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = otg_enable_flag;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int s2mu005_otg_set_property(struct power_supply *psy,
+				enum power_supply_property psp,
+				const union power_supply_propval *val)
+{
+	struct s2mu005_charger_data *charger =
+		container_of(psy, struct s2mu005_charger_data, psy_otg);
+	union power_supply_propval value;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		value.intval = val->intval;
+		pr_info("%s: OTG %s\n", __func__, value.intval > 0 ? "on" : "off");
+		psy_do_property(charger->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL, value);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/*
+ssize_t s2mu003_chg_show_attrs(struct device *dev,
+		const ptrdiff_t offset, char *buf)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct s2mu003_charger_data *charger =
+		container_of(psy, struct s2mu003_charger_data, psy_chg);
+	int i = 0;
+	char *str = NULL;
+
+	switch (offset) {
+	case CHG_REG:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%x\n",
+				charger->reg_addr);
+		break;
+	case CHG_DATA:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%x\n",
+				charger->reg_data);
+		break;
+	case CHG_REGS:
+		str = kzalloc(sizeof(char) * 256, GFP_KERNEL);
+		if (!str)
+			return -ENOMEM;
+
+	//	s2mu005_read_regs(charger->client, str);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%s\n",
+				str);
+
+		kfree(str);
+		break;
+	default:
+		i = -EINVAL;
+		break;
+	}
+
+	return i;
+}
+
+ssize_t s2mu003_chg_store_attrs(struct device *dev,
+		const ptrdiff_t offset,
+		const char *buf, size_t count)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct s2mu003_charger_data *charger =
+		container_of(psy, struct s2mu003_charger_data, psy_chg);
+
+	int ret = 0;
+	int x = 0;
+	uint8_t data = 0;
+
+	switch (offset) {
+	case CHG_REG:
+		if (sscanf(buf, "%x\n", &x) == 1) {
+			charger->reg_addr = x;
+			data = s2mu003_reg_read(charger->client,
+					charger->reg_addr);
+			charger->reg_data = data;
+			dev_dbg(dev, "%s: (read) addr = 0x%x, data = 0x%x\n",
+					__func__, charger->reg_addr, charger->reg_data);
+			ret = count;
+		}
+		break;
+	case CHG_DATA:
+		if (sscanf(buf, "%x\n", &x) == 1) {
+			data = (u8)x;
+
+			dev_dbg(dev, "%s: (write) addr = 0x%x, data = 0x%x\n",
+					__func__, charger->reg_addr, data);
+			ret = s2mu003_reg_write(charger->client,
+					charger->reg_addr, data);
+			if (ret < 0) {
+				dev_dbg(dev, "I2C write fail Reg0x%x = 0x%x\n",
+						(int)charger->reg_addr, (int)data);
+			}
+			ret = count;
+		}
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+*/
+
+static void s2mu005_det_bat_work(struct work_struct *work)
+{
+	struct s2mu005_charger_data *charger =
+		container_of(work, struct s2mu005_charger_data, det_bat_work.work);
+	u8 val;
+	union power_supply_propval value;
+
+	s2mu005_read_reg(charger->client, S2MU005_CHG_STATUS1, &val);
+	if ((val & DET_BAT_STATUS_MASK) == 0)
+	{
+		//value.intval = 0;
+		psy_do_property("s2mu005-fuelgauge", set, POWER_SUPPLY_PROP_CHARGE_EMPTY, value);
+		s2mu005_enable_charger_switch(charger, 0);
+		pr_info("charger-off if battery removed \n");
+	}
+}
+
+/* s2mu005 interrupt service routine */
+static irqreturn_t s2mu005_det_bat_isr(int irq, void *data)
+{
+	struct s2mu005_charger_data *charger = data;
+
+	queue_delayed_work(charger->charger_wqueue, &charger->det_bat_work, 0);
+
+	return IRQ_HANDLED;
+}
+static irqreturn_t s2mu005_chg_isr(int irq, void *data)
+{
+	struct s2mu005_charger_data *charger = data;
+	u8 val;
+
+	s2mu005_read_reg(charger->client, S2MU005_CHG_STATUS0, &val);
+	pr_info("[DEBUG] %s , %02x \n " , __func__, val);
+	if ( val & (CHG_STATUS_DONE << CHG_STATUS_SHIFT) )
+	{
+		pr_info("add self chg done \n");
+		/* add chg done code here */
+	}
+	return IRQ_HANDLED;
+}
+
+#if EN_OVP_IRQ
+static void s2mu005_ovp_work(struct work_struct *work)
+{
+	struct s2mu005_charger_data *charger =
+		container_of(work, struct s2mu005_charger_data, charger_work.work);
+	u8 val;
+	union power_supply_propval value;
+
+	s2mu005_read_reg(charger->client, S2MU005_CHG_STATUS1, &val);
+	val = (val & VBUS_OVP_MASK) >> VBUS_OVP_SHIFT;
+	if (val == 0x02) {
+		charger->ovp = true;
+		dev_info(charger->dev, "%s: OVP triggered, Vbus status: 0x%x\n", __func__, val);
+		charger->unhealth_cnt = HEALTH_DEBOUNCE_CNT;
+		value.intval = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+		psy_do_property("battery", set,
+			POWER_SUPPLY_PROP_HEALTH, value);
+	} else if(val == 0x03 || val == 0x05) {
+		if(charger->ovp) {
+			dev_info(charger->dev, "%s: Recover from OVP, Vbus status 0x%x \n " , __func__, val);
+			charger->unhealth_cnt = 0;
+			charger->ovp = false;
+			value.intval = POWER_SUPPLY_HEALTH_GOOD;
+			psy_do_property("battery", set,
+				POWER_SUPPLY_PROP_HEALTH, value);
+		}
+	}
+}
+#endif
+
+static int s2mu005_charger_parse_dt(struct device *dev,
+		struct s2mu005_charger_platform_data *pdata)
+{
+	struct device_node *np = of_find_node_by_name(NULL, "s2mu005-charger");
+	const u32 *p;
+	int ret, i, len;
+
+	/* SC_CTRL11 , SET_OSC_BUCK , Buck switching frequency setting
+		 * 0 : 500kHz
+         * 1 : 750kHz
+         * 2 : 1MHz
+         * 3 : 2MHz
+         */
+/*	ret = of_property_read_u32(np,
+		"battery,switching_frequency_mode", pdata->switching_frequency_mode);
+	if (!ret)
+		pdata->switching_frequency_mode = 1;
+	pr_info("%s : switching_frequency_mode = %d\n", __func__,
+			pdata->switching_frequency_mode);
+*/
+	/* SC_CTRL8 , SET_VF_VBAT , Battery regulation voltage setting */
+	ret = of_property_read_u32(np, "battery,chg_float_voltage",
+				&pdata->chg_float_voltage);
+
+	np = of_find_node_by_name(NULL, "battery");
+	if (!np) {
+		pr_err("%s np NULL\n", __func__);
+	} else {
+		ret = of_property_read_string(np,
+			"battery,charger_name", (char const **)&pdata->charger_name);
+
+		ret = of_property_read_u32(np, "battery,full_check_type_2nd",
+				&pdata->full_check_type_2nd);
+		if (ret)
+			pr_info("%s : Full check type 2nd is Empty\n", __func__);
+
+		pdata->chg_eoc_dualpath = of_property_read_bool(np,
+				"battery,chg_eoc_dualpath");
+
+		pdata->always_enable = of_property_read_bool(np,
+					"battery,always_enable");
+
+		p = of_get_property(np, "battery,input_current_limit", &len);
+		if (!p)
+			return 1;
+
+		len = len / sizeof(u32);
+
+		pdata->charging_current =
+			kzalloc(sizeof(sec_charging_current_t) * len,
+				GFP_KERNEL);
+
+		for(i = 0; i < len; i++) {
+			ret = of_property_read_u32_index(np,
+					"battery,input_current_limit", i,
+					&pdata->charging_current[i].input_current_limit);
+			if (ret)
+				pr_info("%s : Input_current_limit is Empty\n", __func__);
+		}
+	}
+
+	dev_info(dev, "s2mu005 charger parse dt retval = %d\n", ret);
+	return ret;
+}
+
+/* if need to set s2mu005 pdata */
+static struct of_device_id s2mu005_charger_match_table[] = {
+	{ .compatible = "samsung,s2mu005-charger",},
+	{},
+};
+
+static int s2mu005_charger_probe(struct platform_device *pdev)
+{
+	struct s2mu005_dev *s2mu005 = dev_get_drvdata(pdev->dev.parent);
+	struct s2mu005_platform_data *pdata = dev_get_platdata(s2mu005->dev);
+	struct s2mu005_charger_data *charger;
+	int ret = 0;
+
+	union power_supply_propval val;
+
+	otg_enable_flag = 0;
+	pr_info("%s:[BATT] S2MU005 Charger driver probe\n", __func__);
+	charger = kzalloc(sizeof(*charger), GFP_KERNEL);
+	if (!charger)
+		return -ENOMEM;
+
+	mutex_init(&charger->io_lock);
+
+	charger->dev = &pdev->dev;
+	charger->client = s2mu005->i2c;
+
+	charger->pdata = devm_kzalloc(&pdev->dev, sizeof(*(charger->pdata)),
+			GFP_KERNEL);
+	if (!charger->pdata) {
+		dev_err(&pdev->dev, "Failed to allocate memory\n");
+		ret = -ENOMEM;
+		goto err_parse_dt_nomem;
+	}
+	ret = s2mu005_charger_parse_dt(&pdev->dev, charger->pdata);
+	if (ret < 0)
+		goto err_parse_dt;
+
+	platform_set_drvdata(pdev, charger);
+
+	if (charger->pdata->charger_name == NULL)
+		charger->pdata->charger_name = "sec-charger";
+
+	charger->psy_chg.name           = charger->pdata->charger_name;
+	charger->psy_chg.type           = POWER_SUPPLY_TYPE_UNKNOWN;
+	charger->psy_chg.get_property   = sec_chg_get_property;
+	charger->psy_chg.set_property   = sec_chg_set_property;
+	charger->psy_chg.properties     = sec_charger_props;
+	charger->psy_chg.num_properties = ARRAY_SIZE(sec_charger_props);
+	charger->psy_otg.name		= "otg";
+	charger->psy_otg.type		= POWER_SUPPLY_TYPE_OTG;
+	charger->psy_otg.get_property	= s2mu005_otg_get_property;
+	charger->psy_otg.set_property	= s2mu005_otg_set_property;
+	charger->psy_otg.properties	= s2mu005_otg_props;
+	charger->psy_otg.num_properties	= ARRAY_SIZE(s2mu005_otg_props);
+
+	s2mu005_chg_init(charger);
+
+	ret = power_supply_register(&pdev->dev, &charger->psy_chg);
+	if (ret) {
+		pr_err("%s: Failed to Register psy_chg\n", __func__);
+		goto err_power_supply_register;
+	}
+
+	ret = power_supply_register(&pdev->dev, &charger->psy_otg);
+	if (ret) {
+		pr_err("%s: Failed to Register otg_chg\n", __func__);
+		goto err_power_supply_register_otg;
+	}
+
+	charger->charger_wqueue = create_singlethread_workqueue("charger-wq");
+	if (!charger->charger_wqueue) {
+		dev_info(charger->dev, "%s: failed to create wq.\n", __func__);
+		ret = -ESRCH;
+		goto err_create_wq;
+	}
+	INIT_DELAYED_WORK(&charger->charger_work, s2mu005_ovp_work);
+	INIT_DELAYED_WORK(&charger->det_bat_work, s2mu005_det_bat_work);
+
+	/*
+	 * irq request
+	 * if you need to add irq , please refer below code.
+	 */
+	charger->irq_det_bat = pdata->irq_base + S2MU005_CHG_IRQ_DET_BAT;
+	ret = request_threaded_irq(charger->irq_det_bat, NULL,
+			s2mu005_det_bat_isr, 0 , "det-bat-in-irq", charger);
+	if(ret < 0) {
+		dev_err(s2mu005->dev, "%s: Fail to request det bat in IRQ: %d: %d\n",
+					__func__, charger->irq_det_bat, ret);
+		goto err_reg_irq;
+	}
+	charger->irq_chg = pdata->irq_base + S2MU005_CHG_IRQ_CHG;
+	ret = request_threaded_irq(charger->irq_chg, NULL,
+			s2mu005_chg_isr, 0 , "chg-irq", charger);
+	if(ret < 0) {
+		dev_err(s2mu005->dev, "%s: Fail to request det bat in IRQ: %d: %d\n",
+					__func__, charger->irq_chg, ret);
+		goto err_reg_irq;
+	}
+
+	psy_do_property("s2mu005-fuelgauge", get, POWER_SUPPLY_PROP_SCOPE, val);
+	charger->fg_mode = val.intval;
+
+#if EN_TEST_READ
+	s2mu005_test_read(charger->client);
+#endif
+
+	s2m_acok_register_notifier(&s2m_acok_notifier);
+
+	pr_info("%s:[BATT] S2MU005 charger driver loaded OK\n", __func__);
+
+	return 0;
+
+err_create_wq:
+	destroy_workqueue(charger->charger_wqueue);
+err_reg_irq:
+	power_supply_unregister(&charger->psy_otg);
+err_power_supply_register_otg:
+	power_supply_unregister(&charger->psy_chg);
+err_power_supply_register:
+err_parse_dt:
+err_parse_dt_nomem:
+	mutex_destroy(&charger->io_lock);
+	kfree(charger);
+	return ret;
+}
+
+static int s2mu005_charger_remove(struct platform_device *pdev)
+{
+	struct s2mu005_charger_data *charger =
+		platform_get_drvdata(pdev);
+
+	power_supply_unregister(&charger->psy_chg);
+	s2m_acok_unregister_notifier(&s2m_acok_notifier);
+	mutex_destroy(&charger->io_lock);
+	kfree(charger);
+	return 0;
+}
+
+#if defined CONFIG_PM
+static int s2mu005_charger_suspend(struct device *dev)
+{
+	struct s2mu005_charger_data *charger = dev_get_drvdata(dev);
+	u8 data = 0;
+
+	if (charger->dev_id < 2) {
+		if (!charger->is_charging && !charger->fg_mode) {
+			s2mu005_read_reg(charger->client, 0x72, &data);
+			data |= 0x80;
+			s2mu005_write_reg(charger->client, 0x72, data);
+
+			data = charger->fg_clock + 64 > 0xFF ? 0xFF : charger->fg_clock + 64;
+			s2mu005_write_reg(charger->client, 0x7B, data);
+		}
+
+		s2mu005_read_reg(charger->client, 0x7B, &data);
+		pr_info("%s: 0x7B : 0x%x\n", __func__, data);
+	}
+	return 0;
+}
+
+static int s2mu005_charger_resume(struct device *dev)
+{
+	struct s2mu005_charger_data *charger = dev_get_drvdata(dev);
+	u8 data;
+
+	if (charger->dev_id < 2) {
+		if (!charger->is_charging && !charger->fg_mode) {
+			s2mu005_read_reg(charger->client, 0x72, &data);
+			data &= ~0x80;
+			s2mu005_write_reg(charger->client, 0x72, data);
+
+			s2mu005_write_reg(charger->client, 0x7B, charger->fg_clock);
+		}
+		s2mu005_read_reg(charger->client, 0x7B, &data);
+		pr_info("%s: 0x7B : 0x%x\n", __func__, data);
+	}
+	return 0;
+}
+#else
+#define s2mu005_charger_suspend NULL
+#define s2mu005_charger_resume NULL
+#endif
+
+static void s2mu005_charger_shutdown(struct device *dev)
+{
+	struct s2mu005_charger_data *charger = dev_get_drvdata(dev);
+
+	/*
+	 * In case plug TA --> remove battery --> re-insert battery,
+	 * we need to reset FG if SC_INT[0] = 1. However, it can make
+	 * FG reset if plug TA --> power off --> LPM charging.
+	 * To avoid the problem, when power-off sequence by power-key,
+	 *    0x59[3]=0, 0x7C[0]=0 should be set in kernel.
+	 *    0x59[3]=1, 0x7C[0]=1 should be set in bootloader.
+	 */
+	s2mu005_update_reg(charger->client, 0x59, 0, 0x01 << 3); /* manual reset disable */
+	s2mu005_update_reg(charger->client, 0x7C, 0, 0x01 << 0); /* i2c port reset disable */
+
+	pr_info("%s: S2MU005 Charger driver shutdown\n", __func__);
+
+	if (!(charger->pdata->always_enable)) {
+		pr_info("%s: turn on charger\n", __func__);
+		s2mu005_enable_charger_switch(charger, true);
+	}
+}
+
+static SIMPLE_DEV_PM_OPS(s2mu005_charger_pm_ops, s2mu005_charger_suspend,
+		s2mu005_charger_resume);
+
+static struct platform_driver s2mu005_charger_driver = {
+	.driver         = {
+		.name   = "s2mu005-charger",
+		.owner  = THIS_MODULE,
+		.of_match_table = s2mu005_charger_match_table,
+		.pm     = &s2mu005_charger_pm_ops,
+		.shutdown = s2mu005_charger_shutdown,
+	},
+	.probe          = s2mu005_charger_probe,
+	.remove		= s2mu005_charger_remove,
+};
+
+static int __init s2mu005_charger_init(void)
+{
+	int ret = 0;
+
+	ret = platform_driver_register(&s2mu005_charger_driver);
+
+	return ret;
+}
+module_init(s2mu005_charger_init);
+
+static void __exit s2mu005_charger_exit(void)
+{
+	platform_driver_unregister(&s2mu005_charger_driver);
+}
+module_exit(s2mu005_charger_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Samsung Electronics");
+MODULE_DESCRIPTION("Charger driver for S2MU005");
diff -Naur linux-3.18.14/drivers/battery/s2mu005_fuelgauge.c samsung/drivers/battery/s2mu005_fuelgauge.c
--- linux-3.18.14/drivers/battery/s2mu005_fuelgauge.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery/s2mu005_fuelgauge.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,2471 @@
+/*
+ *  s2mu005_fuelgauge.c
+ *  Samsung S2MU005 Fuel Gauge Driver
+ *
+ *  Copyright (C) 2015 Samsung Electronics
+ *  Developed by Nguyen Tien Dat (tiendat.nt@samsung.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#define DEBUG
+
+#define SINGLE_BYTE	1
+#define TABLE_SIZE	22
+
+#include <linux/battery/fuelgauge/s2mu005_fuelgauge.h>
+#include <linux/of_gpio.h>
+#include <linux/sec_batt.h>
+
+static enum power_supply_property s2mu005_fuelgauge_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_VOLTAGE_AVG,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CURRENT_AVG,
+	POWER_SUPPLY_PROP_CHARGE_FULL,
+	POWER_SUPPLY_PROP_ENERGY_NOW,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_TEMP_AMBIENT,
+	POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN,
+	POWER_SUPPLY_PROP_CHARGE_TYPE,
+};
+
+static int s2mu005_get_vbat(struct s2mu005_fuelgauge_data *fuelgauge);
+static int s2mu005_get_ocv(struct s2mu005_fuelgauge_data *fuelgauge);
+static int s2mu005_get_current(struct s2mu005_fuelgauge_data *fuelgauge);
+static int s2mu005_get_avgcurrent(struct s2mu005_fuelgauge_data *fuelgauge);
+static int s2mu005_get_avgvbat(struct s2mu005_fuelgauge_data *fuelgauge);
+static int s2mu005_get_monout_avgvbat(struct s2mu005_fuelgauge_data *fuelgauge);
+
+static int s2mu005_write_reg_byte(struct i2c_client *client, int reg, u8 data)
+{
+	int ret, i = 0;
+
+	ret = i2c_smbus_write_byte_data(client, reg,  data);
+	if (ret < 0) {
+		for (i = 0; i < 3; i++) {
+			ret = i2c_smbus_write_byte_data(client, reg,  data);
+			if (ret >= 0)
+				break;
+		}
+
+		if (i >= 3)
+			dev_err(&client->dev, "%s: Error(%d)\n", __func__, ret);
+	}
+
+	return ret;
+}
+
+static int s2mu005_write_reg(struct i2c_client *client, int reg, u8 *buf)
+{
+#if SINGLE_BYTE
+	int ret = 0 ;
+	s2mu005_write_reg_byte(client, reg, buf[0]);
+	s2mu005_write_reg_byte(client, reg+1, buf[1]);
+#else
+	int ret, i = 0;
+
+	ret = i2c_smbus_write_i2c_block_data(client, reg, 2, buf);
+	if (ret < 0) {
+		for (i = 0; i < 3; i++) {
+			ret = i2c_smbus_write_i2c_block_data(client, reg, 2, buf);
+			if (ret >= 0)
+				break;
+		}
+
+		if (i >= 3)
+			dev_err(&client->dev, "%s: Error(%d)\n", __func__, ret);
+	}
+#endif
+	return ret;
+}
+
+static int s2mu005_read_reg_byte(struct i2c_client *client, int reg, void *data)
+{
+	int ret = 0;
+
+	ret = i2c_smbus_read_byte_data(client, reg);
+	if (ret < 0)
+		return ret;
+	*(u8 *)data = (u8)ret;
+
+	return ret;
+}
+
+static int s2mu005_read_reg(struct i2c_client *client, int reg, u8 *buf)
+{
+
+#if SINGLE_BYTE
+	int ret =0;
+	u8 data1 = 0 , data2 = 0;
+	s2mu005_read_reg_byte(client, reg, &data1);
+	s2mu005_read_reg_byte(client, reg+1, &data2);
+	buf[0] = data1;
+	buf[1] = data2;
+#else
+	int ret = 0, i = 0;
+
+	ret = i2c_smbus_read_i2c_block_data(client, reg, 2, buf);
+	if (ret < 0) {
+		for (i = 0; i < 3; i++) {
+			ret = i2c_smbus_read_i2c_block_data(client, reg, 2, buf);
+			if (ret >= 0)
+				break;
+		}
+
+		if (i >= 3)
+			dev_err(&client->dev, "%s: Error(%d)\n", __func__, ret);
+	}
+#endif
+	return ret;
+}
+
+static void s2mu005_fg_test_read(struct i2c_client *client)
+{
+	u8 data;
+	char str[1016] = {0,};
+	int i;
+
+	/* address 0x00 ~ 0x1f */
+	for (i = 0x0; i <= 0x1F; i++) {
+		s2mu005_read_reg_byte(client, i, &data);
+		sprintf(str+strlen(str), "0x%02x:0x%02x, ", i, data);
+	}
+
+	/* address 0x27 */
+	s2mu005_read_reg_byte(client, 0x27, &data);
+	sprintf(str+strlen(str),"0x27:0x%02x, ",data);
+
+	/* address 0x44, 0x45 */
+	for (i = 0x44; i <= 0x45; i++) {
+		s2mu005_read_reg_byte(client, i, &data);
+		sprintf(str+strlen(str), "0x%02x:0x%02x, ", i, data);
+	}
+
+	/* print buffer */
+	pr_info("[FG]%s: %s\n", __func__, str);
+}
+
+static void WA_0_issue_at_init(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	int a = 0;
+	u8 v_52 = 0, v_53 =0, temp1, temp2;
+	int FG_volt, UI_volt, offset;
+	u8 v_40 = 0;
+	u8 temp_REG26 = 0, temp_REG27 = 0, temp = 0;
+
+	/* Step 1: [Surge test]  get UI voltage (0.1mV)*/
+	UI_volt = s2mu005_get_ocv(fuelgauge);
+
+	/* current fix for soc */
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x27, &temp_REG27);
+	temp = temp_REG27;
+	temp |= 0x0F;
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x27, temp);
+
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x26, &temp_REG26);
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x26, 0xF7);
+
+	/* avgvbat factor value set to 0xFF  */
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x40, &v_40);
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x40, 0xFF);
+
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x1E, 0x0F);
+	msleep(50);
+
+	/* Step 2: [Surge test] get FG voltage (0.1mV) */
+	FG_volt = s2mu005_get_vbat(fuelgauge) * 10;
+
+	/* Step 3: [Surge test] get offset */
+	offset = UI_volt - FG_volt;
+	pr_info("%s: UI_volt(%d), FG_volt(%d), offset(%d)\n",
+			__func__, UI_volt, FG_volt, offset);
+
+	/* Step 4: [Surge test] */
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x53, &v_53);
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x52, &v_52);
+	pr_info("%s: v_53(0x%x), v_52(0x%x)\n", __func__, v_53, v_52);
+
+	a = (v_53 & 0x0F) << 8;
+	a += v_52;
+	pr_info("%s: a before add offset (0x%x)\n", __func__, a);
+
+	/* 2`s complement */
+	if (a & (0x01 << 11))
+		a = (-10000 * ((a^0xFFF) + 1)) >> 13;
+	else
+		a = (10000 * a) >> 13;
+
+	a = a + offset;
+	pr_err("%s: a after add offset (0x%x)\n", __func__, a);
+
+	/* limit upper/lower offset */
+	if (a > 2490)
+		a = 2490;
+
+	if (a < (-2490))
+		a = -2490;
+
+	a = (a << 13) / 10000;
+	if (a < 0)
+		a = -1*((a^0xFFF)+1);
+
+	pr_info("%s: a after add offset (0x%x)\n", __func__, a);
+
+	a &= 0xfff;
+	pr_info("%s: (a)&0xFFF (0x%x)\n", __func__, a);
+
+	/* modify 0x53[3:0] */
+	temp1 = v_53 & 0xF0;
+	temp2 = (u8)((a&0xF00) >> 8);
+	temp1 |= temp2;
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x53, temp1);
+
+	/* modify 0x52[7:0] */
+	temp2 = (u8)(a & 0xFF);
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x52, temp2);
+
+	/* restart and dumpdone */
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x1E, 0x0F);
+	msleep(300);
+
+	/* restore current register */
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x27, temp_REG27);
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x26, 0xF6);
+
+	/* recovery 0x52 and 0x53 */
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x53, &temp1);
+	temp1 &= 0xF0;
+	temp1 |= (v_53 & 0x0F);
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x53, temp1);
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x52, v_52);
+
+	/* restore monout avgvbat factor value */
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x40, v_40);
+}
+
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+static void WA_force_rawsoc_100(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	u8 temp1, v_40;
+
+	/* Set average voltage coefficient ( addr 0x40 = 0xFF ) */
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x40, &v_40);
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x40, 0xFF);
+
+	/* Fix discharging current ( addr 0x26[0] = 0x1 ) */
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x26, &temp1);
+	temp1 |= 0x01;
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x26, temp1);
+
+	/* Set voltage fix for 100% rawsoc & enable */
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x25, &temp1);
+	temp1 &= 0xF0;
+	temp1 |= 0x05;
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x25, temp1);
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x24, 0xB7);
+
+	/* restart and dumpdone */
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x1E, 0x0F);
+	msleep(300);
+
+	/*Disable voltage fix*/
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x24, &temp1);
+	temp1 &= 0xFE;
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x24, temp1);
+
+	/* Disable discharging current fix */
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x26, &temp1);
+	temp1 &= 0xFE;
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x26, temp1);
+
+	/* Recover Reg 0x40 */
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x40, v_40);
+}
+#endif
+
+static int s2mu005_get_soc_from_ocv(struct s2mu005_fuelgauge_data *fuelgauge, int target_ocv)
+{
+	/* 22 values of mapping table for EVT1*/
+
+	int *soc_arr;
+	int *ocv_arr;
+	int soc = 0;
+	int ocv = target_ocv * 10;
+
+	int high_index = TABLE_SIZE - 1;
+	int low_index = 0;
+	int mid_index = 0;
+
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	soc_arr = fuelgauge->age_data_info[fuelgauge->fg_age_step].soc_arr_val;
+	ocv_arr = fuelgauge->age_data_info[fuelgauge->fg_age_step].ocv_arr_val;
+#else
+	if(fuelgauge->revision >= 2) {
+		soc_arr = fuelgauge->info.soc_arr_evt2;
+		ocv_arr = fuelgauge->info.ocv_arr_evt2;
+	} else {
+		soc_arr = fuelgauge->info.soc_arr_evt1;
+		ocv_arr = fuelgauge->info.ocv_arr_evt1;
+	}
+#endif
+
+	pr_err("%s: soc_arr(%d) ocv_arr(%d)\n", __func__,*soc_arr, *ocv_arr);
+
+	if(ocv <= ocv_arr[TABLE_SIZE - 1]) {
+		soc = soc_arr[TABLE_SIZE - 1];
+		goto soc_ocv_mapping;
+	} else if (ocv >= ocv_arr[0]) {
+		soc = soc_arr[0];
+		goto soc_ocv_mapping;
+	}
+	while (low_index <= high_index) {
+		mid_index = (low_index + high_index) >> 1;
+		if(ocv_arr[mid_index] > ocv)
+			low_index = mid_index + 1;
+		else if(ocv_arr[mid_index] < ocv)
+			high_index = mid_index - 1;
+		else {
+			soc = soc_arr[mid_index];
+			goto soc_ocv_mapping;
+		}
+	}
+	soc = soc_arr[high_index];
+	soc += ((soc_arr[low_index] - soc_arr[high_index]) *
+					(ocv - ocv_arr[high_index])) /
+					(ocv_arr[low_index] - ocv_arr[high_index]);
+
+soc_ocv_mapping:
+	dev_info(&fuelgauge->i2c->dev, "%s: ocv (%d), soc (%d)\n", __func__, ocv, soc);
+	return soc;
+}
+
+static void WA_0_issue_at_init1(struct s2mu005_fuelgauge_data *fuelgauge, int target_ocv)
+{
+	int a = 0;
+	u8 v_52 = 0, v_53 =0, temp1, temp2;
+	int FG_volt, UI_volt, offset;
+	u8 v_40 = 0;
+	u8 temp_REG26 = 0, temp_REG27 = 0, temp = 0;
+
+	mutex_lock(&fuelgauge->fg_lock);
+	/* Step 1: [Surge test]  get UI voltage (0.1mV)*/
+	UI_volt = target_ocv * 10;
+
+	/* avgvbat factor value set to 0xFF  */
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x40, &v_40);
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x40, 0xFF);
+
+	/* current fix for soc */
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x27, &temp_REG27);
+	temp = temp_REG27;
+	temp |= 0x0F;
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x27, temp);
+
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x26, &temp_REG26);
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x26, 0xF7);
+
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x1E, 0x0F);
+	msleep(50);
+
+	/* Step 2: [Surge test] get FG voltage (0.1mV) */
+	FG_volt = s2mu005_get_vbat(fuelgauge) * 10;
+
+	/* Step 3: [Surge test] get offset */
+	offset = UI_volt - FG_volt;
+	pr_info("%s: UI_volt(%d), FG_volt(%d), offset(%d)\n",
+			__func__, UI_volt, FG_volt, offset);
+
+	/* Step 4: [Surge test] */
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x53, &v_53);
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x52, &v_52);
+	pr_info("%s: Read v_53(0x%x), v_52(0x%x)\n", __func__, v_53, v_52);
+
+	a = (v_53 & 0x0F) << 8;
+	a += v_52;
+	pr_info("%s: a before add offset (0x%x)\n", __func__, a);
+
+	/* 2`s complement */
+	if (a & (0x01 << 11))
+		a = (-10000 * ((a^0xFFF) + 1)) >> 13;
+	else
+		a = (10000 * a) >> 13;
+
+	a = a + offset;
+	pr_err("%s: a after add offset (0x%x)\n", __func__, a);
+
+	/* limit upper/lower offset */
+	if (a > 2490)
+		a = 2490;
+
+	if (a < (-2490))
+		a = -2490;
+
+	a = (a << 13) / 10000;
+	if (a < 0)
+		a = -1*((a^0xFFF)+1);
+
+	pr_info("%s: a after add offset (0x%x)\n", __func__, a);
+
+	a &= 0xfff;
+	pr_info("%s: (a)&0xFFF (0x%x)\n", __func__, a);
+
+	/* modify 0x53[3:0] */
+	temp1 = v_53 & 0xF0;
+	temp2 = (u8)((a&0xF00) >> 8);
+	temp1 |= temp2;
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x53, temp1);
+
+	/* modify 0x52[7:0] */
+	temp2 = (u8)(a & 0xFF);
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x52, temp2);
+
+	/* restart and dumpdone */
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x1E, 0x0F);
+	msleep(300);
+
+	/* restore current register */
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x27, temp_REG27);
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x26, 0xF6);
+
+	pr_info("%s: S2MU005 VBAT : %d\n", __func__, s2mu005_get_vbat(fuelgauge) * 10);
+
+	/* recovery 0x52 and 0x53 */
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x53, &temp1);
+	temp1 &= 0xF0;
+	temp1 |= (v_53 & 0x0F);
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x53, temp1);
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x52, v_52);
+
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x53, &v_53);
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x52, &v_52);
+	pr_info("%s: Restored v_53(0x%x), v_52(0x%x)\n", __func__, v_53, v_52);
+
+	/* restore monout avgvbat factor value */
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x40, v_40);
+
+	mutex_unlock(&fuelgauge->fg_lock);
+}
+
+
+static void s2mu005_reset_fg(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	int i;
+	u8 temp = 0;
+	mutex_lock(&fuelgauge->fg_lock);
+	/* step 0: [Surge test] initialize register of FG */
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	/*Reset IC*/
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x1F, 0x40);
+	msleep(50);
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x1F, 0x01);
+	msleep(50);
+#endif
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x0F, fuelgauge->age_data_info[fuelgauge->fg_age_step].batcap[0]);
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x0E, fuelgauge->age_data_info[fuelgauge->fg_age_step].batcap[1]);
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x11, fuelgauge->age_data_info[fuelgauge->fg_age_step].batcap[2]);
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x10, fuelgauge->age_data_info[fuelgauge->fg_age_step].batcap[3]);
+#else
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x0F, fuelgauge->info.batcap[0]);
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x0E, fuelgauge->info.batcap[1]);
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x11, fuelgauge->info.batcap[2]);
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x10, fuelgauge->info.batcap[3]);
+#endif
+
+	/* After battery capacity update, set 0x0C[6] */
+	if (fuelgauge->revision >= 0x0A) {
+		s2mu005_read_reg_byte(fuelgauge->i2c, 0x0C, &temp);
+		temp |= 0x40;
+		s2mu005_write_reg_byte(fuelgauge->i2c, 0x0C, temp);
+	}
+
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	for (i = 0x92; i <= 0xe9; i++) {
+		s2mu005_write_reg_byte(fuelgauge->i2c, i, fuelgauge->age_data_info[fuelgauge->fg_age_step].battery_table3[i - 0x92]);
+	}
+	for (i = 0xea; i <= 0xff; i++) {
+		s2mu005_write_reg_byte(fuelgauge->i2c, i, fuelgauge->age_data_info[fuelgauge->fg_age_step].battery_table4[i - 0xea]);
+	}
+#else
+	if(fuelgauge->revision >= 2) {
+		for(i = 0x92; i <= 0xe9; i++) {
+			s2mu005_write_reg_byte(fuelgauge->i2c, i, fuelgauge->info.battery_table3[i - 0x92]);
+		}
+		for(i = 0xea; i <= 0xff; i++) {
+			s2mu005_write_reg_byte(fuelgauge->i2c, i, fuelgauge->info.battery_table4[i - 0xea]);
+		}
+ 	} else {
+		for(i = 0x92; i <= 0xe9; i++) {
+			s2mu005_write_reg_byte(fuelgauge->i2c, i, fuelgauge->info.battery_table1[i - 0x92]);
+		}
+		for(i = 0xea; i <= 0xff; i++) {
+			s2mu005_write_reg_byte(fuelgauge->i2c, i, fuelgauge->info.battery_table2[i - 0xea]);
+		}
+ 	}
+#endif
+
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x21, 0x13);
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x14, 0x40);
+
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x45, &temp);
+	temp &= 0xF0;
+	temp |= fuelgauge->age_data_info[fuelgauge->fg_age_step].accum[1];
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x45, temp);
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x44,  fuelgauge->age_data_info[fuelgauge->fg_age_step].accum[0]);
+#else
+	if(fuelgauge->revision >= 2) {
+		s2mu005_read_reg_byte(fuelgauge->i2c, 0x45, &temp);
+		temp &= 0xF0;
+		temp |= fuelgauge->pdata->evt2_val;
+		temp |=  fuelgauge->info.fg_accumulative_rate_evt2[1];
+		s2mu005_write_reg_byte(fuelgauge->i2c, 0x45, temp);
+		s2mu005_write_reg_byte(fuelgauge->i2c, 0x44,  fuelgauge->info.fg_accumulative_rate_evt2[0]);
+	} else {
+		s2mu005_read_reg_byte(fuelgauge->i2c, 0x45, &temp);
+		temp &= 0xF0;
+		temp |= 0x07;
+		s2mu005_write_reg_byte(fuelgauge->i2c, 0x45, temp);
+		s2mu005_write_reg_byte(fuelgauge->i2c, 0x44, 0xCC);
+	}
+#endif
+
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x27, &temp);
+	temp |= 0x10;
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x27, temp);
+
+	if(fuelgauge->revision >= 2) {
+		s2mu005_write_reg_byte(fuelgauge->i2c, 0x4B, 0x0B);
+		s2mu005_write_reg_byte(fuelgauge->i2c, 0x4A, 0x10);
+
+		s2mu005_read_reg_byte(fuelgauge->i2c, 0x03, &temp);
+		temp |= 0x40;
+		s2mu005_write_reg_byte(fuelgauge->i2c, 0x03, temp);
+	}
+	else {
+		s2mu005_write_reg_byte(fuelgauge->i2c, 0x4B, 0x09);
+
+		s2mu005_read_reg_byte(fuelgauge->i2c, 0x27, &temp);
+		temp |= 0x0F;
+		s2mu005_write_reg_byte(fuelgauge->i2c, 0x27, temp);
+
+		s2mu005_read_reg_byte(fuelgauge->i2c, 0x26, &temp);
+		temp |= 0xFE;
+		s2mu005_write_reg_byte(fuelgauge->i2c, 0x26, temp);
+
+		s2mu005_write_reg_byte(fuelgauge->i2c, 0x4A, 0xFF);
+
+		s2mu005_read_reg_byte(fuelgauge->i2c, 0x26, &temp);
+		temp &= 0xFE;
+		s2mu005_write_reg_byte(fuelgauge->i2c, 0x26, temp);
+	}
+
+#if !defined(CONFIG_BATTERY_AGE_FORECAST)
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x40, 0x08);
+
+	WA_0_issue_at_init(fuelgauge);
+#else
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x40, 0x08);
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x41, 0x04);
+
+	/* Set discharging current*/
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x26, 0xF6);
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x27, &temp);
+	temp |= 0x0F;
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x27, temp);
+
+	if (fuelgauge->age_reset_status == 1)
+		WA_force_rawsoc_100(fuelgauge);
+	else
+		WA_0_issue_at_init(fuelgauge);
+#endif
+
+	/* If it was voltage mode, recover it */
+	if ((fuelgauge->revision >= 2) && (fuelgauge->mode == HIGH_SOC_VOLTAGE_MODE))
+		s2mu005_write_reg_byte(fuelgauge->i2c, 0x4A, 0xFF);
+
+	/*After FG reset current battery data version get reset to default value 1, causing mismatch in bootloader and kernel FG data verion.
+	 Below code restores the FG data version in 0x48 register to it's initalized value.*/
+	pr_info("%s: FG data version %02x\n", __func__, fuelgauge->info.data_ver);
+	if (fuelgauge->info.data_ver != 0) {
+		s2mu005_read_reg_byte(fuelgauge->i2c, 0x48, &temp);
+		temp &= 0xF1;
+		temp |= (fuelgauge->info.data_ver << 1);
+		s2mu005_write_reg_byte(fuelgauge->i2c, 0x48, temp);
+	}
+
+	mutex_unlock(&fuelgauge->fg_lock);
+	pr_info("%s: Reset FG completed\n", __func__);
+}
+
+static void s2mu005_restart_gauging(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	u8 temp=0, temp_REG26=0, temp_REG27=0;
+	u8 v_40;
+	u8 data[2], r_data[2];
+	pr_info("%s: Re-calculate SOC and voltage\n", __func__);
+	mutex_lock(&fuelgauge->fg_lock);
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x27, &temp_REG27);
+	temp=temp_REG27;
+	temp |= 0x0F;
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x27, temp);
+
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x26, &temp_REG26);
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x26, 0xF7);
+
+	/* avgvbat factor value set to 0xFF  */
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x40, &v_40);
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x40, 0xFF);
+
+	s2mu005_read_reg(fuelgauge->i2c, S2MU005_REG_IRQ, data);
+	pr_info("%s: irq_reg data (%02x%02x)  \n",__func__, data[1], data[0]);
+
+	/* store data for interrupt mask */
+	r_data[0] = data[0];
+	r_data[1] = data[1];
+	/* disable irq for unwanted interrupt */
+	data[1] |= 0x0f;
+	s2mu005_write_reg(fuelgauge->i2c, S2MU005_REG_IRQ, data);
+
+	/* restart gauge */
+
+	//s2mu005_write_reg_byte(fuelgauge->i2c, 0x1f, 0x01);
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x21, 0x13);
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x1E, 0x0F);
+
+	msleep(300);
+
+	/* enable irq after reset */
+	s2mu005_write_reg(fuelgauge->i2c, S2MU005_REG_IRQ, r_data);
+	pr_info("%s: re-store irq_reg data (%02x%02x) \n",__func__, r_data[1], r_data[0]);
+
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x27, temp_REG27);
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x26, 0xF6);
+
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x27, &temp);
+	pr_info("%s: 0x27 : %02x \n", __func__,temp);
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x26, &temp);
+	pr_info("%s: 0x26 : %02x \n", __func__,temp);
+
+	/* restore monout avgvbat factor value */
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x40, v_40);
+
+	mutex_unlock(&fuelgauge->fg_lock);
+}
+
+static void s2mu005_init_regs(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	u8 temp = 0;
+	pr_info("%s: s2mu005 fuelgauge initialize\n", __func__);
+
+	/* Reduce top-off current difference between
+	 * Power on charging and Power off charging
+	 */
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x27, &temp);
+	temp |= 0x10;
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x27, temp);
+
+	if(fuelgauge->revision < 2) {
+	/* Sampling time set 500ms */
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x45, &temp);
+	temp &= 0x3F;
+	temp |= 0x0;
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x45, temp);
+	}
+}
+
+static void s2mu005_alert_init(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+
+	/* VBAT Threshold setting: 3.55V */
+	data[0] = 0x00 & 0x0f;
+
+	/* SOC Threshold setting */
+	data[0] = data[0] | (fuelgauge->pdata->fuel_alert_soc << 4);
+
+	data[1] = 0x00;
+	s2mu005_write_reg(fuelgauge->i2c, S2MU005_REG_IRQ_LVL, data);
+}
+
+static bool s2mu005_check_status(struct i2c_client *client)
+{
+	u8 data[2];
+	bool ret = false;
+
+	/* check if Smn was generated */
+	if (s2mu005_read_reg(client, S2MU005_REG_STATUS, data) < 0)
+		return ret;
+
+	dev_dbg(&client->dev, "%s: status to (%02x%02x)\n",
+		__func__, data[1], data[0]);
+
+	if (data[1] & (0x1 << 1))
+		return true;
+	else
+		return false;
+}
+
+static int s2mu005_set_temperature(struct s2mu005_fuelgauge_data *fuelgauge,
+			int temperature)
+{
+	/*
+	 * s5mu005 include temperature sensor so,
+	 * do not need to set temperature value.
+	 */
+	return temperature;
+}
+
+static int s2mu005_get_temperature(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	s32 temperature = 0;
+
+	/*
+	 *  use monitor regiser.
+	 *  monitor register default setting is temperature
+	 */
+	mutex_lock(&fuelgauge->fg_lock);
+
+	if (s2mu005_read_reg(fuelgauge->i2c, S2MU005_REG_MONOUT, data) < 0)
+		goto err;
+
+	mutex_unlock(&fuelgauge->fg_lock);
+
+	/* data[] store 2's compliment format number */
+	if (data[0] & (0x1 << 7)) {
+		/* Negative */
+		temperature = ((~(data[0])) & 0xFF) + 1;
+		temperature *= -10;
+	} else {
+		temperature = data[0] & 0x7F;
+		temperature *= 10;
+	}
+
+	dev_dbg(&fuelgauge->i2c->dev, "%s: temperature (%d)\n",
+		__func__, temperature);
+
+	return temperature;
+
+err:
+	mutex_unlock(&fuelgauge->fg_lock);
+	return -ERANGE;
+}
+
+static int s2mu005_get_rawsoc(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	u8 data[2], check_data[2];
+	u16 compliment;
+	int rsoc, i;
+	u8 por_state = 0;
+	u8 temp = 0;
+	u8 reg = S2MU005_REG_RSOC;
+	int fg_reset = 0;
+	union power_supply_propval value;
+	int float_voltage = 0;
+	int force_power_off_voltage = 0;
+	int rbat = 0;
+
+	int avg_current = 0, avg_vbat = 0, vbat = 0, curr = 0, avg_monout_vbat = 0;
+	int ocv_pwroff = 0, ocv_100 = 0, ocv_pwr_voltagemode = 0;
+	int target_soc = 0, soc_100 = 0;
+	//bkj - rempcap logging
+	int rsoc1;
+	u8 fg_mode_reg = 0;
+
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x1F, &por_state);
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	if ((por_state & 0x10) && (fuelgauge->age_reset_status == 0))
+#else
+	if (por_state & 0x10)
+#endif
+	{
+		value.intval = 0;
+		psy_do_property("s2mu005-charger", set, POWER_SUPPLY_PROP_CHARGING_ENABLED, value);
+
+		dev_info(&fuelgauge->i2c->dev, "%s: FG reset\n", __func__);
+		s2mu005_reset_fg(fuelgauge);
+		por_state &= ~0x10;
+		s2mu005_write_reg_byte(fuelgauge->i2c, 0x1F, por_state);
+
+		fg_reset = 1;
+	}
+
+	mutex_lock(&fuelgauge->fg_lock);
+
+	if(fuelgauge->revision >= 2)
+		reg = S2MU005_REG_RSOC;
+	else {
+		if(fuelgauge->mode == CURRENT_MODE)
+			reg = S2MU005_REG_RSOC;
+		else {
+			s2mu005_write_reg_byte(fuelgauge->i2c, 0x0C, 0x03);
+			reg = S2MU005_REG_MONOUT;
+		}
+	}
+
+	for (i = 0; i < 50; i++) {
+		if (s2mu005_read_reg(fuelgauge->i2c, reg, data) < 0)
+			goto err;
+		if (s2mu005_read_reg(fuelgauge->i2c, reg, check_data) < 0)
+			goto err;
+
+		dev_dbg(&fuelgauge->i2c->dev, "[DEBUG]%s: data0 (%d) data1 (%d) \n", __func__, data[0], data[1]);
+		if ((data[0] == check_data[0]) && (data[1] == check_data[1]))
+			break;
+	}
+
+	mutex_unlock(&fuelgauge->fg_lock);
+
+	if (fg_reset) {
+		value.intval = 1;
+		psy_do_property("s2mu005-charger", set, POWER_SUPPLY_PROP_CHARGE_ENABLED, value);
+		psy_do_property("s2mu005-charger", set, POWER_SUPPLY_PROP_CHARGING_ENABLED, value);
+	}
+
+	compliment = (data[1] << 8) | (data[0]);
+
+	/* data[] store 2's compliment format number */
+	if (compliment & (0x1 << 15)) {
+		/* Negative */
+		rsoc = ((~compliment) & 0xFFFF) + 1;
+		rsoc = (rsoc * (-10000)) / (0x1 << 14);
+	} else {
+		rsoc = compliment & 0x7FFF;
+		rsoc = ((rsoc * 10000) / (0x1 << 14));
+	}
+
+	if (fg_reset)
+		fuelgauge->diff_soc = fuelgauge->info.soc - rsoc;
+
+	dev_info(&fuelgauge->i2c->dev, "%s: current_soc (%d), previous soc (%d), diff (%d), FG_mode(%d)\n",
+		 __func__, rsoc, fuelgauge->info.soc, fuelgauge->diff_soc, fuelgauge->mode);
+
+	fuelgauge->info.soc = rsoc + fuelgauge->diff_soc;
+
+	avg_current = s2mu005_get_avgcurrent(fuelgauge);
+	avg_vbat =  s2mu005_get_avgvbat(fuelgauge);
+	vbat = s2mu005_get_vbat(fuelgauge);
+	curr = s2mu005_get_current(fuelgauge);
+	avg_monout_vbat =  s2mu005_get_monout_avgvbat(fuelgauge);
+	ocv_pwr_voltagemode = avg_monout_vbat - avg_current * 30 / 100;
+
+	if (avg_current < (-500))
+		rbat = 10;
+	else
+		rbat = 30;
+
+	ocv_pwr_voltagemode = avg_monout_vbat - avg_current * rbat / 100;
+
+	if(fuelgauge->revision >= 2) {
+		if ((fuelgauge->info.soc <= 300) || ((ocv_pwr_voltagemode <= 3600) && (avg_current < 10))) {
+			if(fuelgauge->mode == CURRENT_MODE) { /* switch to VOLTAGE_MODE */
+				fuelgauge->mode = LOW_SOC_VOLTAGE_MODE;
+
+				s2mu005_write_reg_byte(fuelgauge->i2c, 0x4A, 0xFF);
+
+				dev_info(&fuelgauge->i2c->dev, "%s: FG is in low soc voltage mode\n", __func__);
+			}
+		} else if ((fuelgauge->info.soc > 325) && ((ocv_pwr_voltagemode > 3650) || (avg_current >= 10))) {
+			if(fuelgauge->mode == LOW_SOC_VOLTAGE_MODE) {
+				fuelgauge->mode = CURRENT_MODE;
+
+				s2mu005_write_reg_byte(fuelgauge->i2c, 0x4A, 0x10);
+
+				dev_info(&fuelgauge->i2c->dev, "%s: FG is in current mode\n", __func__);
+			}
+		}
+
+		psy_do_property("s2mu005-charger", get, POWER_SUPPLY_PROP_VOLTAGE_MAX, value);
+		float_voltage = value.intval;
+		float_voltage = (float_voltage * 996) / 1000;
+
+		psy_do_property("battery", get, POWER_SUPPLY_PROP_CAPACITY, value);
+		dev_info(&fuelgauge->i2c->dev, "%s: UI SOC = %d\n", __func__, value.intval);
+
+		s2mu005_read_reg_byte(fuelgauge->i2c, 0x4A, &fg_mode_reg);
+
+		dev_info(&fuelgauge->i2c->dev, "%s: fuelgauge->is_charging = %d, avg_vbat = %d, float_voltage = %d, avg_current = %d, 0x4A = 0x%02x\n",
+			__func__, fuelgauge->is_charging, avg_vbat, float_voltage, avg_current, fg_mode_reg);
+
+		if ((value.intval >= 98) ||
+			((fuelgauge->is_charging == true) &&
+			(avg_vbat > float_voltage) && (avg_current < 500))) {
+			if(fuelgauge->mode == CURRENT_MODE) { /* switch to VOLTAGE_MODE */
+				fuelgauge->mode = HIGH_SOC_VOLTAGE_MODE;
+
+				s2mu005_write_reg_byte(fuelgauge->i2c, 0x4A, 0xFF);
+
+				dev_info(&fuelgauge->i2c->dev, "%s: FG is in high soc voltage mode\n", __func__);
+			}
+		}
+		else if (((avg_current > 550) && (value.intval < 97)) ||
+					((avg_current < 10) && (value.intval < 97))) {
+			if(fuelgauge->mode == HIGH_SOC_VOLTAGE_MODE) {
+				fuelgauge->mode = CURRENT_MODE;
+
+				s2mu005_write_reg_byte(fuelgauge->i2c, 0x4A, 0x10);
+
+				dev_info(&fuelgauge->i2c->dev, "%s: FG is in current mode\n", __func__);
+			}
+		}
+	}
+	else {
+		if (!fuelgauge->is_charging && fuelgauge->info.soc <= 300) {
+			if(fuelgauge->mode == CURRENT_MODE) { /* switch to VOLTAGE_MODE */
+
+				fuelgauge->mode = LOW_SOC_VOLTAGE_MODE;
+				value.intval = fuelgauge->mode;
+				psy_do_property("s2mu005-charger", set, POWER_SUPPLY_PROP_SCOPE, value);
+
+				s2mu005_read_reg_byte(fuelgauge->i2c, 0x26, &temp);
+				temp |= 0x01;
+				s2mu005_write_reg_byte(fuelgauge->i2c, 0x26, temp);
+
+				s2mu005_read_reg_byte(fuelgauge->i2c, 0x4B, &temp);
+				temp |= 0x02;
+				s2mu005_write_reg_byte(fuelgauge->i2c, 0x4B, temp);
+
+				s2mu005_read_reg_byte(fuelgauge->i2c, 0x45, &temp);
+				temp &= 0xF0;
+				s2mu005_write_reg_byte(fuelgauge->i2c, 0x45, temp);
+
+				s2mu005_write_reg_byte(fuelgauge->i2c, 0x44, 0x00);
+				fuelgauge->vm_soc = fuelgauge->info.soc;
+
+				dev_info(&fuelgauge->i2c->dev, "%s: FG is in low soc voltage mode: %d\n",
+					__func__, fuelgauge->vm_soc);
+			}
+		} else if (fuelgauge->is_charging && fuelgauge->info.soc >= fuelgauge->vm_soc) {
+			if(fuelgauge->mode == LOW_SOC_VOLTAGE_MODE) {
+
+				fuelgauge->mode = CURRENT_MODE;
+				value.intval = fuelgauge->mode;
+				psy_do_property("s2mu005-charger", set, POWER_SUPPLY_PROP_SCOPE, value);
+
+				s2mu005_read_reg_byte(fuelgauge->i2c, 0x4B, &temp);
+				temp &= ~0x02;
+				s2mu005_write_reg_byte(fuelgauge->i2c, 0x4B, temp);
+
+				s2mu005_read_reg_byte(fuelgauge->i2c, 0x26, &temp);
+				temp &= ~0x01;
+				s2mu005_write_reg_byte(fuelgauge->i2c, 0x26, temp);
+
+				s2mu005_read_reg_byte(fuelgauge->i2c, 0x45, &temp);
+				temp &= 0xF0;
+				temp |= 0x07;
+				s2mu005_write_reg_byte(fuelgauge->i2c, 0x45, temp);
+
+				s2mu005_write_reg_byte(fuelgauge->i2c, 0x44, 0xCC);
+				dev_info(&fuelgauge->i2c->dev, "%s: FG is in current mode\n", __func__);
+			}
+		}
+	}
+
+	psy_do_property("battery", get, POWER_SUPPLY_PROP_TEMP, value);
+
+	if (value.intval <= (-150))
+		force_power_off_voltage = 3550;
+	else
+		force_power_off_voltage = 3300;
+
+	dev_info(&fuelgauge->i2c->dev,
+		"%s: Fuelgauge Mode: %d, Force power-off voltage: %d\n",
+		__func__, fuelgauge->mode, force_power_off_voltage);
+
+	if (((avg_current < (-17)) && (curr < (-17))) &&
+		((avg_monout_vbat - avg_current*rbat / 100) <= 3500) && (fuelgauge->info.soc > 100)) {
+		ocv_pwroff = 3300;
+		target_soc = s2mu005_get_soc_from_ocv(fuelgauge, ocv_pwroff);
+		pr_info("%s : F/G reset Start - current flunctuation\n", __func__);
+		WA_0_issue_at_init1(fuelgauge, ocv_pwroff);
+	} else if (avg_current < (-60) && avg_vbat <= force_power_off_voltage) {
+		if (fuelgauge->mode == CURRENT_MODE) {
+			if (abs(avg_vbat - vbat) <= 20 && abs(avg_current - curr) <= 30) {
+				ocv_pwroff = avg_vbat - avg_current * 15 / 100;
+				target_soc = s2mu005_get_soc_from_ocv(fuelgauge, ocv_pwroff);
+				if (abs(target_soc - fuelgauge->info.soc) > 300) {
+					pr_info("%s : F/G reset Start - current mode: %d\n", __func__, target_soc);
+					WA_0_issue_at_init1(fuelgauge, ocv_pwroff);
+
+				}
+			}
+		} else {
+			if (abs(avg_vbat - vbat) <= 20) {
+				ocv_pwroff = avg_vbat;
+				target_soc = s2mu005_get_soc_from_ocv(fuelgauge, ocv_pwroff);
+				if (abs(target_soc - fuelgauge->info.soc) > 300) {
+					pr_info("%s : F/G reset Start\n", __func__);
+					WA_0_issue_at_init1(fuelgauge, ocv_pwroff);
+				}
+			}
+		}
+	}
+
+	if(fuelgauge->revision < 2) {
+		/* -------------- for enable/disable Current Sensing -------------- */
+		if(fuelgauge->mode == CURRENT_MODE) {
+			ocv_100 = avg_vbat - avg_current * 15 / 100;
+			soc_100 = s2mu005_get_soc_from_ocv(fuelgauge, ocv_100);
+
+			if (fuelgauge->is_charging && avg_current > 0 && fuelgauge->info.soc >= 10000 && fuelgauge->cc_on == true) {
+				fuelgauge->cc_on = false;
+				s2mu005_read_reg_byte(fuelgauge->i2c, 0x45, &temp);
+				temp &= 0xF0;
+				s2mu005_write_reg_byte(fuelgauge->i2c, 0x45, temp);
+
+				s2mu005_write_reg_byte(fuelgauge->i2c, 0x44, 0x00);
+				dev_dbg(&fuelgauge->i2c->dev, "[DEBUG]%s: stop CC, ocv_100: (%d), soc_100: (%d)\n", __func__, ocv_100, soc_100);
+			} else if ((!fuelgauge->is_charging || (fuelgauge->is_charging && avg_current < 0))
+				&& (soc_100 < 10000) && fuelgauge->cc_on == false) {
+				fuelgauge->cc_on = true;
+				s2mu005_read_reg_byte(fuelgauge->i2c, 0x45, &temp);
+				temp &= 0xF0;
+				temp |= 0x07;
+				s2mu005_write_reg_byte(fuelgauge->i2c, 0x45, temp);
+
+				s2mu005_write_reg_byte(fuelgauge->i2c, 0x44, 0xCC);
+				dev_dbg(&fuelgauge->i2c->dev, "[DEBUG]%s: start CC, ocv_100: (%d), soc_100: (%d)\n", __func__, ocv_100, soc_100);
+			}
+		}
+
+		/* -------------- for enable/disable Current Sensing -------------- */
+
+		/* For debugging */
+		s2mu005_read_reg_byte(fuelgauge->i2c, 0x44, &temp);
+		pr_info("%s: Reg 0x44 : 0x%x\n", __func__, temp);
+		s2mu005_read_reg_byte(fuelgauge->i2c, 0x45, &temp);
+		pr_info("%s: Reg 0x45 : 0x%x\n", __func__, temp);
+
+		s2mu005_read_reg_byte(fuelgauge->i2c, 0x26, &temp);
+		pr_info("%s: Reg 0x26 : 0x%x\n", __func__, temp);
+
+		s2mu005_read_reg_byte(fuelgauge->i2c, 0x4B, &temp);
+		pr_info("%s: Reg 0x4B : 0x%x\n", __func__, temp);
+
+		//bkj - rempcap logging
+		/* ------ read remaining capacity -------- */
+		if (fuelgauge->mode == CURRENT_MODE)
+		{
+			mutex_lock(&fuelgauge->fg_lock);
+
+			s2mu005_read_reg_byte(fuelgauge->i2c, 0x0C, &temp);
+			s2mu005_write_reg_byte(fuelgauge->i2c, 0x0C, 0x2A);
+
+			for (i = 0; i < 50; i++) {
+				if (s2mu005_read_reg(fuelgauge->i2c, S2MU005_REG_MONOUT, data) < 0)
+					goto err;
+				if (s2mu005_read_reg(fuelgauge->i2c, S2MU005_REG_MONOUT, check_data) < 0)
+					goto err;
+
+				dev_dbg(&fuelgauge->i2c->dev, "[DEBUG]%s: remaining capacity data0 (%d) data1 (%d)\n", __func__, data[0], data[1]);
+				if ((data[0] == check_data[0]) && (data[1] == check_data[1]))
+					break;
+			}
+			s2mu005_write_reg_byte(fuelgauge->i2c, 0x0C, temp);
+
+			mutex_unlock(&fuelgauge->fg_lock);
+
+			compliment = (data[1] << 8) | (data[0]);
+
+			/* data[] store 2's compliment format number */
+			if (compliment & (0x1 << 15)) {
+				/* Negative */
+				rsoc1 = ((~compliment) & 0xFFFF) + 1;
+				rsoc1 = (rsoc1 * (-1)) / (0x1 << 1);
+			} else {
+				rsoc1 = compliment & 0x7FFF;
+				rsoc1 = ((rsoc1 * 1) / (0x1 << 1));
+			}
+
+			pr_info("%s: remcap (%d) \n", __func__, rsoc1);
+		}
+		/* ------ read remaining capacity -------- */
+	}
+
+	/* S2MU005 FG debug */
+	if(fuelgauge->pdata->fg_log_enable)
+		s2mu005_fg_test_read(fuelgauge->i2c);
+
+	return min(fuelgauge->info.soc, 10000);
+
+err:
+	mutex_unlock(&fuelgauge->fg_lock);
+	return -EINVAL;
+}
+
+static int s2mu005_get_current(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u16 compliment;
+	int curr = 0;
+
+	if (s2mu005_read_reg(fuelgauge->i2c, S2MU005_REG_RCUR_CC, data) < 0)
+		return -EINVAL;
+	compliment = (data[1] << 8) | (data[0]);
+	dev_dbg(&fuelgauge->i2c->dev, "%s: rCUR_CC(0x%4x)\n", __func__, compliment);
+
+	if (compliment & (0x1 << 15)) { /* Charging */
+		curr = ((~compliment) & 0xFFFF) + 1;
+		curr = (curr * 1000) >> 12;
+	} else { /* dischaging */
+		curr = compliment & 0x7FFF;
+		curr = (curr * (-1000)) >> 12;
+	}
+
+	dev_info(&fuelgauge->i2c->dev, "%s: current (%d)mA\n", __func__, curr);
+
+	return curr;
+}
+
+#define TABLE_SIZE	22
+static int s2mu005_get_ocv(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	/* 22 values of mapping table for EVT1*/
+
+	int *soc_arr;
+	int *ocv_arr;
+
+	int soc = fuelgauge->info.soc;
+	int ocv = 0;
+
+	int high_index = TABLE_SIZE - 1;
+	int low_index = 0;
+	int mid_index = 0;
+
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	soc_arr = fuelgauge->age_data_info[fuelgauge->fg_age_step].soc_arr_val;
+	ocv_arr = fuelgauge->age_data_info[fuelgauge->fg_age_step].ocv_arr_val;
+#else
+	if(fuelgauge->revision >= 2) {
+		soc_arr = fuelgauge->info.soc_arr_evt2;
+		ocv_arr = fuelgauge->info.ocv_arr_evt2;
+	} else {
+		soc_arr = fuelgauge->info.soc_arr_evt1;
+		ocv_arr = fuelgauge->info.ocv_arr_evt1;
+	}
+#endif
+	dev_err(&fuelgauge->i2c->dev,
+		"%s: soc (%d) soc_arr[TABLE_SIZE-1] (%d) ocv_arr[TABLE_SIZE-1) (%d)\n",
+		__func__, soc, soc_arr[TABLE_SIZE-1] , ocv_arr[TABLE_SIZE-1]);
+
+	if(soc <= soc_arr[TABLE_SIZE - 1]) {
+		ocv = ocv_arr[TABLE_SIZE - 1];
+		goto ocv_soc_mapping;
+	} else if (soc >= soc_arr[0]) {
+		ocv = ocv_arr[0];
+		goto ocv_soc_mapping;
+	}
+	while (low_index <= high_index) {
+		mid_index = (low_index + high_index) >> 1;
+		if(soc_arr[mid_index] > soc)
+			low_index = mid_index + 1;
+		else if(soc_arr[mid_index] < soc)
+			high_index = mid_index - 1;
+		else {
+			ocv = ocv_arr[mid_index];
+			goto ocv_soc_mapping;
+		}
+	}
+	ocv = ocv_arr[high_index];
+	ocv += ((ocv_arr[low_index] - ocv_arr[high_index]) *
+					(soc - soc_arr[high_index])) /
+					(soc_arr[low_index] - soc_arr[high_index]);
+
+ocv_soc_mapping:
+	dev_info(&fuelgauge->i2c->dev, "%s: soc (%d), ocv (%d)\n", __func__, soc, ocv);
+	return ocv;
+}
+
+static int s2mu005_get_avgcurrent(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u16 compliment;
+	int curr = 0;
+
+	mutex_lock(&fuelgauge->fg_lock);
+
+	if (fuelgauge->revision >= 0x0A)
+		s2mu005_write_reg_byte(fuelgauge->i2c, S2MU005_REG_MONOUT_SEL, 0x17);
+	else
+		s2mu005_write_reg_byte(fuelgauge->i2c, S2MU005_REG_MONOUT_SEL, 0x26);
+
+	if (s2mu005_read_reg(fuelgauge->i2c, S2MU005_REG_MONOUT, data) < 0)
+		goto err;
+	compliment = (data[1] << 8) | (data[0]);
+	dev_dbg(&fuelgauge->i2c->dev, "%s: MONOUT(0x%4x)\n", __func__, compliment);
+
+	if (compliment & (0x1 << 15)) { /* Charging */
+		curr = ((~compliment) & 0xFFFF) + 1;
+		curr = (curr * 1000) >> 12;
+	} else { /* dischaging */
+		curr = compliment & 0x7FFF;
+		curr = (curr * (-1000)) >> 12;
+	}
+	s2mu005_write_reg_byte(fuelgauge->i2c, S2MU005_REG_MONOUT_SEL, 0x10);
+
+	mutex_unlock(&fuelgauge->fg_lock);
+
+	dev_info(&fuelgauge->i2c->dev, "%s: avg current (%d)mA\n", __func__, curr);
+
+	dev_info(&fuelgauge->i2c->dev, "%s: SOC(%d)%%\n", __func__, fuelgauge->info.soc);
+	if ((fuelgauge->info.soc < 100) && (curr < 0) &&
+	    fuelgauge->is_charging) {
+		curr = 1;
+		dev_info(&fuelgauge->i2c->dev, "%s: modified avg current (%d)mA\n", __func__, curr);
+	}
+
+	return curr;
+
+err:
+	mutex_unlock(&fuelgauge->fg_lock);
+	return -EINVAL;
+}
+
+static int s2mu005_get_vbat(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u32 vbat = 0;
+
+	if (s2mu005_read_reg(fuelgauge->i2c, S2MU005_REG_RVBAT, data) < 0)
+		return -EINVAL;
+
+	dev_dbg(&fuelgauge->i2c->dev, "%s: data0 (%d) data1 (%d) \n", __func__, data[0], data[1]);
+	vbat = ((data[0] + (data[1] << 8)) * 1000) >> 13;
+
+	dev_info(&fuelgauge->i2c->dev, "%s: vbat (%d)\n", __func__, vbat);
+
+	return vbat;
+}
+
+static int s2mu005_get_monout_avgvbat(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u16 compliment, avg_vbat;
+
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x40, 0x08);
+	mutex_lock(&fuelgauge->fg_lock);
+
+	if (fuelgauge->revision >= 0x0A)
+		s2mu005_write_reg_byte(fuelgauge->i2c, S2MU005_REG_MONOUT_SEL, 0x16);
+	else
+		s2mu005_write_reg_byte(fuelgauge->i2c, S2MU005_REG_MONOUT_SEL, 0x27);
+
+	mdelay(50);
+
+	if (s2mu005_read_reg(fuelgauge->i2c, S2MU005_REG_MONOUT, data) < 0)
+		goto err;
+	compliment = (data[1] << 8) | (data[0]);
+
+	avg_vbat = (compliment * 1000) >> 12;
+
+	s2mu005_write_reg_byte(fuelgauge->i2c, S2MU005_REG_MONOUT_SEL, 0x10);
+
+	mutex_unlock(&fuelgauge->fg_lock);
+
+	dev_info(&fuelgauge->i2c->dev, "%s: avgvbat (%d)\n", __func__, avg_vbat);
+
+	return avg_vbat;
+
+err:
+	mutex_unlock(&fuelgauge->fg_lock);
+	return -EINVAL;
+}
+
+static int s2mu005_get_avgvbat(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u32 new_vbat, old_vbat = 0;
+	int cnt;
+
+	for (cnt = 0; cnt < 5; cnt++) {
+		if (s2mu005_read_reg(fuelgauge->i2c, S2MU005_REG_RVBAT, data) < 0)
+			return -EINVAL;
+
+		new_vbat = ((data[0] + (data[1] << 8)) * 1000) >> 13;
+
+		if (cnt == 0)
+			old_vbat = new_vbat;
+		else
+			old_vbat = new_vbat / 2 + old_vbat / 2;
+	}
+
+	dev_info(&fuelgauge->i2c->dev, "%s: avgvbat (%d)\n", __func__, old_vbat);
+
+	return old_vbat;
+}
+
+int static s2mu005_set_adc_curroffset_In(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	s32 coffset_old, coffset_new, coffset_old1, coffset_new1;
+
+	if (s2mu005_read_reg(fuelgauge->i2c, S2MU005_REG_COFFSET, data) < 0)
+		return -EINVAL;
+
+	coffset_old = data[0] + ((data[1] & 0xF) << 8);
+	fuelgauge->coffset_old = data[0] + (data[1] << 8);
+
+	if (coffset_old & (0x1 << 11)) {
+
+		if(coffset_old > 0x852)
+			coffset_new = coffset_old - 82;
+		else
+			coffset_new = 0x800;
+	} else {
+
+		if(coffset_old > 82)
+			coffset_new = coffset_old - 82;
+		else
+			coffset_new = ((~(82 - coffset_old))&0xFFF) + 1;
+	}
+
+	data[0] = (coffset_new & 0x0FF);
+    data[1] = ((coffset_new & 0xF00) >> 8) | (data[1] & 0xF0);
+	s2mu005_write_reg(fuelgauge->i2c, S2MU005_REG_COFFSET, data);
+
+	if (coffset_new & (0x1 << 11))
+		coffset_new1 = -1 * ((((~coffset_new&0xFFF)+1) * 1000) >> 13);
+	else
+		coffset_new1 = (coffset_new * 1000 ) >> 13;
+
+	if (coffset_old & (0x1 << 11))
+		coffset_old1 = -1 * ((((~coffset_old&0xFFF)+1) * 1000) >> 13);
+	else
+		coffset_old1 = (coffset_old * 1000 ) >> 13;
+
+	dev_info(&fuelgauge->i2c->dev,
+	"%s: 0x48[2]=1 -10mA :coffset_old:0x%x, coffset_new:0x%x, coffset_old1:(%d)mA, coffset_new1:(%d)mA\n",
+	__func__, fuelgauge->coffset_old, coffset_new,coffset_old1, coffset_new1);
+
+	return 0;
+}
+
+int static s2mu005_set_adc_curroffset_out(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+    u8 data[2];
+    s32 coffset_old, coffset_new, coffset_old1, coffset_new1;
+
+    if (s2mu005_read_reg(fuelgauge->i2c, S2MU005_REG_COFFSET, data) < 0)
+        return -EINVAL;
+
+    coffset_old = data[0] + ((data[1] & 0xF) << 8);
+    fuelgauge->coffset_old = data[0] + (data[1] << 8);
+
+    coffset_new = coffset_old + 82;
+    coffset_new = coffset_new & 0xFFF;
+
+    data[0] = (coffset_new & 0x0FF);
+    data[1] = ((coffset_new & 0xF00) >> 8) | (data[1] & 0xF0);
+    s2mu005_write_reg(fuelgauge->i2c, S2MU005_REG_COFFSET, data);
+
+    if (coffset_new & (0x1 << 11))
+        coffset_new1 = -1 * ((((~coffset_new&0xFFF)+1) * 1000) >> 13);
+    else
+        coffset_new1 = (coffset_new * 1000 ) >> 13;
+
+    if (coffset_old & (0x1 << 11))
+        coffset_old1 = -1 * ((((~coffset_old&0xFFF)+1) * 1000) >> 13);
+    else
+        coffset_old1 = (coffset_old * 1000 ) >> 13;
+
+    dev_info(&fuelgauge->i2c->dev,
+    "%s: 0x48[2]=0 +10mA :coffset_old:0x%x, coffset_new:0x%x, coffset_old1:(%d)mA, coffset_new1:(%d)mA\n",
+    __func__, fuelgauge->coffset_old, coffset_new,coffset_old1, coffset_new1);
+
+	return 0;
+}
+
+/* if ret < 0, discharge */
+static int sec_bat_check_discharge(int vcell)
+{
+	static int cnt;
+	static int pre_vcell = 0;
+
+	if (pre_vcell == 0)
+		pre_vcell = vcell;
+	else if (pre_vcell > vcell)
+		cnt++;
+	else if (vcell >= 3400)
+		cnt = 0;
+	else
+		cnt--;
+
+	pre_vcell = vcell;
+
+	if (cnt >= 3)
+		return -1;
+	else
+		return 1;
+}
+
+/* judge power off or not by current_avg */
+static int s2mu005_get_current_average(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	union power_supply_propval value_bat;
+	int vcell, soc, curr_avg;
+	int check_discharge;
+
+	psy_do_property("battery", get,
+			POWER_SUPPLY_PROP_HEALTH, value_bat);
+	vcell = s2mu005_get_vbat(fuelgauge);
+	soc = s2mu005_get_rawsoc(fuelgauge) / 100;
+	check_discharge = sec_bat_check_discharge(vcell);
+
+	/* if 0% && under 3.4v && low power charging(1000mA), power off */
+	if (!lpcharge && (soc <= 0) && (vcell < 3400) &&
+			((check_discharge < 0) ||
+			 ((value_bat.intval == POWER_SUPPLY_HEALTH_OVERHEAT) ||
+			  (value_bat.intval == POWER_SUPPLY_HEALTH_COLD) ||
+			  (value_bat.intval == POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE)))) {
+		pr_info("%s: SOC(%d), Vnow(%d) : set average current: -1 for power off condition.\n",
+				__func__, soc, vcell);
+		curr_avg = -1;
+	} else {
+		curr_avg = 0;
+		pr_info("%s: SOC(%d), Vnow(%d), curr_avg(%d)\n", __func__, soc, vcell, curr_avg);
+	}
+
+	return curr_avg;
+}
+
+/* capacity is  0.1% unit */
+static void s2mu005_fg_get_scaled_capacity(
+		struct s2mu005_fuelgauge_data *fuelgauge,
+		union power_supply_propval *val)
+{
+	val->intval = (val->intval < fuelgauge->pdata->capacity_min) ?
+		0 : ((val->intval - fuelgauge->pdata->capacity_min) * 1000 /
+		(fuelgauge->capacity_max - fuelgauge->pdata->capacity_min));
+
+	dev_info(&fuelgauge->i2c->dev,
+			"%s: scaled capacity (%d.%d)\n",
+			__func__, val->intval/10, val->intval%10);
+}
+
+/* capacity is integer */
+static void s2mu005_fg_get_atomic_capacity(
+		struct s2mu005_fuelgauge_data *fuelgauge,
+		union power_supply_propval *val)
+{
+	union power_supply_propval val_chg_setting, val_float_voltage;
+	int avg_vbat = 0;
+
+	if (fuelgauge->pdata->capacity_calculation_type &
+			SEC_FUELGAUGE_CAPACITY_TYPE_ATOMIC) {
+		if (fuelgauge->capacity_old < val->intval)
+			val->intval = fuelgauge->capacity_old + 1;
+		else if (fuelgauge->capacity_old > val->intval)
+			val->intval = fuelgauge->capacity_old - 1;
+	}
+
+	psy_do_property("s2mu005-charger", get, \
+		POWER_SUPPLY_PROP_CHARGE_NOW, val_chg_setting);
+	psy_do_property("s2mu005-charger", get, \
+		POWER_SUPPLY_PROP_VOLTAGE_MAX, val_float_voltage);
+	avg_vbat = s2mu005_get_avgvbat(fuelgauge);
+
+	dev_info(&fuelgauge->i2c->dev,
+			"%s: float_voltage = %d, avg_vbat = %d\n",
+			__func__, val_float_voltage.intval, avg_vbat);
+
+	/* keep SOC stable in abnormal status */
+	if (fuelgauge->pdata->capacity_calculation_type &
+			SEC_FUELGAUGE_CAPACITY_TYPE_SKIP_ABNORMAL) {
+		if ((!fuelgauge->is_charging || \
+			(val_chg_setting.intval == 0x00) || \
+			(val_float_voltage.intval + 20 < avg_vbat)) && \
+			(fuelgauge->capacity_old < val->intval)) {
+			dev_err(&fuelgauge->i2c->dev,
+					"%s: capacity (old %d : new %d)\n",
+					__func__, fuelgauge->capacity_old, val->intval);
+			val->intval = fuelgauge->capacity_old;
+		}
+	}
+
+	/* updated old capacity */
+	fuelgauge->capacity_old = val->intval;
+}
+
+static int s2mu005_fg_check_capacity_max(
+		struct s2mu005_fuelgauge_data *fuelgauge, int capacity_max)
+{
+	int new_capacity_max = capacity_max;
+
+	if (new_capacity_max < (fuelgauge->pdata->capacity_max -
+				fuelgauge->pdata->capacity_max_margin - 10)) {
+		new_capacity_max =
+			(fuelgauge->pdata->capacity_max -
+			 fuelgauge->pdata->capacity_max_margin);
+
+		dev_info(&fuelgauge->i2c->dev, "%s: set capacity max(%d --> %d)\n",
+				__func__, capacity_max, new_capacity_max);
+	} else if (new_capacity_max > (fuelgauge->pdata->capacity_max +
+				fuelgauge->pdata->capacity_max_margin)) {
+		new_capacity_max =
+			(fuelgauge->pdata->capacity_max +
+			 fuelgauge->pdata->capacity_max_margin);
+
+		dev_info(&fuelgauge->i2c->dev, "%s: set capacity max(%d --> %d)\n",
+				__func__, capacity_max, new_capacity_max);
+	}
+
+	return new_capacity_max;
+}
+
+static int s2mu005_fg_calculate_dynamic_scale(
+		struct s2mu005_fuelgauge_data *fuelgauge, int capacity)
+{
+	union power_supply_propval raw_soc_val;
+	raw_soc_val.intval = s2mu005_get_rawsoc(fuelgauge) / 10;
+
+	if (raw_soc_val.intval <
+			fuelgauge->pdata->capacity_max -
+			fuelgauge->pdata->capacity_max_margin) {
+		fuelgauge->capacity_max =
+			fuelgauge->pdata->capacity_max -
+			fuelgauge->pdata->capacity_max_margin;
+		dev_dbg(&fuelgauge->i2c->dev, "%s: capacity_max (%d)",
+				__func__, fuelgauge->capacity_max);
+	} else {
+		fuelgauge->capacity_max =
+			(raw_soc_val.intval >
+			 fuelgauge->pdata->capacity_max +
+			 fuelgauge->pdata->capacity_max_margin) ?
+			(fuelgauge->pdata->capacity_max +
+			 fuelgauge->pdata->capacity_max_margin) :
+			raw_soc_val.intval;
+		dev_dbg(&fuelgauge->i2c->dev, "%s: raw soc (%d)",
+				__func__, fuelgauge->capacity_max);
+	}
+
+	if (capacity != 100) {
+		fuelgauge->capacity_max = s2mu005_fg_check_capacity_max(
+			fuelgauge, (fuelgauge->capacity_max * 100 / (capacity + 1)));
+	} else  {
+		fuelgauge->capacity_max =
+			(fuelgauge->capacity_max * 99 / 100);
+	}
+
+	/* update capacity_old for sec_fg_get_atomic_capacity algorithm */
+	fuelgauge->capacity_old = capacity;
+
+	dev_info(&fuelgauge->i2c->dev, "%s: %d is used for capacity_max\n",
+			__func__, fuelgauge->capacity_max);
+
+	return fuelgauge->capacity_max;
+}
+
+bool s2mu005_fuelgauge_fuelalert_init(struct i2c_client *client, int soc)
+{
+	struct s2mu005_fuelgauge_data *fuelgauge = i2c_get_clientdata(client);
+	u8 data[2];
+
+	fuelgauge->is_fuel_alerted = false;
+
+	/* 1. Set s2mu005 alert configuration. */
+	s2mu005_alert_init(fuelgauge);
+
+	if (s2mu005_read_reg(client, S2MU005_REG_IRQ, data) < 0)
+		return -1;
+
+	/*Enable VBAT, SOC */
+	data[1] &= 0xfc;
+
+	/*Disable IDLE_ST, INIT)ST */
+	data[1] |= 0x0c;
+
+	s2mu005_write_reg(client, S2MU005_REG_IRQ, data);
+
+	dev_dbg(&client->dev, "%s: irq_reg(%02x%02x) irq(%d)\n",
+			__func__, data[1], data[0], fuelgauge->pdata->fg_irq);
+
+	return true;
+}
+
+bool s2mu005_fuelgauge_is_fuelalerted(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	return s2mu005_check_status(fuelgauge->i2c);
+}
+
+bool s2mu005_hal_fg_fuelalert_process(void *irq_data, bool is_fuel_alerted)
+{
+	struct s2mu005_fuelgauge_data *fuelgauge = irq_data;
+	int ret;
+
+	ret = i2c_smbus_write_byte_data(fuelgauge->i2c, S2MU005_REG_IRQ, 0x00);
+	if (ret < 0)
+		dev_err(&fuelgauge->i2c->dev, "%s: Error(%d)\n", __func__, ret);
+
+	return ret;
+}
+
+bool s2mu005_hal_fg_full_charged(struct i2c_client *client)
+{
+	return true;
+}
+
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+static int s2mu005_fg_aging_check(
+		struct s2mu005_fuelgauge_data *fuelgauge, int step)
+{
+	u8 batcap0, batcap1, batcap2, batcap3;
+	u8 por_state = 0;
+	union power_supply_propval value;
+	int charging_enabled = false;
+
+	fuelgauge->fg_age_step = step;
+
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x0F, &batcap0);
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x0E, &batcap1);
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x11, &batcap2);
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x10, &batcap3);
+
+	pr_info("%s: [Long life] orig. batcap : %02x, %02x, %02x, %02x , fg_age_step data : %02x, %02x, %02x, %02x \n",
+		__func__, batcap0, batcap1, batcap2, batcap3,
+		fuelgauge->age_data_info[fuelgauge->fg_age_step].batcap[0],
+		fuelgauge->age_data_info[fuelgauge->fg_age_step].batcap[1],
+		fuelgauge->age_data_info[fuelgauge->fg_age_step].batcap[2],
+		fuelgauge->age_data_info[fuelgauge->fg_age_step].batcap[3]);
+
+	if ((batcap0 != fuelgauge->age_data_info[fuelgauge->fg_age_step].batcap[0]) ||
+		(batcap1 != fuelgauge->age_data_info[fuelgauge->fg_age_step].batcap[1]) ||
+		(batcap2 != fuelgauge->age_data_info[fuelgauge->fg_age_step].batcap[2]) ||
+		(batcap3 != fuelgauge->age_data_info[fuelgauge->fg_age_step].batcap[3])) {
+
+		pr_info("%s: [Long life] reset gauge for age forcast , step[%d] \n", __func__, fuelgauge->fg_age_step);
+
+		fuelgauge->age_reset_status = 1;
+		por_state |= 0x10;
+		s2mu005_write_reg_byte(fuelgauge->i2c, 0x1F, por_state);
+
+		/* check charging enable */
+		psy_do_property("s2mu005-charger", get, POWER_SUPPLY_PROP_CHARGING_ENABLED, value);
+		charging_enabled = value.intval;
+
+		if (charging_enabled == true) {
+			pr_info("%s: [Long life] disable charger for reset gauge age forcast \n", __func__);
+			value.intval = SEC_BAT_CHG_MODE_CHARGING_OFF;
+			psy_do_property("s2mu005-charger", set, POWER_SUPPLY_PROP_CHARGING_ENABLED, value);
+		}
+
+		s2mu005_reset_fg(fuelgauge);
+
+		if (charging_enabled == true) {
+			psy_do_property("battery", get, POWER_SUPPLY_PROP_STATUS, value);
+			charging_enabled = value.intval;
+
+			if (charging_enabled == 1) { /* POWER_SUPPLY_STATUS_CHARGING 1 */
+				pr_info("%s: [Long life] enable charger for reset gauge age forcast \n", __func__);
+				value.intval = SEC_BAT_CHG_MODE_CHARGING;
+				psy_do_property("s2mu005-charger", set, POWER_SUPPLY_PROP_CHARGING_ENABLED, value);
+			}
+		}
+
+		por_state &= ~0x10;
+		s2mu005_write_reg_byte(fuelgauge->i2c, 0x1F, por_state);
+		fuelgauge->age_reset_status = 0;
+
+		return 1;
+	}
+	return 0;
+}
+#endif
+
+static int s2mu005_fg_get_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		union power_supply_propval *val)
+{
+	u8 temp = 0;
+	union power_supply_propval ui_soc_val;
+	union power_supply_propval cable_type_val;
+	union power_supply_propval val_chg_setting;
+
+	struct s2mu005_fuelgauge_data *fuelgauge =
+		container_of(psy, struct s2mu005_fuelgauge_data, psy_fg);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+	case POWER_SUPPLY_PROP_ENERGY_NOW:
+		return -ENODATA;
+		/* Cell voltage (VCELL, mV) */
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = s2mu005_get_vbat(fuelgauge);
+		break;
+		/* Additional Voltage Information (mV) */
+	case POWER_SUPPLY_PROP_VOLTAGE_AVG:
+		switch (val->intval) {
+			case SEC_BATTERY_VOLTAGE_AVERAGE:
+				val->intval = s2mu005_get_avgvbat(fuelgauge);
+				break;
+			case SEC_BATTERY_VOLTAGE_OCV:
+				val->intval = s2mu005_get_ocv(fuelgauge);
+				break;
+		}
+		break;
+		/* Current (mA) */
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = s2mu005_get_current(fuelgauge);
+		break;
+		/* Average Current (mA) */
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+		if (fuelgauge->mode && fuelgauge->info.soc < 100)
+			val->intval = s2mu005_get_current_average(fuelgauge);
+		else
+			val->intval = s2mu005_get_avgcurrent(fuelgauge);
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		if (val->intval == SEC_FUELGAUGE_CAPACITY_TYPE_RAW) {
+			val->intval = s2mu005_get_rawsoc(fuelgauge);
+		} else {
+			val->intval = s2mu005_get_rawsoc(fuelgauge) / 10;
+
+			if (fuelgauge->pdata->capacity_calculation_type &
+				(SEC_FUELGAUGE_CAPACITY_TYPE_SCALE |
+					SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE))
+				s2mu005_fg_get_scaled_capacity(fuelgauge, val);
+
+			/* capacity should be between 0% and 100%
+			 * (0.1% degree)
+			 */
+			if (val->intval > 1000)
+				val->intval = 1000;
+			if (val->intval < 0)
+				val->intval = 0;
+
+			/* get only integer part */
+			val->intval /= 10;
+
+			/* change adc current offset when 100% for EVT1 */
+			if (fuelgauge->revision < 2) {
+				psy_do_property("battery", get, POWER_SUPPLY_PROP_CAPACITY, ui_soc_val);
+				psy_do_property("battery", get, POWER_SUPPLY_PROP_ONLINE, cable_type_val);
+				dev_info(&fuelgauge->i2c->dev, "%s: UI SOC = %d, cable_type = %d\n",
+								__func__, ui_soc_val.intval, cable_type_val.intval);
+
+				s2mu005_read_reg_byte(fuelgauge->i2c, 0x48, &temp);
+				if ((fuelgauge->is_charging == true) && (ui_soc_val.intval >= 100) && !(temp & 0x04)) {
+					if(s2mu005_set_adc_curroffset_In(fuelgauge) < 0)
+						return -EINVAL;
+					temp |= 0x04;
+					s2mu005_write_reg_byte(fuelgauge->i2c, 0x48, temp); /* 0x48[2]=1 : adc_offset_on */
+					dev_info(&fuelgauge->i2c->dev, "%s: change coffset to -10mA. 0x48:0x%x\n", __func__, temp);
+				} else if(((cable_type_val.intval == POWER_SUPPLY_TYPE_BATTERY) ||
+								(cable_type_val.intval == POWER_SUPPLY_TYPE_UNKNOWN) ||
+								(cable_type_val.intval == POWER_SUPPLY_TYPE_OTG)) &&
+								(temp & 0x04)) {
+					if(s2mu005_set_adc_curroffset_out(fuelgauge) < 0)
+						return -EINVAL;
+					temp &= ~0x04;
+					s2mu005_write_reg_byte(fuelgauge->i2c, 0x48, temp); /* 0x48[2]=0 : adc_offset_off */
+					dev_info(&fuelgauge->i2c->dev, "%s: change coffset to +10mA. 0x48:0x%x\n", __func__, temp);					
+				}
+			}
+
+			/* check whether doing the wake_unlock */
+			if ((val->intval > fuelgauge->pdata->fuel_alert_soc) &&
+					fuelgauge->is_fuel_alerted) {
+				wake_unlock(&fuelgauge->fuel_alert_wake_lock);
+				s2mu005_fuelgauge_fuelalert_init(fuelgauge->i2c,
+						fuelgauge->pdata->fuel_alert_soc);
+			}
+
+			/* (Only for atomic capacity)
+			 * In initial time, capacity_old is 0.
+			 * and in resume from sleep,
+			 * capacity_old is too different from actual soc.
+			 * should update capacity_old
+			 * by val->intval in booting or resume.
+			 */
+			if (fuelgauge->initial_update_of_soc) {
+				/* updated old capacity */
+				fuelgauge->capacity_old = val->intval;
+				fuelgauge->initial_update_of_soc = false;
+				break;
+			}
+
+            psy_do_property("s2mu005-charger", get, \
+                POWER_SUPPLY_PROP_CHARGE_NOW, val_chg_setting);
+			if (fuelgauge->sleep_initial_update_of_soc) {
+				/* updated old capacity in case of resume */
+				if ((fuelgauge->is_charging && (val_chg_setting.intval != 0x00)) ||
+					((!fuelgauge->is_charging) && (fuelgauge->capacity_old >= val->intval))) {
+					dev_info(&fuelgauge->i2c->dev, "%s: After FG Resume\n",__func__);
+					fuelgauge->capacity_old = val->intval;
+					fuelgauge->sleep_initial_update_of_soc = false;
+					break;
+				}
+			}
+
+			if (fuelgauge->pdata->capacity_calculation_type &
+				(SEC_FUELGAUGE_CAPACITY_TYPE_ATOMIC |
+					 SEC_FUELGAUGE_CAPACITY_TYPE_SKIP_ABNORMAL))
+				s2mu005_fg_get_atomic_capacity(fuelgauge, val);
+		}
+
+		break;
+	/* Battery Temperature */
+	case POWER_SUPPLY_PROP_TEMP:
+	/* Target Temperature */
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		val->intval = s2mu005_get_temperature(fuelgauge);
+		break;
+	case POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:
+		val->intval = fuelgauge->capacity_max;
+		break;
+	case POWER_SUPPLY_PROP_SCOPE:
+		val->intval = fuelgauge->mode;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int s2mu005_fg_set_property(struct power_supply *psy,
+                            enum power_supply_property psp,
+                            const union power_supply_propval *val)
+{
+	struct s2mu005_fuelgauge_data *fuelgauge =
+		container_of(psy, struct s2mu005_fuelgauge_data, psy_fg);
+
+	switch (psp) {
+		case POWER_SUPPLY_PROP_STATUS:
+#if defined(CONFIG_BATTERY_AGE_FORECAST_DETACHABLE)
+			if (val->intval == POWER_SUPPLY_STATUS_FULL)
+				s2mu005_fg_aging_check(fuelgauge,
+					fuelgauge->change_step);
+#endif
+			break;
+		case POWER_SUPPLY_PROP_CHARGE_FULL:
+			if (fuelgauge->pdata->capacity_calculation_type &
+					SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE) {
+#if defined(CONFIG_PREVENT_SOC_JUMP)
+				s2mu005_fg_calculate_dynamic_scale(fuelgauge, val->intval);
+#else
+				s2mu005_fg_calculate_dynamic_scale(fuelgauge, 100);
+#endif
+			}
+			break;
+		case POWER_SUPPLY_PROP_ONLINE:
+			fuelgauge->cable_type = val->intval;
+			if (val->intval == POWER_SUPPLY_TYPE_BATTERY)
+				fuelgauge->is_charging = false;
+			else
+				fuelgauge->is_charging = true;
+			break;
+		case POWER_SUPPLY_PROP_CAPACITY:
+			if (val->intval == SEC_FUELGAUGE_CAPACITY_TYPE_RESET) {
+				fuelgauge->initial_update_of_soc = true;
+				s2mu005_restart_gauging(fuelgauge);
+			}
+			break;
+		case POWER_SUPPLY_PROP_TEMP:
+		case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+			s2mu005_set_temperature(fuelgauge, val->intval);
+			break;
+		case POWER_SUPPLY_PROP_ENERGY_NOW:
+			break;
+		case POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:
+			dev_info(&fuelgauge->i2c->dev,
+				"%s: capacity_max changed, %d -> %d\n",
+				__func__, fuelgauge->capacity_max, val->intval);
+			fuelgauge->capacity_max = s2mu005_fg_check_capacity_max(fuelgauge, val->intval);
+			fuelgauge->initial_update_of_soc = true;
+			break;
+		case POWER_SUPPLY_PROP_CHARGE_TYPE:
+			/* rt5033_fg_reset_capacity_by_jig_connection(fuelgauge->i2c); */
+			break;
+		case POWER_SUPPLY_PROP_CHARGE_EMPTY:
+			pr_info("%s: WA for battery 0 percent\n", __func__);
+			s2mu005_write_reg_byte(fuelgauge->i2c, 0x1F, 0x01);
+			break;
+		case POWER_SUPPLY_PROP_ENERGY_AVG:
+			pr_info("%s: WA for power off issue: val(%d)\n", __func__, val->intval);
+			if(val->intval)
+				s2mu005_write_reg_byte(fuelgauge->i2c, 0x41, 0x10); /* charger start */
+			else
+				s2mu005_write_reg_byte(fuelgauge->i2c, 0x41, 0x04); /* charger end */
+			break;
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+		case POWER_SUPPLY_EXT_PROP_UPDATE_BATTERY_DATA:
+#if defined(CONFIG_BATTERY_AGE_FORECAST_DETACHABLE)
+					fuelgauge->change_step = val->intval;
+#else
+					s2mu005_fg_aging_check(fuelgauge, val->intval);
+#endif
+					break;
+#endif
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void s2mu005_fg_isr_work(struct work_struct *work)
+{
+	struct s2mu005_fuelgauge_data *fuelgauge =
+		container_of(work, struct s2mu005_fuelgauge_data, isr_work.work);
+	u8 fg_alert_status = 0;
+
+	s2mu005_read_reg_byte(fuelgauge->i2c, S2MU005_REG_STATUS, &fg_alert_status);
+	dev_info(&fuelgauge->i2c->dev, "%s : fg_alert_status(0x%x)\n",
+		__func__, fg_alert_status);
+
+	fg_alert_status &= 0x03;
+	if (fg_alert_status & 0x01) {
+		pr_info("%s : Battery Level is very Low!\n", __func__);
+	}
+
+	if (fg_alert_status & 0x02) {
+		pr_info("%s : Battery Voltage is Very Low!\n", __func__);
+	}
+
+	if (!fg_alert_status) {
+		fuelgauge->is_fuel_alerted = false;
+		pr_info("%s : SOC or Volage is Good!\n", __func__);
+		wake_unlock(&fuelgauge->fuel_alert_wake_lock);
+	}
+}
+
+static irqreturn_t s2mu005_fg_irq_thread(int irq, void *irq_data)
+{
+	struct s2mu005_fuelgauge_data *fuelgauge = irq_data;
+	u8 fg_irq = 0;
+
+	s2mu005_read_reg_byte(fuelgauge->i2c, S2MU005_REG_IRQ, &fg_irq);
+	dev_info(&fuelgauge->i2c->dev, "%s: fg_irq(0x%x)\n",
+		__func__, fg_irq);
+	if (fuelgauge->is_fuel_alerted) {
+		return IRQ_HANDLED;
+	} else {
+		wake_lock(&fuelgauge->fuel_alert_wake_lock);
+		fuelgauge->is_fuel_alerted = true;
+		schedule_delayed_work(&fuelgauge->isr_work, 0);
+	}
+
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_OF
+static int s2mu005_fuelgauge_parse_dt(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	struct device_node *np = of_find_node_by_name(NULL, "s2mu005-fuelgauge");
+	int ret;
+	int i, len;
+	const u32 *p;
+
+	        /* reset, irq gpio info */
+	if (np == NULL) {
+		pr_err("%s np NULL\n", __func__);
+	} else {
+		fuelgauge->pdata->fg_irq = of_get_named_gpio(np, "fuelgauge,fuel_int", 0);
+		if (fuelgauge->pdata->fg_irq < 0)
+			pr_err("%s error reading fg_irq = %d\n",
+				__func__, fuelgauge->pdata->fg_irq);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_max",
+				&fuelgauge->pdata->capacity_max);
+		if (ret < 0)
+			pr_err("%s error reading capacity_max %d\n", __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_max_margin",
+				&fuelgauge->pdata->capacity_max_margin);
+		if (ret < 0)
+			pr_err("%s error reading capacity_max_margin %d\n", __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_min",
+				&fuelgauge->pdata->capacity_min);
+		if (ret < 0)
+			pr_err("%s error reading capacity_min %d\n", __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_calculation_type",
+				&fuelgauge->pdata->capacity_calculation_type);
+		if (ret < 0)
+			pr_err("%s error reading capacity_calculation_type %d\n",
+					__func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,evt2_val",
+				&fuelgauge->pdata->evt2_val);
+		if (ret < 0){
+			fuelgauge->pdata->evt2_val = 0x00;
+			pr_info("%s Default value of evt2_val = %x\n",
+					__func__, fuelgauge->pdata->evt2_val);
+		}
+
+		ret = of_property_read_u32(np, "fuelgauge,fg_log_enable",
+				&fuelgauge->pdata->fg_log_enable);
+		if (ret < 0)
+			pr_err("%s fg_log_disabled %d\n", __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,fuel_alert_soc",
+				&fuelgauge->pdata->fuel_alert_soc);
+		if (ret < 0)
+			pr_err("%s error reading pdata->fuel_alert_soc %d\n",
+					__func__, ret);
+		fuelgauge->pdata->repeated_fuelalert = of_property_read_bool(np,
+				"fuelgauge,repeated_fuelalert");
+
+
+
+
+
+		
+
+		np = of_find_node_by_name(NULL, "battery");
+		if (!np) {
+			pr_err("%s np NULL\n", __func__);
+		} else {
+			ret = of_property_read_string(np,
+				"battery,fuelgauge_name",
+				(char const **)&fuelgauge->pdata->fuelgauge_name);
+			p = of_get_property(np,
+					"battery,input_current_limit", &len);
+			if (!p)
+				return 1;
+
+			len = len / sizeof(u32);
+			fuelgauge->pdata->charging_current =
+					kzalloc(sizeof(struct sec_charging_current) * len,
+					GFP_KERNEL);
+
+			for(i = 0; i < len; i++) {
+				ret = of_property_read_u32_index(np,
+					"battery,input_current_limit", i,
+					&fuelgauge->pdata->charging_current[i].input_current_limit);
+				ret = of_property_read_u32_index(np,
+					"battery,fast_charging_current", i,
+					&fuelgauge->pdata->charging_current[i].fast_charging_current);
+				ret = of_property_read_u32_index(np,
+					"battery,full_check_current_1st", i,
+					&fuelgauge->pdata->charging_current[i].full_check_current_1st);
+				ret = of_property_read_u32_index(np,
+					"battery,full_check_current_2nd", i,
+					&fuelgauge->pdata->charging_current[i].full_check_current_2nd);
+			}
+		}
+
+		/* get battery_params node */
+		np = of_find_node_by_name(NULL, "battery_params");
+		if (!np) {
+			pr_err("%s battery_params node NULL\n", __func__);
+		} else {
+#if !defined(CONFIG_BATTERY_AGE_FORECAST)
+			/* get battery_table */
+			ret = of_property_read_u32_array(np, "battery,battery_table1", fuelgauge->info.battery_table1, 88);
+			if (ret < 0) {
+				pr_err("%s error reading battery,battery_table1\n", __func__);
+			}
+
+			ret = of_property_read_u32_array(np, "battery,battery_table2", fuelgauge->info.battery_table2, 22);
+			if (ret < 0) {
+				pr_err("%s error reading battery,battery_table2\n", __func__);
+			}
+
+			ret = of_property_read_u32_array(np, "battery,battery_table3", fuelgauge->info.battery_table3, 88);
+			if (ret < 0) {
+				pr_err("%s error reading battery,battery_table3\n", __func__);
+			}
+
+			ret = of_property_read_u32_array(np, "battery,battery_table4", fuelgauge->info.battery_table4, 22);
+			if (ret < 0) {
+				pr_err("%s error reading battery,battery_table4\n", __func__);
+			}
+
+			ret = of_property_read_u32_array(np, "battery,batcap", fuelgauge->info.batcap, 4);
+			if (ret < 0) {
+				pr_err("%s error reading battery,batcap\n", __func__);
+			}
+
+			ret = of_property_read_u32_array(np, "battery,soc_arr_evt1", fuelgauge->info.soc_arr_evt1, 22);
+			if (ret < 0) {
+				pr_err("%s error reading battery,soc_arr_evt1\n", __func__);
+			}
+
+			ret = of_property_read_u32_array(np, "battery,ocv_arr_evt1", fuelgauge->info.ocv_arr_evt1, 22);
+			if (ret < 0) {
+				pr_err("%s error reading battery,ocv_arr_evt1\n", __func__);
+			}
+
+			ret = of_property_read_u32_array(np, "battery,soc_arr_evt2", fuelgauge->info.soc_arr_evt2, 22);
+			if (ret < 0) {
+				pr_err("%s error reading battery,soc_arr_evt2\n", __func__);
+			}
+
+			ret = of_property_read_u32_array(np, "battery,ocv_arr_evt2", fuelgauge->info.ocv_arr_evt2, 22);
+			if (ret < 0) {
+				pr_err("%s error reading battery,ocv_arr_evt2\n", __func__);
+			}
+			ret = of_property_read_u32_array(np, "battery,FG_Accumulative_rate_evt2", fuelgauge->info.fg_accumulative_rate_evt2, 2);
+			if (ret < 0) {
+
+				fuelgauge->info.fg_accumulative_rate_evt2[0]=0x00;    // REG 0x44
+				fuelgauge->info.fg_accumulative_rate_evt2[1]=0x08;    // REG 0x45
+				pr_err("%s There is no FG_Accumulative_rate value in DT. set to the default value(0x800) \n", __func__);
+			}
+#else
+			of_get_property(np, "battery,battery_data", &len);
+			fuelgauge->fg_num_age_step = len / sizeof(fg_age_data_info_t);
+			fuelgauge->age_data_info = kzalloc(len, GFP_KERNEL);
+			ret = of_property_read_u32_array(np, "battery,battery_data",
+					(int *)fuelgauge->age_data_info, len/sizeof(int));
+
+			pr_err("%s: [Long life] fuelgauge->fg_num_age_step %d \n", __func__,fuelgauge->fg_num_age_step);
+
+			for (i=0 ; i < fuelgauge->fg_num_age_step ; i++){
+				pr_err("%s: [Long life] age_step = %d, table3[0] %d, table4[0] %d, batcap[0] %02x, accum[0] %02x, soc_arr[0] %d, ocv_arr[0] %d \n",
+					__func__, i,
+					fuelgauge->age_data_info[i].battery_table3[0],
+					fuelgauge->age_data_info[i].battery_table4[0],
+					fuelgauge->age_data_info[i].batcap[0],
+					fuelgauge->age_data_info[i].accum[0],
+					fuelgauge->age_data_info[i].soc_arr_val[0],
+					fuelgauge->age_data_info[i].ocv_arr_val[0]);
+			}
+#endif
+
+			/* batt data version */
+			ret = of_property_read_u32_array(np, "battery,data_ver", &fuelgauge->info.data_ver, 1);
+			if (ret < 0) {
+				pr_err("Can get prop %s (%d)\n", "battery,data_ver", ret);
+				fuelgauge->info.data_ver = 0;
+			}
+			pr_info("%s = <%d>\n", "battery,data_ver", fuelgauge->info.data_ver);
+		}
+	}
+
+	return 0;
+}
+
+static struct of_device_id s2mu005_fuelgauge_match_table[] = {
+        { .compatible = "samsung,s2mu005-fuelgauge",},
+        {},
+};
+#else
+static int s2mu005_fuelgauge_parse_dt(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+    return -ENOSYS;
+}
+
+#define s2mu005_fuelgauge_match_table NULL
+#endif /* CONFIG_OF */
+
+static int s2mu005_fuelgauge_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+	struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
+	struct s2mu005_fuelgauge_data *fuelgauge;
+	union power_supply_propval raw_soc_val;
+	int ret = 0;
+	u8 temp = 0;
+
+	pr_info("%s: S2MU005 Fuelgauge Driver Loading\n", __func__);
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE))
+		return -EIO;
+
+	fuelgauge = kzalloc(sizeof(*fuelgauge), GFP_KERNEL);
+	if (!fuelgauge)
+		return -ENOMEM;
+
+	mutex_init(&fuelgauge->fg_lock);
+
+	fuelgauge->i2c = client;
+
+	if (client->dev.of_node) {
+		fuelgauge->pdata = devm_kzalloc(&client->dev, sizeof(*(fuelgauge->pdata)),
+				GFP_KERNEL);
+		if (!fuelgauge->pdata) {
+			dev_err(&client->dev, "Failed to allocate memory\n");
+			ret = -ENOMEM;
+			goto err_parse_dt_nomem;
+		}
+		ret = s2mu005_fuelgauge_parse_dt(fuelgauge);
+		if (ret < 0)
+			goto err_parse_dt;
+	} else {
+		fuelgauge->pdata = client->dev.platform_data;
+	}
+
+	i2c_set_clientdata(client, fuelgauge);
+
+	if (fuelgauge->pdata->fuelgauge_name == NULL)
+		fuelgauge->pdata->fuelgauge_name = "sec-fuelgauge";
+
+	fuelgauge->psy_fg.name          = fuelgauge->pdata->fuelgauge_name;
+	fuelgauge->psy_fg.type          = POWER_SUPPLY_TYPE_UNKNOWN;
+	fuelgauge->psy_fg.get_property  = s2mu005_fg_get_property;
+	fuelgauge->psy_fg.set_property  = s2mu005_fg_set_property;
+	fuelgauge->psy_fg.properties    = s2mu005_fuelgauge_props;
+	fuelgauge->psy_fg.num_properties =
+			ARRAY_SIZE(s2mu005_fuelgauge_props);
+
+	/* 0x48[7:4]=0010 : EVT2 */
+	fuelgauge->revision = 0;
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x48, &temp);
+	fuelgauge->revision = (temp & 0xF0) >> 4;
+
+	pr_info("%s: S2MU005 Fuelgauge revision: %d, reg 0x48 = 0x%x\n", __func__, fuelgauge->revision, temp);
+
+	fuelgauge->capacity_max = fuelgauge->pdata->capacity_max;
+	fuelgauge->info.soc = 0;
+	fuelgauge->mode = CURRENT_MODE;
+
+	raw_soc_val.intval = s2mu005_get_rawsoc(fuelgauge);
+	raw_soc_val.intval = raw_soc_val.intval / 10;
+
+	if (raw_soc_val.intval > fuelgauge->capacity_max)
+		s2mu005_fg_calculate_dynamic_scale(fuelgauge, 100);
+
+	s2mu005_init_regs(fuelgauge);
+
+	ret = power_supply_register(&client->dev, &fuelgauge->psy_fg);
+	if (ret) {
+		pr_err("%s: Failed to Register psy_fg\n", __func__);
+		goto err_data_free;
+	}
+
+	fuelgauge->is_fuel_alerted = false;
+	if (fuelgauge->pdata->fuel_alert_soc >= 0) {
+		s2mu005_fuelgauge_fuelalert_init(fuelgauge->i2c,
+					fuelgauge->pdata->fuel_alert_soc);
+		wake_lock_init(&fuelgauge->fuel_alert_wake_lock,
+					WAKE_LOCK_SUSPEND, "fuel_alerted");
+
+		if (fuelgauge->pdata->fg_irq > 0) {
+			INIT_DELAYED_WORK(
+					&fuelgauge->isr_work, s2mu005_fg_isr_work);
+
+			fuelgauge->fg_irq = gpio_to_irq(fuelgauge->pdata->fg_irq);
+			dev_info(&client->dev,
+					"%s : fg_irq = %d\n", __func__, fuelgauge->fg_irq);
+			if (fuelgauge->fg_irq > 0) {
+				ret = request_threaded_irq(fuelgauge->fg_irq,
+						NULL, s2mu005_fg_irq_thread,
+						IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING
+						| IRQF_ONESHOT,
+						"fuelgauge-irq", fuelgauge);
+				if (ret) {
+					dev_err(&client->dev,
+							"%s: Failed to Request IRQ\n", __func__);
+					goto err_supply_unreg;
+				}
+
+				ret = enable_irq_wake(fuelgauge->fg_irq);
+				if (ret < 0)
+					dev_err(&client->dev,
+							"%s: Failed to Enable Wakeup Source(%d)\n",
+							__func__, ret);
+			} else {
+				dev_err(&client->dev, "%s: Failed gpio_to_irq(%d)\n",
+						__func__, fuelgauge->fg_irq);
+				goto err_supply_unreg;
+			}
+		}
+	}
+
+	fuelgauge->sleep_initial_update_of_soc = false;
+	fuelgauge->initial_update_of_soc = true;
+
+	fuelgauge->cc_on = true;
+
+	pr_info("%s: S2MU005 Fuelgauge Driver Loaded\n", __func__);
+	return 0;
+
+err_supply_unreg:
+	power_supply_unregister(&fuelgauge->psy_fg);
+err_data_free:
+	if (client->dev.of_node)
+		kfree(fuelgauge->pdata);
+
+err_parse_dt:
+err_parse_dt_nomem:
+	mutex_destroy(&fuelgauge->fg_lock);
+	kfree(fuelgauge);
+
+	return ret;
+}
+
+static const struct i2c_device_id s2mu005_fuelgauge_id[] = {
+	{"s2mu005-fuelgauge", 0},
+	{}
+};
+
+static void s2mu005_fuelgauge_shutdown(struct i2c_client *client)
+{
+	struct s2mu005_fuelgauge_data *fuelgauge = i2c_get_clientdata(client);
+	u8 temp = 0;
+
+	if(fuelgauge->revision < 2) {
+		s2mu005_read_reg_byte(fuelgauge->i2c, 0x45, &temp);
+		temp &= 0xF0;
+		s2mu005_write_reg_byte(fuelgauge->i2c, 0x45, temp);
+		s2mu005_write_reg_byte(fuelgauge->i2c, 0x44, 0x00);
+	}
+}
+
+static int s2mu005_fuelgauge_remove(struct i2c_client *client)
+{
+	struct s2mu005_fuelgauge_data *fuelgauge = i2c_get_clientdata(client);
+
+	if (fuelgauge->pdata->fuel_alert_soc >= 0)
+		wake_lock_destroy(&fuelgauge->fuel_alert_wake_lock);
+
+	return 0;
+}
+
+#if defined CONFIG_PM
+static int s2mu005_fuelgauge_suspend(struct device *dev)
+{
+	struct s2mu005_fuelgauge_data *fuelgauge = dev_get_drvdata(dev);
+	u8 temp = 0;
+
+	if(fuelgauge->revision < 2) {
+		if (!fuelgauge->is_charging) {
+			if (fuelgauge->mode == CURRENT_MODE) {
+				s2mu005_read_reg_byte(fuelgauge->i2c, 0x45, &temp);
+				temp &= 0xF0;
+				temp |= 0x06;
+				s2mu005_write_reg_byte(fuelgauge->i2c, 0x45, temp);
+
+				s2mu005_write_reg_byte(fuelgauge->i2c, 0x44, 0xBD);
+			} else {
+				s2mu005_read_reg_byte(fuelgauge->i2c, 0x45, &temp);
+				temp &= 0xF0;
+				s2mu005_write_reg_byte(fuelgauge->i2c, 0x45, temp);
+
+				s2mu005_write_reg_byte(fuelgauge->i2c, 0x44, 0x00);
+			}
+
+			s2mu005_read_reg_byte(fuelgauge->i2c, 0x44, &temp);
+			pr_info("%s: Reg set suspend 0x44 : 0x%x\n",
+				__func__, temp);
+			s2mu005_read_reg_byte(fuelgauge->i2c, 0x45, &temp);
+			pr_info("%s: Reg set suspend 0x45 : 0x%x\n",
+				__func__, temp);
+		}
+	}
+	return 0;
+}
+
+static int s2mu005_fuelgauge_resume(struct device *dev)
+{
+	struct s2mu005_fuelgauge_data *fuelgauge = dev_get_drvdata(dev);
+	static int avg_vbat[5] = {0, };
+	static int vbat[5] = {0, };
+	static int avg_current[5] = {100, 100, 100, 100, 100};
+	static int loop_count = 0;
+	int target_ocv = 0, target_soc = 0, temp_vol = 0, j = 0, k = 0;
+	u8 temp = 0;
+
+	if(fuelgauge->revision < 2) {
+		if (fuelgauge->mode == CURRENT_MODE) {
+			avg_current[loop_count] = s2mu005_get_avgcurrent(fuelgauge);
+			avg_vbat[loop_count] =  s2mu005_get_avgvbat(fuelgauge);
+			vbat[loop_count] = s2mu005_get_vbat(fuelgauge);
+
+			if (loop_count++ >= 5) loop_count = 0;
+
+			for (j = 0; j < 5; j++) {
+				pr_info("%s: abs avergae current : %ld\n", __func__, abs(avg_current[j]));
+				if (abs(avg_current[j]) > 30)
+					break;
+			}
+
+			pr_info("%s: avg current count : %d\n", __func__, j);
+			if (j >= 5) {
+				for (k = 0; k < 5; k++) {
+					if (avg_vbat[k] > vbat[k])
+						temp_vol = avg_vbat[k];
+					else
+						temp_vol = vbat[k];
+
+					if (temp_vol > target_ocv)
+						target_ocv = temp_vol;
+				}
+
+				pr_info("%s: target ocv : %d\n", __func__, target_ocv);
+
+				/* work-around for restart */
+				fuelgauge->target_ocv = target_ocv;      /* max( vbat[5], avgvbat[5] ) */
+				target_soc = s2mu005_get_soc_from_ocv(fuelgauge, fuelgauge->target_ocv);
+
+				if( abs(target_soc - fuelgauge->info.soc) > 300 )
+					WA_0_issue_at_init1(fuelgauge, fuelgauge->target_ocv);
+			}
+		}
+
+		if (!fuelgauge->is_charging) {
+			if (fuelgauge->mode == CURRENT_MODE) {
+				s2mu005_read_reg_byte(fuelgauge->i2c, 0x45, &temp);
+				temp &= 0xF0;
+				temp |= 0x07;
+				s2mu005_write_reg_byte(fuelgauge->i2c, 0x45, temp);
+
+				s2mu005_write_reg_byte(fuelgauge->i2c, 0x44, 0xCC);
+			} else {
+				s2mu005_read_reg_byte(fuelgauge->i2c, 0x45, &temp);
+				temp &= 0xF0;
+				s2mu005_write_reg_byte(fuelgauge->i2c, 0x45, temp);
+
+				s2mu005_write_reg_byte(fuelgauge->i2c, 0x44, 0x00);
+			}
+		}
+
+		s2mu005_read_reg_byte(fuelgauge->i2c, 0x44, &temp);
+		pr_info("%s: Reg set resume 0x44 : 0x%x\n",
+				__func__, temp);
+		s2mu005_read_reg_byte(fuelgauge->i2c, 0x45, &temp);
+		pr_info("%s: Reg set resume 0x45 : 0x%x\n",
+				__func__, temp);
+	}
+
+	fuelgauge->sleep_initial_update_of_soc = true;
+
+	return 0;
+}
+#else
+#define s2mu005_fuelgauge_suspend NULL
+#define s2mu005_fuelgauge_resume NULL
+#endif
+
+static SIMPLE_DEV_PM_OPS(s2mu005_fuelgauge_pm_ops, s2mu005_fuelgauge_suspend,
+		s2mu005_fuelgauge_resume);
+
+static struct i2c_driver s2mu005_fuelgauge_driver = {
+	.driver = {
+		.name = "s2mu005-fuelgauge",
+		.owner = THIS_MODULE,
+		.pm = &s2mu005_fuelgauge_pm_ops,
+		.of_match_table = s2mu005_fuelgauge_match_table,
+	},
+	.probe  = s2mu005_fuelgauge_probe,
+	.remove = s2mu005_fuelgauge_remove,
+	.shutdown   = s2mu005_fuelgauge_shutdown,
+	.id_table   = s2mu005_fuelgauge_id,
+};
+
+static int __init s2mu005_fuelgauge_init(void)
+{
+	pr_info("%s: S2MU005 Fuelgauge Init\n", __func__);
+	return i2c_add_driver(&s2mu005_fuelgauge_driver);
+}
+
+static void __exit s2mu005_fuelgauge_exit(void)
+{
+	i2c_del_driver(&s2mu005_fuelgauge_driver);
+}
+module_init(s2mu005_fuelgauge_init);
+module_exit(s2mu005_fuelgauge_exit);
+
+MODULE_DESCRIPTION("Samsung S2MU005 Fuel Gauge Driver");
+MODULE_AUTHOR("Samsung Electronics");
+MODULE_LICENSE("GPL");
diff -Naur linux-3.18.14/drivers/battery/sec_adc.c samsung/drivers/battery/sec_adc.c
--- linux-3.18.14/drivers/battery/sec_adc.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery/sec_adc.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,185 @@
+/*
+ *  sec_adc.c
+ *  Samsung Mobile Battery Driver
+ *
+ *  Copyright (C) 2012 Samsung Electronics
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/battery/sec_adc.h>
+
+struct adc_list {
+	const char*	name;
+	struct iio_channel *channel;
+	bool is_used;
+};
+
+static struct adc_list batt_adc_list[] = {
+	{.name = "adc-cable"},
+	{.name = "adc-bat"},
+	{.name = "adc-temp"},
+	{.name = "adc-temp"},
+	{.name = "adc-full"},
+	{.name = "adc-volt"},
+	{.name = "adc-chg-temp"},
+	{.name = "adc-in-bat"},
+	{.name = "adc-dischg"},
+	{.name = "adc-dischg-ntc"},
+	{.name = "adc-wpc-temp"},
+	{.name = "adc-slave-chg-temp"},
+};
+
+static void sec_bat_adc_ap_init(struct platform_device *pdev)
+{
+	int i = 0;
+	struct iio_channel *temp_adc;
+
+	for (i = 0; i < SEC_BAT_ADC_CHANNEL_NUM; i++) {
+		temp_adc = iio_channel_get(&pdev->dev, batt_adc_list[i].name);
+		batt_adc_list[i].channel = temp_adc;
+		batt_adc_list[i].is_used = !IS_ERR_OR_NULL(temp_adc);
+	}
+}
+
+static int sec_bat_adc_ap_read(int channel)
+{
+	int data = -1;
+	int ret = 0;
+
+	ret = (batt_adc_list[channel].is_used) ?
+		iio_read_channel_raw(batt_adc_list[channel].channel, &data) : 0;
+
+	return data;
+}
+
+static void sec_bat_adc_ap_exit(void)
+{
+	int i = 0;
+	for (i = 0; i < SEC_BAT_ADC_CHANNEL_NUM; i++) {
+		if (batt_adc_list[i].is_used) {
+			iio_channel_release(batt_adc_list[i].channel);
+		}
+	}
+}
+
+static void sec_bat_adc_none_init(struct platform_device *pdev)
+{
+}
+
+static int sec_bat_adc_none_read(int channel)
+{
+	return 0;
+}
+
+static void sec_bat_adc_none_exit(void)
+{
+}
+
+static void sec_bat_adc_ic_init(struct platform_device *pdev)
+{
+}
+
+static int sec_bat_adc_ic_read(int channel)
+{
+	return 0;
+}
+
+static void sec_bat_adc_ic_exit(void)
+{
+}
+static int adc_read_type(struct sec_battery_info *battery, int channel)
+{
+	int adc = 0;
+
+	if ((!battery->pdata->self_discharging_en) &&
+	    ((channel == SEC_BAT_ADC_CHANNEL_DISCHARGING_CHECK) ||
+	     (channel == SEC_BAT_ADC_CHANNEL_DISCHARGING_NTC))) {
+		pr_info("%s : Doesn't enable Self Discharging Algorithm\n", __func__);
+		return 0;
+	}
+
+	switch (battery->pdata->temp_adc_type)
+	{
+	case SEC_BATTERY_ADC_TYPE_NONE :
+		adc = sec_bat_adc_none_read(channel);
+		break;
+	case SEC_BATTERY_ADC_TYPE_AP :
+		adc = sec_bat_adc_ap_read(channel);
+		break;
+	case SEC_BATTERY_ADC_TYPE_IC :
+		adc = sec_bat_adc_ic_read(channel);
+		break;
+	case SEC_BATTERY_ADC_TYPE_NUM :
+		break;
+	default :
+		break;
+	}
+	return adc;
+}
+
+static void adc_init_type(struct platform_device *pdev,
+			  struct sec_battery_info *battery)
+{
+	switch (battery->pdata->temp_adc_type)
+	{
+	case SEC_BATTERY_ADC_TYPE_NONE :
+		sec_bat_adc_none_init(pdev);
+		break;
+	case SEC_BATTERY_ADC_TYPE_AP :
+		sec_bat_adc_ap_init(pdev);
+		break;
+	case SEC_BATTERY_ADC_TYPE_IC :
+		sec_bat_adc_ic_init(pdev);
+		break;
+	case SEC_BATTERY_ADC_TYPE_NUM :
+		break;
+	default :
+		break;
+	}
+}
+
+static void adc_exit_type(struct sec_battery_info *battery)
+{
+	switch (battery->pdata->temp_adc_type)
+	{
+	case SEC_BATTERY_ADC_TYPE_NONE :
+		sec_bat_adc_none_exit();
+		break;
+	case SEC_BATTERY_ADC_TYPE_AP :
+		sec_bat_adc_ap_exit();
+		break;
+	case SEC_BATTERY_ADC_TYPE_IC :
+		sec_bat_adc_ic_exit();
+		break;
+	case SEC_BATTERY_ADC_TYPE_NUM :
+		break;
+	default :
+		break;
+	}
+}
+
+int adc_read(struct sec_battery_info *battery, int channel)
+{
+	int adc = 0;
+
+	adc = adc_read_type(battery, channel);
+
+	dev_dbg(battery->dev, "[%s]adc = %d\n", __func__, adc);
+
+	return adc;
+}
+
+void adc_init(struct platform_device *pdev, struct sec_battery_info *battery)
+{
+	adc_init_type(pdev, battery);
+}
+
+void adc_exit(struct sec_battery_info *battery)
+{
+	adc_exit_type(battery);
+}
+
diff -Naur linux-3.18.14/drivers/battery/sec_battery.c samsung/drivers/battery/sec_battery.c
--- linux-3.18.14/drivers/battery/sec_battery.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery/sec_battery.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,8439 @@
+/*
+ *  sec_battery.c
+ *  Samsung Mobile Battery Driver
+ *
+ *  Copyright (C) 2012 Samsung Electronics
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/battery/sec_battery.h>
+#ifdef CONFIG_CCIC_NOTIFIER
+#include <linux/ccic/ccic_notifier.h>
+#endif /* CONFIG_CCIC_NOTIFIER */
+
+#define SEC_INPUT_VOLTAGE_5V	5
+#define SEC_INPUT_VOLTAGE_9V	9
+
+bool sleep_mode = false;
+
+bool slate_mode_state;
+static struct device_attribute sec_battery_attrs[] = {
+	SEC_BATTERY_ATTR(batt_reset_soc),
+	SEC_BATTERY_ATTR(batt_read_raw_soc),
+	SEC_BATTERY_ATTR(batt_read_adj_soc),
+	SEC_BATTERY_ATTR(batt_type),
+	SEC_BATTERY_ATTR(batt_vfocv),
+	SEC_BATTERY_ATTR(batt_vol_adc),
+	SEC_BATTERY_ATTR(batt_vol_adc_cal),
+	SEC_BATTERY_ATTR(batt_vol_aver),
+	SEC_BATTERY_ATTR(batt_vol_adc_aver),
+	SEC_BATTERY_ATTR(batt_current_ua_now),
+	SEC_BATTERY_ATTR(batt_current_ua_avg),
+	SEC_BATTERY_ATTR(batt_temp),
+	SEC_BATTERY_ATTR(batt_temp_adc),
+	SEC_BATTERY_ATTR(batt_temp_aver),
+	SEC_BATTERY_ATTR(batt_temp_adc_aver),
+	SEC_BATTERY_ATTR(chg_temp),
+	SEC_BATTERY_ATTR(chg_temp_adc),
+	SEC_BATTERY_ATTR(slave_chg_temp),
+	SEC_BATTERY_ATTR(slave_chg_temp_adc),
+
+	SEC_BATTERY_ATTR(batt_vf_adc),
+	SEC_BATTERY_ATTR(batt_slate_mode),
+
+	SEC_BATTERY_ATTR(batt_lp_charging),
+	SEC_BATTERY_ATTR(siop_activated),
+	SEC_BATTERY_ATTR(siop_level),
+	SEC_BATTERY_ATTR(siop_event),
+	SEC_BATTERY_ATTR(batt_charging_source),
+	SEC_BATTERY_ATTR(fg_reg_dump),
+	SEC_BATTERY_ATTR(fg_reset_cap),
+	SEC_BATTERY_ATTR(fg_capacity),
+	SEC_BATTERY_ATTR(fg_asoc),
+	SEC_BATTERY_ATTR(auth),
+	SEC_BATTERY_ATTR(chg_current_adc),
+	SEC_BATTERY_ATTR(wc_adc),
+	SEC_BATTERY_ATTR(wc_status),
+	SEC_BATTERY_ATTR(wc_enable),
+	SEC_BATTERY_ATTR(wc_control),
+	SEC_BATTERY_ATTR(hv_charger_status),
+	SEC_BATTERY_ATTR(hv_wc_charger_status),
+	SEC_BATTERY_ATTR(hv_charger_set),
+	SEC_BATTERY_ATTR(factory_mode),
+	SEC_BATTERY_ATTR(store_mode),
+	SEC_BATTERY_ATTR(update),
+	SEC_BATTERY_ATTR(test_mode),
+
+	SEC_BATTERY_ATTR(call),
+	SEC_BATTERY_ATTR(2g_call),
+	SEC_BATTERY_ATTR(talk_gsm),
+	SEC_BATTERY_ATTR(3g_call),
+	SEC_BATTERY_ATTR(talk_wcdma),
+	SEC_BATTERY_ATTR(music),
+	SEC_BATTERY_ATTR(video),
+	SEC_BATTERY_ATTR(browser),
+	SEC_BATTERY_ATTR(hotspot),
+	SEC_BATTERY_ATTR(camera),
+	SEC_BATTERY_ATTR(camcorder),
+	SEC_BATTERY_ATTR(data_call),
+	SEC_BATTERY_ATTR(wifi),
+	SEC_BATTERY_ATTR(wibro),
+	SEC_BATTERY_ATTR(lte),
+	SEC_BATTERY_ATTR(lcd),
+	SEC_BATTERY_ATTR(gps),
+	SEC_BATTERY_ATTR(event),
+	SEC_BATTERY_ATTR(batt_temp_table),
+	SEC_BATTERY_ATTR(batt_high_current_usb),
+#if defined(CONFIG_SAMSUNG_BATTERY_ENG_TEST)
+	SEC_BATTERY_ATTR(test_charge_current),
+#endif
+	SEC_BATTERY_ATTR(set_stability_test),
+	SEC_BATTERY_ATTR(batt_capacity_max),
+	SEC_BATTERY_ATTR(batt_inbat_voltage),
+#if defined(CONFIG_BATTERY_SWELLING_SELF_DISCHARGING)
+	SEC_BATTERY_ATTR(batt_discharging_check),
+	SEC_BATTERY_ATTR(batt_discharging_check_adc),
+	SEC_BATTERY_ATTR(batt_discharging_ntc),
+	SEC_BATTERY_ATTR(batt_discharging_ntc_adc),
+	SEC_BATTERY_ATTR(batt_self_discharging_control),
+#endif
+#if defined(CONFIG_SW_SELF_DISCHARGING)
+	SEC_BATTERY_ATTR(batt_sw_self_discharging),
+#endif
+	SEC_BATTERY_ATTR(batt_inbat_wireless_cs100),
+	SEC_BATTERY_ATTR(hmt_ta_connected),
+	SEC_BATTERY_ATTR(hmt_ta_charge),
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	SEC_BATTERY_ATTR(fg_cycle),
+	SEC_BATTERY_ATTR(fg_fullcapnom),
+	SEC_BATTERY_ATTR(battery_cycle),
+#if defined(CONFIG_BATTERY_AGE_FORECAST_DETACHABLE)
+	SEC_BATTERY_ATTR(batt_after_manufactured),
+#endif
+#endif
+	SEC_BATTERY_ATTR(fg_full_voltage),
+	SEC_BATTERY_ATTR(batt_wpc_temp),
+	SEC_BATTERY_ATTR(batt_wpc_temp_adc),
+#if defined(CONFIG_WIRELESS_FIRMWARE_UPDATE)
+	SEC_BATTERY_ATTR(batt_wireless_firmware_update),
+	SEC_BATTERY_ATTR(otp_firmware_result),
+	SEC_BATTERY_ATTR(wc_ic_grade),
+	SEC_BATTERY_ATTR(otp_firmware_ver_bin),
+	SEC_BATTERY_ATTR(otp_firmware_ver),
+	SEC_BATTERY_ATTR(tx_firmware_result),
+	SEC_BATTERY_ATTR(tx_firmware_ver),
+	SEC_BATTERY_ATTR(batt_tx_status),
+#endif
+	SEC_BATTERY_ATTR(wc_vout),
+	SEC_BATTERY_ATTR(wc_vrect),
+	SEC_BATTERY_ATTR(batt_hv_wireless_status),
+	SEC_BATTERY_ATTR(batt_hv_wireless_pad_ctrl),
+	SEC_BATTERY_ATTR(batt_tune_float_voltage),
+	SEC_BATTERY_ATTR(batt_tune_intput_charge_current),
+	SEC_BATTERY_ATTR(batt_tune_fast_charge_current),
+	SEC_BATTERY_ATTR(batt_tune_ui_term_cur_1st),
+	SEC_BATTERY_ATTR(batt_tune_ui_term_cur_2nd),
+	SEC_BATTERY_ATTR(batt_tune_temp_high_normal),
+	SEC_BATTERY_ATTR(batt_tune_temp_high_rec_normal),
+	SEC_BATTERY_ATTR(batt_tune_temp_low_normal),
+	SEC_BATTERY_ATTR(batt_tune_temp_low_rec_normal),
+	SEC_BATTERY_ATTR(batt_tune_chg_temp_high),
+	SEC_BATTERY_ATTR(batt_tune_chg_temp_rec),
+	SEC_BATTERY_ATTR(batt_tune_chg_limit_cur),
+	SEC_BATTERY_ATTR(batt_tune_coil_temp_high),
+	SEC_BATTERY_ATTR(batt_tune_coil_temp_rec),
+	SEC_BATTERY_ATTR(batt_tune_coil_limit_cur),
+#if defined(CONFIG_UPDATE_BATTERY_DATA)
+	SEC_BATTERY_ATTR(batt_update_data),
+#endif
+	SEC_BATTERY_ATTR(batt_misc_event),
+	SEC_BATTERY_ATTR(factory_mode_relieve),
+	SEC_BATTERY_ATTR(factory_mode_bypass),
+	SEC_BATTERY_ATTR(batt_wdt_control),
+	SEC_BATTERY_ATTR(safety_timer_set),
+};
+
+static enum power_supply_property sec_battery_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_CHARGE_TYPE,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_VOLTAGE_AVG,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CURRENT_AVG,
+	POWER_SUPPLY_PROP_CHARGE_NOW,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_TEMP_AMBIENT,
+#if defined(CONFIG_CALC_TIME_TO_FULL)
+	POWER_SUPPLY_PROP_TIME_TO_FULL_NOW,
+#endif
+#if defined(CONFIG_BATTERY_SWELLING)
+	POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT,
+#endif
+	POWER_SUPPLY_PROP_CHARGE_COUNTER_SHADOW,
+	POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL,
+	POWER_SUPPLY_PROP_CHARGE_UNO_CONTROL,
+};
+
+static enum power_supply_property sec_power_props[] = {
+	POWER_SUPPLY_PROP_ONLINE,
+};
+
+static enum power_supply_property sec_ac_props[] = {
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_TEMP,
+};
+
+static enum power_supply_property sec_ps_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_ONLINE,
+};
+
+static char *supply_list[] = {
+	"battery",
+};
+
+char *sec_bat_charging_mode_str[] = {
+	"None",
+	"Normal",
+	"Additional",
+	"Re-Charging",
+	"ABS"
+};
+
+char *sec_bat_status_str[] = {
+	"Unknown",
+	"Charging",
+	"Discharging",
+	"Not-charging",
+	"Full"
+};
+
+char *sec_bat_health_str[] = {
+	"Unknown",
+	"Good",
+	"Overheat",
+	"Warm",
+	"Dead",
+	"OverVoltage",
+	"UnspecFailure",
+	"Cold",
+	"Cool",
+	"WatchdogTimerExpire",
+	"SafetyTimerExpired",
+	"UnderVoltage",
+	"OverheatLimit"
+};
+
+static int sec_bat_get_wireless_current(struct sec_battery_info *battery, int incurr)
+{
+	/* 1. SIOP EVENT */
+	if (battery->siop_event & SIOP_EVENT_WPC_CALL &&
+			(battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK ||
+			battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK_TA)) {
+		if (battery->capacity >= battery->pdata->wireless_cc_cv) {
+			if (incurr > battery->pdata->siop_call_cv_current)
+				incurr = battery->pdata->siop_call_cv_current;
+		} else {
+			if (incurr > battery->pdata->siop_call_cc_current)
+				incurr = battery->pdata->siop_call_cc_current;
+		}
+	}
+
+	/* 2. WPC_SLEEP_MODE */
+	if(battery->cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS && sleep_mode) {
+		if(incurr > battery->pdata->sleep_mode_limit_current)
+			incurr = battery->pdata->sleep_mode_limit_current;
+		pr_info("%s sleep_mode =%d, wpc_temp_mode =%d, in_curr = %d \n", __func__,
+			sleep_mode, battery->wpc_temp_mode, incurr);
+	}
+
+	/* 3. WPC_TEMP_MODE */
+	if (battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS ||
+			battery->cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS ||
+			battery->cable_type == POWER_SUPPLY_TYPE_PMA_WIRELESS ||
+			battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK ||
+			battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK_TA){
+		if(battery->wpc_temp_mode &&
+			(incurr > battery->pdata->wpc_charging_limit_current))
+			incurr = battery->pdata->wpc_charging_limit_current;
+	}
+
+	/* 4. WPC_CV_MODE */
+	if (battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS && battery->wc_cv_mode) {
+		if (incurr >= battery->pdata->charging_current[POWER_SUPPLY_TYPE_WIRELESS].input_current_limit)
+			incurr = battery->pdata->wc_cv_current;
+	}
+
+	/* 5. Full-Additional state */
+	if (battery->status == POWER_SUPPLY_STATUS_FULL && battery->charging_mode == SEC_BATTERY_CHARGING_2ND) {
+		if (incurr > battery->pdata->siop_hv_wireless_input_limit_current)
+			incurr = battery->pdata->siop_hv_wireless_input_limit_current;
+	}
+
+	/* 6. Full-None state && SIOP_LEVEL 100 */
+	if (battery->siop_level == 100 &&
+		battery->status == POWER_SUPPLY_STATUS_FULL && battery->charging_mode == SEC_BATTERY_CHARGING_NONE) {
+		incurr = battery->pdata->wc_full_input_limit_current;
+	}
+
+	if (battery->wc_heat_limit == SEC_BATTERY_WC_HEAT_HIGH ||
+		battery->pad_limit == SEC_BATTERY_WPC_TEMP_HIGH) {
+		if (incurr > battery->pdata->wc_heating_input_limit_current) /* 5V, 400mA */
+			incurr = battery->pdata->wc_heating_input_limit_current;
+		pr_info("%s: wc_heat_limit occurred. input current is under %dmA\n",
+			__func__, battery->pdata->wc_heating_input_limit_current);
+	}
+
+	/* 7. Wireless Battery Pack. if capacity under 5%, set WIRELESS_TYPE current. */
+	if (battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK ||
+		battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK_TA) {
+		if (battery->capacity <= 5) {
+			battery->wc_pack_max_curr = true;
+			incurr = battery->pdata->charging_current[POWER_SUPPLY_TYPE_WIRELESS].input_current_limit;
+			pr_info("%s: Capacity Under 5 percent, Input Current set WIRELESSS TYPE CABLE\n", __func__);
+		} else {
+			battery->wc_pack_max_curr = false;
+		}
+	}
+
+	return incurr;
+}
+
+static void sec_bat_get_charging_current_by_siop(struct sec_battery_info *battery,
+		int *input_current, int *charging_current) {
+	int usb_charging_current = battery->pdata->charging_current[POWER_SUPPLY_TYPE_USB].fast_charging_current;
+	if (battery->siop_level == 3) {
+		/* side sync scenario : siop_level 3 */
+		if (battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS ||
+				battery->cable_type == POWER_SUPPLY_TYPE_PMA_WIRELESS ||
+				battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK ||
+				battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK_TA) {
+			if (*input_current > battery->pdata->siop_wireless_input_limit_current)
+				*input_current = battery->pdata->siop_wireless_input_limit_current;
+			*charging_current = battery->pdata->siop_wireless_charging_limit_current;
+		} else if (battery->cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS) {
+			if (*input_current > battery->pdata->siop_hv_wireless_input_limit_current)
+				*input_current = battery->pdata->siop_hv_wireless_input_limit_current;
+			*charging_current = battery->pdata->siop_hv_wireless_charging_limit_current;
+		} else if (battery->cable_type == POWER_SUPPLY_TYPE_HV_MAINS ||
+				battery->cable_type == POWER_SUPPLY_TYPE_HV_ERR) {
+			if (*input_current > 450)
+				*input_current = 450;
+			*charging_current = battery->pdata->siop_hv_charging_limit_current;
+		} else {
+			if (*input_current > 800)
+				*input_current = 800;
+			*charging_current = battery->pdata->charging_current[
+				battery->cable_type].fast_charging_current;
+			if (*charging_current > battery->pdata->siop_charging_limit_current)
+				*charging_current = battery->pdata->siop_charging_limit_current;
+		}
+	} else if (battery->siop_level < 100) {
+		/* decrease the charging current according to siop level */
+		*charging_current = *charging_current * battery->siop_level / 100;
+
+		/* do forced set charging current */
+		if (*charging_current > 0 && *charging_current < usb_charging_current)
+			*charging_current = usb_charging_current;
+
+		if (battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS ||
+				battery->cable_type == POWER_SUPPLY_TYPE_PMA_WIRELESS ||
+				battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK ||
+				battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK_TA) {
+			if(*input_current > battery->pdata->siop_wireless_input_limit_current)
+				*input_current = battery->pdata->siop_wireless_input_limit_current;
+			if (*charging_current > battery->pdata->siop_wireless_charging_limit_current)
+				*charging_current = battery->pdata->siop_wireless_charging_limit_current;
+		} else if (battery->cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS) {
+			if(*input_current > battery->pdata->siop_hv_wireless_input_limit_current)
+				*input_current = battery->pdata->siop_hv_wireless_input_limit_current;
+			if (*charging_current > battery->pdata->siop_hv_wireless_charging_limit_current)
+				*charging_current = battery->pdata->siop_hv_wireless_charging_limit_current;
+		} else if (battery->cable_type == POWER_SUPPLY_TYPE_HV_MAINS ||
+				battery->cable_type == POWER_SUPPLY_TYPE_HV_ERR){
+			if (*input_current > battery->pdata->siop_hv_input_limit_current)
+				*input_current = battery->pdata->siop_hv_input_limit_current;
+			if (*charging_current > battery->pdata->siop_hv_charging_limit_current)
+				*charging_current = battery->pdata->siop_hv_charging_limit_current;
+		} else {
+			if (*input_current > battery->pdata->siop_input_limit_current)
+				*input_current = battery->pdata->siop_input_limit_current;
+			if (*charging_current > battery->pdata->siop_charging_limit_current)
+				*charging_current = battery->pdata->siop_charging_limit_current;
+		}
+	}
+}
+
+static int sec_bat_set_charging_current(struct sec_battery_info *battery)
+{
+	union power_supply_propval value;
+	int input_current = battery->pdata->charging_current[battery->cable_type].input_current_limit,
+	    charging_current = battery->pdata->charging_current[battery->cable_type].fast_charging_current,
+	    topoff_current = battery->pdata->charging_current[battery->cable_type].full_check_current_1st;
+
+	mutex_lock(&battery->iolock);
+	if (battery->cable_type == POWER_SUPPLY_TYPE_BATTERY) {
+		battery->wireless_input_current =
+			battery->pdata->charging_current[POWER_SUPPLY_TYPE_BATTERY].input_current_limit;
+	} else {
+		sec_bat_get_charging_current_by_siop(battery, &input_current, &charging_current);
+		/* check input current */
+		if (battery->current_event & SEC_BAT_CURRENT_EVENT_AFC) {
+			if (battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS ||
+				battery->cable_type == POWER_SUPPLY_TYPE_PMA_WIRELESS ||
+				battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK ||
+				battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK_TA) {
+				if (battery->wireless_input_current != input_current)
+					input_current = battery->pdata->pre_wc_afc_input_current; // 500mA
+				wake_lock(&battery->afc_wake_lock);
+				cancel_delayed_work(&battery->wc_afc_work);
+				queue_delayed_work_on(0, battery->monitor_wqueue,
+					&battery->wc_afc_work , msecs_to_jiffies(1700));
+			} else {
+				input_current = battery->pdata->pre_afc_input_current; // 1000mA
+				wake_lock(&battery->afc_wake_lock);
+				cancel_delayed_work(&battery->afc_work);
+				queue_delayed_work_on(0, battery->monitor_wqueue,
+					&battery->afc_work, msecs_to_jiffies(2000));
+			}
+		} else if (battery->store_mode && !battery->ignore_store_mode) {
+			if (battery->cable_type == POWER_SUPPLY_TYPE_HV_MAINS ||
+				battery->cable_type == POWER_SUPPLY_TYPE_HV_MAINS_12V ||
+				battery->cable_type == POWER_SUPPLY_TYPE_HV_ERR) {
+				input_current = battery->pdata->store_mode_afc_input_current;
+			}
+		}
+
+		/* Calculate wireless input current under the specific conditions (siop_event, wpc_sleep_mode, wpc_temp_mode)*/
+		if (battery->wc_status != SEC_WIRELESS_PAD_NONE) {
+			input_current = sec_bat_get_wireless_current(battery, input_current);
+		}
+
+		/* check topoff current */
+		if (battery->charging_mode == SEC_BATTERY_CHARGING_2ND &&
+			battery->pdata->full_check_type_2nd == SEC_BATTERY_FULLCHARGED_CHGPSY) {
+			topoff_current =
+				battery->pdata->charging_current[battery->cable_type].full_check_current_2nd;
+		}
+
+		/* check swelling state */
+		if (battery->current_event & SEC_BAT_CURRENT_EVENT_LOW_TEMP_SWELLING) {
+			charging_current = (charging_current > battery->pdata->swelling_low_temp_current) ?
+				battery->pdata->swelling_low_temp_current : charging_current;
+			topoff_current = (topoff_current > battery->pdata->swelling_low_temp_topoff) ?
+				battery->pdata->swelling_low_temp_topoff : topoff_current;
+		} else if (battery->current_event & SEC_BAT_CURRENT_EVENT_HIGH_TEMP_SWELLING) {
+			charging_current = (charging_current > battery->pdata->swelling_high_temp_current) ?
+				battery->pdata->swelling_high_temp_current : charging_current;
+			topoff_current = (topoff_current > battery->pdata->swelling_high_temp_topoff) ?
+				battery->pdata->swelling_high_temp_topoff : topoff_current;
+		} else if (battery->current_event & SEC_BAT_CURRENT_EVENT_LOW_TEMP) {
+				charging_current = (charging_current > battery->pdata->swelling_low_temp_current) ?
+					battery->pdata->swelling_low_temp_current : charging_current;
+		}
+	}
+
+	if (battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS ||
+		battery->cable_type == POWER_SUPPLY_TYPE_PMA_WIRELESS ||
+		battery->cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS ||
+		battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK ||
+		battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK_TA) {
+		/* set charging current */
+		if (battery->charging_current != charging_current) {
+			value.intval = charging_current;
+			psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_CURRENT_NOW, value);
+			battery->charging_current = charging_current;
+		}
+		/* set input current for wireless charging */
+		if (battery->wireless_input_current != input_current) {
+			value.intval = input_current;
+			psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_CURRENT_MAX, value);
+			battery->wireless_input_current = input_current;
+		}
+	} else {
+		/* set input current for wired charging */
+		if (battery->wired_input_current != input_current) {
+			value.intval = input_current;
+			psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_CURRENT_MAX, value);
+			battery->wired_input_current = input_current;
+		}
+		/* set charging current */
+		if (battery->charging_current != charging_current) {
+			value.intval = charging_current;
+			psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_CURRENT_NOW, value);
+			battery->charging_current = charging_current;
+		}
+	}
+
+	/* set topoff current */
+	if (battery->topoff_current != topoff_current) {
+		value.intval = topoff_current;
+		psy_do_property(battery->pdata->charger_name, set,
+			POWER_SUPPLY_PROP_CURRENT_FULL, value);
+		battery->topoff_current = topoff_current;
+	}
+	mutex_unlock(&battery->iolock);
+	return 0;
+}
+
+static int sec_bat_set_charge(
+				struct sec_battery_info *battery,
+				int chg_mode)
+{
+	union power_supply_propval val;
+	ktime_t current_time;
+	struct timespec ts;
+
+	if ((battery->cable_type == POWER_SUPPLY_TYPE_HMT_CONNECTED) ||
+		(battery->cable_type == POWER_SUPPLY_TYPE_OTG))
+		return 0;
+
+	val.intval = battery->status;
+	psy_do_property(battery->pdata->charger_name, set,
+		POWER_SUPPLY_PROP_STATUS, val);
+	current_time = ktime_get_boottime();
+	ts = ktime_to_timespec(current_time);
+
+	if (chg_mode == SEC_BAT_CHG_MODE_CHARGING) {
+		if (battery->cable_type != POWER_SUPPLY_TYPE_HV_WIRELESS &&
+			battery->cable_type != POWER_SUPPLY_TYPE_HV_WIRELESS_ETX)
+		{
+			battery->wc_heating_start_time= 0;
+			battery->wc_heating_passed_time= 0;
+			battery->wc_heat_limit = SEC_BATTERY_WC_HEAT_NONE;
+		}
+		/*Reset charging start time only in initial charging start */
+		if (battery->charging_start_time == 0) {
+			if (ts.tv_sec < 1)
+				ts.tv_sec = 1;
+			battery->charging_start_time = ts.tv_sec;
+			battery->charging_next_time =
+				battery->pdata->charging_reset_time;
+		}
+		battery->charging_block = false;
+	} else {
+		if (battery->cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS) {
+			if (battery->wc_heat_limit == SEC_BATTERY_WC_HEAT_HIGH ||
+				battery->pad_limit == SEC_BATTERY_WPC_TEMP_HIGH) {
+				val.intval = WIRELESS_VOUT_9V;
+				psy_do_property(battery->pdata->wireless_charger_name, set,
+					POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, val);
+				battery->pad_limit = SEC_BATTERY_WPC_TEMP_NONE;
+			}
+		}
+		battery->charging_start_time = 0;
+		battery->charging_passed_time = 0;
+		battery->wc_heating_start_time= 0;
+		battery->wc_heating_passed_time= 0;
+		battery->wc_heat_limit = SEC_BATTERY_WC_HEAT_NONE;
+		battery->charging_next_time = 0;
+		battery->charging_fullcharged_time = 0;
+		battery->full_check_cnt = 0;
+		battery->charging_block = true;
+#if defined(CONFIG_STEP_CHARGING)
+		sec_bat_reset_step_charging(battery);
+#endif
+	}
+
+	battery->temp_highlimit_cnt = 0;
+	battery->temp_high_cnt = 0;
+	battery->temp_low_cnt = 0;
+	battery->temp_recover_cnt = 0;
+
+	val.intval = chg_mode;
+	psy_do_property(battery->pdata->charger_name, set,
+		POWER_SUPPLY_PROP_CHARGING_ENABLED, val);
+
+	return 0;
+}
+
+#if 0 //temp block
+static void sec_bat_set_misc_event(struct sec_battery_info *battery,
+	const int misc_event_type, bool do_clear) {
+
+	mutex_lock(&battery->misclock);
+	pr_info("%s: %s misc event(now=0x%x, value=0x%x)\n",
+		__func__, ((do_clear) ? "clear" : "set"), battery->misc_event, misc_event_type);
+	if (do_clear) {
+		battery->misc_event &= ~misc_event_type;
+	} else {
+		battery->misc_event |= misc_event_type;
+	}
+	mutex_unlock(&battery->misclock);
+
+	if (battery->prev_misc_event != battery->misc_event) {
+		cancel_delayed_work(&battery->misc_event_work);
+		wake_lock(&battery->misc_event_wake_lock);
+		queue_delayed_work_on(0, battery->monitor_wqueue,
+			&battery->misc_event_work, 0);
+	}
+}
+#endif
+
+static int sec_bat_get_adc_data(struct sec_battery_info *battery,
+			int adc_ch, int count)
+{
+	int adc_data;
+	int adc_max;
+	int adc_min;
+	int adc_total;
+	int i;
+
+	adc_data = 0;
+	adc_max = 0;
+	adc_min = 0;
+	adc_total = 0;
+
+	for (i = 0; i < count; i++) {
+		mutex_lock(&battery->adclock);
+#ifdef CONFIG_OF
+		adc_data = adc_read(battery, adc_ch);
+#else
+		adc_data = adc_read(battery->pdata, adc_ch);
+#endif
+		mutex_unlock(&battery->adclock);
+
+		if (adc_data < 0)
+			goto err;
+
+		if (i != 0) {
+			if (adc_data > adc_max)
+				adc_max = adc_data;
+			else if (adc_data < adc_min)
+				adc_min = adc_data;
+		} else {
+			adc_max = adc_data;
+			adc_min = adc_data;
+		}
+		adc_total += adc_data;
+	}
+
+	return (adc_total - adc_max - adc_min) / (count - 2);
+err:
+	return adc_data;
+}
+
+/*
+static unsigned long calculate_average_adc(
+			struct sec_battery_info *battery,
+			int channel, int adc)
+{
+	unsigned int cnt = 0;
+	int total_adc = 0;
+	int average_adc = 0;
+	int index = 0;
+
+	cnt = battery->adc_sample[channel].cnt;
+	total_adc = battery->adc_sample[channel].total_adc;
+
+	if (adc < 0) {
+		dev_err(battery->dev,
+			"%s : Invalid ADC : %d\n", __func__, adc);
+		adc = battery->adc_sample[channel].average_adc;
+	}
+
+	if (cnt < ADC_SAMPLE_COUNT) {
+		battery->adc_sample[channel].adc_arr[cnt] = adc;
+		battery->adc_sample[channel].index = cnt;
+		battery->adc_sample[channel].cnt = ++cnt;
+
+		total_adc += adc;
+		average_adc = total_adc / cnt;
+	} else {
+		index = battery->adc_sample[channel].index;
+		if (++index >= ADC_SAMPLE_COUNT)
+			index = 0;
+
+		total_adc = total_adc -
+			battery->adc_sample[channel].adc_arr[index] + adc;
+		average_adc = total_adc / ADC_SAMPLE_COUNT;
+
+		battery->adc_sample[channel].adc_arr[index] = adc;
+		battery->adc_sample[channel].index = index;
+	}
+
+	battery->adc_sample[channel].total_adc = total_adc;
+	battery->adc_sample[channel].average_adc = average_adc;
+
+	return average_adc;
+}
+*/
+
+static int sec_bat_get_adc_value(
+		struct sec_battery_info *battery, int channel)
+{
+	int adc;
+
+	adc = sec_bat_get_adc_data(battery, channel,
+		battery->pdata->adc_check_count);
+
+	if (adc < 0) {
+		dev_err(battery->dev,
+			"%s: Error in ADC\n", __func__);
+		return adc;
+	}
+
+	return adc;
+}
+
+static int sec_bat_get_charger_type_adc
+				(struct sec_battery_info *battery)
+{
+	/* It is true something valid is
+	connected to the device for charging.
+	By default this something is considered to be USB.*/
+	int result = POWER_SUPPLY_TYPE_USB;
+
+	int adc = 0;
+	int i;
+
+	/* Do NOT check cable type when cable_switch_check() returns false
+	 * and keep current cable type
+	 */
+	if (battery->pdata->cable_switch_check &&
+	    !battery->pdata->cable_switch_check())
+		return battery->cable_type;
+
+	adc = sec_bat_get_adc_value(battery,
+		SEC_BAT_ADC_CHANNEL_CABLE_CHECK);
+
+	/* Do NOT check cable type when cable_switch_normal() returns false
+	 * and keep current cable type
+	 */
+	if (battery->pdata->cable_switch_normal &&
+	    !battery->pdata->cable_switch_normal())
+		return battery->cable_type;
+
+	for (i = 0; i < SEC_SIZEOF_POWER_SUPPLY_TYPE; i++)
+		if ((adc > battery->pdata->cable_adc_value[i].min) &&
+			(adc < battery->pdata->cable_adc_value[i].max))
+			break;
+	if (i >= SEC_SIZEOF_POWER_SUPPLY_TYPE)
+		dev_err(battery->dev,
+			"%s : default USB\n", __func__);
+	else
+		result = i;
+
+	dev_dbg(battery->dev, "%s : result(%d), adc(%d)\n",
+		__func__, result, adc);
+
+	return result;
+}
+
+static bool sec_bat_check_vf_adc(struct sec_battery_info *battery)
+{
+	int adc;
+
+	adc = sec_bat_get_adc_data(battery,
+		SEC_BAT_ADC_CHANNEL_BAT_CHECK,
+		battery->pdata->adc_check_count);
+
+	if (adc < 0) {
+		dev_err(battery->dev, "%s: VF ADC error\n", __func__);
+		adc = battery->check_adc_value;
+	} else
+		battery->check_adc_value = adc;
+
+	if ((battery->check_adc_value <= battery->pdata->check_adc_max) &&
+		(battery->check_adc_value >= battery->pdata->check_adc_min)) {
+		return true;
+	} else {
+		dev_info(battery->dev, "%s: adc (%d)\n", __func__, battery->check_adc_value);
+		return false;
+	}
+}
+
+static bool sec_bat_check_by_psy(struct sec_battery_info *battery)
+{
+	char *psy_name;
+	union power_supply_propval value;
+	bool ret;
+	ret = true;
+
+	switch (battery->pdata->battery_check_type) {
+	case SEC_BATTERY_CHECK_PMIC:
+		psy_name = battery->pdata->pmic_name;
+		break;
+	case SEC_BATTERY_CHECK_FUELGAUGE:
+		psy_name = battery->pdata->fuelgauge_name;
+		break;
+	case SEC_BATTERY_CHECK_CHARGER:
+		psy_name = battery->pdata->charger_name;
+		break;
+	default:
+		dev_err(battery->dev,
+			"%s: Invalid Battery Check Type\n", __func__);
+		ret = false;
+		goto battery_check_error;
+		break;
+	}
+
+	psy_do_property(psy_name, get,
+		POWER_SUPPLY_PROP_PRESENT, value);
+	ret = (bool)value.intval;
+
+battery_check_error:
+	return ret;
+}
+
+static bool sec_bat_check(struct sec_battery_info *battery)
+{
+	bool ret;
+	ret = true;
+
+	if (battery->factory_mode || battery->is_jig_on) {
+		dev_dbg(battery->dev, "%s: No need to check in factory mode\n",
+			__func__);
+		return ret;
+	}
+
+	if (battery->health != POWER_SUPPLY_HEALTH_GOOD &&
+		battery->health != POWER_SUPPLY_HEALTH_UNSPEC_FAILURE) {
+		dev_dbg(battery->dev, "%s: No need to check\n", __func__);
+		return ret;
+	}
+
+	switch (battery->pdata->battery_check_type) {
+	case SEC_BATTERY_CHECK_ADC:
+		if(battery->cable_type == POWER_SUPPLY_TYPE_BATTERY)
+			ret = battery->present;
+		else
+			ret = sec_bat_check_vf_adc(battery);
+		break;
+	case SEC_BATTERY_CHECK_INT:
+		if(battery->cable_type == POWER_SUPPLY_TYPE_BATTERY)
+			ret = battery->present;
+		else {
+			msleep(50);
+			/* high is miss the battery */
+			ret = !(gpio_get_value(battery->pdata->bat_irq_gpio));
+		}
+		break;
+	case SEC_BATTERY_CHECK_CALLBACK:
+		if(battery->cable_type == POWER_SUPPLY_TYPE_BATTERY) {
+			ret = battery->present;
+		} else {
+			if (battery->pdata->check_battery_callback)
+				ret = battery->pdata->check_battery_callback();
+		}
+		break;
+	case SEC_BATTERY_CHECK_PMIC:
+	case SEC_BATTERY_CHECK_FUELGAUGE:
+	case SEC_BATTERY_CHECK_CHARGER:
+		ret = sec_bat_check_by_psy(battery);
+		break;
+	case SEC_BATTERY_CHECK_NONE:
+		dev_dbg(battery->dev, "%s: No Check\n", __func__);
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+static bool sec_bat_get_cable_type(
+			struct sec_battery_info *battery,
+			int cable_source_type)
+{
+	bool ret;
+	int cable_type;
+
+	ret = false;
+	cable_type = battery->cable_type;
+
+	if (cable_source_type & SEC_BATTERY_CABLE_SOURCE_CALLBACK) {
+		if (battery->pdata->check_cable_callback)
+			cable_type =
+				battery->pdata->check_cable_callback();
+	}
+
+	if (cable_source_type & SEC_BATTERY_CABLE_SOURCE_ADC) {
+		if (gpio_get_value_cansleep(
+			battery->pdata->bat_gpio_ta_nconnected) ^
+			battery->pdata->bat_polarity_ta_nconnected)
+			cable_type = POWER_SUPPLY_TYPE_BATTERY;
+		else
+			cable_type =
+				sec_bat_get_charger_type_adc(battery);
+	}
+
+	if (battery->cable_type == cable_type) {
+		dev_dbg(battery->dev,
+			"%s: No need to change cable status\n", __func__);
+	} else {
+		if (cable_type < POWER_SUPPLY_TYPE_BATTERY ||
+			cable_type >= SEC_SIZEOF_POWER_SUPPLY_TYPE) {
+			dev_err(battery->dev,
+				"%s: Invalid cable type\n", __func__);
+		} else {
+			battery->cable_type = cable_type;
+			if (battery->pdata->check_cable_result_callback)
+				battery->pdata->check_cable_result_callback(
+					battery->cable_type);
+
+			ret = true;
+
+			dev_dbg(battery->dev, "%s: Cable Changed (%d)\n",
+				__func__, battery->cable_type);
+		}
+	}
+
+	return ret;
+}
+
+static void sec_bat_set_charging_status(struct sec_battery_info *battery,
+		int status) {
+	union power_supply_propval value;
+	switch (status) {
+		case POWER_SUPPLY_STATUS_CHARGING:
+		if (battery->siop_level != 100)
+			battery->stop_timer = true;
+		break;
+		
+		case POWER_SUPPLY_STATUS_NOT_CHARGING:
+		case POWER_SUPPLY_STATUS_DISCHARGING:
+			if (battery->status == POWER_SUPPLY_STATUS_FULL ||
+				battery->capacity == 100) {
+				value.intval = 100;
+				psy_do_property(battery->pdata->fuelgauge_name, set,
+						POWER_SUPPLY_PROP_CHARGE_FULL, value);
+				/* To get SOC value (NOT raw SOC), need to reset value */
+				value.intval = 0;
+				psy_do_property(battery->pdata->fuelgauge_name, get,
+						POWER_SUPPLY_PROP_CAPACITY, value);
+				battery->capacity = value.intval;
+			}
+			battery->expired_time = battery->pdata->expired_time;
+			battery->prev_safety_time = 0;
+			break;
+		case POWER_SUPPLY_STATUS_FULL:
+			if (battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS ||
+				battery->cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS ||
+				battery->cable_type == POWER_SUPPLY_TYPE_PMA_WIRELESS ||
+				battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK ||
+				battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK_TA) {
+#ifdef CONFIG_CS100_JPNCONCEPT
+				if (battery->charging_mode == SEC_BATTERY_CHARGING_2ND ||
+					battery->charging_passed_time > battery->pdata->charging_total_time) {
+#endif
+					value.intval = POWER_SUPPLY_STATUS_FULL;
+					psy_do_property(battery->pdata->wireless_charger_name, set,
+						POWER_SUPPLY_PROP_STATUS, value);
+#ifdef CONFIG_CS100_JPNCONCEPT
+				}
+#endif
+			}
+			break;
+		default:
+			break;
+	}
+	battery->status = status;
+}
+
+static bool sec_bat_battery_cable_check(struct sec_battery_info *battery)
+{
+	if (!sec_bat_check(battery)) {
+		if (battery->check_count < battery->pdata->check_count)
+			battery->check_count++;
+		else {
+			dev_err(battery->dev,
+				"%s: Battery Disconnected\n", __func__);
+			battery->present = false;
+			battery->health = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;
+
+			if (battery->status !=
+				POWER_SUPPLY_STATUS_DISCHARGING) {
+				sec_bat_set_charging_status(battery,
+						POWER_SUPPLY_STATUS_NOT_CHARGING);
+				sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_BUCK_OFF);
+			}
+
+			if (battery->pdata->check_battery_result_callback)
+				battery->pdata->
+					check_battery_result_callback();
+			return false;
+		}
+	} else
+		battery->check_count = 0;
+
+	battery->present = true;
+
+	if (battery->health == POWER_SUPPLY_HEALTH_UNSPEC_FAILURE) {
+		battery->health = POWER_SUPPLY_HEALTH_GOOD;
+
+		if (battery->status == POWER_SUPPLY_STATUS_NOT_CHARGING) {
+			sec_bat_set_charging_status(battery,
+					POWER_SUPPLY_STATUS_CHARGING);
+#if defined(CONFIG_BATTERY_SWELLING)
+			if (!battery->swelling_mode)
+#endif
+			sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING);
+		}
+	}
+
+	dev_dbg(battery->dev, "%s: Battery Connected\n", __func__);
+
+	if (battery->pdata->cable_check_type &
+		SEC_BATTERY_CABLE_CHECK_POLLING) {
+		if (sec_bat_get_cable_type(battery,
+			battery->pdata->cable_source_type)) {
+			wake_lock(&battery->cable_wake_lock);
+			queue_delayed_work_on(0, battery->monitor_wqueue,
+					   &battery->cable_work, 0);
+		}
+	}
+	return true;
+}
+
+static int sec_bat_ovp_uvlo_by_psy(struct sec_battery_info *battery)
+{
+	char *psy_name;
+	union power_supply_propval value;
+
+	value.intval = POWER_SUPPLY_HEALTH_GOOD;
+
+	switch (battery->pdata->ovp_uvlo_check_type) {
+	case SEC_BATTERY_OVP_UVLO_PMICPOLLING:
+		psy_name = battery->pdata->pmic_name;
+		break;
+	case SEC_BATTERY_OVP_UVLO_CHGPOLLING:
+		psy_name = battery->pdata->charger_name;
+		break;
+	default:
+		dev_err(battery->dev,
+			"%s: Invalid OVP/UVLO Check Type\n", __func__);
+		goto ovp_uvlo_check_error;
+		break;
+	}
+
+	psy_do_property(psy_name, get,
+		POWER_SUPPLY_PROP_HEALTH, value);
+
+ovp_uvlo_check_error:
+	return value.intval;
+}
+
+static bool sec_bat_ovp_uvlo_result(
+		struct sec_battery_info *battery, int health)
+{
+	if (battery->health != health) {
+		battery->health = health;
+		switch (health) {
+		case POWER_SUPPLY_HEALTH_GOOD:
+			dev_info(battery->dev, "%s: Safe voltage\n", __func__);
+			dev_info(battery->dev, "%s: is_recharging : %d\n", __func__, battery->is_recharging);
+			sec_bat_set_charging_status(battery,
+					POWER_SUPPLY_STATUS_CHARGING);
+			battery->charging_mode = SEC_BATTERY_CHARGING_1ST;
+#if defined(CONFIG_BATTERY_SWELLING)
+			if (!battery->swelling_mode)
+#endif
+			sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING);
+			battery->health_check_count = 0;
+			break;
+		case POWER_SUPPLY_HEALTH_OVERVOLTAGE:
+		case POWER_SUPPLY_HEALTH_UNDERVOLTAGE:
+			dev_info(battery->dev,
+				"%s: Unsafe voltage (%d)\n",
+				__func__, health);
+			sec_bat_set_charging_status(battery,
+					POWER_SUPPLY_STATUS_NOT_CHARGING);
+			sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING_OFF);
+			battery->charging_mode = SEC_BATTERY_CHARGING_NONE;
+			battery->is_recharging = false;
+			battery->health_check_count = DEFAULT_HEALTH_CHECK_COUNT;
+			/* Take the wakelock during 10 seconds
+			   when over-voltage status is detected	 */
+			wake_lock_timeout(&battery->vbus_wake_lock, HZ * 10);
+			break;
+		}
+		power_supply_changed(&battery->psy_bat);
+		return true;
+	}
+
+	return false;
+}
+
+static bool sec_bat_ovp_uvlo(struct sec_battery_info *battery)
+{
+	int health;
+
+	if (battery->factory_mode || battery->is_jig_on || battery->wdt_kick_disable) {
+		dev_dbg(battery->dev,
+			"%s: No need to check in factory mode\n",
+			__func__);
+		return false;
+	} else if ((battery->status == POWER_SUPPLY_STATUS_FULL) &&
+		   (battery->charging_mode == SEC_BATTERY_CHARGING_NONE)) {
+		dev_dbg(battery->dev, "%s: No need to check in Full status", __func__);
+		return false;
+	}
+
+	if (battery->health != POWER_SUPPLY_HEALTH_GOOD &&
+		battery->health != POWER_SUPPLY_HEALTH_OVERVOLTAGE &&
+		battery->health != POWER_SUPPLY_HEALTH_UNDERVOLTAGE) {
+		dev_dbg(battery->dev, "%s: No need to check\n", __func__);
+		return false;
+	}
+
+	health = battery->health;
+
+	switch (battery->pdata->ovp_uvlo_check_type) {
+	case SEC_BATTERY_OVP_UVLO_CALLBACK:
+		if (battery->pdata->ovp_uvlo_callback)
+			health = battery->pdata->ovp_uvlo_callback();
+		break;
+	case SEC_BATTERY_OVP_UVLO_PMICPOLLING:
+	case SEC_BATTERY_OVP_UVLO_CHGPOLLING:
+		health = sec_bat_ovp_uvlo_by_psy(battery);
+		break;
+	case SEC_BATTERY_OVP_UVLO_PMICINT:
+	case SEC_BATTERY_OVP_UVLO_CHGINT:
+		/* nothing for interrupt check */
+	default:
+		break;
+	}
+
+	return sec_bat_ovp_uvlo_result(battery, health);
+}
+
+static bool sec_bat_check_recharge(struct sec_battery_info *battery)
+{
+#if defined(CONFIG_BATTERY_SWELLING)
+	if (battery->swelling_mode == SWELLING_MODE_CHARGING ||
+		battery->swelling_mode == SWELLING_MODE_FULL) {
+		pr_info("%s: Skip normal recharge check routine for swelling mode\n",
+			__func__);
+		return false;
+	}
+#endif
+	if ((battery->status == POWER_SUPPLY_STATUS_CHARGING) &&
+			(battery->pdata->full_condition_type &
+			 SEC_BATTERY_FULL_CONDITION_NOTIMEFULL) &&
+			(battery->charging_mode == SEC_BATTERY_CHARGING_NONE)) {
+		dev_info(battery->dev,
+				"%s: Re-charging by NOTIMEFULL (%d)\n",
+				__func__, battery->capacity);
+		goto check_recharge_check_count;
+	}
+
+	if (battery->status == POWER_SUPPLY_STATUS_FULL &&
+			battery->charging_mode == SEC_BATTERY_CHARGING_NONE) {
+		int recharging_voltage = battery->pdata->recharge_condition_vcell;
+		if ((battery->current_event & SEC_BAT_CURRENT_EVENT_LOW_TEMP)
+			&& (battery->pdata->swelling_low_temp_2step_mode)) {
+			recharging_voltage = battery->pdata->chg_float_voltage - 150; // float voltage - 150mV
+			dev_info(battery->dev, "%s: recharging voltage changed by low temp(%d)\n",
+					__func__, recharging_voltage);
+		}
+
+		if ((battery->pdata->recharge_condition_type &
+					SEC_BATTERY_RECHARGE_CONDITION_SOC) &&
+				(battery->capacity <=
+				 battery->pdata->recharge_condition_soc)) {
+			battery->expired_time = battery->pdata->recharging_expired_time;
+			battery->prev_safety_time = 0;
+			dev_info(battery->dev,
+					"%s: Re-charging by SOC (%d)\n",
+					__func__, battery->capacity);
+			goto check_recharge_check_count;
+		}
+
+		if ((battery->pdata->recharge_condition_type &
+					SEC_BATTERY_RECHARGE_CONDITION_AVGVCELL) &&
+				 (battery->voltage_avg <= recharging_voltage)) {
+			battery->expired_time = battery->pdata->recharging_expired_time;
+			battery->prev_safety_time = 0;
+			dev_info(battery->dev,
+					"%s: Re-charging by average VCELL (%d)\n",
+					__func__, battery->voltage_avg);
+			goto check_recharge_check_count;
+		}
+
+		if ((battery->pdata->recharge_condition_type &
+					SEC_BATTERY_RECHARGE_CONDITION_VCELL) &&
+				 (battery->voltage_now <= recharging_voltage)) {
+			battery->expired_time = battery->pdata->recharging_expired_time;
+			battery->prev_safety_time = 0;
+			dev_info(battery->dev,
+					"%s: Re-charging by VCELL (%d)\n",
+					__func__, battery->voltage_now);
+			goto check_recharge_check_count;
+		}
+	}
+
+	battery->recharge_check_cnt = 0;
+	return false;
+
+check_recharge_check_count:
+	if (battery->recharge_check_cnt <
+		battery->pdata->recharge_check_count)
+		battery->recharge_check_cnt++;
+	dev_dbg(battery->dev,
+		"%s: recharge count = %d\n",
+		__func__, battery->recharge_check_cnt);
+
+	if (battery->recharge_check_cnt >=
+		battery->pdata->recharge_check_count)
+		return true;
+	else
+		return false;
+}
+
+static bool sec_bat_voltage_check(struct sec_battery_info *battery)
+{
+	union power_supply_propval value;
+
+	if (battery->status == POWER_SUPPLY_STATUS_DISCHARGING) {
+		dev_dbg(battery->dev,
+			"%s: Charging Disabled\n", __func__);
+		return true;
+	}
+
+	/* OVP/UVLO check */
+	if (sec_bat_ovp_uvlo(battery)) {
+		if (battery->pdata->ovp_uvlo_result_callback)
+			battery->pdata->
+				ovp_uvlo_result_callback(battery->health);
+		return false;
+	}
+
+	if ((battery->status == POWER_SUPPLY_STATUS_FULL) &&
+#if defined(CONFIG_BATTERY_SWELLING)
+	    (battery->charging_mode == SEC_BATTERY_CHARGING_2ND ||
+	     battery->is_recharging || battery->swelling_mode)) {
+#else
+		(battery->charging_mode == SEC_BATTERY_CHARGING_2ND ||
+		 battery->is_recharging)) {
+#endif
+		value.intval = 0;
+		psy_do_property(battery->pdata->fuelgauge_name, get,
+			POWER_SUPPLY_PROP_CAPACITY, value);
+		if (value.intval <
+			battery->pdata->full_condition_soc &&
+				battery->voltage_now <
+				(battery->pdata->recharge_condition_vcell - 50)) {
+			sec_bat_set_charging_status(battery,
+					POWER_SUPPLY_STATUS_CHARGING);
+			battery->voltage_now = 1080;
+			battery->voltage_avg = 1080;
+			power_supply_changed(&battery->psy_bat);
+			dev_info(battery->dev,
+				"%s: battery status full -> charging, RepSOC(%d)\n", __func__, value.intval);
+			return false;
+		}
+	}
+
+	/* Re-Charging check */
+	if (sec_bat_check_recharge(battery)) {
+		if (battery->pdata->full_check_type !=
+			SEC_BATTERY_FULLCHARGED_NONE)
+			battery->charging_mode = SEC_BATTERY_CHARGING_1ST;
+		else
+			battery->charging_mode = SEC_BATTERY_CHARGING_2ND;
+		battery->is_recharging = true;
+#if defined(CONFIG_BATTERY_SWELLING)
+		if (!battery->swelling_mode)
+#endif
+		sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING);
+		sec_bat_set_charging_current(battery);
+		return false;
+	}
+
+	return true;
+}
+
+static bool sec_bat_get_temperature_by_adc(
+				struct sec_battery_info *battery,
+				enum sec_battery_adc_channel channel,
+				union power_supply_propval *value)
+{
+	int temp = 0;
+	int temp_adc;
+	int low = 0;
+	int high = 0;
+	int mid = 0;
+	const sec_bat_adc_table_data_t *temp_adc_table;
+	unsigned int temp_adc_table_size;
+
+	temp_adc = sec_bat_get_adc_value(battery, channel);
+	if (temp_adc < 0)
+		return true;
+
+	switch (channel) {
+	case SEC_BAT_ADC_CHANNEL_TEMP:
+		temp_adc_table = battery->pdata->temp_adc_table;
+		temp_adc_table_size =
+			battery->pdata->temp_adc_table_size;
+		battery->temp_adc = temp_adc;
+		break;
+	case SEC_BAT_ADC_CHANNEL_TEMP_AMBIENT:
+		temp_adc_table = battery->pdata->temp_amb_adc_table;
+		temp_adc_table_size =
+			battery->pdata->temp_amb_adc_table_size;
+		battery->temp_ambient_adc = temp_adc;
+		break;
+	case SEC_BAT_ADC_CHANNEL_CHG_TEMP:
+		temp_adc_table = battery->pdata->chg_temp_adc_table;
+		temp_adc_table_size =
+			battery->pdata->chg_temp_adc_table_size;
+		battery->chg_temp_adc = temp_adc;
+		break;
+	case SEC_BAT_ADC_CHANNEL_WPC_TEMP:
+		temp_adc_table = battery->pdata->wpc_temp_adc_table;
+		temp_adc_table_size =
+			battery->pdata->wpc_temp_adc_table_size;
+		battery->wpc_temp_adc = temp_adc;
+		break;
+	case SEC_BAT_ADC_CHANNEL_SLAVE_CHG_TEMP:
+		temp_adc_table = battery->pdata->slave_chg_temp_adc_table;
+		temp_adc_table_size =
+			battery->pdata->slave_chg_temp_adc_table_size;
+		battery->slave_chg_temp_adc = temp_adc;
+		break;
+	default:
+		dev_err(battery->dev,
+			"%s: Invalid Property\n", __func__);
+		return false;
+	}
+
+	if (temp_adc_table[0].adc >= temp_adc) {
+		temp = temp_adc_table[0].data;
+		goto temp_by_adc_goto;
+	} else if (temp_adc_table[temp_adc_table_size-1].adc <= temp_adc) {
+		temp = temp_adc_table[temp_adc_table_size-1].data;
+		goto temp_by_adc_goto;
+	}
+
+	high = temp_adc_table_size - 1;
+
+	while (low <= high) {
+		mid = (low + high) / 2;
+		if (temp_adc_table[mid].adc > temp_adc)
+			high = mid - 1;
+		else if (temp_adc_table[mid].adc < temp_adc)
+			low = mid + 1;
+		else {
+			temp = temp_adc_table[mid].data;
+			goto temp_by_adc_goto;
+		}
+	}
+
+	temp = temp_adc_table[high].data;
+	temp += ((temp_adc_table[low].data - temp_adc_table[high].data) *
+		 (temp_adc - temp_adc_table[high].adc)) /
+		(temp_adc_table[low].adc - temp_adc_table[high].adc);
+
+temp_by_adc_goto:
+	value->intval = temp;
+
+	dev_dbg(battery->dev,
+		"%s: Temp(%d), Temp-ADC(%d)\n",
+		__func__, temp, temp_adc);
+
+	return true;
+}
+
+static bool sec_bat_temperature(
+				struct sec_battery_info *battery)
+{
+	bool ret;
+	ret = true;
+
+	if (lpcharge) {
+		battery->temp_highlimit_threshold =
+			battery->pdata->temp_highlimit_threshold_lpm;
+		battery->temp_highlimit_recovery =
+			battery->pdata->temp_highlimit_recovery_lpm;
+		battery->temp_high_threshold =
+			battery->pdata->temp_high_threshold_lpm;
+		battery->temp_high_recovery =
+			battery->pdata->temp_high_recovery_lpm;
+		battery->temp_low_recovery =
+			battery->pdata->temp_low_recovery_lpm;
+		battery->temp_low_threshold =
+			battery->pdata->temp_low_threshold_lpm;
+	} else {
+		battery->temp_highlimit_threshold =
+			battery->pdata->temp_highlimit_threshold_normal;
+		battery->temp_highlimit_recovery =
+			battery->pdata->temp_highlimit_recovery_normal;
+		battery->temp_high_threshold =
+			battery->pdata->temp_high_threshold_normal;
+		battery->temp_high_recovery =
+			battery->pdata->temp_high_recovery_normal;
+		battery->temp_low_recovery =
+			battery->pdata->temp_low_recovery_normal;
+		battery->temp_low_threshold =
+			battery->pdata->temp_low_threshold_normal;
+	}
+
+	dev_info(battery->dev,
+		"%s: HLT(%d) HLR(%d) HT(%d), HR(%d), LT(%d), LR(%d)\n",
+		__func__, battery->temp_highlimit_threshold,
+		battery->temp_highlimit_recovery,
+		battery->temp_high_threshold,
+		battery->temp_high_recovery,
+		battery->temp_low_threshold,
+		battery->temp_low_recovery);
+	return ret;
+}
+
+#if defined(CONFIG_BATTERY_SWELLING)
+static void sec_bat_swelling_check(struct sec_battery_info *battery, int temperature)
+{
+	union power_supply_propval val = {0, };
+	int swelling_rechg_voltage = battery->pdata->swelling_high_rechg_voltage;
+	int float_voltage = battery->pdata->swelling_drop_float_voltage;
+	bool en_swelling = false, en_rechg = false;
+
+	psy_do_property(battery->pdata->charger_name, get,
+			POWER_SUPPLY_PROP_VOLTAGE_MAX, val);
+
+		pr_info("%s: status(%d), swell_mode(%d:%d:%d), cv(0x%02x)mV, temp(%d)\n",
+		__func__, battery->status, battery->swelling_mode,
+		battery->charging_block, (battery->current_event & SEC_BAT_CURRENT_EVENT_LOW_TEMP),
+		val.intval, temperature);
+
+	/* swelling_mode
+		under voltage over voltage, battery missing */
+	if ((battery->status == POWER_SUPPLY_STATUS_DISCHARGING) ||\
+		(battery->status == POWER_SUPPLY_STATUS_NOT_CHARGING)) {
+		pr_debug("%s: DISCHARGING or NOT-CHARGING. stop swelling mode\n", __func__);
+		battery->swelling_mode = SWELLING_MODE_NONE;
+		battery->current_event &=
+			~(SEC_BAT_CURRENT_EVENT_LOW_TEMP_SWELLING | SEC_BAT_CURRENT_EVENT_LOW_TEMP | SEC_BAT_CURRENT_EVENT_HIGH_TEMP_SWELLING);
+		goto skip_swelling_chek;
+	}
+
+	if (!battery->swelling_mode) {
+		if (((temperature >= battery->pdata->swelling_high_temp_block) ||
+			(temperature <= battery->pdata->swelling_low_temp_block_2nd)) &&
+			battery->pdata->temp_check_type) {
+			pr_info("%s: swelling mode start. stop charging\n", __func__);
+			battery->swelling_mode = SWELLING_MODE_CHARGING;
+			battery->swelling_full_check_cnt = 0;
+			sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING_OFF);
+			en_swelling = true;
+		} else if ((temperature <= battery->pdata->swelling_low_temp_block_1st) &&
+			!(battery->current_event & SEC_BAT_CURRENT_EVENT_LOW_TEMP)) {
+			pr_info("%s: low temperature reduce current\n", __func__);
+			battery->current_event |= SEC_BAT_CURRENT_EVENT_LOW_TEMP ;
+			sec_bat_set_charging_current(battery);
+		} else if ((temperature >= battery->pdata->swelling_low_temp_recov_1st) &&
+			(battery->current_event & SEC_BAT_CURRENT_EVENT_LOW_TEMP)) {
+			pr_info("%s: normal temperature temperature recover current\n", __func__);
+			battery->current_event &= ~SEC_BAT_CURRENT_EVENT_LOW_TEMP;
+			sec_bat_set_charging_current(battery);
+		}
+	}
+
+	if (!battery->voltage_now)
+		return;
+
+	if (battery->swelling_mode) {
+		if (temperature <= battery->pdata->swelling_low_temp_recov_2nd) {
+			swelling_rechg_voltage = battery->pdata->swelling_low_rechg_voltage;
+		}
+
+		if (val.intval != float_voltage) {
+			pr_info("%s: float voltage change(%d -> %d)\n", __func__, val.intval, float_voltage);
+			if (!battery->charging_block) {
+				sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING_OFF);
+				val.intval = float_voltage;
+				psy_do_property(battery->pdata->charger_name, set,
+						POWER_SUPPLY_PROP_VOLTAGE_MAX, val);
+				sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING);
+			} else {
+				val.intval = float_voltage;
+				psy_do_property(battery->pdata->charger_name, set,
+						POWER_SUPPLY_PROP_VOLTAGE_MAX, val);
+			}
+		}
+
+		if ((temperature <= battery->pdata->swelling_high_temp_recov) &&
+		    (temperature >= battery->pdata->swelling_low_temp_recov_2nd)) {
+			pr_info("%s: swelling mode end. restart charging\n", __func__);
+			battery->swelling_mode = SWELLING_MODE_NONE;
+			battery->charging_mode = SEC_BATTERY_CHARGING_1ST;
+			battery->current_event &=
+				~(SEC_BAT_CURRENT_EVENT_LOW_TEMP_SWELLING | SEC_BAT_CURRENT_EVENT_LOW_TEMP | SEC_BAT_CURRENT_EVENT_HIGH_TEMP_SWELLING);
+			sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING);
+			/* restore 4.4V float voltage */
+			val.intval = battery->pdata->swelling_normal_float_voltage;
+			psy_do_property(battery->pdata->charger_name, set,
+					POWER_SUPPLY_PROP_VOLTAGE_MAX, val);
+			/* restore charging current */
+			if (temperature <= battery->pdata->swelling_low_temp_block_1st) {
+					battery->current_event |= SEC_BAT_CURRENT_EVENT_LOW_TEMP;
+			}
+			sec_bat_set_charging_current(battery);
+		} else if (battery->voltage_now < swelling_rechg_voltage &&
+			battery->charging_block) {
+			pr_info("%s: swelling mode recharging start. Vbatt(%d)\n",
+				__func__, battery->voltage_now);
+			battery->charging_mode = SEC_BATTERY_CHARGING_1ST;
+			en_rechg = true;
+			/* change 4.20V float voltage */
+			val.intval = battery->pdata->swelling_drop_float_voltage;
+			psy_do_property(battery->pdata->charger_name, set,
+					POWER_SUPPLY_PROP_VOLTAGE_MAX, val);
+			/* set charging enable */
+			sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING);
+			if (temperature <= battery->pdata->swelling_low_temp_recov_2nd) {
+				pr_info("%s: swelling mode reduce charging current(LOW-temp:%d)\n",
+					__func__, temperature);
+				battery->current_event |= SEC_BAT_CURRENT_EVENT_LOW_TEMP_SWELLING;
+				sec_bat_set_charging_current(battery);
+			} else if (temperature >= battery->pdata->swelling_high_temp_recov) {
+				pr_info("%s: swelling mode reduce charging current(HIGH-temp:%d)\n",
+					__func__, temperature);
+				battery->current_event |= SEC_BAT_CURRENT_EVENT_HIGH_TEMP_SWELLING;
+				sec_bat_set_charging_current(battery);
+			}
+		}
+	}
+	if (en_swelling && !en_rechg) {
+		pr_info("%s : SAFETY TIME RESET (SWELLING MODE CHARING STOP!)\n", __func__);
+		battery->expired_time = battery->pdata->expired_time;
+		battery->prev_safety_time = 0;
+	}
+skip_swelling_chek:
+	dev_dbg(battery->dev, "%s end\n", __func__);
+}
+#endif
+
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+static bool sec_bat_set_aging_step(struct sec_battery_info *battery, int step)
+{
+	union power_supply_propval value;
+
+	if (battery->pdata->num_age_step <= 0 || step < 0 || step >= battery->pdata->num_age_step) {
+		pr_info("%s: [AGE] abnormal age step : %d/%d\n",
+			__func__, step, battery->pdata->num_age_step-1);
+		return false;
+	}
+
+	battery->pdata->age_step = step;
+
+	/* float voltage */
+	battery->pdata->chg_float_voltage =
+		battery->pdata->age_data[battery->pdata->age_step].float_voltage;
+	battery->pdata->swelling_normal_float_voltage =
+		battery->pdata->chg_float_voltage;
+	if (!battery->swelling_mode) {
+		value.intval = battery->pdata->chg_float_voltage;
+		psy_do_property(battery->pdata->charger_name, set,
+			POWER_SUPPLY_PROP_VOLTAGE_MAX, value);
+	}
+
+	/* full/recharge condition */
+	battery->pdata->recharge_condition_vcell =
+		battery->pdata->age_data[battery->pdata->age_step].recharge_condition_vcell;
+	battery->pdata->full_condition_soc =
+		battery->pdata->age_data[battery->pdata->age_step].full_condition_soc;
+	battery->pdata->full_condition_vcell =
+		battery->pdata->age_data[battery->pdata->age_step].full_condition_vcell;
+
+#if defined(CONFIG_FUELGAUGE_S2MU005)
+	value.intval = battery->pdata->age_step;
+	psy_do_property(battery->pdata->fuelgauge_name, set,
+		POWER_SUPPLY_EXT_PROP_UPDATE_BATTERY_DATA, value);
+#else
+	value.intval = battery->pdata->full_condition_soc;
+	psy_do_property(battery->pdata->fuelgauge_name, set,
+		POWER_SUPPLY_PROP_CAPACITY_LEVEL, value);
+#endif
+	dev_info(battery->dev,
+		 "%s: Step(%d/%d), Cycle(%d), float_v(%d), r_v(%d), f_s(%d), f_vl(%d)\n",
+		 __func__,
+		 battery->pdata->age_step, battery->pdata->num_age_step-1, battery->batt_cycle,
+		 battery->pdata->chg_float_voltage,
+		 battery->pdata->recharge_condition_vcell,
+		 battery->pdata->full_condition_soc,
+		 battery->pdata->full_condition_vcell);
+
+	return true;
+}
+
+static void sec_bat_aging_check(struct sec_battery_info *battery)
+{
+	int prev_step = battery->pdata->age_step;
+	int calc_step = -1;
+	bool ret;
+
+	if (battery->pdata->num_age_step <= 0 || battery->batt_cycle < 0)
+		return;
+
+	if (battery->temperature < 50) {
+		pr_info("%s: [AGE] skip (temperature:%d)\n", __func__, battery->temperature);
+		return;
+	}
+
+	for (calc_step = battery->pdata->num_age_step - 1; calc_step >= 0; calc_step--) {
+		if (battery->pdata->age_data[calc_step].cycle <= battery->batt_cycle)
+			break;
+	}
+
+	dev_info(battery->dev,
+		"%s: [Long life] prev_step = %d, calc_step = %d\n",  __func__, prev_step, calc_step);
+
+	if (calc_step == prev_step)
+		return;
+
+	ret = sec_bat_set_aging_step(battery, calc_step);
+	dev_info(battery->dev,
+		"%s: %s change step (%d->%d), Cycle(%d)\n",
+		__func__, ret ? "Succeed in" : "Fail to",
+		prev_step, battery->pdata->age_step, battery->batt_cycle);
+}
+#endif
+
+static bool sec_bat_temperature_check(
+				struct sec_battery_info *battery)
+{
+	int temp_value;
+	int pre_health;
+	union power_supply_propval val = {0, };
+
+	if (battery->status == POWER_SUPPLY_STATUS_DISCHARGING) {
+		battery->health_change = false;
+		dev_dbg(battery->dev,
+			"%s: Charging Disabled\n", __func__);
+		return true;
+	}
+
+	if (battery->health != POWER_SUPPLY_HEALTH_GOOD &&
+		battery->health != POWER_SUPPLY_HEALTH_OVERHEAT &&
+		battery->health != POWER_SUPPLY_HEALTH_COLD &&
+		battery->health != POWER_SUPPLY_HEALTH_OVERHEATLIMIT) {
+		dev_dbg(battery->dev, "%s: No need to check\n", __func__);
+		return false;
+	}
+
+	sec_bat_temperature(battery);
+
+	switch (battery->pdata->temp_check_type) {
+	case SEC_BATTERY_TEMP_CHECK_ADC:
+		temp_value = battery->temp_adc;
+		break;
+	case SEC_BATTERY_TEMP_CHECK_TEMP:
+		temp_value = battery->temperature;
+		break;
+	default:
+		dev_err(battery->dev,
+			"%s: Invalid Temp Check Type\n", __func__);
+		return true;
+	}
+	pre_health = battery->health;
+
+	if (temp_value >= battery->temp_highlimit_threshold) {
+		if (battery->health != POWER_SUPPLY_HEALTH_OVERHEATLIMIT) {
+			if (battery->temp_highlimit_cnt <
+			    battery->pdata->temp_check_count) {
+				battery->temp_highlimit_cnt++;
+				battery->temp_high_cnt = 0;
+				battery->temp_low_cnt = 0;
+				battery->temp_recover_cnt = 0;
+			}
+			dev_dbg(battery->dev,
+				"%s: highlimit count = %d\n",
+				__func__, battery->temp_highlimit_cnt);
+		}
+	} else if (temp_value >= battery->temp_high_threshold) {
+		if (battery->health == POWER_SUPPLY_HEALTH_OVERHEATLIMIT) {
+			if (temp_value <= battery->temp_highlimit_recovery) {
+				if (battery->temp_recover_cnt <
+				    battery->pdata->temp_check_count) {
+					battery->temp_recover_cnt++;
+					battery->temp_highlimit_cnt = 0;
+					battery->temp_high_cnt = 0;
+					battery->temp_low_cnt = 0;
+				}
+				dev_dbg(battery->dev,
+					"%s: recovery count = %d\n",
+					__func__, battery->temp_recover_cnt);
+			}
+		} else if (battery->health != POWER_SUPPLY_HEALTH_OVERHEAT) {
+			if (battery->temp_high_cnt <
+			    battery->pdata->temp_check_count) {
+				battery->temp_high_cnt++;
+				battery->temp_highlimit_cnt = 0;
+				battery->temp_low_cnt = 0;
+				battery->temp_recover_cnt = 0;
+			}
+			dev_dbg(battery->dev,
+				"%s: high count = %d\n",
+				__func__, battery->temp_high_cnt);
+		}
+	} else if ((temp_value <= battery->temp_high_recovery) &&
+				(temp_value >= battery->temp_low_recovery)) {
+		if (battery->health == POWER_SUPPLY_HEALTH_OVERHEAT ||
+		    battery->health == POWER_SUPPLY_HEALTH_OVERHEATLIMIT ||
+		    battery->health == POWER_SUPPLY_HEALTH_COLD) {
+			if (battery->temp_recover_cnt <
+			    battery->pdata->temp_check_count) {
+				battery->temp_recover_cnt++;
+				battery->temp_highlimit_cnt = 0;
+				battery->temp_high_cnt = 0;
+				battery->temp_low_cnt = 0;
+			}
+			dev_dbg(battery->dev,
+				"%s: recovery count = %d\n",
+				__func__, battery->temp_recover_cnt);
+		}
+	} else if (temp_value <= battery->temp_low_threshold) {
+		if (battery->health != POWER_SUPPLY_HEALTH_COLD) {
+			if (battery->temp_low_cnt <
+			    battery->pdata->temp_check_count) {
+				battery->temp_low_cnt++;
+				battery->temp_highlimit_cnt = 0;
+				battery->temp_high_cnt = 0;
+				battery->temp_recover_cnt = 0;
+			}
+			dev_dbg(battery->dev,
+				"%s: low count = %d\n",
+				__func__, battery->temp_low_cnt);
+		}
+	} else {
+		battery->temp_highlimit_cnt = 0;
+		battery->temp_high_cnt = 0;
+		battery->temp_low_cnt = 0;
+		battery->temp_recover_cnt = 0;
+	}
+
+	if (battery->temp_highlimit_cnt >=
+	    battery->pdata->temp_check_count) {
+		battery->health = POWER_SUPPLY_HEALTH_OVERHEATLIMIT;
+		battery->temp_highlimit_cnt = 0;
+	} else if (battery->temp_high_cnt >=
+		battery->pdata->temp_check_count) {
+		battery->health = POWER_SUPPLY_HEALTH_OVERHEAT;
+		battery->temp_high_cnt = 0;
+	} else if (battery->temp_low_cnt >=
+		battery->pdata->temp_check_count) {
+		battery->health = POWER_SUPPLY_HEALTH_COLD;
+		battery->temp_low_cnt = 0;
+	} else if (battery->temp_recover_cnt >=
+		 battery->pdata->temp_check_count) {
+		if (battery->health == POWER_SUPPLY_HEALTH_OVERHEATLIMIT) {
+			battery->health = POWER_SUPPLY_HEALTH_OVERHEAT;
+		} else {
+#if defined(CONFIG_BATTERY_SWELLING_SELF_DISCHARGING) || defined(CONFIG_SW_SELF_DISCHARGING)
+			//union power_supply_propval value;
+
+			psy_do_property(battery->pdata->charger_name, get,
+					POWER_SUPPLY_PROP_VOLTAGE_MAX, val);
+			if (val.intval <= battery->pdata->swelling_normal_float_voltage) {
+				val.intval = battery->pdata->swelling_normal_float_voltage;
+				psy_do_property(battery->pdata->charger_name, set,
+						POWER_SUPPLY_PROP_VOLTAGE_MAX, val);
+			}
+#endif
+			battery->health = POWER_SUPPLY_HEALTH_GOOD;
+		}
+		battery->temp_recover_cnt = 0;
+	}
+	if (pre_health != battery->health) {
+		battery->health_change = true;
+		dev_info(battery->dev, "%s, health_change true\n", __func__);
+	} else {
+		battery->health_change = false;
+	}
+
+	if ((battery->health == POWER_SUPPLY_HEALTH_OVERHEAT) ||
+		(battery->health == POWER_SUPPLY_HEALTH_COLD) ||
+		(battery->health == POWER_SUPPLY_HEALTH_OVERHEATLIMIT)) {
+		if (battery->status != POWER_SUPPLY_STATUS_NOT_CHARGING) {
+#if defined(CONFIG_BATTERY_SWELLING_SELF_DISCHARGING) || defined(CONFIG_SW_SELF_DISCHARGING)
+			if ((battery->health == POWER_SUPPLY_HEALTH_OVERHEAT) ||
+				(battery->health == POWER_SUPPLY_HEALTH_OVERHEATLIMIT)) {
+				//union power_supply_propval val;
+				/* change 4.20V float voltage */
+				val.intval = battery->pdata->swelling_drop_float_voltage;
+				psy_do_property(battery->pdata->charger_name, set,
+						POWER_SUPPLY_PROP_VOLTAGE_MAX, val);
+			}
+#endif
+			if (battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS ||
+				battery->cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS ||
+				battery->cable_type == POWER_SUPPLY_TYPE_PMA_WIRELESS ||
+				battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK ||
+				battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK_TA) {
+				//union power_supply_propval val;
+				val.intval = battery->health;
+				psy_do_property(battery->pdata->wireless_charger_name, set,
+						POWER_SUPPLY_PROP_HEALTH, val);
+			}
+			dev_info(battery->dev,
+				"%s: Unsafe Temperature\n", __func__);
+			sec_bat_set_charging_status(battery,
+					POWER_SUPPLY_STATUS_NOT_CHARGING);
+			if (battery->health == POWER_SUPPLY_HEALTH_OVERHEATLIMIT) {
+				/* change charging current to battery (default 0mA) */
+				sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_BUCK_OFF);
+			} else {
+				sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING_OFF);
+			}
+
+			psy_do_property(battery->pdata->charger_name, get,
+					POWER_SUPPLY_PROP_VOLTAGE_MAX, val);
+			if (val.intval != battery->pdata->swelling_drop_float_voltage) {
+				val.intval = battery->pdata->swelling_drop_float_voltage;
+				psy_do_property(battery->pdata->charger_name, set,
+						POWER_SUPPLY_PROP_VOLTAGE_MAX, val);
+
+			}
+			return false;
+		}
+	} else {
+		/* if recovered from not charging */
+		if ((battery->health == POWER_SUPPLY_HEALTH_GOOD) &&
+			(battery->status ==
+			 POWER_SUPPLY_STATUS_NOT_CHARGING)) {
+			dev_info(battery->dev,
+					"%s: Safe Temperature\n", __func__);
+			if (battery->capacity >= 100)
+				sec_bat_set_charging_status(battery,
+						POWER_SUPPLY_STATUS_FULL);
+			else {	/* Normal Charging */
+				sec_bat_set_charging_status(battery,
+						POWER_SUPPLY_STATUS_CHARGING);
+				}
+#if defined(CONFIG_BATTERY_SWELLING)
+			if ((temp_value >= battery->pdata->swelling_high_temp_recov) ||
+				(temp_value <= battery->pdata->swelling_low_temp_recov_2nd)) {
+				pr_info("%s: swelling mode start. stop charging\n", __func__);
+				battery->swelling_mode = SWELLING_MODE_CHARGING;
+				battery->swelling_full_check_cnt = 0;
+				sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING_OFF);
+			} else {
+				//union power_supply_propval val = {0, };
+				/* restore float voltage */
+				val.intval = battery->pdata->swelling_normal_float_voltage;
+				psy_do_property(battery->pdata->charger_name, set,
+						POWER_SUPPLY_PROP_VOLTAGE_MAX, val);
+				/* turn on charger by cable type */
+				sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING);
+			}
+#else
+			/* turn on charger by cable type */
+			sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING);
+#endif
+			return false;
+		}
+	}
+	return true;
+}
+
+#if !defined(CONFIG_SEC_FACTORY)
+static void sec_bat_chg_temperature_check(
+	struct sec_battery_info *battery)
+{
+	struct timespec ts;
+	ktime_t current_time;
+
+	if (battery->skip_chg_temp_check || battery->pdata->slave_chg_temp_check || battery->skip_wpc_temp_check)
+		return;
+
+	if (battery->siop_level >= 100 && battery->pdata->chg_temp_check &&
+			((battery->cable_type == POWER_SUPPLY_TYPE_HV_MAINS) ||
+			 (battery->cable_type == POWER_SUPPLY_TYPE_HV_ERR) ||
+			 (battery->cable_type == POWER_SUPPLY_TYPE_HV_MAINS_12V))) {
+		union power_supply_propval value;
+		if ((battery->chg_limit == SEC_BATTERY_CHG_TEMP_NONE) &&
+				(battery->chg_temp > battery->pdata->chg_high_temp_1st)) {
+			battery->chg_limit = SEC_BATTERY_CHG_TEMP_HIGH_1ST;
+			if (battery->wired_input_current > battery->pdata->chg_charging_limit_current) {
+				value.intval = battery->pdata->chg_charging_limit_current;
+				psy_do_property(battery->pdata->charger_name, set,
+						POWER_SUPPLY_PROP_CURRENT_MAX, value);
+				battery->wired_input_current = value.intval;
+				dev_info(battery->dev,"%s: Chg current is reduced by Temp: %d\n",
+						__func__, battery->chg_temp);
+			}
+		} else if ((battery->chg_limit == SEC_BATTERY_CHG_TEMP_HIGH_1ST) &&
+				(battery->pre_chg_temp < battery->pdata->chg_high_temp_2nd) &&
+				(battery->chg_temp > battery->pdata->chg_high_temp_2nd)) {
+			battery->chg_limit = SEC_BATTERY_CHG_TEMP_HIGH_2ND;
+			if (battery->wired_input_current > battery->pdata->chg_charging_limit_current_2nd) {
+				value.intval = battery->pdata->chg_charging_limit_current_2nd;
+				psy_do_property(battery->pdata->charger_name, set,
+						POWER_SUPPLY_PROP_CURRENT_MAX, value);
+				battery->wired_input_current = value.intval;
+				dev_info(battery->dev,"%s: Chg current 2nd is reduced by Temp: %d\n",
+						__func__, battery->chg_temp);
+			}
+		} else if ((battery->chg_limit != SEC_BATTERY_CHG_TEMP_NONE) &&
+				(battery->chg_temp < battery->pdata->chg_high_temp_recovery)) {
+			battery->chg_limit = SEC_BATTERY_CHG_TEMP_NONE;
+			value.intval = battery->pdata->charging_current
+				[battery->cable_type].input_current_limit;
+			psy_do_property(battery->pdata->charger_name, set,
+					POWER_SUPPLY_PROP_CURRENT_MAX, value);
+			battery->wired_input_current = value.intval;
+			dev_info(battery->dev,"%s: Chg current is recovered by Temp: %d\n",
+					__func__, battery->chg_temp);
+		}
+	} else if (battery->siop_level >= 100 && battery->pdata->wpc_temp_check &&
+			(battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS ||
+			battery->cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS ||
+			battery->cable_type == POWER_SUPPLY_TYPE_PMA_WIRELESS ||
+			battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK ||
+			battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK_TA)) {
+		union power_supply_propval value;
+		
+		current_time = ktime_get_boottime();
+		ts = ktime_to_timespec(current_time);
+
+		if ((battery->chg_limit == SEC_BATTERY_CHG_TEMP_NONE) &&
+			(battery->wpc_temp > battery->pdata->wpc_high_temp)) {
+
+			battery->wpc_temp_mode = true;
+			battery->chg_limit = SEC_BATTERY_CHG_TEMP_HIGH_1ST;
+			if (battery->wc_heating_start_time == 0) {
+				if (ts.tv_sec < 1)
+					ts.tv_sec = 1;
+				battery->wc_heating_start_time = ts.tv_sec;
+			}
+			if (battery->wireless_input_current > battery->pdata->wpc_charging_limit_current) {
+				value.intval = battery->pdata->wpc_charging_limit_current;
+				psy_do_property(battery->pdata->charger_name, set,
+						POWER_SUPPLY_PROP_CURRENT_MAX, value);
+				battery->wireless_input_current = value.intval;
+				dev_info(battery->dev,"%s: WPC Chg current is reduced by Temp: %d\n",
+						__func__, battery->wpc_temp);
+			}
+		} else if ((battery->chg_limit != SEC_BATTERY_CHG_TEMP_NONE) && \
+			(battery->wc_heat_limit != SEC_BATTERY_WC_HEAT_HIGH) &&
+			(battery->wpc_temp < battery->pdata->wpc_high_temp_recovery)) { /* 1st recovery 41.4C */
+			battery->wpc_temp_mode = false;
+			battery->chg_limit = SEC_BATTERY_CHG_TEMP_NONE;
+			if (battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS && battery->wc_cv_mode)
+				value.intval = battery->pdata->wc_cv_current;
+ 			else
+				value.intval = battery->pdata->charging_current
+					[battery->cable_type].input_current_limit;
+			psy_do_property(battery->pdata->charger_name, set,
+					POWER_SUPPLY_PROP_CURRENT_MAX, value);
+			battery->wireless_input_current = value.intval;
+			dev_info(battery->dev,"%s: WPC Chg current is recovered by Temp: %d\n",
+					__func__, battery->wpc_temp);
+		} else if ((battery->chg_limit != SEC_BATTERY_CHG_TEMP_NONE) && \
+			(battery->wc_heat_limit == SEC_BATTERY_WC_HEAT_HIGH) &&
+			(battery->wpc_temp < battery->pdata->wpc_heat_temp_recovery)) { /* 2nd recovery 35.0'C */
+			battery->wc_heating_start_time = 0;
+			battery->wc_heating_passed_time = 0;
+			battery->wc_heat_limit = SEC_BATTERY_WC_HEAT_NONE;
+			battery->wpc_temp_mode = false;
+			battery->chg_limit = SEC_BATTERY_CHG_TEMP_NONE;
+			if (battery->cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS) {
+				value.intval = WIRELESS_VOUT_9V;
+				psy_do_property(battery->pdata->wireless_charger_name, set,
+					POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+			}
+			if (battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS && battery->wc_cv_mode)
+				value.intval = battery->pdata->wc_cv_current;
+ 			else
+				value.intval = battery->pdata->charging_current
+					[battery->cable_type].input_current_limit;
+			psy_do_property(battery->pdata->charger_name, set,
+					POWER_SUPPLY_PROP_CURRENT_MAX, value);
+			battery->wireless_input_current = value.intval;
+			dev_info(battery->dev,"%s: WPC Heat current is recovered by Temp: %d\n",
+					__func__, battery->wpc_temp);
+		}
+
+		if (battery->cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS &&
+			battery->pad_limit != SEC_BATTERY_WPC_TEMP_NONE) {
+
+			battery->pad_limit = SEC_BATTERY_WPC_TEMP_NONE;
+
+			value.intval = WIRELESS_VOUT_9V;
+			psy_do_property(battery->pdata->wireless_charger_name, set,
+				POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+
+			dev_info(battery->dev,"%s: RX voltage is recovered by Temp: %d, siop(%d)\n",
+					__func__, battery->wpc_temp, battery->siop_level);
+
+			value.intval = battery->pdata->wpc_charging_limit_current;
+			psy_do_property(battery->pdata->charger_name, set,
+					POWER_SUPPLY_PROP_CURRENT_MAX, value);
+			battery->wireless_input_current = value.intval;
+			dev_info(battery->dev,"%s: WPC Chg current is recovered by Temp: %d, siop(%d)\n",
+					__func__, battery->wpc_temp, battery->siop_level);
+		}
+	} else if (battery->siop_level < 100 && battery->pdata->wpc_temp_check &&
+			battery->cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS ) {
+		union power_supply_propval value;
+		battery->wc_heating_start_time = 0;
+		battery->wc_heating_passed_time = 0;
+		battery->wc_heat_limit = SEC_BATTERY_WC_HEAT_NONE;
+		if ((battery->pad_limit == SEC_BATTERY_WPC_TEMP_NONE) &&
+			(battery->wpc_temp > battery->pdata->wpc_lcd_on_high_temp)) {
+			battery->pad_limit = SEC_BATTERY_WPC_TEMP_HIGH;
+
+			if (battery->wireless_input_current > battery->pdata->wpc_hv_lcd_on_input_limit_current) {
+				value.intval = battery->pdata->wpc_hv_lcd_on_input_limit_current;
+				psy_do_property(battery->pdata->charger_name, set,
+						POWER_SUPPLY_PROP_CURRENT_MAX, value);
+				battery->wireless_input_current = value.intval;
+				dev_info(battery->dev,"%s: WPC Chg current is reduced by Temp: %d\n",
+						__func__, battery->wpc_temp);
+			}
+
+			if(battery->capacity < 95) {
+				value.intval = WIRELESS_VOUT_5V;
+				psy_do_property(battery->pdata->wireless_charger_name, set,
+						POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+			}
+
+			dev_info(battery->dev,"%s: RX voltage is reduced by Temp: %d\n",
+					__func__, battery->wpc_temp);
+		} else if ((battery->pad_limit != SEC_BATTERY_WPC_TEMP_NONE) &&
+			(battery->wpc_temp < battery->pdata->wpc_lcd_on_high_temp_rec)) {
+			battery->pad_limit = SEC_BATTERY_WPC_TEMP_NONE;
+
+			value.intval = WIRELESS_VOUT_9V;
+			psy_do_property(battery->pdata->wireless_charger_name, set,
+					POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+
+			dev_info(battery->dev,"%s: RX voltage is recovered by Temp: %d\n",
+					__func__, battery->wpc_temp);
+
+			value.intval = battery->pdata->siop_hv_wireless_input_limit_current;
+			psy_do_property(battery->pdata->charger_name, set,
+					POWER_SUPPLY_PROP_CURRENT_MAX, value);
+			battery->wireless_input_current = value.intval;
+			dev_info(battery->dev,"%s: WPC Chg current is recovered by Temp: %d\n",
+					__func__, battery->wpc_temp);
+		}
+	} else if (battery->chg_limit != SEC_BATTERY_CHG_TEMP_NONE) {
+		battery->chg_limit = SEC_BATTERY_CHG_TEMP_NONE;
+		battery->wpc_temp_mode = false;
+	} else if (battery->pad_limit != SEC_BATTERY_WPC_TEMP_NONE) {
+		battery->pad_limit = SEC_BATTERY_WPC_TEMP_NONE;
+	}
+}
+#endif
+
+static int sec_bat_get_inbat_vol_by_adc(struct sec_battery_info *battery)
+{
+	int inbat = 0;
+	int inbat_adc;
+	int low = 0;
+	int high = 0;
+	int mid = 0;
+	const sec_bat_adc_table_data_t *inbat_adc_table;
+	unsigned int inbat_adc_table_size;
+
+	if (!battery->pdata->inbat_adc_table) {
+		dev_err(battery->dev, "%s: not designed to read in-bat voltage\n", __func__);
+		return -1;
+	}
+
+	inbat_adc_table = battery->pdata->inbat_adc_table;
+	inbat_adc_table_size =
+		battery->pdata->inbat_adc_table_size;
+
+	inbat_adc = sec_bat_get_adc_value(battery, SEC_BAT_ADC_CHANNEL_INBAT_VOLTAGE);
+	if (inbat_adc <= 0)
+		return inbat_adc;
+	battery->inbat_adc = inbat_adc;
+
+	if (inbat_adc_table[0].adc <= inbat_adc) {
+		inbat = inbat_adc_table[0].data;
+		goto inbat_by_adc_goto;
+	} else if (inbat_adc_table[inbat_adc_table_size-1].adc >= inbat_adc) {
+		inbat = inbat_adc_table[inbat_adc_table_size-1].data;
+		goto inbat_by_adc_goto;
+	}
+
+	high = inbat_adc_table_size - 1;
+
+	while (low <= high) {
+		mid = (low + high) / 2;
+		if (inbat_adc_table[mid].adc < inbat_adc)
+			high = mid - 1;
+		else if (inbat_adc_table[mid].adc > inbat_adc)
+			low = mid + 1;
+		else {
+			inbat = inbat_adc_table[mid].data;
+			goto inbat_by_adc_goto;
+		}
+	}
+
+	inbat = inbat_adc_table[high].data;
+	inbat +=
+		((inbat_adc_table[low].data - inbat_adc_table[high].data) *
+		 (inbat_adc - inbat_adc_table[high].adc)) /
+		(inbat_adc_table[low].adc - inbat_adc_table[high].adc);
+
+	if (inbat < 0)
+		inbat = 0;
+
+inbat_by_adc_goto:
+	dev_info(battery->dev,
+			"%s: inbat(%d), inbat-ADC(%d)\n",
+			__func__, inbat, inbat_adc);
+
+	return inbat;
+}
+
+static bool sec_bat_check_fullcharged_condition(
+					struct sec_battery_info *battery)
+{
+	int full_check_type;
+
+	if (battery->charging_mode == SEC_BATTERY_CHARGING_1ST)
+		full_check_type = battery->pdata->full_check_type;
+	else
+		full_check_type = battery->pdata->full_check_type_2nd;
+
+	switch (full_check_type) {
+	case SEC_BATTERY_FULLCHARGED_ADC:
+	case SEC_BATTERY_FULLCHARGED_FG_CURRENT:
+	case SEC_BATTERY_FULLCHARGED_SOC:
+	case SEC_BATTERY_FULLCHARGED_CHGGPIO:
+	case SEC_BATTERY_FULLCHARGED_CHGPSY:
+		break;
+
+	/* If these is NOT full check type or NONE full check type,
+	 * it is full-charged
+	 */
+	case SEC_BATTERY_FULLCHARGED_CHGINT:
+	case SEC_BATTERY_FULLCHARGED_TIME:
+	case SEC_BATTERY_FULLCHARGED_NONE:
+	default:
+		return true;
+		break;
+	}
+
+	if (battery->pdata->full_condition_type &
+		SEC_BATTERY_FULL_CONDITION_SOC) {
+		if (battery->capacity <
+			battery->pdata->full_condition_soc) {
+			dev_dbg(battery->dev,
+				"%s: Not enough SOC (%d%%)\n",
+				__func__, battery->capacity);
+			return false;
+		}
+	}
+
+	if (battery->pdata->full_condition_type &
+		SEC_BATTERY_FULL_CONDITION_VCELL) {
+		if (battery->voltage_now <
+			battery->pdata->full_condition_vcell) {
+			dev_dbg(battery->dev,
+				"%s: Not enough VCELL (%dmV)\n",
+				__func__, battery->voltage_now);
+			return false;
+		}
+	}
+
+	if (battery->pdata->full_condition_type &
+		SEC_BATTERY_FULL_CONDITION_AVGVCELL) {
+		if (battery->voltage_avg <
+			battery->pdata->full_condition_avgvcell) {
+			dev_dbg(battery->dev,
+				"%s: Not enough AVGVCELL (%dmV)\n",
+				__func__, battery->voltage_avg);
+			return false;
+		}
+	}
+
+	if (battery->pdata->full_condition_type &
+		SEC_BATTERY_FULL_CONDITION_OCV) {
+		if (battery->voltage_ocv <
+			battery->pdata->full_condition_ocv) {
+			dev_dbg(battery->dev,
+				"%s: Not enough OCV (%dmV)\n",
+				__func__, battery->voltage_ocv);
+			return false;
+		}
+	}
+
+	return true;
+}
+
+static void sec_bat_do_test_function(
+		struct sec_battery_info *battery)
+{
+	union power_supply_propval value;
+
+	switch (battery->test_mode) {
+		case 1:
+			if (battery->status == POWER_SUPPLY_STATUS_CHARGING) {
+				sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING_OFF);
+				sec_bat_set_charging_status(battery,
+						POWER_SUPPLY_STATUS_DISCHARGING);
+			}
+			break;
+		case 2:
+			if(battery->status == POWER_SUPPLY_STATUS_DISCHARGING) {
+				sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING);
+				psy_do_property(battery->pdata->charger_name, get,
+						POWER_SUPPLY_PROP_STATUS, value);
+				sec_bat_set_charging_status(battery, value.intval);
+			}
+			battery->test_mode = 0;
+			break;
+		case 3: // clear temp block
+			battery->health = POWER_SUPPLY_HEALTH_GOOD;
+			sec_bat_set_charging_status(battery,
+					POWER_SUPPLY_STATUS_DISCHARGING);
+			break;
+		case 4:
+			if(battery->status == POWER_SUPPLY_STATUS_DISCHARGING) {
+				sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING);
+				psy_do_property(battery->pdata->charger_name, get,
+						POWER_SUPPLY_PROP_STATUS, value);
+				sec_bat_set_charging_status(battery, value.intval);
+			}
+			break;
+		default:
+			pr_info("%s: error test: unknown state\n", __func__);
+			break;
+	}
+}
+static bool sec_bat_wc_heating_time_management(
+				struct sec_battery_info *battery)
+{
+	unsigned long wc_heating_time;
+	struct timespec ts;
+	union power_supply_propval value;
+
+	pr_info("%s: Heating time(%ld), wpc_temp_mode(%d)\n",
+		__func__, battery->wc_heating_passed_time, battery->wpc_temp_mode);
+
+	if (battery->wc_heating_start_time == 0) {
+		dev_dbg(battery->dev,
+			"%s: Wireless Charging Heating Disabled\n", __func__);
+		return true;
+	}
+
+	get_monotonic_boottime(&ts);
+
+	if (battery->wpc_temp_mode && battery->siop_level >= 100) {
+		if (ts.tv_sec >= battery->wc_heating_start_time)
+			wc_heating_time = ts.tv_sec - battery->wc_heating_start_time;
+		else
+			wc_heating_time = 0xFFFFFFFF - battery->wc_heating_start_time
+				+ ts.tv_sec;
+		battery->wc_heating_passed_time = wc_heating_time;
+		pr_info("%s: Wireless Charging Heating Time : %ld secs\n", __func__,
+			battery->wc_heating_passed_time);
+	} else {
+		battery->wc_heating_start_time = 0;
+		battery->wc_heating_passed_time = 0;
+		battery->wc_heat_limit = SEC_BATTERY_WC_HEAT_NONE;
+	}
+
+	if ((battery->wc_heating_passed_time > battery->pdata->wc_heating_time) &&
+		battery->wc_heat_limit != SEC_BATTERY_WC_HEAT_HIGH) { /* 5min */
+		pr_info("%s: After 5 min heating timer, start heating control(5V, 400mA)\n", __func__);
+		battery->wc_heat_limit = SEC_BATTERY_WC_HEAT_HIGH;
+		sec_bat_set_charging_current(battery);
+		if (battery->capacity < 95) {
+			value.intval = WIRELESS_VOUT_5V; /* Vout 5V*/
+			psy_do_property(battery->pdata->wireless_charger_name, set,
+				POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+		}
+	}
+	return true;
+}
+static bool sec_bat_time_management(
+				struct sec_battery_info *battery)
+{
+	unsigned long charging_time = 0;
+	struct timespec ts = {0, };
+
+	get_monotonic_boottime(&ts);
+
+		if (battery->charging_start_time == 0 || !battery->safety_timer_set) {
+		dev_dbg(battery->dev,
+			"%s: Charging Disabled\n", __func__);
+		return true;
+	}
+
+	if (ts.tv_sec >= battery->charging_start_time)
+		charging_time = ts.tv_sec - battery->charging_start_time;
+	else
+		charging_time = 0xFFFFFFFF - battery->charging_start_time
+		    + ts.tv_sec;
+
+	battery->charging_passed_time = charging_time;
+
+	if (battery->pdata->chg_temp_check && battery->skip_chg_temp_check) {
+		if ((battery->cable_type == POWER_SUPPLY_TYPE_HV_MAINS ||
+			battery->cable_type == POWER_SUPPLY_TYPE_HV_ERR ||
+			battery->cable_type == POWER_SUPPLY_TYPE_HV_MAINS_12V) &&
+			battery->charging_passed_time >= battery->pdata->chg_skip_check_time) {
+				battery->skip_chg_temp_check = false;
+				dev_info(battery->dev,
+					"%s: skip_chg_temp_check(%d), Charging Time : %ld secs\n",
+					__func__,
+					battery->skip_chg_temp_check,
+					battery->charging_passed_time);
+		}
+	}
+
+	if (battery->pdata->wpc_temp_check && battery->skip_wpc_temp_check) {
+		if ((battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS ||
+			battery->cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS ||
+			battery->cable_type == POWER_SUPPLY_TYPE_PMA_WIRELESS ||
+			battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK ||
+			battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK_TA) &&
+			battery->charging_passed_time >= battery->pdata->wpc_skip_check_time) {
+				battery->skip_wpc_temp_check = false;
+				dev_info(battery->dev,
+					"%s: skip_wpc_temp_check(%d), Charging Time : %ld secs\n",
+					__func__,
+					battery->skip_wpc_temp_check,
+					battery->charging_passed_time);
+		}
+	}
+
+	switch (battery->status) {
+	case POWER_SUPPLY_STATUS_FULL:
+		if (battery->expired_time == 0) {
+			dev_info(battery->dev,
+				"%s: Recharging Timer Expired\n", __func__);
+			battery->charging_mode = SEC_BATTERY_CHARGING_NONE;
+			battery->health = POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE;
+			sec_bat_set_charging_status(battery,
+					POWER_SUPPLY_STATUS_NOT_CHARGING);
+			battery->is_recharging = false;
+			if (sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING_OFF)) {
+				dev_err(battery->dev,
+					"%s: Fail to Set Charger\n", __func__);
+				return true;
+			}
+
+			return false;
+		}
+		break;
+	case POWER_SUPPLY_STATUS_CHARGING:
+		if ((battery->pdata->full_condition_type &
+			SEC_BATTERY_FULL_CONDITION_NOTIMEFULL) &&
+			(battery->is_recharging && (battery->expired_time == 0))) {
+			dev_info(battery->dev,
+			"%s: Recharging Timer Expired\n", __func__);
+			battery->charging_mode = SEC_BATTERY_CHARGING_NONE;
+			battery->health = POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE;
+				sec_bat_set_charging_status(battery,
+					POWER_SUPPLY_STATUS_NOT_CHARGING);
+			battery->is_recharging = false;
+			if (sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING_OFF)) {
+				dev_err(battery->dev,
+					"%s: Fail to Set Charger\n", __func__);
+				return true;
+			}
+			return false;
+		} else if (!battery->is_recharging &&
+			(battery->expired_time == 0)) {
+			dev_info(battery->dev,
+				"%s: Charging Timer Expired\n", __func__);
+			battery->charging_mode = SEC_BATTERY_CHARGING_NONE;
+			battery->health = POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE;
+			sec_bat_set_charging_status(battery,
+					POWER_SUPPLY_STATUS_NOT_CHARGING);
+
+			if (sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING_OFF)) {
+				dev_err(battery->dev,
+					"%s: Fail to Set Charger\n", __func__);
+				return true;
+			}
+
+			return false;
+		}
+		if (battery->pdata->charging_reset_time) {
+			if (charging_time > battery->charging_next_time) {
+				/*reset current in charging status */
+				battery->charging_next_time =
+					battery->charging_passed_time +
+					(battery->pdata->charging_reset_time);
+
+				dev_dbg(battery->dev,
+					"%s: Reset charging current\n",
+					__func__);
+#if defined(CONFIG_BATTERY_SWELLING)
+				if (!battery->swelling_mode) {
+					if (sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING)) {
+						dev_err(battery->dev,
+							"%s: Fail to Set Charger\n",
+							__func__);
+						return true;
+					}
+				}
+#else
+				if (sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING)) {
+					dev_err(battery->dev,
+						"%s: Fail to Set Charger\n",
+						__func__);
+					return true;
+				}
+#endif
+			}
+		}
+		break;
+	default:
+		dev_err(battery->dev,
+			"%s: Undefine Battery Status\n", __func__);
+		return true;
+	}
+
+	return true;
+}
+
+static bool sec_bat_check_fullcharged(
+				struct sec_battery_info *battery)
+{
+	union power_supply_propval value;
+	int current_adc;
+	int full_check_type;
+	bool ret;
+	int err;
+
+	ret = false;
+
+	if (!sec_bat_check_fullcharged_condition(battery))
+		goto not_full_charged;
+
+	if (battery->charging_mode == SEC_BATTERY_CHARGING_1ST)
+		full_check_type = battery->pdata->full_check_type;
+	else
+		full_check_type = battery->pdata->full_check_type_2nd;
+
+	switch (full_check_type) {
+	case SEC_BATTERY_FULLCHARGED_ADC:
+		current_adc =
+			sec_bat_get_adc_value(battery,
+			SEC_BAT_ADC_CHANNEL_FULL_CHECK);
+
+		dev_dbg(battery->dev,
+			"%s: Current ADC (%d)\n",
+			__func__, current_adc);
+
+		if (current_adc < 0)
+			break;
+		battery->current_adc = current_adc;
+
+		if (battery->current_adc <
+			(battery->charging_mode ==
+			SEC_BATTERY_CHARGING_1ST ?
+			battery->pdata->charging_current[
+			battery->cable_type].full_check_current_1st :
+			battery->pdata->charging_current[
+			battery->cable_type].full_check_current_2nd)) {
+			battery->full_check_cnt++;
+			dev_dbg(battery->dev,
+				"%s: Full Check ADC (%d)\n",
+				__func__,
+				battery->full_check_cnt);
+		} else
+			battery->full_check_cnt = 0;
+		break;
+
+	case SEC_BATTERY_FULLCHARGED_FG_CURRENT:
+		if ((battery->current_now > 0 && battery->current_now <
+			battery->pdata->charging_current[
+			battery->cable_type].full_check_current_1st) &&
+			(battery->current_avg > 0 && battery->current_avg <
+			(battery->charging_mode ==
+			SEC_BATTERY_CHARGING_1ST ?
+			battery->pdata->charging_current[
+			battery->cable_type].full_check_current_1st :
+			battery->pdata->charging_current[
+			battery->cable_type].full_check_current_2nd))) {
+				battery->full_check_cnt++;
+				dev_dbg(battery->dev,
+				"%s: Full Check Current (%d)\n",
+				__func__,
+				battery->full_check_cnt);
+		} else
+			battery->full_check_cnt = 0;
+		break;
+
+	case SEC_BATTERY_FULLCHARGED_TIME:
+		if ((battery->charging_mode ==
+			SEC_BATTERY_CHARGING_2ND ?
+			(battery->charging_passed_time -
+			battery->charging_fullcharged_time) :
+			battery->charging_passed_time) >
+			(battery->charging_mode ==
+			SEC_BATTERY_CHARGING_1ST ?
+			battery->pdata->charging_current[
+			battery->cable_type].full_check_current_1st :
+			battery->pdata->charging_current[
+			battery->cable_type].full_check_current_2nd)) {
+			battery->full_check_cnt++;
+			dev_dbg(battery->dev,
+				"%s: Full Check Time (%d)\n",
+				__func__,
+				battery->full_check_cnt);
+		} else
+			battery->full_check_cnt = 0;
+		break;
+
+	case SEC_BATTERY_FULLCHARGED_SOC:
+		if (battery->capacity <=
+			(battery->charging_mode ==
+			SEC_BATTERY_CHARGING_1ST ?
+			battery->pdata->charging_current[
+			battery->cable_type].full_check_current_1st :
+			battery->pdata->charging_current[
+			battery->cable_type].full_check_current_2nd)) {
+			battery->full_check_cnt++;
+			dev_dbg(battery->dev,
+				"%s: Full Check SOC (%d)\n",
+				__func__,
+				battery->full_check_cnt);
+		} else
+			battery->full_check_cnt = 0;
+		break;
+
+	case SEC_BATTERY_FULLCHARGED_CHGGPIO:
+		err = gpio_request(
+			battery->pdata->chg_gpio_full_check,
+			"GPIO_CHG_FULL");
+		if (err) {
+			dev_err(battery->dev,
+				"%s: Error in Request of GPIO\n", __func__);
+			break;
+		}
+		if (!(gpio_get_value_cansleep(
+			battery->pdata->chg_gpio_full_check) ^
+			!battery->pdata->chg_polarity_full_check)) {
+			battery->full_check_cnt++;
+			dev_dbg(battery->dev,
+				"%s: Full Check GPIO (%d)\n",
+				__func__, battery->full_check_cnt);
+		} else
+			battery->full_check_cnt = 0;
+		gpio_free(battery->pdata->chg_gpio_full_check);
+		break;
+
+	case SEC_BATTERY_FULLCHARGED_CHGINT:
+	case SEC_BATTERY_FULLCHARGED_CHGPSY:
+		psy_do_property(battery->pdata->charger_name, get,
+			POWER_SUPPLY_PROP_STATUS, value);
+
+		if (value.intval == POWER_SUPPLY_STATUS_FULL) {
+			battery->full_check_cnt++;
+			dev_info(battery->dev,
+				"%s: Full Check Charger (%d)\n",
+				__func__, battery->full_check_cnt);
+		} else
+			battery->full_check_cnt = 0;
+		break;
+
+	/* If these is NOT full check type or NONE full check type,
+	 * it is full-charged
+	 */
+	case SEC_BATTERY_FULLCHARGED_NONE:
+		battery->full_check_cnt = 0;
+		ret = true;
+		break;
+	default:
+		dev_err(battery->dev,
+			"%s: Invalid Full Check\n", __func__);
+		break;
+	}
+
+	if (battery->full_check_cnt >=
+		battery->pdata->full_check_count) {
+		battery->full_check_cnt = 0;
+		ret = true;
+	}
+
+not_full_charged:
+	return ret;
+}
+
+static void sec_bat_do_fullcharged(
+				struct sec_battery_info *battery)
+{
+	union power_supply_propval value;
+
+	/* To let charger/fuel gauge know the full status,
+	 * set status before calling sec_bat_set_charge()
+	 */
+	sec_bat_set_charging_status(battery,
+			POWER_SUPPLY_STATUS_FULL);
+
+	if (battery->charging_mode == SEC_BATTERY_CHARGING_1ST &&
+		battery->pdata->full_check_type_2nd != SEC_BATTERY_FULLCHARGED_NONE) {
+		battery->charging_mode = SEC_BATTERY_CHARGING_2ND;
+		battery->charging_fullcharged_time =
+			battery->charging_passed_time;
+		if (battery->cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS) {
+			if (battery->wc_heat_limit == SEC_BATTERY_WC_HEAT_HIGH ||
+				battery->pad_limit == SEC_BATTERY_WPC_TEMP_HIGH) {
+				value.intval = WIRELESS_VOUT_9V;
+				psy_do_property(battery->pdata->wireless_charger_name, set,
+					POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+				battery->pad_limit = SEC_BATTERY_WPC_TEMP_NONE;
+			}
+		}
+		value.intval = SEC_BAT_CHG_MODE_CHARGING_OFF;
+		psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_CHARGING_ENABLED, value);
+		if (battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS ||
+				battery->cable_type == POWER_SUPPLY_TYPE_PMA_WIRELESS ||
+				battery->cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS ||
+				battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK ||
+				battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK_TA) {
+			if (battery->wireless_input_current > battery->pdata->siop_hv_wireless_input_limit_current) {
+				value.intval = battery->pdata->siop_hv_wireless_input_limit_current;
+				psy_do_property(battery->pdata->charger_name, set,
+						POWER_SUPPLY_PROP_CURRENT_MAX, value);
+				battery->wireless_input_current = value.intval;
+				pr_info("%s: set wireless input current limit to %dmA",
+						__func__, battery->wireless_input_current);
+			}
+		}
+		sec_bat_set_charging_current(battery);
+		sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING);
+	} else {
+		battery->charging_mode = SEC_BATTERY_CHARGING_NONE;
+		battery->is_recharging = false;
+
+		if (!battery->wdt_kick_disable) {
+			pr_info("%s: wdt kick enable -> Charger Off, %d\n",
+					__func__, battery->wdt_kick_disable);
+			sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING_OFF);
+		} else {
+			pr_info("%s: wdt kick disabled -> skip charger off, %d\n",
+					__func__, battery->wdt_kick_disable);
+		}
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+		sec_bat_aging_check(battery);
+#endif
+
+		value.intval = POWER_SUPPLY_STATUS_FULL;
+		psy_do_property(battery->pdata->fuelgauge_name, set,
+			POWER_SUPPLY_PROP_STATUS, value);
+		if (battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS ||
+			battery->cable_type == POWER_SUPPLY_TYPE_PMA_WIRELESS ||
+			battery->cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS ||
+			battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK ||
+			battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK_TA) {
+			value.intval = battery->pdata->wc_full_input_limit_current;
+			psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_CURRENT_MAX, value);
+			battery->wireless_input_current = value.intval;
+			pr_info("%s: set wireless input current limit to %dmA",
+				__func__, battery->wireless_input_current);
+		}
+	}
+
+	/* platform can NOT get information of battery
+	 * because wakeup time is too short to check uevent
+	 * To make sure that target is wakeup if full-charged,
+	 * activated wake lock in a few seconds
+	 */
+	if (battery->pdata->polling_type == SEC_BATTERY_MONITOR_ALARM)
+		wake_lock_timeout(&battery->vbus_wake_lock, HZ * 10);
+}
+
+static bool sec_bat_fullcharged_check(
+				struct sec_battery_info *battery)
+{
+	if ((battery->charging_mode == SEC_BATTERY_CHARGING_NONE) ||
+		(battery->status == POWER_SUPPLY_STATUS_NOT_CHARGING)) {
+		dev_dbg(battery->dev,
+			"%s: No Need to Check Full-Charged\n", __func__);
+		return true;
+	}
+
+	if (sec_bat_check_fullcharged(battery)) {
+		union power_supply_propval value;
+		if (battery->capacity < 100) {
+			battery->full_check_cnt = battery->pdata->full_check_count;
+		} else {
+			sec_bat_do_fullcharged(battery);
+		}
+
+		/* update capacity max */
+		value.intval = battery->capacity;
+		psy_do_property(battery->pdata->fuelgauge_name, set,
+				POWER_SUPPLY_PROP_CHARGE_FULL, value);
+		pr_info("%s : forced full-charged sequence for the capacity(%d)\n",
+				__func__, battery->capacity);
+	}
+
+	dev_info(battery->dev,
+		"%s: Charging Mode : %s\n", __func__,
+		battery->is_recharging ?
+		sec_bat_charging_mode_str[SEC_BATTERY_CHARGING_RECHARGING] :
+		sec_bat_charging_mode_str[battery->charging_mode]);
+
+	return true;
+}
+
+static void sec_bat_get_temperature_info(
+				struct sec_battery_info *battery)
+{
+	union power_supply_propval value;
+
+	switch (battery->pdata->thermal_source) {
+	case SEC_BATTERY_THERMAL_SOURCE_FG:
+		psy_do_property(battery->pdata->fuelgauge_name, get,
+			POWER_SUPPLY_PROP_TEMP, value);
+		battery->temperature = value.intval;
+
+		psy_do_property(battery->pdata->fuelgauge_name, get,
+			POWER_SUPPLY_PROP_TEMP_AMBIENT, value);
+		battery->temper_amb = value.intval;
+		break;
+	case SEC_BATTERY_THERMAL_SOURCE_CALLBACK:
+		if (battery->pdata->get_temperature_callback) {
+			battery->pdata->get_temperature_callback(
+				POWER_SUPPLY_PROP_TEMP, &value);
+			battery->temperature = value.intval;
+			psy_do_property(battery->pdata->fuelgauge_name, set,
+				POWER_SUPPLY_PROP_TEMP, value);
+
+			battery->pdata->get_temperature_callback(
+				POWER_SUPPLY_PROP_TEMP_AMBIENT, &value);
+			battery->temper_amb = value.intval;
+			psy_do_property(battery->pdata->fuelgauge_name, set,
+				POWER_SUPPLY_PROP_TEMP_AMBIENT, value);
+		}
+		break;
+	case SEC_BATTERY_THERMAL_SOURCE_ADC:
+		sec_bat_get_temperature_by_adc(battery,
+			SEC_BAT_ADC_CHANNEL_TEMP, &value);
+		battery->temperature = value.intval;
+		psy_do_property(battery->pdata->fuelgauge_name, set,
+			POWER_SUPPLY_PROP_TEMP, value);
+
+		sec_bat_get_temperature_by_adc(battery,
+			SEC_BAT_ADC_CHANNEL_TEMP_AMBIENT, &value);
+		battery->temper_amb = value.intval;
+		psy_do_property(battery->pdata->fuelgauge_name, set,
+			POWER_SUPPLY_PROP_TEMP_AMBIENT, value);
+
+		if (battery->pdata->chg_thermal_source) {
+			sec_bat_get_temperature_by_adc(battery,
+				   SEC_BAT_ADC_CHANNEL_CHG_TEMP, &value);
+			if (battery->pre_chg_temp == 0) {
+				battery->pre_chg_temp = value.intval;
+				battery->chg_temp = value.intval;
+			} else {
+				battery->pre_chg_temp = battery->chg_temp;
+				battery->chg_temp = value.intval;
+			}
+		}
+
+		if (battery->pdata->wpc_thermal_source) {
+			sec_bat_get_temperature_by_adc(battery,
+				SEC_BAT_ADC_CHANNEL_WPC_TEMP, &value);
+			battery->wpc_temp = value.intval;
+		}
+
+		if (battery->pdata->slave_thermal_source) {
+			sec_bat_get_temperature_by_adc(battery,
+				SEC_BAT_ADC_CHANNEL_SLAVE_CHG_TEMP, &value);
+			if (battery->pre_slave_chg_temp == 0) {
+				battery->pre_slave_chg_temp = value.intval;
+				battery->slave_chg_temp = value.intval;
+			} else {
+				battery->pre_slave_chg_temp = battery->slave_chg_temp;
+				battery->slave_chg_temp = value.intval;
+			}
+
+			/* set temperature */
+			value.intval = ((battery->slave_chg_temp) << 16) | (battery->chg_temp);
+			psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_TEMP, value);
+		}
+		break;
+	default:
+		break;
+	}
+}
+
+static void sec_bat_get_battery_info(
+				struct sec_battery_info *battery)
+{
+	union power_supply_propval value;
+
+	psy_do_property(battery->pdata->fuelgauge_name, get,
+		POWER_SUPPLY_PROP_VOLTAGE_NOW, value);
+	battery->voltage_now = value.intval;
+
+	value.intval = SEC_BATTERY_VOLTAGE_AVERAGE;
+	psy_do_property(battery->pdata->fuelgauge_name, get,
+		POWER_SUPPLY_PROP_VOLTAGE_AVG, value);
+	battery->voltage_avg = value.intval;
+
+	value.intval = SEC_BATTERY_VOLTAGE_OCV;
+	psy_do_property(battery->pdata->fuelgauge_name, get,
+		POWER_SUPPLY_PROP_VOLTAGE_AVG, value);
+	battery->voltage_ocv = value.intval;
+
+	value.intval = SEC_BATTERY_CURRENT_MA;
+	psy_do_property(battery->pdata->fuelgauge_name, get,
+		POWER_SUPPLY_PROP_CURRENT_NOW, value);
+	battery->current_now = value.intval;
+
+	value.intval = SEC_BATTERY_CURRENT_MA;
+	psy_do_property(battery->pdata->fuelgauge_name, get,
+		POWER_SUPPLY_PROP_CURRENT_AVG, value);
+	battery->current_avg = value.intval;
+
+	/* input current limit in charger */
+	psy_do_property(battery->pdata->charger_name, get,
+		POWER_SUPPLY_PROP_CURRENT_MAX, value);
+	battery->current_max = value.intval;
+
+	/* check abnormal status for wireless charging */
+	if (battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS ||
+		battery->cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS ||
+		battery->cable_type == POWER_SUPPLY_TYPE_PMA_WIRELESS ||
+		battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK ||
+		battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK_TA)
+		psy_do_property(battery->pdata->wireless_charger_name, set,
+			POWER_SUPPLY_PROP_ENERGY_NOW, value);
+
+	sec_bat_get_temperature_info(battery);
+
+	/* To get SOC value (NOT raw SOC), need to reset value */
+	value.intval = 0;
+	psy_do_property(battery->pdata->fuelgauge_name, get,
+			POWER_SUPPLY_PROP_CAPACITY, value);
+	/* if the battery status was full, and SOC wasn't 100% yet,
+		then ignore FG SOC, and report (previous SOC +1)% */
+	battery->capacity = value.intval;
+
+	if (battery->capacity > 5 && battery->ignore_siop) {
+		battery->ignore_siop = false;
+		if (battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS ||
+			battery->cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS ||
+			battery->cable_type == POWER_SUPPLY_TYPE_PMA_WIRELESS ||
+			battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK ||
+			battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK_TA)
+			queue_delayed_work_on(0, battery->monitor_wqueue, &battery->siop_work, 0);
+		else
+			queue_delayed_work_on(0, battery->monitor_wqueue, &battery->siop_work, 0);
+	}
+
+	if (battery->store_mode) {
+		if (battery->capacity > 5 && battery->ignore_store_mode) {
+			battery->ignore_store_mode = false;
+			sec_bat_set_charging_current(battery);
+		} else if(battery->capacity <= 5 && !battery->ignore_store_mode) {
+			battery->ignore_store_mode = true;
+			sec_bat_set_charging_current(battery);
+		}
+	}
+
+#if defined(CONFIG_SW_SELF_DISCHARGING)
+	if (battery->temperature >= battery->pdata->self_discharging_temp_block &&
+			battery->voltage_now >= battery->pdata->self_discharging_volt_block) {
+		battery->sw_self_discharging = true;
+#if defined(CONFIG_CHARGER_S2MU005)
+		value.intval = 1;
+		pr_info("%s : start discharge\n",__func__);
+		psy_do_property(battery->pdata->charger_name, set,
+					POWER_SUPPLY_PROP_RESISTANCE, value);
+#endif
+		wake_lock(&battery->self_discharging_wake_lock);
+	} else if (battery->temperature <= battery->pdata->self_discharging_temp_recov ||
+			battery->voltage_now <= battery->pdata->swelling_drop_float_voltage) {
+		battery->sw_self_discharging = false;
+#if defined(CONFIG_CHARGER_S2MU005)
+		value.intval = 0;
+		pr_info("%s : stop discharge\n",__func__);
+		psy_do_property(battery->pdata->charger_name, set,
+					POWER_SUPPLY_PROP_RESISTANCE, value);
+#endif
+		wake_unlock(&battery->self_discharging_wake_lock);
+	}
+	pr_info("%s : sw_self_discharging (%d)\n",__func__, battery->sw_self_discharging);
+#endif
+
+	dev_info(battery->dev,
+		"%s:Vnow(%dmV),Inow(%dmA),Imax(%dmA),SOC(%d%%),Tbat(%d),Tchg(%d),Twpc(%d)"
+#if defined(CONFIG_SW_SELF_DISCHARGING)
+		",sw_self_dis(%d)"
+#endif
+		"\n", __func__,
+		battery->voltage_now, battery->current_now,
+		battery->current_max, battery->capacity,
+		battery->temperature, battery->chg_temp,
+		battery->wpc_temp
+#if defined(CONFIG_SW_SELF_DISCHARGING)
+		, battery->sw_self_discharging
+#endif
+		);
+	dev_dbg(battery->dev,
+		"%s,Vavg(%dmV),Vocv(%dmV),Tamb(%d),"
+		"Iavg(%dmA),Iadc(%d)\n",
+		battery->present ? "Connected" : "Disconnected",
+		battery->voltage_avg, battery->voltage_ocv,
+		battery->temper_amb,
+		battery->current_avg, battery->current_adc);
+}
+
+static void sec_bat_polling_work(struct work_struct *work)
+{
+	struct sec_battery_info *battery = container_of(
+		work, struct sec_battery_info, polling_work.work);
+
+	wake_lock(&battery->monitor_wake_lock);
+	queue_delayed_work_on(0, battery->monitor_wqueue, &battery->monitor_work, 0);
+	dev_dbg(battery->dev, "%s: Activated\n", __func__);
+}
+
+static void sec_bat_program_alarm(
+				struct sec_battery_info *battery, int seconds)
+{
+	alarm_start(&battery->polling_alarm,
+		    ktime_add(battery->last_poll_time, ktime_set(seconds, 0)));
+}
+
+static unsigned int sec_bat_get_polling_time(
+	struct sec_battery_info *battery)
+{
+	if (battery->status ==
+		POWER_SUPPLY_STATUS_FULL)
+		battery->polling_time =
+			battery->pdata->polling_time[
+			POWER_SUPPLY_STATUS_CHARGING];
+	else
+		battery->polling_time =
+			battery->pdata->polling_time[
+			battery->status];
+
+	battery->polling_short = true;
+
+	switch (battery->status) {
+	case POWER_SUPPLY_STATUS_CHARGING:
+		if (battery->polling_in_sleep)
+			battery->polling_short = false;
+		break;
+	case POWER_SUPPLY_STATUS_DISCHARGING:
+		if (battery->polling_in_sleep && (battery->ps_enable != true)) {
+#if defined(CONFIG_SW_SELF_DISCHARGING)
+			if (battery->voltage_now > battery->pdata->self_discharging_volt_block) {
+				if(battery->temperature > battery->pdata->self_discharging_temp_pollingtime)
+					battery->polling_time = 300;
+				else
+					battery->polling_time = 600;
+			} else
+#endif
+			battery->polling_time =
+				battery->pdata->polling_time[
+				SEC_BATTERY_POLLING_TIME_SLEEP];
+		} else
+			battery->polling_time =
+				battery->pdata->polling_time[
+				battery->status];
+		battery->polling_short = false;
+		break;
+	case POWER_SUPPLY_STATUS_FULL:
+		if (battery->polling_in_sleep) {
+			if (!(battery->pdata->full_condition_type &
+				SEC_BATTERY_FULL_CONDITION_NOSLEEPINFULL) &&
+				battery->charging_mode ==
+				SEC_BATTERY_CHARGING_NONE) {
+#if defined(CONFIG_SW_SELF_DISCHARGING)
+			if (battery->voltage_now > battery->pdata->self_discharging_volt_block) {
+				if(battery->temperature > battery->pdata->self_discharging_temp_pollingtime)
+					battery->polling_time = 300;
+				else
+					battery->polling_time = 600;
+			} else
+#endif
+				battery->polling_time =
+					battery->pdata->polling_time[
+					SEC_BATTERY_POLLING_TIME_SLEEP];
+			}
+			battery->polling_short = false;
+		} else {
+			if (battery->charging_mode ==
+				SEC_BATTERY_CHARGING_NONE)
+				battery->polling_short = false;
+		}
+		break;
+	case POWER_SUPPLY_STATUS_NOT_CHARGING:
+		if ((battery->health == POWER_SUPPLY_HEALTH_OVERVOLTAGE ||
+			(battery->health == POWER_SUPPLY_HEALTH_UNDERVOLTAGE)) &&
+			(battery->health_check_count > 0)) {
+			battery->health_check_count--;
+			battery->polling_time = 1;
+			battery->polling_short = false;
+		}
+		break;
+	}
+
+	if (battery->polling_short)
+		return battery->pdata->polling_time[
+			SEC_BATTERY_POLLING_TIME_BASIC];
+	/* set polling time to 46s to reduce current noise on wc */
+	else if (battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS &&
+			battery->status == POWER_SUPPLY_STATUS_CHARGING)
+		battery->polling_time = 46;
+
+	return battery->polling_time;
+}
+
+static bool sec_bat_is_short_polling(
+	struct sec_battery_info *battery)
+{
+	/* Change the full and short monitoring sequence
+	 * Originally, full monitoring was the last time of polling_count
+	 * But change full monitoring to first time
+	 * because temperature check is too late
+	 */
+	if (!battery->polling_short || battery->polling_count == 1)
+		return false;
+	else
+		return true;
+}
+
+static void sec_bat_update_polling_count(
+	struct sec_battery_info *battery)
+{
+	/* do NOT change polling count in sleep
+	 * even though it is short polling
+	 * to keep polling count along sleep/wakeup
+	 */
+	if (battery->polling_short && battery->polling_in_sleep)
+		return;
+
+	if (battery->polling_short &&
+		((battery->polling_time /
+		battery->pdata->polling_time[
+		SEC_BATTERY_POLLING_TIME_BASIC])
+		> battery->polling_count))
+		battery->polling_count++;
+	else
+		battery->polling_count = 1;	/* initial value = 1 */
+}
+
+static void sec_bat_set_polling(
+	struct sec_battery_info *battery)
+{
+	unsigned int polling_time_temp;
+
+	dev_dbg(battery->dev, "%s: Start\n", __func__);
+
+	polling_time_temp = sec_bat_get_polling_time(battery);
+
+	dev_dbg(battery->dev,
+		"%s: Status:%s, Sleep:%s, Charging:%s, Short Poll:%s\n",
+		__func__, sec_bat_status_str[battery->status],
+		battery->polling_in_sleep ? "Yes" : "No",
+		(battery->charging_mode ==
+		SEC_BATTERY_CHARGING_NONE) ? "No" : "Yes",
+		battery->polling_short ? "Yes" : "No");
+	dev_dbg(battery->dev,
+		"%s: Polling time %d/%d sec.\n", __func__,
+		battery->polling_short ?
+		(polling_time_temp * battery->polling_count) :
+		polling_time_temp, battery->polling_time);
+
+	/* To sync with log above,
+	 * change polling count after log is displayed
+	 * Do NOT update polling count in initial monitor
+	 */
+	if (!battery->pdata->monitor_initial_count)
+		sec_bat_update_polling_count(battery);
+	else
+		dev_dbg(battery->dev,
+			"%s: Initial monitor %d times left.\n", __func__,
+			battery->pdata->monitor_initial_count);
+
+	switch (battery->pdata->polling_type) {
+	case SEC_BATTERY_MONITOR_WORKQUEUE:
+		if (battery->pdata->monitor_initial_count) {
+			battery->pdata->monitor_initial_count--;
+			schedule_delayed_work(&battery->polling_work, HZ);
+		} else
+			schedule_delayed_work(&battery->polling_work,
+				polling_time_temp * HZ);
+		break;
+	case SEC_BATTERY_MONITOR_ALARM:
+		battery->last_poll_time = ktime_get_boottime();
+
+		if (battery->pdata->monitor_initial_count) {
+			battery->pdata->monitor_initial_count--;
+			sec_bat_program_alarm(battery, 1);
+		} else
+			sec_bat_program_alarm(battery, polling_time_temp);
+		break;
+	case SEC_BATTERY_MONITOR_TIMER:
+		break;
+	default:
+		break;
+	}
+	dev_dbg(battery->dev, "%s: End\n", __func__);
+}
+
+/* OTG during HV wireless charging or sleep mode have 4.5W normal wireless charging UI */
+static bool sec_bat_hv_wc_normal_mode_check(struct sec_battery_info *battery)
+{
+	union power_supply_propval value;
+
+	psy_do_property(battery->pdata->charger_name, get,
+			POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL, value);
+	if (value.intval || sleep_mode) {
+		pr_info("%s: otg(%d), sleep_mode(%d)\n", __func__, value.intval, sleep_mode);
+		return true;
+	}
+	return false;
+}
+
+#if defined(CONFIG_BATTERY_SWELLING)
+static void sec_bat_swelling_fullcharged_check(struct sec_battery_info *battery)
+{
+	union power_supply_propval value;
+
+	switch (battery->pdata->full_check_type_2nd) {
+	case SEC_BATTERY_FULLCHARGED_FG_CURRENT:
+		if ((battery->current_now > 0 && battery->current_now <
+			battery->pdata->charging_current[
+			battery->cable_type].full_check_current_1st) &&
+			(battery->current_avg > 0 &&
+			battery->current_avg < battery->topoff_current)) {
+			value.intval = POWER_SUPPLY_STATUS_FULL;
+		}
+		break;
+	default:
+		psy_do_property(battery->pdata->charger_name, get,
+			POWER_SUPPLY_PROP_STATUS, value);
+		break;
+	}
+
+	if (value.intval == POWER_SUPPLY_STATUS_FULL) {
+		battery->swelling_full_check_cnt++;
+		pr_info("%s: Swelling mode full-charged check (%d)\n",
+			__func__, battery->swelling_full_check_cnt);
+	} else
+		battery->swelling_full_check_cnt = 0;
+
+	if (battery->swelling_full_check_cnt >=
+		battery->pdata->full_check_count) {
+		battery->swelling_full_check_cnt = 0;
+		battery->charging_mode = SEC_BATTERY_CHARGING_NONE;
+		battery->is_recharging = false;
+		battery->swelling_mode = SWELLING_MODE_FULL;
+		sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING_OFF);
+		battery->expired_time = battery->pdata->expired_time;
+		battery->prev_safety_time = 0;
+	}
+}
+#endif
+
+static void sec_bat_calculate_safety_time(struct sec_battery_info *battery)
+{
+	unsigned long long expired_time = battery->expired_time;
+	struct timespec ts = {0, };
+	int curr = 0;
+	int input_power = battery->current_max * battery->input_voltage * 1000;
+	int charging_power = battery->charging_current * battery->pdata->swelling_normal_float_voltage;
+	static int discharging_cnt = 0;
+
+	if (battery->current_avg < 0) {
+		discharging_cnt++;
+	} else {
+		discharging_cnt = 0;
+	}
+
+	if (discharging_cnt >= 5) {
+		battery->expired_time = battery->pdata->expired_time;
+		battery->prev_safety_time = 0;
+		pr_info("%s : SAFETY TIME RESET! DISCHARGING CNT(%d)\n",
+			__func__, discharging_cnt);
+		discharging_cnt = 0;
+		return;
+	} else if (battery->lcd_status && battery->stop_timer) {
+		battery->prev_safety_time = 0;
+		return;
+	}
+
+	get_monotonic_boottime(&ts);
+
+	if (battery->prev_safety_time == 0) {
+		battery->prev_safety_time = ts.tv_sec;
+	}
+
+	if (input_power > charging_power) {
+		curr = battery->charging_current;
+	} else {
+		curr = input_power / battery->pdata->swelling_normal_float_voltage;
+		curr = (curr * 9) / 10;
+	}
+
+	if (battery->lcd_status && !battery->stop_timer) {
+		battery->stop_timer = true;
+	} else if (!battery->lcd_status && battery->stop_timer) {
+		battery->stop_timer = false;
+	}
+
+	pr_info("%s : EXPIRED_TIME(%llu), IP(%d), CP(%d), CURR(%d), STANDARD(%d)\n",
+		__func__, expired_time, input_power, charging_power, curr, battery->pdata->standard_curr);
+
+	if (curr == 0)
+		return;
+
+	expired_time = (expired_time * battery->pdata->standard_curr) / curr;
+
+	pr_info("%s : CAL_EXPIRED_TIME(%llu) TIME NOW(%ld) TIME PREV(%ld)\n", __func__, expired_time, ts.tv_sec, battery->prev_safety_time);
+
+	if (expired_time <= ((ts.tv_sec - battery->prev_safety_time) * 1000))
+		expired_time = 0;
+	else
+		expired_time -= ((ts.tv_sec - battery->prev_safety_time) * 1000);
+
+	battery->cal_safety_time = expired_time;
+	expired_time = (expired_time * curr) / battery->pdata->standard_curr;
+
+	battery->expired_time = expired_time;
+	battery->prev_safety_time = ts.tv_sec;
+	pr_info("%s : REMAIN_TIME(%ld) CAL_REMAIN_TIME(%ld)\n", __func__, battery->expired_time, battery->cal_safety_time);
+}
+
+#if defined(CONFIG_CALC_TIME_TO_FULL)
+static void sec_bat_calc_time_to_full(struct sec_battery_info * battery)
+{
+	if (battery->status == POWER_SUPPLY_STATUS_CHARGING ||
+		(battery->status == POWER_SUPPLY_STATUS_FULL && battery->capacity != 100)) {
+		union power_supply_propval value;
+		int cable_type, input, charge;
+		if (battery->cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS) {
+			if (sec_bat_hv_wc_normal_mode_check(battery))
+				cable_type = POWER_SUPPLY_TYPE_WIRELESS;
+			else
+				cable_type = POWER_SUPPLY_TYPE_HV_WIRELESS;
+		} else {
+			cable_type = battery->cable_type;
+		}
+
+		input = battery->pdata->charging_current[cable_type].input_current_limit;
+		charge = battery->pdata->charging_current[cable_type].fast_charging_current;
+		if ((cable_type == POWER_SUPPLY_TYPE_HV_MAINS) ||
+			(cable_type == POWER_SUPPLY_TYPE_HV_ERR) ||
+			(battery->cable_type == POWER_SUPPLY_TYPE_HV_MAINS_12V)) {
+			value.intval = battery->pdata->ttf_hv_charge_current;
+		} else if (cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS) {
+			value.intval = battery->pdata->ttf_hv_wireless_charge_current;
+		} else if (cable_type == POWER_SUPPLY_TYPE_USB) {
+			value.intval = battery->current_max - 50;
+		} else if ((cable_type == POWER_SUPPLY_TYPE_WIRELESS) ||
+			(cable_type == POWER_SUPPLY_TYPE_PMA_WIRELESS) ||
+			(cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK) ||
+			(cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK_TA)) {
+			value.intval = battery->current_max + 100;
+		} else if (input == battery->current_max) {
+			if (input == 1800) // TA cannot charge 2100
+				value.intval = 1950;
+			else
+				value.intval = charge - 50;
+		} else {
+			value.intval = battery->current_max + 100;
+		}
+		psy_do_property(battery->pdata->fuelgauge_name, get,
+				POWER_SUPPLY_PROP_TIME_TO_FULL_NOW, value);
+		dev_info(battery->dev, "%s: T: %5d sec, passed time: %5ld\n",
+				__func__, value.intval, battery->charging_passed_time);
+		battery->timetofull = value.intval;
+	} else {
+		battery->timetofull = -1;
+	}
+}
+
+static void sec_bat_time_to_full_work(struct work_struct *work)
+{
+	struct sec_battery_info *battery = container_of(work,
+				struct sec_battery_info, timetofull_work.work);
+	union power_supply_propval value;
+
+	psy_do_property(battery->pdata->charger_name, get,
+		POWER_SUPPLY_PROP_CURRENT_MAX, value);
+	battery->current_max = value.intval;
+
+	value.intval = SEC_BATTERY_CURRENT_MA;
+	psy_do_property(battery->pdata->fuelgauge_name, get,
+		POWER_SUPPLY_PROP_CURRENT_NOW, value);
+	battery->current_now = value.intval;
+
+	value.intval = SEC_BATTERY_CURRENT_MA;
+	psy_do_property(battery->pdata->fuelgauge_name, get,
+		POWER_SUPPLY_PROP_CURRENT_AVG, value);
+	battery->current_avg = value.intval;
+
+	sec_bat_calc_time_to_full(battery);
+	battery->complete_timetofull = true;
+	dev_info(battery->dev, "%s: \n",__func__);
+	if (battery->voltage_now > 0)
+		battery->voltage_now--;
+	power_supply_changed(&battery->psy_bat);
+}
+#endif
+
+static void sec_bat_wc_cv_mode_check(struct sec_battery_info *battery)
+{
+	union power_supply_propval value;
+
+	pr_info("%s: battery->wc_cv_mode = %d \n", __func__, battery->wc_cv_mode);
+
+	if (battery->capacity >= battery->pdata->wireless_cc_cv) {
+		pr_info("%s: 4.5W WC Changed Vout input current limit\n", __func__);
+		battery->wc_cv_mode = true;
+		sec_bat_set_charging_current(battery);
+		value.intval = WIRELESS_VOUT_CC_CV_VOUT; // 5.5V
+		psy_do_property(battery->pdata->wireless_charger_name, set,
+			POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+		value.intval = WIRELESS_VRECT_ADJ_ROOM_5; // 80mv
+		psy_do_property(battery->pdata->wireless_charger_name, set,
+			POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+		if (battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS ||
+			battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK_TA) {
+			value.intval = WIRELESS_CLAMP_ENABLE;
+			psy_do_property(battery->pdata->wireless_charger_name, set,
+				POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+		}
+		/* Change FOD values for CV mode */
+		value.intval = POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE;
+		psy_do_property(battery->pdata->wireless_charger_name, set,
+			POWER_SUPPLY_PROP_STATUS, value);
+	}
+}
+
+static void sec_bat_siop_work(struct work_struct *work)
+{
+	struct sec_battery_info *battery = container_of(work,
+				struct sec_battery_info, siop_work.work);
+
+	pr_info("%s : set current by siop level(%d)\n",__func__, battery->siop_level);
+
+	sec_bat_set_charging_current(battery);
+#if !defined(CONFIG_SEC_FACTORY)
+	if ((battery->pdata->chg_temp_check || battery->pdata->wpc_temp_check) && battery->siop_level >= 100)
+		sec_bat_chg_temperature_check(battery);
+#endif
+
+	wake_unlock(&battery->siop_wake_lock);
+}
+
+static void sec_bat_siop_level_work(struct work_struct *work)
+{
+	struct sec_battery_info *battery = container_of(work,
+			struct sec_battery_info, siop_level_work.work);
+
+	if (battery->siop_prev_event != battery->siop_event) {
+		wake_unlock(&battery->siop_level_wake_lock);
+		return;
+	}
+	if (battery->capacity <= 5) {
+		battery->siop_level = 100;
+		battery->ignore_siop = true;
+	} else if (battery->ignore_siop) {
+		battery->ignore_siop = false;
+	}
+
+	if (battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS ||
+			battery->cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS ||
+			battery->cable_type == POWER_SUPPLY_TYPE_PMA_WIRELESS ||
+			battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK ||
+			battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK_TA) {
+		queue_delayed_work_on(0, battery->monitor_wqueue, &battery->siop_work, 0);
+	}
+	else
+		queue_delayed_work_on(0, battery->monitor_wqueue, &battery->siop_work, 0);
+	wake_lock(&battery->siop_wake_lock);
+
+	wake_unlock(&battery->siop_level_wake_lock);
+}
+
+static void sec_bat_wc_headroom_work(struct work_struct *work)
+{
+	struct sec_battery_info *battery = container_of(work,
+			struct sec_battery_info, wc_headroom_work.work);
+	union power_supply_propval value;
+
+	/* The default headroom is high, because initial wireless charging state is unstable.
+		After 10sec wireless charging, however, recover headroom level to avoid chipset damage */
+	if (battery->wc_status != SEC_WIRELESS_PAD_NONE) {
+		/* When the capacity is higher than 99, and the device is in 5V wireless charging state,
+			then Vrect headroom has to be headroom_2.
+			Refer to the sec_bat_siop_work function. */
+		if (battery->capacity < 99 && battery->status != POWER_SUPPLY_STATUS_FULL) {
+			if (battery->wc_status == SEC_WIRELESS_PAD_WPC ||
+				battery->wc_status == SEC_WIRELESS_PAD_WPC_PACK ||
+				battery->wc_status == SEC_WIRELESS_PAD_WPC_PACK_TA) {
+				if (battery->capacity < battery->pdata->wireless_cc_cv)
+					value.intval = WIRELESS_VRECT_ADJ_ROOM_4; /* WPC 4.5W, Vrect Room 30mV */
+				else
+					value.intval = WIRELESS_VRECT_ADJ_ROOM_5; /* WPC 4.5W, Vrect Room 80mV */
+			} else if (battery->wc_status == SEC_WIRELESS_PAD_WPC_HV) {
+				value.intval = WIRELESS_VRECT_ADJ_ROOM_5;
+			} else {
+				value.intval = WIRELESS_VRECT_ADJ_OFF;
+			}
+			psy_do_property(battery->pdata->wireless_charger_name, set,
+				POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+			pr_info("%s: Changed Vrect adjustment from Rx activation(10seconds)", __func__);
+		}
+		if (battery->wc_status == SEC_WIRELESS_PAD_WPC ||
+			battery->wc_status == SEC_WIRELESS_PAD_WPC_PACK ||
+			battery->wc_status == SEC_WIRELESS_PAD_WPC_PACK_TA)
+			sec_bat_wc_cv_mode_check(battery);
+	}
+	wake_unlock(&battery->wc_headroom_wake_lock);
+}
+
+static void sec_bat_siop_event_work(struct work_struct *work)
+{
+	struct sec_battery_info *battery = container_of(work,
+			struct sec_battery_info, siop_event_work.work);
+
+	union power_supply_propval value;
+
+	if (battery->cable_type != POWER_SUPPLY_TYPE_WIRELESS_PACK &&
+			battery->cable_type != POWER_SUPPLY_TYPE_WIRELESS_PACK_TA) {
+		battery->siop_prev_event = battery->siop_event;
+		wake_unlock(&battery->siop_event_wake_lock);
+		return;
+	}
+
+	if (!(battery->siop_prev_event & SIOP_EVENT_WPC_CALL) && (battery->siop_event & SIOP_EVENT_WPC_CALL)) {
+		pr_info("%s : set current by siop event(%d)\n",__func__, battery->siop_event);
+		if (battery->capacity >= battery->pdata->wireless_cc_cv) {
+			pr_info("%s SIOP EVENT CALL CV START.\n", __func__);
+			value.intval = WIRELESS_VOUT_CV_CALL;
+		} else {
+			pr_info("%s SIOP EVENT CALL CC START.\n", __func__);
+			value.intval = WIRELESS_VOUT_CC_CALL;
+		}
+		/* set current first */
+		sec_bat_set_charging_current(battery);
+		psy_do_property(battery->pdata->wireless_charger_name, set,
+				POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+	} else if ((battery->siop_prev_event & SIOP_EVENT_WPC_CALL) && !(battery->siop_event & SIOP_EVENT_WPC_CALL)) {
+		if (battery->wc_cv_mode)
+			value.intval = WIRELESS_VOUT_CC_CV_VOUT; // 5.5V
+		else
+			value.intval = WIRELESS_VOUT_5V;
+		psy_do_property(battery->pdata->wireless_charger_name, set,
+				POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+		wake_lock(&battery->siop_level_wake_lock);
+		queue_delayed_work_on(0, battery->monitor_wqueue, &battery->siop_level_work, 0);
+	}
+	battery->siop_prev_event = battery->siop_event;
+	wake_unlock(&battery->siop_event_wake_lock);
+}
+
+#if defined(CONFIG_WIRELESS_FIRMWARE_UPDATE)
+static void sec_bat_fw_update_work(struct sec_battery_info *battery, int mode)
+{
+	union power_supply_propval value;
+
+	dev_info(battery->dev, "%s \n", __func__);
+
+	wake_lock_timeout(&battery->vbus_wake_lock, HZ * 10);
+
+	switch (mode) {
+		case SEC_WIRELESS_RX_SDCARD_MODE:
+		case SEC_WIRELESS_RX_BUILT_IN_MODE:
+			value.intval = true;
+			psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_CHARGE_UNO_CONTROL, value);
+
+			value.intval = mode;
+			psy_do_property(battery->pdata->wireless_charger_name, set,
+				POWER_SUPPLY_PROP_CHARGE_POWERED_OTG_CONTROL, value);
+
+			value.intval = false;
+			psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_CHARGE_UNO_CONTROL, value);
+
+			break;
+		case SEC_WIRELESS_TX_ON_MODE:
+			value.intval = true;
+			psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_CHARGE_UNO_CONTROL, value);
+
+			value.intval = mode;
+			psy_do_property(battery->pdata->wireless_charger_name, set,
+				POWER_SUPPLY_PROP_CHARGE_POWERED_OTG_CONTROL, value);
+
+			break;
+		case SEC_WIRELESS_TX_OFF_MODE:
+			value.intval = false;
+			psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_CHARGE_UNO_CONTROL, value);
+			break;
+		default:
+			break;
+	}
+}
+
+static void sec_bat_fw_init_work(struct work_struct *work)
+{
+	struct sec_battery_info *battery = container_of(work,
+				struct sec_battery_info, fw_init_work.work);
+
+	union power_supply_propval value;
+	int uno_status, wpc_det;
+
+	dev_info(battery->dev, "%s \n", __func__);
+
+	wpc_det = gpio_get_value(battery->pdata->wpc_det);
+
+	pr_info("%s wpc_det = %d \n", __func__, wpc_det);
+
+	psy_do_property(battery->pdata->charger_name, get,
+		POWER_SUPPLY_PROP_CHARGE_UNO_CONTROL, value);
+	uno_status = value.intval;
+	pr_info("%s uno = %d \n", __func__, uno_status);
+
+	if (!uno_status && !wpc_det) {
+		pr_info("%s uno on \n", __func__);
+		value.intval = true;
+		psy_do_property(battery->pdata->charger_name, set,
+			POWER_SUPPLY_PROP_CHARGE_UNO_CONTROL, value);
+	}
+
+	value.intval = SEC_WIRELESS_RX_INIT;
+	psy_do_property(battery->pdata->wireless_charger_name, set,
+		POWER_SUPPLY_PROP_CHARGE_POWERED_OTG_CONTROL, value);
+
+	if (!uno_status && !wpc_det) {
+		pr_info("%s uno off \n", __func__);
+		value.intval = false;
+		psy_do_property(battery->pdata->charger_name, set,
+			POWER_SUPPLY_PROP_CHARGE_UNO_CONTROL, value);
+	}
+}
+#endif
+#if defined(CONFIG_UPDATE_BATTERY_DATA)
+static int sec_bat_parse_dt(struct device *dev, struct sec_battery_info *battery);
+static void sec_bat_update_data_work(struct work_struct *work)
+{
+	struct sec_battery_info *battery = container_of(work,
+				struct sec_battery_info, batt_data_work.work);
+
+	sec_battery_update_data(battery->data_path);
+	wake_unlock(&battery->batt_data_wake_lock);
+}
+#endif
+
+static void sec_bat_misc_event_work(struct work_struct *work)
+{
+	struct sec_battery_info *battery = container_of(work,
+				struct sec_battery_info, misc_event_work.work);
+	int xor_misc_event = battery->prev_misc_event ^ battery->misc_event;
+
+	if ((xor_misc_event & BATT_MISC_EVENT_UNDEFINED_RANGE_TYPE) &&
+		(battery->cable_type == POWER_SUPPLY_TYPE_BATTERY)) {
+		if (battery->misc_event & BATT_MISC_EVENT_UNDEFINED_RANGE_TYPE) {
+			sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_BUCK_OFF);
+		} else if (battery->prev_misc_event & BATT_MISC_EVENT_UNDEFINED_RANGE_TYPE) {
+			sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING_OFF);
+		}
+	}
+
+	pr_info("%s: change misc event(0x%x --> 0x%x)\n",
+		__func__, battery->prev_misc_event, battery->misc_event);
+	battery->prev_misc_event = battery->misc_event;
+	wake_unlock(&battery->misc_event_wake_lock);
+
+	wake_lock(&battery->monitor_wake_lock);
+	queue_delayed_work_on(0, battery->monitor_wqueue, &battery->monitor_work, 0);
+}
+
+static void sec_bat_monitor_work(
+				struct work_struct *work)
+{
+	struct sec_battery_info *battery =
+		container_of(work, struct sec_battery_info,
+		monitor_work.work);
+	static struct timespec old_ts;
+	struct timespec c_ts;
+	union power_supply_propval value;
+
+	dev_dbg(battery->dev, "%s: Start\n", __func__);
+	c_ts = ktime_to_timespec(ktime_get_boottime());
+
+	/* monitor once after wakeup */
+	if (battery->polling_in_sleep) {
+		battery->polling_in_sleep = false;
+		if ((battery->status == POWER_SUPPLY_STATUS_DISCHARGING) &&
+			(battery->ps_enable != true)) {
+			if ((unsigned long)(c_ts.tv_sec - old_ts.tv_sec) < 10 * 60) {
+				union power_supply_propval value;
+
+				psy_do_property(battery->pdata->fuelgauge_name, get,
+					POWER_SUPPLY_PROP_VOLTAGE_NOW, value);
+				battery->voltage_now = value.intval;
+
+				value.intval = 0;
+				psy_do_property(battery->pdata->fuelgauge_name, get,
+					POWER_SUPPLY_PROP_CAPACITY, value);
+				battery->capacity = value.intval;
+
+				sec_bat_get_temperature_info(battery);
+				power_supply_changed(&battery->psy_bat);
+				pr_info("Skip monitor work(%ld, Vnow:%d(mV), SoC:%d(%%), Tbat:%d(0.1'C))\n",
+					c_ts.tv_sec - old_ts.tv_sec, battery->voltage_now, battery->capacity, battery->temperature);
+
+				goto skip_monitor;
+			}
+		}
+	}
+	/* update last monitor time */
+	old_ts = c_ts;
+
+	sec_bat_get_battery_info(battery);
+
+#if defined(CONFIG_STEP_CHARGING)
+	if(sec_bat_check_step_charging(battery))
+		sec_bat_set_charging_current(battery);
+#endif
+#if defined(CONFIG_CALC_TIME_TO_FULL)
+	/* time to full check */
+	sec_bat_calc_time_to_full(battery);
+#endif
+
+	if (battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK ||
+		battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK_TA) {
+		if ((battery->capacity <= 5 && !battery->wc_pack_max_curr) ||
+				(battery->capacity > 5 && battery->wc_pack_max_curr))
+			sec_bat_set_charging_current(battery);
+	}
+
+	/* 0. test mode */
+	if (battery->test_mode) {
+		dev_err(battery->dev, "%s: Test Mode\n", __func__);
+		sec_bat_do_test_function(battery);
+		if (battery->test_mode != 0)
+			goto continue_monitor;
+	}
+
+	/* 1. battery check */
+	if (!sec_bat_battery_cable_check(battery))
+		goto continue_monitor;
+
+	/* 2. voltage check */
+	if (!sec_bat_voltage_check(battery))
+		goto continue_monitor;
+
+	/* monitor short routine in initial monitor */
+	if (battery->pdata->monitor_initial_count ||
+		sec_bat_is_short_polling(battery))
+		goto continue_monitor;
+
+	/* 3. time management */
+	if (!sec_bat_time_management(battery))
+		goto continue_monitor;
+
+	/* 4. temperature check */
+	if (!sec_bat_temperature_check(battery))
+		goto continue_monitor;
+
+	if (!sec_bat_wc_heating_time_management(battery))
+		goto continue_monitor;
+
+	if ((battery->capacity >= 95) &&
+		(battery->cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS)) {
+		psy_do_property(battery->pdata->wireless_charger_name, get,
+				POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+		pr_info("%s: soc(%d), cable(%d), vout(%d)\n",
+			__func__, battery->capacity, battery->cable_type, value.intval);
+
+		//if (value.intval != P9220_VOUT_9V_VAL) {
+		if (value.intval != 0x37) {
+			value.intval = WIRELESS_VOUT_9V;
+			psy_do_property(battery->pdata->wireless_charger_name, set,
+					POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+		}
+	}
+#if defined(CONFIG_BATTERY_SWELLING_SELF_DISCHARGING)
+	sec_bat_discharging_check(battery);
+#endif
+
+#if defined(CONFIG_BATTERY_SWELLING)
+	sec_bat_swelling_check(battery, battery->temperature);
+
+	if ((battery->swelling_mode == SWELLING_MODE_CHARGING || battery->swelling_mode == SWELLING_MODE_FULL) &&
+		(!battery->charging_block))
+		sec_bat_swelling_fullcharged_check(battery);
+	else
+		sec_bat_fullcharged_check(battery);
+#else
+	/* 5. full charging check */
+	sec_bat_fullcharged_check(battery);
+#endif /* CONFIG_BATTERY_SWELLING */
+
+	/* 6. additional check */
+	if (battery->pdata->monitor_additional_check)
+		battery->pdata->monitor_additional_check();
+
+#if !defined(CONFIG_SEC_FACTORY)
+	/* 7. charger temperature check */
+	if (battery->pdata->chg_temp_check || battery->pdata->wpc_temp_check)
+		sec_bat_chg_temperature_check(battery);
+#endif
+	if ((battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS ||
+			battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK ||
+			battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK_TA) &&
+			!battery->wc_cv_mode && battery->charging_passed_time > 10)
+		sec_bat_wc_cv_mode_check(battery);
+
+continue_monitor:
+#if 1
+	/* calculate safety time */
+	if (!battery->charging_block)
+		sec_bat_calculate_safety_time(battery);
+#endif
+	dev_info(battery->dev,
+		 "%s: Status(%s), mode(%s), Health(%s), Cable(%d), level(%d%%)"
+#if defined(CONFIG_AFC_CHARGER_MODE)
+		", HV(%s), sleep_mode(%d)"
+#endif
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+#if defined(CONFIG_BATTERY_AGE_FORECAST_DETACHABLE)
+		", Cycle(%dw)"
+#else
+		", Cycle(%d)"
+#endif
+#endif
+		 "\n", __func__,
+		 sec_bat_status_str[battery->status],
+		 sec_bat_charging_mode_str[battery->charging_mode],
+		 sec_bat_health_str[battery->health],
+		 battery->cable_type, battery->siop_level
+#if defined(CONFIG_AFC_CHARGER_MODE)
+		, battery->hv_chg_name, sleep_mode
+#endif
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+		, battery->batt_cycle
+#endif
+		 );
+#if defined(CONFIG_SAMSUNG_BATTERY_ENG_TEST)
+	dev_info(battery->dev,
+			"%s: battery->stability_test(%d), battery->eng_not_full_status(%d)\n",
+			__func__, battery->stability_test, battery->eng_not_full_status);
+#endif
+#if defined(CONFIG_SEC_FACTORY)
+	if (battery->pdata->factory_store_mode_en == true && (battery->cable_type != POWER_SUPPLY_TYPE_BATTERY) && (battery->cable_type != POWER_SUPPLY_TYPE_OTG)) {
+#else
+	if (battery->store_mode && battery->cable_type != POWER_SUPPLY_TYPE_BATTERY) {
+#endif
+		dev_info(battery->dev,
+			"%s: @battery->capacity = (%d), battery->status= (%d), battery->store_mode=(%d)\n",
+			__func__, battery->capacity, battery->status, battery->store_mode);
+
+		if ((battery->capacity >= STORE_MODE_CHARGING_MAX) && (battery->status == POWER_SUPPLY_STATUS_CHARGING)) {
+			sec_bat_set_charging_status(battery,
+					POWER_SUPPLY_STATUS_DISCHARGING);
+			sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING_OFF);
+		}
+		if ((battery->capacity <= STORE_MODE_CHARGING_MIN) && (battery->status == POWER_SUPPLY_STATUS_DISCHARGING)) {
+			sec_bat_set_charging_status(battery,
+					POWER_SUPPLY_STATUS_CHARGING);
+			if (battery->siop_level != 100)
+				battery->stop_timer = true;
+			sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING);
+		}
+	}
+	power_supply_changed(&battery->psy_bat);
+
+skip_monitor:
+	sec_bat_set_polling(battery);
+
+	if (battery->capacity <= 0 || battery->health_change)
+		wake_lock_timeout(&battery->monitor_wake_lock, HZ * 5);
+	else
+		wake_unlock(&battery->monitor_wake_lock);
+
+	dev_dbg(battery->dev, "%s: End\n", __func__);
+
+	return;
+}
+
+static enum alarmtimer_restart sec_bat_alarm(
+	struct alarm *alarm, ktime_t now)
+{
+	struct sec_battery_info *battery = container_of(alarm,
+				struct sec_battery_info, polling_alarm);
+
+	dev_dbg(battery->dev,
+			"%s\n", __func__);
+
+	/* In wake up, monitor work will be queued in complete function
+	 * To avoid duplicated queuing of monitor work,
+	 * do NOT queue monitor work in wake up by polling alarm
+	 */
+	if (!battery->polling_in_sleep) {
+		wake_lock(&battery->monitor_wake_lock);
+		queue_delayed_work_on(0, battery->monitor_wqueue, &battery->monitor_work, 0);
+		dev_dbg(battery->dev, "%s: Activated\n", __func__);
+	}
+
+	return ALARMTIMER_NORESTART;
+}
+
+static void sec_bat_check_input_voltage(struct sec_battery_info *battery)
+{
+
+	if (battery->cable_type == POWER_SUPPLY_TYPE_HV_MAINS)
+		battery->input_voltage = SEC_INPUT_VOLTAGE_9V;
+	else
+		battery->input_voltage = SEC_INPUT_VOLTAGE_5V;
+
+	pr_info("%s: battery->input_voltage : %dV\n", __func__, battery->input_voltage);
+}
+
+static void sec_bat_cable_work(struct work_struct *work)
+{
+	struct sec_battery_info *battery = container_of(work,
+				struct sec_battery_info, cable_work.work);
+	union power_supply_propval val;
+	int current_cable_type;
+
+	dev_info(battery->dev, "%s: Start\n", __func__);
+
+	if (battery->wc_status && battery->wc_enable) {
+		int wl_cur, wr_cur;
+		if (battery->wc_status == SEC_WIRELESS_PAD_WPC)
+			current_cable_type = POWER_SUPPLY_TYPE_WIRELESS;
+		else if (battery->wc_status == SEC_WIRELESS_PAD_WPC_HV)
+			current_cable_type = POWER_SUPPLY_TYPE_HV_WIRELESS;
+		else if (battery->wc_status == SEC_WIRELESS_PAD_WPC_PACK)
+			current_cable_type = POWER_SUPPLY_TYPE_WIRELESS_PACK;
+		else if (battery->wc_status == SEC_WIRELESS_PAD_WPC_PACK_TA)
+			current_cable_type = POWER_SUPPLY_TYPE_WIRELESS_PACK_TA;
+		else
+			current_cable_type = POWER_SUPPLY_TYPE_PMA_WIRELESS;
+		wl_cur = battery->pdata->charging_current[
+			current_cable_type].input_current_limit;
+		wr_cur = battery->pdata->charging_current[
+			battery->wire_status].input_current_limit;
+		if (wl_cur <= wr_cur)
+			current_cable_type = battery->wire_status;
+	} else
+		current_cable_type = battery->wire_status;
+
+	if ((current_cable_type == battery->cable_type) && !battery->slate_mode) {
+		dev_dbg(battery->dev,
+				"%s: Cable is NOT Changed(%d)\n",
+				__func__, battery->cable_type);
+		/* Do NOT activate cable work for NOT changed */
+		goto end_of_cable_work;
+	}
+
+#if defined(CONFIG_BATTERY_SWELLING)
+	if ((current_cable_type == POWER_SUPPLY_TYPE_BATTERY) ||
+		(battery->cable_type == POWER_SUPPLY_TYPE_BATTERY && battery->swelling_mode == SWELLING_MODE_NONE)) {
+		battery->swelling_mode = SWELLING_MODE_NONE;
+		/* restore 4.4V float voltage */
+		val.intval = battery->pdata->swelling_normal_float_voltage;
+		psy_do_property(battery->pdata->charger_name, set,
+			POWER_SUPPLY_PROP_VOLTAGE_MAX, val);
+		pr_info("%s: float voltage = %d\n", __func__, val.intval);
+	} else {
+		pr_info("%s: skip  float_voltage setting, swelling_mode(%d)\n",
+			__func__, battery->swelling_mode);
+	}
+#endif
+
+	battery->cable_type = current_cable_type;
+#if defined(CONFIG_CALC_TIME_TO_FULL)
+	battery->complete_timetofull = false;
+#endif
+	if (battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS ||
+		battery->cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS ||
+		battery->cable_type == POWER_SUPPLY_TYPE_PMA_WIRELESS ||
+		battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK ||
+		battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK_TA) {
+		power_supply_changed(&battery->psy_bat);
+		/* After 10sec wireless charging, Vrect headroom has to be reduced */
+		wake_lock(&battery->wc_headroom_wake_lock);
+		queue_delayed_work_on(0, battery->monitor_wqueue, &battery->wc_headroom_work,
+			msecs_to_jiffies(10000));
+	}
+
+	if (battery->pdata->check_cable_result_callback)
+		battery->pdata->check_cable_result_callback(
+			battery->cable_type);
+	/* platform can NOT get information of cable connection
+	 * because wakeup time is too short to check uevent
+	 * To make sure that target is wakeup
+	 * if cable is connected and disconnected,
+	 * activated wake lock in a few seconds
+	 */
+	wake_lock_timeout(&battery->vbus_wake_lock, HZ * 10);
+
+	if (battery->cable_type == POWER_SUPPLY_TYPE_BATTERY ||
+		((battery->pdata->cable_check_type &
+		SEC_BATTERY_CABLE_CHECK_NOINCOMPATIBLECHARGE) &&
+		battery->cable_type == POWER_SUPPLY_TYPE_UNKNOWN)) {
+		battery->charging_mode = SEC_BATTERY_CHARGING_NONE;
+		battery->is_recharging = false;
+		sec_bat_set_charging_status(battery,
+				POWER_SUPPLY_STATUS_DISCHARGING);
+		battery->health = POWER_SUPPLY_HEALTH_GOOD;
+		battery->wpc_temp_mode = false;
+#if defined(CONFIG_CALC_TIME_TO_FULL)
+		cancel_delayed_work(&battery->timetofull_work);
+#endif
+		battery->skip_chg_temp_check = false;
+		battery->skip_wpc_temp_check = false;
+		battery->wc_cv_mode = false;
+		battery->wc_pack_max_curr = false;
+		if (sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING_OFF))
+			goto end_of_cable_work;
+	} else if (battery->slate_mode == true) {
+		sec_bat_set_charging_status(battery,
+				POWER_SUPPLY_STATUS_DISCHARGING);
+		battery->cable_type = POWER_SUPPLY_TYPE_BATTERY;
+
+		val.intval = 0;
+		psy_do_property(battery->pdata->charger_name, set,
+			POWER_SUPPLY_PROP_CURRENT_NOW, val);
+
+		dev_info(battery->dev,
+			"%s:slate mode on\n",__func__);
+
+		if (sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_BUCK_OFF))
+			goto end_of_cable_work;
+	} else {
+#if defined(CONFIG_EN_OOPS)
+		val.intval = battery->cable_type;
+		psy_do_property(battery->pdata->fuelgauge_name, set,
+				POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN, val);
+#endif
+		/* Do NOT display the charging icon when OTG or HMT_CONNECTED is enabled */
+		if (battery->cable_type == POWER_SUPPLY_TYPE_OTG ||
+			battery->cable_type == POWER_SUPPLY_TYPE_POWER_SHARING) {
+			battery->charging_mode = SEC_BATTERY_CHARGING_NONE;
+			battery->status = POWER_SUPPLY_STATUS_DISCHARGING;
+		} else {
+			if (battery->pdata->full_check_type !=
+				SEC_BATTERY_FULLCHARGED_NONE)
+				battery->charging_mode =
+					SEC_BATTERY_CHARGING_1ST;
+			else
+				battery->charging_mode =
+					SEC_BATTERY_CHARGING_2ND;
+
+			if (battery->status == POWER_SUPPLY_STATUS_FULL)
+				sec_bat_set_charging_status(battery,
+						POWER_SUPPLY_STATUS_FULL);
+			else
+				sec_bat_set_charging_status(battery,
+						POWER_SUPPLY_STATUS_CHARGING);
+		}
+
+#if defined(CONFIG_AFC_CHARGER_MODE)
+		if (battery->cable_type == POWER_SUPPLY_TYPE_MAINS ||
+			battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS ||
+			battery->cable_type == POWER_SUPPLY_TYPE_PMA_WIRELESS ||
+			battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK ||
+			battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK_TA) {
+			battery->current_event |= SEC_BAT_CURRENT_EVENT_AFC;
+		} else {
+			battery->current_event &= ~SEC_BAT_CURRENT_EVENT_AFC;
+		}
+#endif
+
+		if (battery->cable_type == POWER_SUPPLY_TYPE_OTG ||
+			battery->cable_type == POWER_SUPPLY_TYPE_POWER_SHARING) {
+			if (sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING_OFF))
+				goto end_of_cable_work;
+		} else {
+			if (sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING))
+				goto end_of_cable_work;
+		}
+
+#if defined(CONFIG_CALC_TIME_TO_FULL)
+		battery->complete_timetofull = false;
+		queue_delayed_work_on(0, battery->monitor_wqueue, &battery->timetofull_work,
+					msecs_to_jiffies(7000));
+#endif
+		if (battery->pdata->chg_temp_check &&
+			(battery->cable_type == POWER_SUPPLY_TYPE_HV_MAINS ||
+			battery->cable_type == POWER_SUPPLY_TYPE_HV_MAINS_12V ||
+			battery->cable_type == POWER_SUPPLY_TYPE_HV_ERR ) &&
+			battery->capacity <= battery->pdata->chg_skip_check_capacity) {
+				battery->skip_chg_temp_check = true;
+				dev_info(battery->dev,
+					"%s: skip_chg_temp_check(%d), Charging Time : %ld secs, soc(%d)\n",
+					__func__,
+					battery->skip_chg_temp_check,
+					battery->charging_passed_time,
+					battery->capacity);
+		}
+		if (battery->pdata->wpc_temp_check &&
+			(battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS ||
+			battery->cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS ||
+			battery->cable_type == POWER_SUPPLY_TYPE_PMA_WIRELESS ||
+			battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK ||
+			battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK_TA) &&
+			battery->capacity <= battery->pdata->wpc_skip_check_capacity) {
+				battery->skip_wpc_temp_check = true;
+				dev_info(battery->dev,
+					"%s: skip_wpc_temp_check(%d), Charging Time : %ld secs, soc(%d)\n",
+					__func__,
+					battery->skip_wpc_temp_check,
+					battery->charging_passed_time,
+					battery->capacity);
+		}
+	}
+
+	/* set online(cable type) */
+	val.intval = battery->cable_type;
+	psy_do_property(battery->pdata->charger_name, set,
+		POWER_SUPPLY_PROP_ONLINE, val);
+	psy_do_property(battery->pdata->fuelgauge_name, set,
+		POWER_SUPPLY_PROP_ONLINE, val);
+	if (battery->status != POWER_SUPPLY_STATUS_DISCHARGING)
+		sec_bat_check_input_voltage(battery);
+
+	/* update charging current */
+	psy_do_property(battery->pdata->charger_name, get,
+		POWER_SUPPLY_PROP_CURRENT_NOW, val);
+	battery->charging_current = val.intval;
+	/* set charging current */
+	sec_bat_set_charging_current(battery);
+
+	/* polling time should be reset when cable is changed
+	 * polling_in_sleep should be reset also
+	 * before polling time is re-calculated
+	 * to prevent from counting 1 for events
+	 * right after cable is connected
+	 */
+	battery->polling_in_sleep = false;
+	sec_bat_get_polling_time(battery);
+
+	dev_info(battery->dev,
+		"%s: Status:%s, Sleep:%s, Charging:%s, Short Poll:%s\n",
+		__func__, sec_bat_status_str[battery->status],
+		battery->polling_in_sleep ? "Yes" : "No",
+		(battery->charging_mode ==
+		SEC_BATTERY_CHARGING_NONE) ? "No" : "Yes",
+		battery->polling_short ? "Yes" : "No");
+	dev_info(battery->dev,
+		"%s: Polling time is reset to %d sec.\n", __func__,
+		battery->polling_time);
+
+	battery->polling_count = 1;	/* initial value = 1 */
+
+	wake_lock(&battery->monitor_wake_lock);
+	queue_delayed_work_on(0, battery->monitor_wqueue, &battery->monitor_work, 0);
+end_of_cable_work:
+	wake_unlock(&battery->cable_wake_lock);
+	dev_dbg(battery->dev, "%s: End\n", __func__);
+}
+
+static void sec_bat_afc_work(struct work_struct *work)
+{
+	struct sec_battery_info *battery = container_of(work,
+				struct sec_battery_info, afc_work.work);
+	union power_supply_propval value;
+
+	psy_do_property(battery->pdata->charger_name, get,
+		POWER_SUPPLY_PROP_CURRENT_MAX, value);
+	battery->current_max = value.intval;
+
+	if (battery->current_event & SEC_BAT_CURRENT_EVENT_AFC &&
+		battery->cable_type == POWER_SUPPLY_TYPE_MAINS) {
+		battery->current_event &= ~SEC_BAT_CURRENT_EVENT_AFC;
+		if (battery->current_max >= battery->pdata->pre_afc_input_current)
+			sec_bat_set_charging_current(battery);
+	}
+	wake_unlock(&battery->afc_wake_lock);
+}
+
+static void sec_bat_wc_afc_work(struct work_struct *work)
+{
+	struct sec_battery_info *battery = container_of(work,
+				struct sec_battery_info, wc_afc_work.work);
+	union power_supply_propval value;
+
+	pr_info("%s\n", __func__);
+	psy_do_property(battery->pdata->charger_name, get,
+			POWER_SUPPLY_PROP_CURRENT_MAX, value);
+		battery->current_max = value.intval;
+
+	if (battery->current_event & SEC_BAT_CURRENT_EVENT_AFC &&
+		(battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS ||
+		battery->cable_type == POWER_SUPPLY_TYPE_PMA_WIRELESS ||
+		battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK ||
+		battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK_TA)) {
+		battery->current_event &= ~SEC_BAT_CURRENT_EVENT_AFC;
+		if (battery->current_max >= battery->pdata->pre_wc_afc_input_current)
+			sec_bat_set_charging_current(battery);
+	}
+	wake_unlock(&battery->afc_wake_lock);
+}
+
+ssize_t sec_bat_show_attrs(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct sec_battery_info *battery =
+		container_of(psy, struct sec_battery_info, psy_bat);
+	const ptrdiff_t offset = attr - sec_battery_attrs;
+	union power_supply_propval value;
+	int i = 0;
+	int ret = 0;
+
+	switch (offset) {
+	case BATT_RESET_SOC:
+		break;
+	case BATT_READ_RAW_SOC:
+		{
+			union power_supply_propval value;
+
+			value.intval =
+				SEC_FUELGAUGE_CAPACITY_TYPE_RAW;
+			psy_do_property(battery->pdata->fuelgauge_name, get,
+				POWER_SUPPLY_PROP_CAPACITY, value);
+
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				value.intval);
+		}
+		break;
+	case BATT_READ_ADJ_SOC:
+		break;
+	case BATT_TYPE:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%s\n",
+			battery->pdata->vendor);
+		break;
+	case BATT_VFOCV:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			battery->voltage_ocv);
+		break;
+	case BATT_VOL_ADC:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			battery->inbat_adc);
+		break;
+	case BATT_VOL_ADC_CAL:
+		break;
+	case BATT_VOL_AVER:
+		break;
+	case BATT_VOL_ADC_AVER:
+		break;
+
+	case BATT_CURRENT_UA_NOW:
+		{
+			union power_supply_propval value;
+
+			value.intval = SEC_BATTERY_CURRENT_UA;
+			psy_do_property(battery->pdata->fuelgauge_name, get,
+				POWER_SUPPLY_PROP_CURRENT_NOW, value);
+
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				value.intval);
+		}
+		break;
+	case BATT_CURRENT_UA_AVG:
+		{
+			union power_supply_propval value;
+
+			value.intval = SEC_BATTERY_CURRENT_UA;
+			psy_do_property(battery->pdata->fuelgauge_name, get,
+				POWER_SUPPLY_PROP_CURRENT_AVG, value);
+
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				value.intval);
+		}
+		break;
+
+	case BATT_TEMP:
+		switch (battery->pdata->thermal_source) {
+		case SEC_BATTERY_THERMAL_SOURCE_FG:
+			psy_do_property(battery->pdata->fuelgauge_name, get,
+				POWER_SUPPLY_PROP_TEMP, value);
+			break;
+		case SEC_BATTERY_THERMAL_SOURCE_CALLBACK:
+			if (battery->pdata->get_temperature_callback) {
+			battery->pdata->get_temperature_callback(
+				POWER_SUPPLY_PROP_TEMP, &value);
+			}
+			break;
+		case SEC_BATTERY_THERMAL_SOURCE_ADC:
+			sec_bat_get_temperature_by_adc(battery,
+				SEC_BAT_ADC_CHANNEL_TEMP, &value);
+			break;
+		default:
+			break;
+		}
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			value.intval);
+		break;
+	case BATT_TEMP_ADC:
+		/*
+			If F/G is used for reading the temperature and
+			compensation table is used,
+			the raw value that isn't compensated can be read by
+			POWER_SUPPLY_PROP_TEMP_AMBIENT
+		 */
+		switch (battery->pdata->thermal_source) {
+		case SEC_BATTERY_THERMAL_SOURCE_FG:
+			psy_do_property(battery->pdata->fuelgauge_name, get,
+				POWER_SUPPLY_PROP_TEMP_AMBIENT, value);
+			battery->temp_adc = value.intval;
+			break;
+		default:
+			break;
+		}
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			battery->temp_adc);
+		break;
+	case BATT_TEMP_AVER:
+		break;
+	case BATT_TEMP_ADC_AVER:
+		break;
+	case BATT_CHG_TEMP:
+		if (battery->pdata->chg_thermal_source) {
+			sec_bat_get_temperature_by_adc(battery,
+				       SEC_BAT_ADC_CHANNEL_CHG_TEMP, &value);
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				       value.intval);
+		} else {
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				       0);
+		}
+		break;
+	case BATT_CHG_TEMP_ADC:
+		if (battery->pdata->chg_thermal_source) {
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				       battery->chg_temp_adc);
+		} else {
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				       0);
+		}
+		break;
+	case BATT_SLAVE_CHG_TEMP:
+		if (battery->pdata->slave_thermal_source) {
+			sec_bat_get_temperature_by_adc(battery,
+						   SEC_BAT_ADC_CHANNEL_SLAVE_CHG_TEMP, &value);
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+					   value.intval);
+		} else {
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+					   0);
+		}
+		break;
+	case BATT_SLAVE_CHG_TEMP_ADC:
+		if (battery->pdata->slave_thermal_source) {
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+					   battery->slave_chg_temp_adc);
+		} else {
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+					   0);
+		}
+		break;
+	case BATT_VF_ADC:
+		break;
+	case BATT_SLATE_MODE:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			battery->slate_mode);
+		break;
+
+	case BATT_LP_CHARGING:
+		if (lpcharge) {
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				       lpcharge ? 1 : 0);
+		}
+		break;
+	case SIOP_ACTIVATED:
+		break;
+	case SIOP_LEVEL:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			battery->siop_level);
+		break;
+	case SIOP_EVENT:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			battery->siop_event);
+		break;
+	case BATT_CHARGING_SOURCE:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			battery->cable_type);
+		break;
+	case FG_REG_DUMP:
+		break;
+	case FG_RESET_CAP:
+		break;
+	case FG_CAPACITY:
+	{
+		union power_supply_propval value;
+
+		value.intval =
+			SEC_BATTERY_CAPACITY_DESIGNED;
+		psy_do_property(battery->pdata->fuelgauge_name, get,
+			POWER_SUPPLY_PROP_ENERGY_NOW, value);
+
+		i += scnprintf(buf + i, PAGE_SIZE - i, "0x%04x ",
+			value.intval);
+
+		value.intval =
+			SEC_BATTERY_CAPACITY_ABSOLUTE;
+		psy_do_property(battery->pdata->fuelgauge_name, get,
+			POWER_SUPPLY_PROP_ENERGY_NOW, value);
+
+		i += scnprintf(buf + i, PAGE_SIZE - i, "0x%04x ",
+			value.intval);
+
+		value.intval =
+			SEC_BATTERY_CAPACITY_TEMPERARY;
+		psy_do_property(battery->pdata->fuelgauge_name, get,
+			POWER_SUPPLY_PROP_ENERGY_NOW, value);
+
+		i += scnprintf(buf + i, PAGE_SIZE - i, "0x%04x ",
+			value.intval);
+
+		value.intval =
+			SEC_BATTERY_CAPACITY_CURRENT;
+		psy_do_property(battery->pdata->fuelgauge_name, get,
+			POWER_SUPPLY_PROP_ENERGY_NOW, value);
+
+		i += scnprintf(buf + i, PAGE_SIZE - i, "0x%04x\n",
+			value.intval);
+	}
+		break;
+	case FG_ASOC:
+		value.intval = -1;
+		{
+			struct power_supply *psy_fg;
+			psy_fg = get_power_supply_by_name(battery->pdata->fuelgauge_name);
+			if (!psy_fg) {
+				pr_err("%s: Fail to get psy (%s)\n",
+						__func__, battery->pdata->fuelgauge_name);
+			} else {
+				if (psy_fg->get_property != NULL) {
+					ret = psy_fg->get_property(psy_fg,
+							POWER_SUPPLY_PROP_ENERGY_FULL, &value);
+					if (ret < 0) {
+						pr_err("%s: Fail to %s get (%d=>%d)\n",
+								__func__, battery->pdata->fuelgauge_name,
+								POWER_SUPPLY_PROP_ENERGY_FULL, ret);
+					}
+				}
+			}
+		}
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			       value.intval);
+		break;
+	case AUTH:
+		break;
+	case CHG_CURRENT_ADC:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			battery->current_adc);
+		break;
+	case WC_ADC:
+		break;
+	case WC_STATUS:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			((battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS) ||
+			(battery->cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS) ||
+			(battery->cable_type == POWER_SUPPLY_TYPE_PMA_WIRELESS) ||
+			(battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK) ||
+			(battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK_TA)) ? 1: 0);
+		break;
+	case WC_ENABLE:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			battery->wc_enable);
+		break;
+	case WC_CONTROL:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			battery->wc_enable);
+		break;
+	case HV_CHARGER_STATUS:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			((battery->cable_type == POWER_SUPPLY_TYPE_HV_MAINS) ||
+			(battery->cable_type == POWER_SUPPLY_TYPE_HV_MAINS_12V) ||
+			(battery->cable_type == POWER_SUPPLY_TYPE_HV_ERR)) ? 1 : 0);
+		break;
+	case HV_WC_CHARGER_STATUS:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			(battery->cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS ? 1 : 0));
+		break;
+	case HV_CHARGER_SET:
+		break;
+	case FACTORY_MODE:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			battery->factory_mode);
+		break;
+	case STORE_MODE:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			battery->store_mode);
+		break;
+	case UPDATE:
+		break;
+	case TEST_MODE:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			battery->test_mode);
+		break;
+
+	case BATT_EVENT_CALL:
+	case BATT_EVENT_2G_CALL:
+	case BATT_EVENT_TALK_GSM:
+		break;
+	case BATT_EVENT_3G_CALL:
+	case BATT_EVENT_TALK_WCDMA:
+		break;
+	case BATT_EVENT_MUSIC:
+		break;
+	case BATT_EVENT_VIDEO:
+		break;
+	case BATT_EVENT_BROWSER:
+		break;
+	case BATT_EVENT_HOTSPOT:
+		break;
+	case BATT_EVENT_CAMERA:
+		break;
+	case BATT_EVENT_CAMCORDER:
+		break;
+	case BATT_EVENT_DATA_CALL:
+		break;
+	case BATT_EVENT_WIFI:
+		break;
+	case BATT_EVENT_WIBRO:
+		break;
+	case BATT_EVENT_LTE:
+		break;
+	case BATT_EVENT_LCD:
+		break;
+	case BATT_EVENT_GPS:
+		break;
+	case BATT_EVENT:
+		break;
+	case BATT_TEMP_TABLE:
+		i += scnprintf(buf + i, PAGE_SIZE - i,
+			"%d %d %d %d %d %d %d %d\n",
+			battery->pdata->temp_high_threshold_normal,
+			battery->pdata->temp_high_recovery_normal,
+			battery->pdata->temp_low_threshold_normal,
+			battery->pdata->temp_low_recovery_normal,
+			battery->pdata->temp_high_threshold_lpm,
+			battery->pdata->temp_high_recovery_lpm,
+			battery->pdata->temp_low_threshold_lpm,
+			battery->pdata->temp_low_recovery_lpm);
+		break;
+	case BATT_HIGH_CURRENT_USB:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			battery->is_hc_usb);
+		break;
+#if defined(CONFIG_SAMSUNG_BATTERY_ENG_TEST)
+	case BATT_TEST_CHARGE_CURRENT:
+		{
+			union power_supply_propval value;
+
+			psy_do_property(battery->pdata->charger_name, get,
+				POWER_SUPPLY_PROP_CURRENT_NOW, value);
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+					value.intval);
+		}
+		break;
+#endif
+	case BATT_STABILITY_TEST:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			battery->stability_test);
+		break;
+	case BATT_CAPACITY_MAX:
+		psy_do_property(battery->pdata->fuelgauge_name, get,
+				POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN, value);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n", value.intval);
+		break;
+	case BATT_INBAT_VOLTAGE:
+		if(battery->pdata->support_fgsrc_change == true) 
+		{
+			value.intval = 0;
+
+			if (strcmp(battery->pdata->fgsrc_switch_name, "sm5705-fuelgauge")==0)
+			{
+				pr_info("%s SM5705_FGSRC_SWITCH \n", __func__);
+				psy_do_property(battery->pdata->fuelgauge_name, get,
+						POWER_SUPPLY_PROP_INBAT_VOLTAGE_FGSRC_SWITCHING, value);
+				ret = value.intval;
+			}
+			else{
+				psy_do_property(battery->pdata->fgsrc_switch_name, set,
+						POWER_SUPPLY_PROP_ENERGY_NOW, value);
+				mdelay(200);
+				psy_do_property(battery->pdata->fuelgauge_name, get,
+						POWER_SUPPLY_PROP_VOLTAGE_NOW, value);
+				dev_info(battery->dev, "voltage(%d)\n", value.intval/10);
+				ret = value.intval /10;
+				mdelay(200);
+				value.intval = 1;
+				psy_do_property(battery->pdata->fgsrc_switch_name, set,
+						POWER_SUPPLY_PROP_ENERGY_NOW, value);
+			} 
+		}
+		else{
+			ret = sec_bat_get_inbat_vol_by_adc(battery);
+		}
+		dev_info(battery->dev, "in-battery voltage(%d)\n", ret);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				ret);
+		break;
+#if defined(CONFIG_BATTERY_SWELLING_SELF_DISCHARGING)
+	case BATT_DISCHARGING_CHECK:
+		ret = gpio_get_value(battery->pdata->factory_discharging);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+					ret);
+		break;
+	case BATT_DISCHARGING_CHECK_ADC:
+		sec_bat_self_discharging_check(battery);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			       battery->self_discharging_adc);
+		break;
+	case BATT_DISCHARGING_NTC:
+		sec_bat_self_discharging_ntc_check(battery);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			       battery->discharging_ntc);
+		break;
+	case BATT_DISCHARGING_NTC_ADC:
+		sec_bat_self_discharging_ntc_check(battery);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			       battery->discharging_ntc_adc);
+		break;
+	case BATT_SELF_DISCHARGING_CONTROL:
+		break;
+#endif
+#if defined(CONFIG_SW_SELF_DISCHARGING)
+	case BATT_SW_SELF_DISCHARGING:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			       battery->sw_self_discharging);
+		break;
+#endif
+	case BATT_INBAT_WIRELESS_CS100:
+		psy_do_property(battery->pdata->wireless_charger_name, get,
+			POWER_SUPPLY_PROP_STATUS, value);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n", value.intval);
+		break;
+	case SAFETY_TIMER_SET:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			       battery->safety_timer_set);
+		break;
+	case HMT_TA_CONNECTED:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			(battery->cable_type == POWER_SUPPLY_TYPE_HMT_CONNECTED) ? 1 : 0);
+		break;
+	case HMT_TA_CHARGE:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			(battery->cable_type == POWER_SUPPLY_TYPE_HMT_CHARGE) ? 1 : 0);
+		break;
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	case FG_CYCLE:
+		value.intval = SEC_BATTERY_CAPACITY_CYCLE;
+		psy_do_property(battery->pdata->fuelgauge_name, get,
+			POWER_SUPPLY_PROP_ENERGY_NOW, value);
+		value.intval = value.intval / 100;
+		dev_info(battery->dev, "fg cycle(%d)\n", value.intval);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n", value.intval);
+		break;
+	case FG_FULLCAPNOM:
+		value.intval =
+			SEC_BATTERY_CAPACITY_AGEDCELL;
+		psy_do_property(battery->pdata->fuelgauge_name, get,
+			POWER_SUPPLY_PROP_ENERGY_NOW, value);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n", value.intval/2);
+		break;
+#if defined(CONFIG_BATTERY_AGE_FORECAST_DETACHABLE)
+	case BATT_AFTER_MANUFACTURED:
+#if defined(CONFIG_ENG_BATTERY_CONCEPT) || defined(CONFIG_SEC_FACTORY)
+	case BATTERY_CYCLE:
+#endif
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n", battery->batt_cycle);
+		break;
+#else
+	case BATTERY_CYCLE:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n", battery->batt_cycle);
+		break;
+#endif
+#endif
+	case FG_FULL_VOLTAGE:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n", battery->pdata->chg_float_voltage);
+		break;
+	case BATT_WPC_TEMP:
+		if (battery->pdata->wpc_thermal_source) {
+			sec_bat_get_temperature_by_adc(battery,
+				SEC_BAT_ADC_CHANNEL_WPC_TEMP, &value);
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				value.intval);
+		} else {
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				0);
+		}
+		break;
+	case BATT_WPC_TEMP_ADC:
+		if (battery->pdata->wpc_thermal_source) {
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				battery->wpc_temp_adc);
+		} else {
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				0);
+		}
+		break;
+#if defined(CONFIG_WIRELESS_FIRMWARE_UPDATE)
+	case BATT_WIRELESS_FIRMWARE_UPDATE:
+		value.intval = SEC_WIRELESS_OTP_FIRM_VERIFY;
+		psy_do_property(battery->pdata->wireless_charger_name, get,
+			POWER_SUPPLY_PROP_MANUFACTURER, value);
+		pr_info("%s RX firmware verify. result: %d\n", __func__, value.intval);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n", value.intval);
+		break;
+	case BATT_WIRELESS_OTP_FIRMWARE_RESULT:
+		value.intval = SEC_WIRELESS_OTP_FIRM_RESULT;
+		psy_do_property(battery->pdata->wireless_charger_name, get,
+			POWER_SUPPLY_PROP_MANUFACTURER, value);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n", value.intval);
+		break;
+	case BATT_WIRELESS_IC_GRADE:
+		value.intval = SEC_WIRELESS_IC_REVISION;
+		psy_do_property(battery->pdata->wireless_charger_name, get,
+			POWER_SUPPLY_PROP_MANUFACTURER, value);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "0x%x ", value.intval);
+
+		value.intval = SEC_WIRELESS_IC_GRADE;
+		psy_do_property(battery->pdata->wireless_charger_name, get,
+			POWER_SUPPLY_PROP_MANUFACTURER, value);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "0x%x\n", value.intval);
+		break;
+	case BATT_WIRELESS_FIRMWARE_VER_BIN:
+		value.intval = SEC_WIRELESS_OTP_FIRM_VER_BIN;
+		psy_do_property(battery->pdata->wireless_charger_name, get,
+			POWER_SUPPLY_PROP_MANUFACTURER, value);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%x\n", value.intval);
+		break;
+	case BATT_WIRELESS_FIRMWARE_VER:
+		value.intval = SEC_WIRELESS_OTP_FIRM_VER;
+		psy_do_property(battery->pdata->wireless_charger_name, get,
+			POWER_SUPPLY_PROP_MANUFACTURER, value);
+
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%x\n", value.intval);
+		break;
+	case BATT_WIRELESS_TX_FIRMWARE_RESULT:
+		value.intval = SEC_WIRELESS_TX_FIRM_RESULT;
+		psy_do_property(battery->pdata->wireless_charger_name, get,
+			POWER_SUPPLY_PROP_MANUFACTURER, value);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n", value.intval);
+		break;
+	case BATT_WIRELESS_TX_FIRMWARE_VER:
+		value.intval = SEC_WIRELESS_TX_FIRM_VER;
+		psy_do_property(battery->pdata->wireless_charger_name, get,
+			POWER_SUPPLY_PROP_MANUFACTURER, value);
+
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%x\n", value.intval);
+		break;
+	case BATT_TX_STATUS:
+		value.intval = SEC_TX_FIRMWARE;
+		psy_do_property(battery->pdata->wireless_charger_name, get,
+			POWER_SUPPLY_PROP_MANUFACTURER, value);
+
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%x\n", value.intval);
+		break;
+#endif
+	case BATT_WIRELESS_VOUT:
+		psy_do_property(battery->pdata->wireless_charger_name, get,
+			POWER_SUPPLY_PROP_ENERGY_NOW, value);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n", value.intval);
+		break;
+	case BATT_WIRELESS_VRCT:
+		psy_do_property(battery->pdata->wireless_charger_name, get,
+			POWER_SUPPLY_PROP_ENERGY_AVG, value);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n", value.intval);
+		break;
+	case BATT_HV_WIRELESS_STATUS:
+		psy_do_property(battery->pdata->wireless_charger_name, get,
+			POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n", value.intval);
+		break;
+	case BATT_HV_WIRELESS_PAD_CTRL:
+		break;
+	case BATT_TUNE_FLOAT_VOLTAGE:
+		ret = battery->pdata->chg_float_voltage;
+		pr_info("%s float voltage = %d mA",__func__, ret);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				ret);
+		break;
+	case BATT_TUNE_INPUT_CHARGE_CURRENT:
+		ret = battery->pdata->charging_current[i].input_current_limit;
+		pr_info("%s input charge current = %d mA",__func__, ret);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				ret);
+		break;
+	case BATT_TUNE_FAST_CHARGE_CURRENT:
+		ret = battery->pdata->charging_current[i].fast_charging_current;
+		pr_info("%s fast charge current = %d mA",__func__, ret);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				ret);
+		break;
+	case BATT_TUNE_UI_TERM_CURRENT_1ST:
+		ret = battery->pdata->charging_current[i].full_check_current_1st;
+		pr_info("%s ui term current = %d mA",__func__, ret);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				ret);
+		break;
+	case BATT_TUNE_UI_TERM_CURRENT_2ND:
+		ret = battery->pdata->charging_current[i].full_check_current_1st;
+		pr_info("%s ui term current = %d mA",__func__, ret);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				ret);
+		break;
+	case BATT_TUNE_TEMP_HIGH_NORMAL:
+		ret = battery->pdata->temp_high_threshold_normal;
+		pr_info("%s temp high normal block	= %d ",__func__, ret);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				ret);
+		break;
+	case BATT_TUNE_TEMP_HIGH_REC_NORMAL:
+		ret = battery->pdata->temp_high_recovery_normal;
+		pr_info("%s temp high normal recover  = %d ",__func__, ret);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				ret);
+		break;
+	case BATT_TUNE_TEMP_LOW_NORMAL:
+		ret = battery->pdata->temp_low_threshold_normal;
+		pr_info("%s temp low normal block  = %d ",__func__, ret);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				ret);
+		break;
+	case BATT_TUNE_TEMP_LOW_REC_NORMAL:
+		ret = battery->pdata->temp_low_recovery_normal;
+		pr_info("%s temp low normal recover  = %d ",__func__, ret);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				ret);
+		break;
+	case BATT_TUNE_CHG_TEMP_HIGH:
+		ret = battery->pdata->chg_high_temp_1st;
+		pr_info("%s chg_high_temp_1st = %d ",__func__, ret);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				ret);
+		break;
+	case BATT_TUNE_CHG_TEMP_REC:
+		ret = battery->pdata->chg_high_temp_recovery;
+		pr_info("%s chg_high_temp_recovery	= %d ",__func__, ret);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				ret);
+		break;
+	case BATT_TUNE_CHG_LIMMIT_CURRENT:
+		ret = battery->pdata->chg_charging_limit_current;
+		pr_info("%s chg_charging_limit_current = %d ",__func__, ret);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				ret);
+		break;
+	case BATT_TUNE_COIL_TEMP_HIGH:
+		ret = battery->pdata->wpc_high_temp;
+		pr_info("%s wpc_high_temp = %d ",__func__, ret);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				ret);
+		break;
+	case BATT_TUNE_COIL_TEMP_REC:
+		ret = battery->pdata->wpc_high_temp_recovery;
+		pr_info("%s wpc_high_temp_recovery	= %d ",__func__, ret);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				ret);
+		break;
+	case BATT_TUNE_COIL_LIMMIT_CURRENT:
+		ret = battery->pdata->wpc_charging_limit_current;
+		pr_info("%s wpc_charging_limit_current = %d ",__func__, ret);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				ret);
+		break;
+#if defined(CONFIG_UPDATE_BATTERY_DATA)
+	case BATT_UPDATE_DATA:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%s\n",
+				battery->data_path ? "OK" : "NOK");
+		break;
+#endif
+	case BATT_MISC_EVENT:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				battery->misc_event);
+		break;
+	case BATT_WDT_CONTROL:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				battery->wdt_kick_disable);
+		break;
+	default:
+		i = -EINVAL;
+		break;
+	}
+
+	return i;
+}
+
+void update_external_temp_table(struct sec_battery_info *battery, int temp[])
+{
+	battery->pdata->temp_high_threshold_normal = temp[0];
+	battery->pdata->temp_high_recovery_normal = temp[1];
+	battery->pdata->temp_low_threshold_normal = temp[2];
+	battery->pdata->temp_low_recovery_normal = temp[3];
+	battery->pdata->temp_high_threshold_lpm = temp[4];
+	battery->pdata->temp_high_recovery_lpm = temp[5];
+	battery->pdata->temp_low_threshold_lpm = temp[6];
+	battery->pdata->temp_low_recovery_lpm = temp[7];
+
+}
+
+bool sec_bat_get_slate_mode(void)
+{
+	return slate_mode_state;
+}
+
+ssize_t sec_bat_store_attrs(
+					struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct sec_battery_info *battery =
+		container_of(psy, struct sec_battery_info, psy_bat);
+	const ptrdiff_t offset = attr - sec_battery_attrs;
+	int ret = -EINVAL;
+	int x = 0;
+	int t[12];
+	int i = 0;
+
+	switch (offset) {
+	case BATT_RESET_SOC:
+		/* Do NOT reset fuel gauge in charging mode */
+		if ((battery->cable_type == POWER_SUPPLY_TYPE_BATTERY) ||
+			battery->is_jig_on) {
+			union power_supply_propval value;
+			battery->voltage_now = 1234;
+			battery->voltage_avg = 1234;
+			power_supply_changed(&battery->psy_bat);
+
+			value.intval =
+				SEC_FUELGAUGE_CAPACITY_TYPE_RESET;
+			psy_do_property(battery->pdata->fuelgauge_name, set,
+					POWER_SUPPLY_PROP_CAPACITY, value);
+			dev_info(battery->dev,"do reset SOC\n");
+			/* update battery info */
+			sec_bat_get_battery_info(battery);
+		}
+		ret = count;
+		break;
+	case BATT_READ_RAW_SOC:
+		break;
+	case BATT_READ_ADJ_SOC:
+		break;
+	case BATT_TYPE:
+		break;
+	case BATT_VFOCV:
+		break;
+	case BATT_VOL_ADC:
+		break;
+	case BATT_VOL_ADC_CAL:
+		break;
+	case BATT_VOL_AVER:
+		break;
+	case BATT_VOL_ADC_AVER:
+		break;
+	case BATT_CURRENT_UA_NOW:
+		break;
+	case BATT_CURRENT_UA_AVG:
+		break;
+	case BATT_TEMP:
+		break;
+	case BATT_TEMP_ADC:
+		break;
+	case BATT_TEMP_AVER:
+		break;
+	case BATT_TEMP_ADC_AVER:
+		break;
+	case BATT_CHG_TEMP:
+		break;
+	case BATT_CHG_TEMP_ADC:
+		break;
+	case BATT_SLAVE_CHG_TEMP:
+		break;
+	case BATT_SLAVE_CHG_TEMP_ADC:
+		break;
+	case BATT_VF_ADC:
+		break;
+	case BATT_SLATE_MODE:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			if (x == 1) {
+				battery->slate_mode = true;
+			} else if (x == 0) {
+				battery->slate_mode = false;
+			} else {
+				dev_info(battery->dev,
+					"%s: SLATE MODE unknown command\n",
+					__func__);
+				return -EINVAL;
+			}
+			slate_mode_state = battery->slate_mode;
+			wake_lock(&battery->cable_wake_lock);
+			queue_delayed_work_on(0, battery->monitor_wqueue,
+					   &battery->cable_work, 0);
+			ret = count;
+		}
+		break;
+
+	case BATT_LP_CHARGING:
+		break;
+	case SIOP_ACTIVATED:
+		break;
+	case SIOP_LEVEL:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			dev_info(battery->dev,
+					"%s: siop level: %d\n", __func__, x);
+			battery->chg_limit = SEC_BATTERY_CHG_TEMP_NONE;
+			battery->wpc_temp_mode = false;
+			if (x == battery->siop_level && battery->capacity > 5) {
+				dev_info(battery->dev,
+						"%s: skip same siop level: %d\n", __func__, x);
+				return count;
+			} else if (x >= 0 && x <= 100) {
+				battery->siop_level = x;
+			} else {
+				battery->siop_level = 100;
+			}
+
+			if (battery->siop_event == SIOP_EVENT_WPC_CALL_START ||
+				battery->siop_event == SIOP_EVENT_WPC_CALL_END)
+				return count;
+
+			if (battery->capacity <= 5) {
+				battery->siop_level = 100;
+				battery->ignore_siop = true;
+			} else if (battery->ignore_siop) {
+				battery->ignore_siop = false;
+			}
+
+			if (delayed_work_pending(&battery->siop_event_work))
+				return count;
+
+			cancel_delayed_work(&battery->siop_work);
+			wake_lock(&battery->siop_level_wake_lock);
+			queue_delayed_work_on(0, battery->monitor_wqueue, &battery->siop_level_work, 0);
+
+			ret = count;
+		}
+		break;
+	case SIOP_EVENT:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			if (battery->pdata->siop_event_check_type & SIOP_EVENT_WPC_CALL) { // To reduce call noise with battery pack
+				if (x == SIOP_EVENT_WPC_CALL_START) {
+					battery->siop_event |= SIOP_EVENT_WPC_CALL;
+					pr_info("%s : WPC Enable & SIOP EVENT CALL START. 0x%x\n",
+						__func__, battery->siop_event);
+					cancel_delayed_work(&battery->siop_level_work);
+					cancel_delayed_work(&battery->siop_work);
+					wake_lock(&battery->siop_event_wake_lock);
+					queue_delayed_work_on(0, battery->monitor_wqueue, &battery->siop_event_work, 0);
+				} else if (x == SIOP_EVENT_WPC_CALL_END) {
+					battery->siop_event &= ~SIOP_EVENT_WPC_CALL;
+					pr_info("%s : WPC Enable & SIOP EVENT CALL END. 0x%x\n",
+						__func__, battery->siop_event);
+					cancel_delayed_work(&battery->siop_level_work);
+					cancel_delayed_work(&battery->siop_work);
+					wake_lock(&battery->siop_event_wake_lock);
+					queue_delayed_work_on(0, battery->monitor_wqueue, &battery->siop_event_work,
+							msecs_to_jiffies(5000));
+				} else {
+					battery->siop_event &= ~SIOP_EVENT_WPC_CALL;
+					pr_info("%s : WPC Disable & SIOP EVENT 0x%x\n", __func__, battery->siop_event);
+				}
+			}
+			ret = count;
+		}
+		break;
+	case BATT_CHARGING_SOURCE:
+		break;
+	case FG_REG_DUMP:
+		break;
+	case FG_RESET_CAP:
+		break;
+	case FG_CAPACITY:
+		break;
+	case AUTH:
+		break;
+	case CHG_CURRENT_ADC:
+		break;
+	case WC_ADC:
+		break;
+	case WC_STATUS:
+		break;
+	case WC_ENABLE:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			if (x == 0) {
+				battery->wc_enable = false;
+			} else if (x == 1) {
+				battery->wc_enable = true;
+			} else {
+				dev_info(battery->dev,
+					"%s: WPC ENABLE unknown command\n",
+					__func__);
+				return -EINVAL;
+			}
+			wake_lock(&battery->cable_wake_lock);
+			queue_delayed_work_on(0, battery->monitor_wqueue,
+					&battery->cable_work, 0);
+			ret = count;
+		}
+		break;
+	case WC_CONTROL:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			if (x == 0) {
+				battery->wc_enable = false;
+				if (battery->pdata->wpc_en >= 0) {
+					gpio_direction_output(battery->pdata->wpc_en, 1);
+					pr_info("%s: WC CONTROL: Disable", __func__);
+				}
+			} else if (x == 1) {
+				battery->wc_enable = true;
+				if (battery->pdata->wpc_en >= 0) {
+					gpio_direction_output(battery->pdata->wpc_en, 0);
+					pr_info("%s: WC CONTROL: Enable", __func__);
+				}
+			} else {
+				dev_info(battery->dev,
+					"%s: WC CONTROL unknown command\n",
+					__func__);
+				return -EINVAL;
+			}
+			ret = count;
+		}
+		break;
+	case HV_CHARGER_STATUS:
+		break;
+	case HV_WC_CHARGER_STATUS:
+		break;
+	case HV_CHARGER_SET:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			dev_info(battery->dev,
+				"%s: HV_CHARGER_SET(%d)\n", __func__, x);
+			if (x == 1) {
+				battery->wire_status = POWER_SUPPLY_TYPE_HV_MAINS;
+				wake_lock(&battery->cable_wake_lock);
+				queue_delayed_work_on(0, battery->monitor_wqueue, &battery->cable_work, 0);
+			} else {
+				battery->wire_status = POWER_SUPPLY_TYPE_BATTERY;
+				wake_lock(&battery->cable_wake_lock);
+				queue_delayed_work_on(0, battery->monitor_wqueue, &battery->cable_work, 0);
+			}
+			ret = count;
+		}
+		break;
+	case FACTORY_MODE:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			battery->factory_mode = x ? true : false;
+			ret = count;
+		}
+		break;
+	case STORE_MODE:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+#if !defined(CONFIG_SEC_FACTORY)
+			if (x) {
+				if (!battery->store_mode) {
+					battery->pdata->wpc_high_temp -= 30;
+					battery->pdata->wpc_high_temp_recovery -= 30;
+					battery->pdata->wpc_skip_check_capacity = 0;
+					battery->pdata->wpc_skip_check_time = 0;
+				}	
+				battery->store_mode = true;
+				if(battery->capacity <= 5) {
+					battery->ignore_store_mode = true;
+				} else {
+					if(battery->cable_type == POWER_SUPPLY_TYPE_HV_MAINS || \
+						battery->cable_type == POWER_SUPPLY_TYPE_HV_MAINS_12V ||
+						battery->cable_type == POWER_SUPPLY_TYPE_HV_ERR)
+						sec_bat_set_charging_current(battery);
+				}
+			}
+#endif
+			ret = count;
+		}
+		break;
+	case UPDATE:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+#ifdef CONFIG_FUELGAUGE_S2MU005
+			union power_supply_propval value;
+
+			/* update rVBAT register every 250ms for AT+BATTTEST */
+			value.intval = 1;
+			psy_do_property(battery->pdata->fuelgauge_name, set,
+							POWER_SUPPLY_PROP_ENERGY_NOW, value);
+			msleep(250);
+
+			sec_bat_get_battery_info(battery);
+
+			/* update rVBAT register every 4s for normal case */
+			value.intval = 0;
+			psy_do_property(battery->pdata->fuelgauge_name, set,
+							POWER_SUPPLY_PROP_ENERGY_NOW, value);
+#else
+			/* update battery info */
+			sec_bat_get_battery_info(battery);
+#endif
+			ret = count;
+		}
+		break;
+	case TEST_MODE:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			battery->test_mode = x;
+			wake_lock(&battery->monitor_wake_lock);
+			queue_delayed_work_on(0, battery->monitor_wqueue,
+				&battery->monitor_work, 0);
+			ret = count;
+		}
+		break;
+
+	case BATT_EVENT_CALL:
+	case BATT_EVENT_2G_CALL:
+	case BATT_EVENT_TALK_GSM:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			ret = count;
+		}
+		break;
+	case BATT_EVENT_3G_CALL:
+	case BATT_EVENT_TALK_WCDMA:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			ret = count;
+		}
+		break;
+	case BATT_EVENT_MUSIC:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			ret = count;
+		}
+		break;
+	case BATT_EVENT_VIDEO:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			ret = count;
+		}
+		break;
+	case BATT_EVENT_BROWSER:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			ret = count;
+		}
+		break;
+	case BATT_EVENT_HOTSPOT:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			ret = count;
+		}
+		break;
+	case BATT_EVENT_CAMERA:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			ret = count;
+		}
+		break;
+	case BATT_EVENT_CAMCORDER:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			ret = count;
+		}
+		break;
+	case BATT_EVENT_DATA_CALL:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			ret = count;
+		}
+		break;
+	case BATT_EVENT_WIFI:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			ret = count;
+		}
+		break;
+	case BATT_EVENT_WIBRO:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			ret = count;
+		}
+		break;
+	case BATT_EVENT_LTE:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			ret = count;
+		}
+		break;
+	case BATT_EVENT_LCD:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			if (x) {
+				battery->lcd_status = true;
+			} else {
+				battery->lcd_status = false;
+			}
+			ret = count;
+		}
+		break;
+	case BATT_EVENT_GPS:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			ret = count;
+		}
+		break;
+	case BATT_TEMP_TABLE:
+		if (sscanf(buf, "%d %d %d %d %d %d %d %d\n",
+			&t[0], &t[1], &t[2], &t[3], &t[4], &t[5], &t[6], &t[7]) == 8) {
+			pr_info("%s: (new) %d %d %d %d %d %d %d %d\n",
+				__func__, t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7]);
+			pr_info("%s: (default) %d %d %d %d %d %d %d %d\n",
+				__func__,
+				battery->pdata->temp_high_threshold_normal,
+				battery->pdata->temp_high_recovery_normal,
+				battery->pdata->temp_low_threshold_normal,
+				battery->pdata->temp_low_recovery_normal,
+				battery->pdata->temp_high_threshold_lpm,
+				battery->pdata->temp_high_recovery_lpm,
+				battery->pdata->temp_low_threshold_lpm,
+				battery->pdata->temp_low_recovery_lpm);
+			update_external_temp_table(battery, t);
+			ret = count;
+		}
+		break;
+	case BATT_HIGH_CURRENT_USB:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			union power_supply_propval value;
+			battery->is_hc_usb = x ? true : false;
+			value.intval = battery->is_hc_usb;
+
+			psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_USB_HC, value);
+
+			pr_info("%s: is_hc_usb (%d)\n", __func__, battery->is_hc_usb);
+			ret = count;
+		}
+		break;
+#if defined(CONFIG_SAMSUNG_BATTERY_ENG_TEST)
+	case BATT_TEST_CHARGE_CURRENT:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			if (x >= 0 && x <= 2000) {
+				union power_supply_propval value;
+				dev_err(battery->dev,
+					"%s: BATT_TEST_CHARGE_CURRENT(%d)\n", __func__, x);
+				battery->pdata->charging_current[
+					POWER_SUPPLY_TYPE_USB].input_current_limit = x;
+				battery->pdata->charging_current[
+					POWER_SUPPLY_TYPE_USB].fast_charging_current = x;
+				if (x > 500) {
+					battery->eng_not_full_status = true;
+					battery->pdata->temp_check_type =
+						SEC_BATTERY_TEMP_CHECK_NONE;
+					battery->pdata->charging_total_time =
+						10000 * 60 * 60;
+				}
+				if (battery->cable_type == POWER_SUPPLY_TYPE_USB) {
+					value.intval = x;
+					psy_do_property(battery->pdata->charger_name, set,
+						POWER_SUPPLY_PROP_CURRENT_NOW,
+						value);
+				}
+			}
+			ret = count;
+		}
+		break;
+#endif
+	case BATT_STABILITY_TEST:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			dev_err(battery->dev,
+				"%s: BATT_STABILITY_TEST(%d)\n", __func__, x);
+			if (x) {
+				battery->stability_test = true;
+				battery->eng_not_full_status = true;
+			}
+			else {
+				battery->stability_test = false;
+				battery->eng_not_full_status = false;
+			}
+			ret = count;
+		}
+		break;
+	case BATT_CAPACITY_MAX:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			union power_supply_propval value;
+			dev_err(battery->dev,
+					"%s: BATT_CAPACITY_MAX(%d)\n", __func__, x);
+			if (!fg_reset) {
+				value.intval = x;
+				psy_do_property(battery->pdata->fuelgauge_name, set,
+						POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN, value);
+
+				/* update soc */
+				value.intval = 0;
+				psy_do_property(battery->pdata->fuelgauge_name, get,
+						POWER_SUPPLY_PROP_CAPACITY, value);
+				battery->capacity = value.intval;
+				power_supply_changed(&battery->psy_bat);
+			}
+			ret = count;
+		}
+		break;
+	case BATT_INBAT_VOLTAGE:
+		break;
+#if defined(CONFIG_BATTERY_SWELLING_SELF_DISCHARGING)
+	case BATT_DISCHARGING_CHECK:
+		break;
+	case BATT_DISCHARGING_CHECK_ADC:
+		break;
+	case BATT_DISCHARGING_NTC:
+		break;
+	case BATT_DISCHARGING_NTC_ADC:
+		break;
+	case BATT_SELF_DISCHARGING_CONTROL:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			dev_err(battery->dev,
+				"%s: BATT_SELF_DISCHARGING_CONTROL(%d)\n", __func__, x);
+			if (x) {
+				battery->factory_self_discharging_mode_on = true;
+				pr_info("SELF DISCHARGING IC ENABLE\n");
+				sec_bat_self_discharging_control(battery, true);
+			} else {
+				battery->factory_self_discharging_mode_on = false;
+				pr_info("SELF DISCHARGING IC DISENABLE\n");
+				sec_bat_self_discharging_control(battery, false);
+			}
+			ret = count;
+		}
+		break;
+#endif
+#if defined(CONFIG_SW_SELF_DISCHARGING)
+	case BATT_SW_SELF_DISCHARGING:
+		break;
+#endif
+	case BATT_INBAT_WIRELESS_CS100:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			union power_supply_propval value;
+
+			pr_info("%s send cs100 command \n",__func__);
+			value.intval = POWER_SUPPLY_STATUS_FULL;
+			psy_do_property(battery->pdata->wireless_charger_name, set,
+					POWER_SUPPLY_PROP_STATUS, value);
+			ret = count;
+		}
+		break;
+	case SAFETY_TIMER_SET:
+		if (sscanf(buf, "%10d\n", &x) == 1) {
+			if (x) {
+				battery->safety_timer_set = true;
+			} else {
+				battery->safety_timer_set = false;
+			}
+			ret = count;
+		}
+		break;
+	case HMT_TA_CONNECTED:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			union power_supply_propval value;
+			dev_info(battery->dev,
+					"%s: HMT_TA_CONNECTED(%d)\n", __func__, x);
+			if (x) {
+				value.intval = false;
+				psy_do_property(battery->pdata->charger_name, set,
+						POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL,
+						value);
+				dev_info(battery->dev,
+						"%s: changed to OTG cable detached\n", __func__);
+
+				battery->wire_status = POWER_SUPPLY_TYPE_HMT_CONNECTED;
+				wake_lock(&battery->cable_wake_lock);
+				queue_delayed_work_on(0, battery->monitor_wqueue, &battery->cable_work, 0);
+			} else {
+				value.intval = true;
+				psy_do_property(battery->pdata->charger_name, set,
+						POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL,
+						value);
+				dev_info(battery->dev,
+						"%s: changed to OTG cable attached\n", __func__);
+
+				battery->wire_status = POWER_SUPPLY_TYPE_OTG;
+				wake_lock(&battery->cable_wake_lock);
+				queue_delayed_work_on(0, battery->monitor_wqueue, &battery->cable_work, 0);
+			}
+			ret = count;
+		}
+		break;
+	case HMT_TA_CHARGE:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			union power_supply_propval value;
+			dev_info(battery->dev,
+					"%s: HMT_TA_CHARGE(%d)\n", __func__, x);
+			psy_do_property(battery->pdata->charger_name, get,
+					POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL, value);
+			if (value.intval) {
+				dev_info(battery->dev,
+					"%s: ignore HMT_TA_CHARGE(%d)\n", __func__, x);
+			} else {
+				if (x) {
+					value.intval = false;
+					psy_do_property(battery->pdata->charger_name, set,
+							POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL,
+							value);
+					dev_info(battery->dev,
+						"%s: changed to OTG cable detached\n", __func__);
+					battery->wire_status = POWER_SUPPLY_TYPE_HMT_CHARGE;
+					wake_lock(&battery->cable_wake_lock);
+					queue_delayed_work_on(0, battery->monitor_wqueue, &battery->cable_work, 0);
+				} else {
+					value.intval = false;
+					psy_do_property(battery->pdata->charger_name, set,
+							POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL,
+							value);
+					dev_info(battery->dev,
+							"%s: changed to OTG cable detached\n", __func__);
+					battery->wire_status = POWER_SUPPLY_TYPE_HMT_CONNECTED;
+					wake_lock(&battery->cable_wake_lock);
+					queue_delayed_work_on(0, battery->monitor_wqueue, &battery->cable_work, 0);
+				}
+			}
+			ret = count;
+		}
+		break;
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	case FG_CYCLE:
+		break;
+	case FG_FULLCAPNOM:
+		break;
+#if defined(CONFIG_BATTERY_AGE_FORECAST_DETACHABLE)
+	case BATT_AFTER_MANUFACTURED:
+#else
+	case BATTERY_CYCLE:
+#endif
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			dev_info(battery->dev, "%s: %s(%d)\n", __func__,
+				(offset == BATTERY_CYCLE) ?
+				"BATTERY_CYCLE" : "BATTERY_CYCLE(W)", x);
+			if (x >= 0) {
+				int prev_battery_cycle = battery->batt_cycle;
+				battery->batt_cycle = x;
+				dev_info(battery->dev,
+					"%s: [Long life] prev_battery_cycle = %d, new bat. cycle = %d\n",
+					__func__, prev_battery_cycle, battery->batt_cycle);
+				if (prev_battery_cycle < 0) {
+					dev_info(battery->dev,
+						"%s: [Long life] Do sec_bat_aging_check()\n", __func__);
+					sec_bat_aging_check(battery);
+				}
+			}
+			ret = count;
+		}
+		break;
+#endif
+	case FG_FULL_VOLTAGE:
+		break;
+	case BATT_WPC_TEMP:
+	case BATT_WPC_TEMP_ADC:
+		break;
+#if defined(CONFIG_WIRELESS_FIRMWARE_UPDATE)
+	case BATT_WIRELESS_FIRMWARE_UPDATE:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			if (x == SEC_WIRELESS_RX_SDCARD_MODE) {
+				pr_info("%s fw mode is SDCARD \n", __func__);
+				sec_bat_fw_update_work(battery, SEC_WIRELESS_RX_SDCARD_MODE);
+			} else if (x == SEC_WIRELESS_RX_BUILT_IN_MODE) {
+				pr_info("%s fw mode is BUILD IN \n", __func__);
+				sec_bat_fw_update_work(battery, SEC_WIRELESS_RX_BUILT_IN_MODE);
+			} else if (x == SEC_WIRELESS_TX_ON_MODE) {
+				pr_info("%s tx mode is on \n", __func__);
+				sec_bat_fw_update_work(battery, SEC_WIRELESS_TX_ON_MODE);
+			} else if (x == SEC_WIRELESS_TX_OFF_MODE) {
+				pr_info("%s tx mode is off \n", __func__);
+				sec_bat_fw_update_work(battery, SEC_WIRELESS_TX_OFF_MODE);
+			} else {
+				dev_info(battery->dev, "%s: wireless firmware unknown command\n", __func__);
+				return -EINVAL;
+			}
+			ret = count;
+		}
+		break;
+	case BATT_WIRELESS_OTP_FIRMWARE_RESULT:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			union power_supply_propval value;
+			if (x == 2) {
+				value.intval = x;
+				pr_info("%s RX firmware update ready!\n", __func__);
+				psy_do_property(battery->pdata->wireless_charger_name, set,
+								POWER_SUPPLY_PROP_MANUFACTURER, value);
+			} else {
+				dev_info(battery->dev, "%s: firmware unknown command\n", __func__);
+				return -EINVAL;
+			}
+			ret = count;
+		}
+		break;
+	case BATT_WIRELESS_IC_GRADE:
+	case BATT_WIRELESS_FIRMWARE_VER_BIN:
+	case BATT_WIRELESS_FIRMWARE_VER:
+	case BATT_WIRELESS_TX_FIRMWARE_RESULT:
+	case BATT_WIRELESS_TX_FIRMWARE_VER:
+		break;
+	case BATT_TX_STATUS:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			if (x == SEC_TX_OFF) {
+				pr_info("%s TX mode is off \n", __func__);
+				sec_bat_fw_update_work(battery, SEC_WIRELESS_TX_OFF_MODE);
+			} else if (x == SEC_TX_STANDBY) {
+				pr_info("%s TX mode is on \n", __func__);
+				sec_bat_fw_update_work(battery, SEC_WIRELESS_TX_ON_MODE);
+			} else {
+				dev_info(battery->dev, "%s: TX firmware unknown command\n", __func__);
+				return -EINVAL;
+			}
+			ret = count;
+		}
+		break;
+#endif
+	case BATT_WIRELESS_VOUT:
+	case BATT_WIRELESS_VRCT:
+		break;
+	case BATT_HV_WIRELESS_STATUS:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			union power_supply_propval value;
+			if (x == 1 && battery->cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS) {
+				wake_lock(&battery->cable_wake_lock);
+#ifdef CONFIG_SEC_FACTORY
+				pr_info("%s change cable type HV WIRELESS -> WIRELESS \n", __func__);
+				battery->wc_status = SEC_WIRELESS_PAD_WPC;
+				battery->cable_type = POWER_SUPPLY_TYPE_WIRELESS;
+				sec_bat_set_charging_current(battery);
+#endif
+				pr_info("%s HV_WIRELESS_STATUS set to 1. Vout set to 5V. \n", __func__);
+				value.intval = WIRELESS_VOUT_5V;
+				psy_do_property(battery->pdata->wireless_charger_name, set,
+								POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+				wake_unlock(&battery->cable_wake_lock);
+			} else if (x == 3 && battery->cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS) {
+				pr_info("%s HV_WIRELESS_STATUS set to 3. Vout set to 9V. \n", __func__);
+				value.intval = WIRELESS_VOUT_9V;
+				psy_do_property(battery->pdata->wireless_charger_name, set,
+								POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+			} else {
+				dev_info(battery->dev, "%s: HV_WIRELESS_STATUS unknown command\n", __func__);
+				return -EINVAL;
+			}
+			ret = count;
+		}
+		break;
+	case BATT_HV_WIRELESS_PAD_CTRL:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			union power_supply_propval value;
+
+			pr_err("%s: x : %d\n", __func__, x);
+
+			if (x == 1) {
+#if 0 //temp block
+				ret = sec_set_param(CM_OFFSET, '1');
+#else
+				ret = -1;
+#endif
+				if (ret < 0) {
+					pr_err("%s:sec_set_param failed\n", __func__);
+					return ret;
+				} else {
+					pr_info("%s fan off \n", __func__);
+					sleep_mode = true;
+					if (battery->cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS) {
+#if defined(CONFIG_CALC_TIME_TO_FULL)
+						battery->complete_timetofull = false;
+#endif
+						value.intval = WIRELESS_PAD_FAN_ON;
+						psy_do_property(battery->pdata->wireless_charger_name, set,
+									POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+						msleep(250);
+						value.intval = WIRELESS_PAD_FAN_OFF;
+						psy_do_property(battery->pdata->wireless_charger_name, set,
+							POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+
+						msleep(250);
+						value.intval = battery->pdata->sleep_mode_limit_current;
+						psy_do_property(battery->pdata->charger_name, set,
+								POWER_SUPPLY_PROP_CURRENT_MAX, value);
+						battery->wireless_input_current = value.intval;
+#if defined(CONFIG_CALC_TIME_TO_FULL)
+						queue_delayed_work_on(0, battery->monitor_wqueue, &battery->timetofull_work,
+								msecs_to_jiffies(5000));
+#endif
+						wake_lock(&battery->monitor_wake_lock);
+						queue_delayed_work_on(0, battery->monitor_wqueue, &battery->monitor_work, 0);
+					}
+				}
+			} else if (x == 2) {
+#if 0 //temp block
+				ret = sec_set_param(CM_OFFSET, '0');
+#else
+				ret = -1;
+#endif
+				if (ret < 0) {
+					pr_err("%s: sec_set_param failed\n", __func__);
+					return ret;
+				} else {
+					sleep_mode = false;
+					pr_info("%s fan on \n", __func__);
+					if (battery->cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS) {
+#if defined(CONFIG_CALC_TIME_TO_FULL)
+						battery->complete_timetofull = false;
+#endif
+						value.intval = WIRELESS_PAD_FAN_ON;
+						psy_do_property(battery->pdata->wireless_charger_name, set,
+									POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+
+						msleep(250);
+
+#if defined(CONFIG_CALC_TIME_TO_FULL)
+						queue_delayed_work_on(0, battery->monitor_wqueue, &battery->timetofull_work,
+								msecs_to_jiffies(5000));
+#endif
+						wake_lock(&battery->monitor_wake_lock);
+						queue_delayed_work_on(0, battery->monitor_wqueue, &battery->monitor_work, 0);
+					}
+				}
+			} else if (x == 3) {
+				pr_info("%s led off \n", __func__);
+				value.intval = WIRELESS_PAD_LED_OFF;
+				psy_do_property(battery->pdata->wireless_charger_name, set,
+								POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+			} else if (x == 4) {
+				pr_info("%s led on \n", __func__);
+				value.intval = WIRELESS_PAD_LED_ON;
+				psy_do_property(battery->pdata->wireless_charger_name, set,
+								POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+			} else {
+				dev_info(battery->dev, "%s: BATT_HV_WIRELESS_PAD_CTRL unknown command\n", __func__);
+				return -EINVAL;
+			}
+			ret = count;
+		}
+		break;
+	case BATT_TUNE_FLOAT_VOLTAGE:
+		sscanf(buf, "%d\n", &x);
+		pr_info("%s float voltage = %d mV",__func__, x);
+
+		if(x > 4000 && x <= 4400 ){
+			union power_supply_propval value;
+			value.intval = x;
+			psy_do_property(battery->pdata->charger_name, set,
+					POWER_SUPPLY_PROP_VOLTAGE_MAX, value);
+		}
+		break;
+	case BATT_TUNE_INPUT_CHARGE_CURRENT:
+		sscanf(buf, "%d\n", &x);
+		pr_info("%s input charge current = %d mA",__func__, x);
+
+		if(x > 0 && x <= 4000 ){
+			union power_supply_propval value;
+			for(i=0; i<POWER_SUPPLY_TYPE_MAX; i++)
+				battery->pdata->charging_current[i].input_current_limit = x;
+
+			value.intval = x;
+			psy_do_property(battery->pdata->charger_name, set,
+						POWER_SUPPLY_PROP_CURRENT_MAX, value);
+		}
+		break;
+	case BATT_TUNE_FAST_CHARGE_CURRENT:
+		sscanf(buf, "%d\n", &x);
+		pr_info("%s fast charge current = %d mA",__func__, x);
+		if(x > 0 && x <= 4000 ){
+			union power_supply_propval value;
+			for(i=0; i<POWER_SUPPLY_TYPE_MAX; i++)
+				battery->pdata->charging_current[i].fast_charging_current = x;
+
+			value.intval = x;
+				psy_do_property(battery->pdata->charger_name, set,
+					POWER_SUPPLY_PROP_CURRENT_AVG, value);
+		}
+		break;
+	case BATT_TUNE_UI_TERM_CURRENT_1ST:
+		sscanf(buf, "%d\n", &x);
+		pr_info("%s ui term current = %d mA",__func__, x);
+
+		if(x > 0 && x < 1000 ){
+			for(i=0; i<POWER_SUPPLY_TYPE_MAX; i++)
+				battery->pdata->charging_current[i].full_check_current_1st = x;
+		}
+		break;
+	case BATT_TUNE_UI_TERM_CURRENT_2ND:
+		sscanf(buf, "%d\n", &x);
+		pr_info("%s ui term current = %d mA",__func__, x);
+
+		if(x > 0 && x < 1000 ){
+			for(i=0; i<POWER_SUPPLY_TYPE_MAX; i++)
+				battery->pdata->charging_current[i].full_check_current_1st = x;
+		}
+		break;	
+	case BATT_TUNE_TEMP_HIGH_NORMAL:
+		sscanf(buf, "%d\n", &x);
+		pr_info("%s temp high normal block	= %d ",__func__, x);
+		if(x < 900 && x > -200)
+			battery->pdata->temp_high_threshold_normal = x;
+		break;
+	case BATT_TUNE_TEMP_HIGH_REC_NORMAL:
+		sscanf(buf, "%d\n", &x);
+		pr_info("%s temp high normal recover  = %d ",__func__, x);
+		if(x <900 && x > -200)
+			battery->pdata->temp_high_recovery_normal = x;
+		break;
+	case BATT_TUNE_TEMP_LOW_NORMAL:
+		sscanf(buf, "%d\n", &x);
+		pr_info("%s temp low normal block  = %d ",__func__, x);
+		if(x <900 && x > -200)
+			battery->pdata->temp_low_threshold_normal = x;
+		break;
+	case BATT_TUNE_TEMP_LOW_REC_NORMAL:
+		sscanf(buf, "%d\n", &x);
+		pr_info("%s temp low normal recover  = %d ",__func__, x);
+		if(x <900 && x > -200)
+			battery->pdata->temp_low_recovery_normal = x;
+		break;
+	case BATT_TUNE_CHG_TEMP_HIGH:
+		sscanf(buf, "%d\n", &x);
+		pr_info("%s chg_high_temp  = %d ",__func__, x);
+		if(x <900 && x > -200)
+			battery->pdata->chg_high_temp_1st = x;
+		break;
+	case BATT_TUNE_CHG_TEMP_REC:
+		sscanf(buf, "%d\n", &x);
+		pr_info("%s chg_high_temp_recovery	= %d ",__func__, x);
+		if(x <900 && x > -200)
+			battery->pdata->chg_high_temp_recovery = x;
+		break;
+	case BATT_TUNE_CHG_LIMMIT_CURRENT:
+		sscanf(buf, "%d\n", &x);
+		pr_info("%s chg_charging_limit_current	= %d ",__func__, x);
+		if(x <3000 && x > 0)
+		{
+			battery->pdata->chg_charging_limit_current = x;
+			battery->pdata->charging_current[POWER_SUPPLY_TYPE_HV_ERR].input_current_limit= x;
+			battery->pdata->charging_current[POWER_SUPPLY_TYPE_HV_UNKNOWN].input_current_limit= x;
+			battery->pdata->charging_current[POWER_SUPPLY_TYPE_HV_MAINS].input_current_limit= x;
+		}
+		break;
+	case BATT_TUNE_COIL_TEMP_HIGH:
+		sscanf(buf, "%d\n", &x);
+		pr_info("%s wpc_high_temp  = %d ",__func__, x);
+		if(x <900 && x > -200)
+			battery->pdata->wpc_high_temp = x;
+		break;
+	case BATT_TUNE_COIL_TEMP_REC:
+		sscanf(buf, "%d\n", &x);
+		pr_info("%s wpc_high_temp_recovery	= %d ",__func__, x);
+		if(x <900 && x > -200)
+			battery->pdata->wpc_high_temp_recovery = x;
+		break;
+	case BATT_TUNE_COIL_LIMMIT_CURRENT:
+		sscanf(buf, "%d\n", &x);
+		pr_info("%s wpc_charging_limit_current	= %d ",__func__, x);
+		if(x <3000 && x > 0)
+		{
+			battery->pdata->wpc_charging_limit_current = x;
+			battery->pdata->charging_current[POWER_SUPPLY_TYPE_HV_ERR].input_current_limit= x;
+			battery->pdata->charging_current[POWER_SUPPLY_TYPE_HV_UNKNOWN].input_current_limit= x;
+			battery->pdata->charging_current[POWER_SUPPLY_TYPE_HV_MAINS].input_current_limit= x;
+		}
+		break;
+#if defined(CONFIG_UPDATE_BATTERY_DATA)
+	case BATT_UPDATE_DATA:
+		if (!battery->data_path && (count * sizeof(char)) < 256) {
+			battery->data_path = kzalloc((count * sizeof(char) + 1), GFP_KERNEL);
+			if (battery->data_path) {
+				sscanf(buf, "%s\n", battery->data_path);
+				cancel_delayed_work(&battery->batt_data_work);
+				wake_lock(&battery->batt_data_wake_lock);
+				queue_delayed_work_on(0, battery->monitor_wqueue,
+					&battery->batt_data_work, msecs_to_jiffies(100));
+			} else {
+				pr_info("%s: failed to alloc data_path buffer\n", __func__);
+			}
+		}
+		ret = count;
+		break;
+#endif
+	case BATT_MISC_EVENT:
+		break;
+	case FACTORY_MODE_RELIEVE:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			union power_supply_propval value;
+			value.intval = x;
+			psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+			ret = count;
+		}
+		break;
+	case FACTORY_MODE_BYPASS:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			union power_supply_propval value;
+			value.intval = x;
+			psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_AUTHENTIC, value);
+			ret = count;
+		}
+		break;
+	case BATT_WDT_CONTROL:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			pr_info("%s: Charger WDT Set : %d\n", __func__, x);
+			battery->wdt_kick_disable = x;
+		}
+		ret = count;
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static int sec_bat_create_attrs(struct device *dev)
+{
+	unsigned long i;
+	int rc;
+
+	for (i = 0; i < ARRAY_SIZE(sec_battery_attrs); i++) {
+		rc = device_create_file(dev, &sec_battery_attrs[i]);
+		if (rc)
+			goto create_attrs_failed;
+	}
+	goto create_attrs_succeed;
+
+create_attrs_failed:
+	while (i--)
+		device_remove_file(dev, &sec_battery_attrs[i]);
+create_attrs_succeed:
+	return rc;
+}
+
+static int sec_bat_set_property(struct power_supply *psy,
+				enum power_supply_property psp,
+				const union power_supply_propval *val)
+{
+	struct sec_battery_info *battery =
+		container_of(psy, struct sec_battery_info, psy_bat);
+	int current_cable_type;
+	int full_check_type;
+	union power_supply_propval value;
+
+	dev_dbg(battery->dev,
+		"%s: (%d,%d)\n", __func__, psp, val->intval);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		if (battery->charging_mode == SEC_BATTERY_CHARGING_1ST)
+			full_check_type = battery->pdata->full_check_type;
+		else
+			full_check_type = battery->pdata->full_check_type_2nd;
+		if ((full_check_type == SEC_BATTERY_FULLCHARGED_CHGINT) &&
+			(val->intval == POWER_SUPPLY_STATUS_FULL))
+			sec_bat_do_fullcharged(battery);
+		sec_bat_set_charging_status(battery, val->intval);
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		sec_bat_ovp_uvlo_result(battery, val->intval);
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		current_cable_type = val->intval;
+
+		if ((battery->muic_cable_type != ATTACHED_DEV_SMARTDOCK_TA_MUIC)
+		    && ((current_cable_type == POWER_SUPPLY_TYPE_SMART_OTG) ||
+			(current_cable_type == POWER_SUPPLY_TYPE_SMART_NOTG)))
+			break;
+
+		if (current_cable_type < 0) {
+			dev_info(battery->dev,
+					"%s: ignore event(%d)\n",
+					__func__, current_cable_type);
+		} else if (current_cable_type == POWER_SUPPLY_TYPE_OTG) {
+			battery->charging_mode = SEC_BATTERY_CHARGING_NONE;
+			battery->is_recharging = false;
+			sec_bat_set_charging_status(battery,
+					POWER_SUPPLY_STATUS_DISCHARGING);
+			battery->cable_type = current_cable_type;
+			wake_lock(&battery->monitor_wake_lock);
+			queue_delayed_work_on(0, battery->monitor_wqueue,
+					   &battery->monitor_work, 0);
+			break;
+		} else {
+			battery->wire_status = current_cable_type;
+			if ((battery->wire_status == POWER_SUPPLY_TYPE_BATTERY) &&
+				(battery->wc_status != SEC_WIRELESS_PAD_NONE) )
+				current_cable_type = POWER_SUPPLY_TYPE_WIRELESS;
+		}
+		dev_info(battery->dev,
+				"%s: current_cable(%d), wc_status(%d), wire_status(%d)\n",
+				__func__, current_cable_type, battery->wc_status,
+				battery->wire_status);
+
+		/* cable is attached or detached
+		 * if current_cable_type is minus value,
+		 * check cable by sec_bat_get_cable_type()
+		 * although SEC_BATTERY_CABLE_SOURCE_EXTERNAL is set
+		 * (0 is POWER_SUPPLY_TYPE_UNKNOWN)
+		 */
+		if ((current_cable_type >= 0) &&
+			(current_cable_type < SEC_SIZEOF_POWER_SUPPLY_TYPE) &&
+			(battery->pdata->cable_source_type &
+			SEC_BATTERY_CABLE_SOURCE_EXTERNAL)) {
+
+			wake_lock(&battery->cable_wake_lock);
+				queue_delayed_work_on(0, battery->monitor_wqueue,
+					&battery->cable_work,0);
+		} else {
+			if (sec_bat_get_cable_type(battery,
+						battery->pdata->cable_source_type)) {
+				wake_lock(&battery->cable_wake_lock);
+					queue_delayed_work_on(0, battery->monitor_wqueue,
+						&battery->cable_work,0);
+			}
+		}
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		battery->capacity = val->intval;
+		power_supply_changed(&battery->psy_bat);
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		/* If JIG is attached, the voltage is set as 1079 */
+		pr_info("%s : set to the battery history : (%d)\n",__func__, val->intval);
+		if(val->intval == 1079)	{
+			battery->voltage_now = 1079;
+			battery->voltage_avg = 1079;
+			power_supply_changed(&battery->psy_bat);
+		}
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+		queue_delayed_work_on(0, battery->monitor_wqueue, &battery->monitor_work, 0);
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		battery->present = val->intval;
+
+		wake_lock(&battery->monitor_wake_lock);
+		queue_delayed_work_on(0, battery->monitor_wqueue,
+				   &battery->monitor_work, 0);
+		break;
+#if defined(CONFIG_BATTERY_SWELLING)
+	case POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT:
+		break;
+#endif
+	case POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION:
+	case POWER_SUPPLY_PROP_CHARGE_COUNTER_SHADOW:
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL:
+		value.intval = val->intval;
+		pr_info("%s: CHGIN-OTG %s\n", __func__, value.intval > 0 ? "on" : "off");
+		psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL, value);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_UNO_CONTROL:
+		value.intval = val->intval;
+		pr_info("%s: WCIN-UNO %s\n", __func__, value.intval > 0 ? "on" : "off");
+		psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_CHARGE_UNO_CONTROL, value);
+		break;
+#if defined(CONFIG_UPDATE_BATTERY_DATA)
+	case POWER_SUPPLY_PROP_POWER_DESIGN:
+		sec_bat_parse_dt(battery->dev, battery);
+		break;
+#endif
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sec_bat_get_property(struct power_supply *psy,
+				enum power_supply_property psp,
+				union power_supply_propval *val)
+{
+	struct sec_battery_info *battery =
+		container_of(psy, struct sec_battery_info, psy_bat);
+	union power_supply_propval value;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		if ((battery->health == POWER_SUPPLY_HEALTH_OVERVOLTAGE) ||
+			(battery->health == POWER_SUPPLY_HEALTH_UNDERVOLTAGE)) {
+				val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+		} else {
+			if ((battery->pdata->cable_check_type &
+				SEC_BATTERY_CABLE_CHECK_NOUSBCHARGE) &&
+				!lpcharge) {
+				switch (battery->cable_type) {
+				case POWER_SUPPLY_TYPE_USB:
+				case POWER_SUPPLY_TYPE_USB_DCP:
+				case POWER_SUPPLY_TYPE_USB_CDP:
+				case POWER_SUPPLY_TYPE_USB_ACA:
+					val->intval =
+						POWER_SUPPLY_STATUS_DISCHARGING;
+					return 0;
+				}
+			}
+#if defined(CONFIG_STORE_MODE)
+			if (battery->store_mode &&
+					battery->cable_type != POWER_SUPPLY_TYPE_BATTERY &&
+					battery->status == POWER_SUPPLY_STATUS_DISCHARGING) {
+				val->intval = POWER_SUPPLY_STATUS_CHARGING;
+			} else
+#endif
+				val->intval = battery->status;
+		}
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+		if (battery->cable_type == POWER_SUPPLY_TYPE_BATTERY ||
+			battery->cable_type == POWER_SUPPLY_TYPE_MHL_USB_100) {
+			val->intval = POWER_SUPPLY_CHARGE_TYPE_NONE;
+		} else {
+			psy_do_property(battery->pdata->charger_name, get,
+				POWER_SUPPLY_PROP_CHARGE_TYPE, value);
+			if (value.intval == POWER_SUPPLY_CHARGE_TYPE_UNKNOWN)
+				/* if error in CHARGE_TYPE of charger
+				 * set CHARGE_TYPE as NONE
+				 */
+				val->intval = POWER_SUPPLY_CHARGE_TYPE_NONE;
+			else
+				val->intval = value.intval;
+		}
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = battery->health;
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = battery->present;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		if (battery->cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS) {
+			if (sec_bat_hv_wc_normal_mode_check(battery))
+				val->intval = POWER_SUPPLY_TYPE_WIRELESS;
+			else
+				val->intval = POWER_SUPPLY_TYPE_HV_WIRELESS_ETX;
+		}
+		else if(battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK)
+			val->intval = POWER_SUPPLY_TYPE_WIRELESS;
+		else if(battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK_TA)
+			val->intval = POWER_SUPPLY_TYPE_WIRELESS;
+		else if(battery->cable_type == POWER_SUPPLY_TYPE_PMA_WIRELESS)
+			val->intval = POWER_SUPPLY_TYPE_WIRELESS;
+		else
+			val->intval = battery->cable_type;
+		pr_info("%s cable type = %d sleep_mode = %d\n", __func__, val->intval, sleep_mode);
+		break;
+	case POWER_SUPPLY_PROP_TECHNOLOGY:
+		val->intval = battery->pdata->technology;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+#ifdef CONFIG_SEC_FACTORY
+		psy_do_property(battery->pdata->fuelgauge_name, get,
+				POWER_SUPPLY_PROP_VOLTAGE_NOW, value);
+		battery->voltage_now = value.intval;
+		dev_err(battery->dev,
+			"%s: voltage now(%d)\n", __func__, battery->voltage_now);
+#endif
+		/* voltage value should be in uV */
+		val->intval = battery->voltage_now * 1000;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_AVG:
+#ifdef CONFIG_SEC_FACTORY
+		value.intval = SEC_BATTERY_VOLTAGE_AVERAGE;
+		psy_do_property(battery->pdata->fuelgauge_name, get,
+				POWER_SUPPLY_PROP_VOLTAGE_AVG, value);
+		battery->voltage_avg = value.intval;
+		dev_err(battery->dev,
+			"%s: voltage avg(%d)\n", __func__, battery->voltage_avg);
+#endif
+		/* voltage value should be in uV */
+		val->intval = battery->voltage_avg * 1000;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = battery->current_now;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+		val->intval = battery->current_avg;
+		break;
+	/* charging mode (differ from power supply) */
+	case POWER_SUPPLY_PROP_CHARGE_NOW:
+		val->intval = battery->charging_mode;
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		if (battery->pdata->fake_capacity) {
+			val->intval = 90;
+			pr_info("%s : capacity(%d)\n", __func__, val->intval);
+		} else {
+#if defined(CONFIG_SAMSUNG_BATTERY_ENG_TEST)
+			if (battery->status == POWER_SUPPLY_STATUS_FULL) {
+				if(battery->eng_not_full_status)
+					val->intval = battery->capacity;
+				else
+					val->intval = 100;
+			} else {
+				val->intval = battery->capacity;
+			}
+#else
+			if (battery->status == POWER_SUPPLY_STATUS_FULL)
+				val->intval = 100;
+			else
+				val->intval = battery->capacity;
+#endif
+		}
+		break;
+	case POWER_SUPPLY_PROP_TEMP:
+		val->intval = battery->temperature;
+		break;
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		val->intval = battery->temper_amb;
+		break;
+#if defined(CONFIG_CALC_TIME_TO_FULL)
+	case POWER_SUPPLY_PROP_TIME_TO_FULL_NOW:
+		if (battery->capacity == 100) {
+			val->intval = -1;
+			break;
+		}
+
+		if (((battery->status == POWER_SUPPLY_STATUS_CHARGING) ||
+			(battery->status == POWER_SUPPLY_STATUS_FULL && battery->capacity != 100)) &&
+			battery->complete_timetofull &&
+			!battery->swelling_mode)
+			val->intval = battery->timetofull;
+		else
+			val->intval = -1;
+		break;
+#endif
+#if defined(CONFIG_BATTERY_SWELLING)
+	case POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT:
+		if (battery->swelling_mode)
+			val->intval = 1;
+		else
+			val->intval = 0;
+		break;
+#endif
+	case POWER_SUPPLY_PROP_CHARGE_COUNTER_SHADOW:
+		val->intval = battery->wire_status;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL:
+	case POWER_SUPPLY_PROP_CHARGE_UNO_CONTROL:
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int sec_usb_get_property(struct power_supply *psy,
+				enum power_supply_property psp,
+				union power_supply_propval *val)
+{
+	struct sec_battery_info *battery =
+		container_of(psy, struct sec_battery_info, psy_usb);
+
+	if (psp != POWER_SUPPLY_PROP_ONLINE)
+		return -EINVAL;
+
+	if ((battery->health == POWER_SUPPLY_HEALTH_OVERVOLTAGE) ||
+		(battery->health == POWER_SUPPLY_HEALTH_UNDERVOLTAGE)) {
+		val->intval = 0;
+		return 0;
+	}
+	/* Set enable=1 only if the USB charger is connected */
+	switch (battery->wire_status) {
+	case POWER_SUPPLY_TYPE_USB:
+	case POWER_SUPPLY_TYPE_USB_DCP:
+	case POWER_SUPPLY_TYPE_USB_CDP:
+	case POWER_SUPPLY_TYPE_USB_ACA:
+	case POWER_SUPPLY_TYPE_MHL_USB:
+	case POWER_SUPPLY_TYPE_MHL_USB_100:
+		val->intval = 1;
+		break;
+	default:
+		val->intval = 0;
+		break;
+	}
+
+	if (battery->slate_mode)
+		val->intval = 0;
+	return 0;
+}
+
+static int sec_ac_get_property(struct power_supply *psy,
+			       enum power_supply_property psp,
+			       union power_supply_propval *val)
+{
+	struct sec_battery_info *battery =
+		container_of(psy, struct sec_battery_info, psy_ac);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		if ((battery->health == POWER_SUPPLY_HEALTH_OVERVOLTAGE) ||
+				(battery->health == POWER_SUPPLY_HEALTH_UNDERVOLTAGE)) {
+			val->intval = 0;
+			return 0;
+		}
+
+		/* Set enable=1 only if the AC charger is connected */
+		switch (battery->cable_type) {
+		case POWER_SUPPLY_TYPE_MAINS:
+		case POWER_SUPPLY_TYPE_MISC:
+		case POWER_SUPPLY_TYPE_CARDOCK:
+		case POWER_SUPPLY_TYPE_UARTOFF:
+		case POWER_SUPPLY_TYPE_LAN_HUB:
+		case POWER_SUPPLY_TYPE_UNKNOWN:
+		case POWER_SUPPLY_TYPE_MHL_500:
+		case POWER_SUPPLY_TYPE_MHL_900:
+		case POWER_SUPPLY_TYPE_MHL_1500:
+		case POWER_SUPPLY_TYPE_MHL_2000:
+		case POWER_SUPPLY_TYPE_SMART_OTG:
+		case POWER_SUPPLY_TYPE_SMART_NOTG:
+		case POWER_SUPPLY_TYPE_HV_PREPARE_MAINS:
+		case POWER_SUPPLY_TYPE_HV_ERR:
+		case POWER_SUPPLY_TYPE_HV_UNKNOWN:
+		case POWER_SUPPLY_TYPE_HV_MAINS:
+		case POWER_SUPPLY_TYPE_HV_MAINS_12V:
+		case POWER_SUPPLY_TYPE_MDOCK_TA:
+		case POWER_SUPPLY_TYPE_HMT_CONNECTED:
+		case POWER_SUPPLY_TYPE_HMT_CHARGE:
+			val->intval = 1;
+			break;
+		default:
+			val->intval = 0;
+			break;
+		}
+		break;
+	case POWER_SUPPLY_PROP_TEMP:
+		val->intval = battery->chg_temp;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sec_wireless_get_property(struct power_supply *psy,
+			       enum power_supply_property psp,
+			       union power_supply_propval *val)
+{
+	struct sec_battery_info *battery =
+		container_of(psy, struct sec_battery_info, psy_wireless);
+
+	if (psp != POWER_SUPPLY_PROP_ONLINE)
+		return -EINVAL;
+
+	val->intval = battery->wc_status;
+
+	return 0;
+}
+
+static int sec_wireless_set_property(struct power_supply *psy,
+				enum power_supply_property psp,
+				const union power_supply_propval *val)
+{
+	struct sec_battery_info *battery =
+		container_of(psy, struct sec_battery_info, psy_wireless);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		battery->wc_status = val->intval;
+
+		wake_lock(&battery->cable_wake_lock);
+		queue_delayed_work_on(0, battery->monitor_wqueue,
+			&battery->cable_work, 0);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sec_ps_set_property(struct power_supply *psy,
+				enum power_supply_property psp,
+				const union power_supply_propval *val)
+{
+	struct sec_battery_info *battery =
+		container_of(psy, struct sec_battery_info, psy_ps);
+	union power_supply_propval value;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		if (val->intval == 0 && battery->ps_enable == true) {
+			battery->ps_enable = false;
+			value.intval = val->intval;
+			psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL, value);
+		} else if ((val->intval == 1) && (battery->ps_enable == false) &&
+				(battery->ps_status == true)) {
+			battery->ps_enable = true;
+			value.intval = val->intval;
+		psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL, value);
+	} else {
+		dev_err(battery->dev,
+				"%s: invalid setting (%d)\n", __func__, val->intval);
+	}
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		if (val->intval == POWER_SUPPLY_TYPE_POWER_SHARING) {
+			battery->ps_status = true;
+			battery->ps_enable = true;
+			value.intval = battery->ps_enable;
+			psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL, value);
+		} else {
+			battery->ps_status = false;
+			battery->ps_enable = false;
+			value.intval = battery->ps_enable;
+			psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL, value);
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sec_ps_get_property(struct power_supply *psy,
+			       enum power_supply_property psp,
+			       union power_supply_propval *val)
+{
+	struct sec_battery_info *battery =
+		container_of(psy, struct sec_battery_info, psy_ps);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = (battery->ps_enable) ? 1 : 0;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = (battery->ps_status) ? 1 : 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static irqreturn_t sec_bat_irq_thread(int irq, void *irq_data)
+{
+	struct sec_battery_info *battery = irq_data;
+
+	dev_info(battery->dev, "%s: bat_irq occured_start\n", __func__);
+
+	if (battery->pdata->battery_check_type ==
+		SEC_BATTERY_CHECK_INT) {
+		if (battery->pdata->check_battery_callback)
+			battery->present = battery->pdata->check_battery_callback();
+
+		wake_lock(&battery->monitor_wake_lock);
+		queue_delayed_work_on(0, battery->monitor_wqueue, &battery->monitor_work, 0);
+	}
+
+	return IRQ_HANDLED;
+}
+
+#if defined(CONFIG_MUIC_NOTIFIER)
+static int sec_bat_cable_check(struct sec_battery_info *battery,
+				muic_attached_dev_t attached_dev)
+{
+	int current_cable_type = -1;
+	union power_supply_propval val;
+
+	pr_info("[%s]ATTACHED(%d)\n", __func__, attached_dev);
+
+	switch (attached_dev)
+	{
+	case ATTACHED_DEV_JIG_UART_OFF_MUIC:
+	case ATTACHED_DEV_JIG_UART_ON_MUIC:
+#if defined(CONFIG_SEC_FACTORY) && defined(CONFIG_MUIC_S2MU005_DISCHARGING_WA)
+		current_cable_type = POWER_SUPPLY_TYPE_BATTERY;
+#endif
+		battery->is_jig_on = true;
+		break;
+	//case ATTACHED_DEV_UNDEFINED_RANGE_MUIC:
+	case ATTACHED_DEV_SMARTDOCK_MUIC:
+	case ATTACHED_DEV_DESKDOCK_MUIC:
+	case ATTACHED_DEV_JIG_USB_ON_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_BATTERY;
+		break;
+	case ATTACHED_DEV_OTG_MUIC:
+	case ATTACHED_DEV_JIG_UART_OFF_VB_OTG_MUIC:
+	case ATTACHED_DEV_HMT_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_OTG;
+		break;
+	case ATTACHED_DEV_JIG_USB_OFF_MUIC:
+#if defined(CONFIG_SEC_FACTORY) && defined(CONFIG_MUIC_S2MU005_DISCHARGING_WA)
+	case ATTACHED_DEV_CARKIT_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_BATTERY;
+		val.intval = SEC_BAT_CHG_MODE_CHARGING_OFF;
+		psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_CHARGING_ENABLED, val);
+		break;
+#endif
+	case ATTACHED_DEV_USB_MUIC:
+	case ATTACHED_DEV_SMARTDOCK_USB_MUIC:
+	case ATTACHED_DEV_UNOFFICIAL_ID_USB_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_USB;
+		break;
+	case ATTACHED_DEV_JIG_UART_OFF_VB_MUIC:
+	case ATTACHED_DEV_JIG_UART_OFF_VB_FG_MUIC:
+#if defined(CONFIG_SEC_FACTORY) && defined(CONFIG_MUIC_S2MU005_DISCHARGING_WA)
+		current_cable_type = POWER_SUPPLY_TYPE_BATTERY;
+		val.intval = SEC_BAT_CHG_MODE_CHARGING_OFF;
+		psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_CHARGING_ENABLED, val);
+#else	
+		current_cable_type = factory_mode ? POWER_SUPPLY_TYPE_BATTERY :
+			POWER_SUPPLY_TYPE_UARTOFF;
+#endif			
+		break;
+	case ATTACHED_DEV_RDU_TA_MUIC:
+		battery->store_mode = true;
+	case ATTACHED_DEV_TA_MUIC:
+	case ATTACHED_DEV_CARDOCK_MUIC:
+	case ATTACHED_DEV_DESKDOCK_VB_MUIC:
+	case ATTACHED_DEV_SMARTDOCK_TA_MUIC:
+	case ATTACHED_DEV_AFC_CHARGER_5V_MUIC:
+	case ATTACHED_DEV_UNOFFICIAL_TA_MUIC:
+	case ATTACHED_DEV_UNOFFICIAL_ID_TA_MUIC:
+	case ATTACHED_DEV_UNOFFICIAL_ID_ANY_MUIC:
+	case ATTACHED_DEV_QC_CHARGER_5V_MUIC:
+	case ATTACHED_DEV_UNSUPPORTED_ID_VB_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_MAINS;
+		break;
+	case ATTACHED_DEV_CDP_MUIC:
+	case ATTACHED_DEV_UNOFFICIAL_ID_CDP_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_USB_CDP;
+		break;
+	case ATTACHED_DEV_USB_LANHUB_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_LAN_HUB;
+		break;
+	case ATTACHED_DEV_CHARGING_CABLE_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_POWER_SHARING;
+		break;
+	case ATTACHED_DEV_AFC_CHARGER_PREPARE_MUIC:
+	case ATTACHED_DEV_QC_CHARGER_PREPARE_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_HV_PREPARE_MAINS;
+		break;
+	case ATTACHED_DEV_AFC_CHARGER_9V_MUIC:
+	case ATTACHED_DEV_QC_CHARGER_9V_MUIC:
+#if defined(CONFIG_MUIC_HV_12V)
+	case ATTACHED_DEV_AFC_CHARGER_12V_MUIC:
+#endif
+		current_cable_type = POWER_SUPPLY_TYPE_HV_MAINS;
+		break;
+#if defined(CONFIG_MUIC_HV_12V)
+	case ATTACHED_DEV_AFC_CHARGER_12V_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_HV_MAINS_12V;
+		break;
+#endif
+	case ATTACHED_DEV_AFC_CHARGER_ERR_V_MUIC:
+	case ATTACHED_DEV_QC_CHARGER_ERR_V_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_HV_ERR;
+		break;
+	case ATTACHED_DEV_UNDEFINED_CHARGING_MUIC:
+#if defined(CONFIG_SEC_FACTORY) && defined(CONFIG_MUIC_S2MU005_DISCHARGING_WA)
+		current_cable_type = POWER_SUPPLY_TYPE_BATTERY;
+		val.intval = SEC_BAT_CHG_MODE_CHARGING_OFF;
+		psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_CHARGING_ENABLED, val);
+#else
+		current_cable_type = POWER_SUPPLY_TYPE_MAINS;
+#endif
+		break;
+	case ATTACHED_DEV_HV_ID_ERR_UNDEFINED_MUIC:
+	case ATTACHED_DEV_HV_ID_ERR_UNSUPPORTED_MUIC:
+	case ATTACHED_DEV_HV_ID_ERR_SUPPORTED_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_HV_UNKNOWN;
+		break;
+	case ATTACHED_DEV_VZW_INCOMPATIBLE_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_UNKNOWN;
+		break;
+	case ATTACHED_DEV_MHL_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_MHL_1500;
+		break;
+	default:
+		pr_err("%s: invalid type for charger:%d\n",
+			__func__, attached_dev);
+	}
+#ifndef CONFIG_FUELGAUGE_S2MU005
+	if (battery->is_jig_on && !battery->pdata->support_fgsrc_change)
+		psy_do_property(battery->pdata->fuelgauge_name, set,
+			POWER_SUPPLY_PROP_ENERGY_NOW, val);
+#endif
+#ifdef CONFIG_CHARGER_S2MU005
+	if (battery->is_jig_on) {
+		val.intval = SEC_BAT_CHG_MODE_CHARGING_OFF;
+		psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_CHARGING_ENABLED, val);
+	}
+#endif
+
+	val.intval = battery->is_jig_on;
+	psy_do_property(battery->pdata->charger_name, set,
+		POWER_SUPPLY_PROP_ENERGY_NOW, val);
+
+	return current_cable_type;
+
+}
+
+static int batt_handle_notification(struct notifier_block *nb,
+		unsigned long action, void *data)
+{
+#ifdef CONFIG_CCIC_NOTIFIER
+	CC_NOTI_ATTACH_TYPEDEF *p_noti = (CC_NOTI_ATTACH_TYPEDEF *)data;
+	muic_attached_dev_t attached_dev = p_noti->cable_type;
+#else
+	muic_attached_dev_t attached_dev = *(muic_attached_dev_t *)data;
+#endif
+	const char *cmd;
+	int cable_type;
+	struct sec_battery_info *battery =
+		container_of(nb, struct sec_battery_info,
+			     batt_nb);
+	union power_supply_propval value;
+
+	switch (action) {
+	case MUIC_NOTIFY_CMD_DETACH:
+	case MUIC_NOTIFY_CMD_LOGICALLY_DETACH:
+		cmd = "DETACH";
+		battery->is_jig_on = false;
+		cable_type = POWER_SUPPLY_TYPE_BATTERY;
+		battery->muic_cable_type = ATTACHED_DEV_NONE_MUIC;
+		break;
+	case MUIC_NOTIFY_CMD_ATTACH:
+	case MUIC_NOTIFY_CMD_LOGICALLY_ATTACH:
+		cmd = "ATTACH";
+		cable_type = sec_bat_cable_check(battery, attached_dev);
+		battery->muic_cable_type = attached_dev;
+		break;
+	default:
+		cmd = "ERROR";
+		cable_type = -1;
+		battery->muic_cable_type = ATTACHED_DEV_NONE_MUIC;
+		break;
+	}
+
+#if 0 //temp block
+	sec_bat_set_misc_event(battery, BATT_MISC_EVENT_UNDEFINED_RANGE_TYPE,
+		(battery->muic_cable_type != ATTACHED_DEV_UNDEFINED_RANGE_MUIC));
+#endif
+
+	if (cable_type < 0) {
+		dev_info(battery->dev, "%s: ignore event(%d)\n",
+			__func__, cable_type);
+	} else if (cable_type == POWER_SUPPLY_TYPE_POWER_SHARING) {
+		battery->ps_status = true;
+		battery->ps_enable = true;
+		battery->wire_status = cable_type;
+		dev_info(battery->dev, "%s: power sharing cable plugin\n", __func__);
+	} else if (cable_type == POWER_SUPPLY_TYPE_WIRELESS) {
+		battery->wc_status = SEC_WIRELESS_PAD_WPC;
+	} else if (cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK) {
+		battery->wc_status = SEC_WIRELESS_PAD_WPC_PACK;
+	} else if (cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK_TA) {
+		battery->wc_status = SEC_WIRELESS_PAD_WPC_PACK_TA;
+	} else if (cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS) {
+		battery->wc_status = SEC_WIRELESS_PAD_WPC_HV;
+	} else if (cable_type == POWER_SUPPLY_TYPE_PMA_WIRELESS) {
+		battery->wc_status = SEC_WIRELESS_PAD_PMA;
+	} else if ((cable_type == POWER_SUPPLY_TYPE_UNKNOWN) &&
+		   (battery->status != POWER_SUPPLY_STATUS_DISCHARGING)) {
+		battery->cable_type = cable_type;
+		wake_lock(&battery->monitor_wake_lock);
+		queue_delayed_work_on(0, battery->monitor_wqueue, &battery->monitor_work, 0);
+		dev_info(battery->dev,
+			"%s: UNKNOWN cable plugin\n", __func__);
+		return 0;
+	} else {
+		battery->wire_status = cable_type;
+		if ((battery->wire_status == POWER_SUPPLY_TYPE_BATTERY)	&&
+			(battery->wc_status) && (!battery->ps_status))
+			cable_type = POWER_SUPPLY_TYPE_WIRELESS;
+	}
+	dev_info(battery->dev,
+			"%s: current_cable(%d), wc_status(%d), wire_status(%d)\n",
+			__func__, cable_type, battery->wc_status,
+			battery->wire_status);
+
+	if (attached_dev == ATTACHED_DEV_USB_LANHUB_MUIC) {
+		if (!strcmp(cmd, "ATTACH")) {
+			value.intval = true;
+			psy_do_property(battery->pdata->charger_name, set,
+					POWER_SUPPLY_PROP_CHARGE_POWERED_OTG_CONTROL,
+					value);
+			dev_info(battery->dev,
+				"%s: Powered OTG cable attached\n", __func__);
+		} else {
+			value.intval = false;
+			psy_do_property(battery->pdata->charger_name, set,
+					POWER_SUPPLY_PROP_CHARGE_POWERED_OTG_CONTROL,
+					value);
+			dev_info(battery->dev,
+				"%s: Powered OTG cable detached\n", __func__);
+		}
+	}
+
+#if defined(CONFIG_AFC_CHARGER_MODE)
+	if (!strcmp(cmd, "ATTACH")) {
+		if ((battery->muic_cable_type >= ATTACHED_DEV_QC_CHARGER_PREPARE_MUIC) &&
+		    (battery->muic_cable_type <= ATTACHED_DEV_QC_CHARGER_9V_MUIC)) {
+			battery->hv_chg_name = "QC";
+		} else if ((battery->muic_cable_type >= ATTACHED_DEV_AFC_CHARGER_PREPARE_MUIC) &&
+			 (battery->muic_cable_type <= ATTACHED_DEV_AFC_CHARGER_ERR_V_DUPLI_MUIC)) {
+			battery->hv_chg_name = "AFC";
+#if defined(CONFIG_MUIC_HV_12V)
+		} else if (battery->muic_cable_type == ATTACHED_DEV_AFC_CHARGER_12V_MUIC) {
+			battery->hv_chg_name = "12V";
+#endif
+		} else
+			battery->hv_chg_name = "NONE";
+	} else {
+			battery->hv_chg_name = "NONE";
+	}
+
+	pr_info("%s : HV_CHARGER_NAME(%s)\n",
+		__func__, battery->hv_chg_name);
+#endif
+
+	if ((cable_type >= 0) &&
+	    cable_type <= SEC_SIZEOF_POWER_SUPPLY_TYPE) {
+		if (cable_type == POWER_SUPPLY_TYPE_POWER_SHARING) {
+			value.intval = battery->ps_enable;
+			psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL, value);
+			wake_lock(&battery->monitor_wake_lock);
+			queue_delayed_work_on(0, battery->monitor_wqueue, &battery->monitor_work, 0);
+		} else if((cable_type == POWER_SUPPLY_TYPE_BATTERY) && (battery->ps_status)) {
+			if (battery->ps_enable) {
+				battery->ps_enable = false;
+				value.intval = battery->ps_enable;
+				psy_do_property(battery->pdata->charger_name, set,
+					POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL, value);
+			}
+			battery->ps_status = false;
+			wake_lock(&battery->monitor_wake_lock);
+			queue_delayed_work_on(0, battery->monitor_wqueue, &battery->monitor_work, 0);
+		} else if(cable_type != battery->cable_type) {
+			wake_lock(&battery->cable_wake_lock);
+			queue_delayed_work_on(0, battery->monitor_wqueue,
+					   &battery->cable_work, 0);
+		} else {
+			dev_info(battery->dev,
+				"%s: Cable is Not Changed(%d)\n",
+				__func__, battery->cable_type);
+		}
+	}
+
+	pr_info("%s: CMD=%s, attached_dev=%d\n", __func__, cmd, attached_dev);
+
+	return 0;
+}
+#endif /* CONFIG_MUIC_NOTIFIER */
+
+#if defined(CONFIG_VBUS_NOTIFIER)
+static int vbus_handle_notification(struct notifier_block *nb,
+		unsigned long action, void *data)
+{
+	vbus_status_t vbus_status = *(vbus_status_t *)data;
+	struct sec_battery_info *battery =
+		container_of(nb, struct sec_battery_info,
+			     vbus_nb);
+	union power_supply_propval value;
+
+	if (battery->muic_cable_type == ATTACHED_DEV_HMT_MUIC &&
+		battery->muic_vbus_status != vbus_status &&
+		battery->muic_vbus_status == STATUS_VBUS_HIGH &&
+		vbus_status == STATUS_VBUS_LOW) {
+		sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING_OFF);
+		msleep(500);
+		value.intval = true;
+		psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL,
+				value);
+		dev_info(battery->dev,
+			"%s: changed to OTG cable attached\n", __func__);
+
+		battery->wire_status = POWER_SUPPLY_TYPE_OTG;
+		wake_lock(&battery->cable_wake_lock);
+		queue_delayed_work_on(0, battery->monitor_wqueue, &battery->cable_work, 0);
+	}
+	pr_info("%s: action=%d, vbus_status=%d\n", __func__, (int)action, vbus_status);
+	battery->muic_vbus_status = vbus_status;
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_OF
+static int sec_bat_parse_dt(struct device *dev,
+		struct sec_battery_info *battery)
+{
+	struct device_node *np = dev->of_node;
+	sec_battery_platform_data_t *pdata = battery->pdata;
+	int ret = 0, len;
+	unsigned int i;
+	const u32 *p;
+	u32 temp = 0;
+
+	if (!np) {
+		pr_info("%s: np NULL\n", __func__);
+		return 1;
+	}
+
+	ret = of_property_read_string(np,
+		"battery,vendor", (char const **)&pdata->vendor);
+	if (ret)
+		pr_info("%s: Vendor is Empty\n", __func__);
+
+	ret = of_property_read_string(np,
+		"battery,charger_name", (char const **)&pdata->charger_name);
+	if (ret)
+		pr_info("%s: Charger name is Empty\n", __func__);
+
+	ret = of_property_read_string(np,
+		"battery,fuelgauge_name", (char const **)&pdata->fuelgauge_name);
+	if (ret)
+		pr_info("%s: Fuelgauge name is Empty\n", __func__);
+
+	ret = of_property_read_string(np,
+		"battery,wireless_charger_name", (char const **)&pdata->wireless_charger_name);
+	if (ret)
+		pr_info("%s: Wireless charger name is Empty\n", __func__);
+
+	ret = of_property_read_string(np,
+		"battery,fgsrc_switch_name", (char const **)&pdata->fgsrc_switch_name);
+	if (ret)
+		pr_info("%s: fgsrc_switch_name is Empty\n", __func__);
+	else
+		pdata->support_fgsrc_change = true;
+
+	ret = of_property_read_string(np,
+		"battery,chip_vendor", (char const **)&pdata->chip_vendor);
+	if (ret)
+		pr_info("%s: Chip vendor is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,technology",
+		&pdata->technology);
+	if (ret)
+		pr_info("%s : technology is Empty\n", __func__);
+
+	ret = of_property_read_u32(np,
+		"battery,wireless_cc_cv", &pdata->wireless_cc_cv);
+
+	pdata->fake_capacity = of_property_read_bool(np,
+						     "battery,fake_capacity");
+
+	p = of_get_property(np, "battery,polling_time", &len);
+	if (!p)
+		return 1;
+
+	len = len / sizeof(u32);
+	pdata->polling_time = kzalloc(sizeof(*pdata->polling_time) * len, GFP_KERNEL);
+	ret = of_property_read_u32_array(np, "battery,polling_time",
+					 pdata->polling_time, len);
+	if (ret)
+		pr_info("%s : battery,polling_time is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,thermal_source",
+		&pdata->thermal_source);
+	if (ret)
+		pr_info("%s : Thermal source is Empty\n", __func__);
+
+	if (pdata->thermal_source == SEC_BATTERY_THERMAL_SOURCE_ADC) {
+		p = of_get_property(np, "battery,temp_table_adc", &len);
+		if (!p)
+			return 1;
+
+		len = len / sizeof(u32);
+
+		pdata->temp_adc_table_size = len;
+		pdata->temp_amb_adc_table_size = len;
+
+		pdata->temp_adc_table =
+			kzalloc(sizeof(sec_bat_adc_table_data_t) *
+				pdata->temp_adc_table_size, GFP_KERNEL);
+		pdata->temp_amb_adc_table =
+			kzalloc(sizeof(sec_bat_adc_table_data_t) *
+				pdata->temp_adc_table_size, GFP_KERNEL);
+
+		for(i = 0; i < pdata->temp_adc_table_size; i++) {
+			ret = of_property_read_u32_index(np,
+					 "battery,temp_table_adc", i, &temp);
+			pdata->temp_adc_table[i].adc = (int)temp;
+			if (ret)
+				pr_info("%s : Temp_adc_table(adc) is Empty\n",
+					__func__);
+
+			ret = of_property_read_u32_index(np,
+							 "battery,temp_table_data", i, &temp);
+			pdata->temp_adc_table[i].data = (int)temp;
+			if (ret)
+				pr_info("%s : Temp_adc_table(data) is Empty\n",
+					__func__);
+
+			ret = of_property_read_u32_index(np,
+							 "battery,temp_table_adc", i, &temp);
+			pdata->temp_amb_adc_table[i].adc = (int)temp;
+			if (ret)
+				pr_info("%s : Temp_amb_adc_table(adc) is Empty\n",
+					__func__);
+
+			ret = of_property_read_u32_index(np,
+							 "battery,temp_table_data", i, &temp);
+			pdata->temp_amb_adc_table[i].data = (int)temp;
+			if (ret)
+				pr_info("%s : Temp_amb_adc_table(data) is Empty\n",
+					__func__);
+		}
+	}
+	ret = of_property_read_u32(np, "battery,chg_thermal_source",
+		&pdata->chg_thermal_source);
+	if (ret)
+		pr_info("%s : chg_thermal_source is Empty\n", __func__);
+
+	if(pdata->chg_thermal_source) {
+		p = of_get_property(np, "battery,chg_temp_table_adc", &len);
+		if (!p)
+			return 1;
+
+		len = len / sizeof(u32);
+
+		pdata->chg_temp_adc_table_size = len;
+
+		pdata->chg_temp_adc_table =
+			kzalloc(sizeof(sec_bat_adc_table_data_t) *
+				pdata->chg_temp_adc_table_size, GFP_KERNEL);
+
+		for(i = 0; i < pdata->chg_temp_adc_table_size; i++) {
+			ret = of_property_read_u32_index(np,
+							 "battery,chg_temp_table_adc", i, &temp);
+			pdata->chg_temp_adc_table[i].adc = (int)temp;
+			if (ret)
+				pr_info("%s : CHG_Temp_adc_table(adc) is Empty\n",
+					__func__);
+
+			ret = of_property_read_u32_index(np,
+							 "battery,chg_temp_table_data", i, &temp);
+			pdata->chg_temp_adc_table[i].data = (int)temp;
+			if (ret)
+				pr_info("%s : CHG_Temp_adc_table(data) is Empty\n",
+					__func__);
+		}
+	}
+
+	ret = of_property_read_u32(np, "battery,wpc_thermal_source",
+		&pdata->wpc_thermal_source);
+	if (ret)
+		pr_info("%s : wpc_thermal_source is Empty\n", __func__);
+
+	if(pdata->wpc_thermal_source) {
+		p = of_get_property(np, "battery,wpc_temp_table_adc", &len);
+		if (!p) {
+			pr_info("%s : wpc_temp_table_adc(adc) is Empty\n",__func__);
+		} else {
+			len = len / sizeof(u32);
+
+			pdata->wpc_temp_adc_table_size = len;
+
+			pdata->wpc_temp_adc_table =
+				kzalloc(sizeof(sec_bat_adc_table_data_t) *
+					pdata->wpc_temp_adc_table_size, GFP_KERNEL);
+
+			for(i = 0; i < pdata->wpc_temp_adc_table_size; i++) {
+				ret = of_property_read_u32_index(np,
+								 "battery,wpc_temp_table_adc", i, &temp);
+				pdata->wpc_temp_adc_table[i].adc = (int)temp;
+				if (ret)
+					pr_info("%s : WPC_Temp_adc_table(adc) is Empty\n",
+						__func__);
+
+				ret = of_property_read_u32_index(np,
+								 "battery,wpc_temp_table_data", i, &temp);
+				pdata->wpc_temp_adc_table[i].data = (int)temp;
+				if (ret)
+					pr_info("%s : WPC_Temp_adc_table(data) is Empty\n",
+						__func__);
+			}
+		}
+	}
+
+	ret = of_property_read_u32(np, "battery,slave_thermal_source",
+		&pdata->slave_thermal_source);
+	if (ret)
+		pr_info("%s : slave_thermal_source is Empty\n", __func__);
+
+	if(pdata->slave_thermal_source) {
+		p = of_get_property(np, "battery,slave_chg_temp_table_adc", &len);
+		if (!p)
+			return 1;
+
+		len = len / sizeof(u32);
+
+		pdata->slave_chg_temp_adc_table_size = len;
+
+		pdata->slave_chg_temp_adc_table =
+			kzalloc(sizeof(sec_bat_adc_table_data_t) *
+				pdata->slave_chg_temp_adc_table_size, GFP_KERNEL);
+
+		for(i = 0; i < pdata->slave_chg_temp_adc_table_size; i++) {
+			ret = of_property_read_u32_index(np,
+							 "battery,slave_chg_temp_table_adc", i, &temp);
+			pdata->slave_chg_temp_adc_table[i].adc = (int)temp;
+			if (ret)
+				pr_info("%s : slave_chg_temp_adc_table(adc) is Empty\n",
+					__func__);
+
+			ret = of_property_read_u32_index(np,
+							 "battery,slave_chg_temp_table_data", i, &temp);
+			pdata->slave_chg_temp_adc_table[i].data = (int)temp;
+			if (ret)
+				pr_info("%s : slave_chg_temp_adc_table(data) is Empty\n",
+					__func__);
+		}
+	}
+	ret = of_property_read_u32(np, "battery,slave_chg_temp_check",
+		&pdata->slave_chg_temp_check);
+	if (ret)
+		pr_info("%s : slave_chg_temp_check is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,chg_temp_check",
+		&pdata->chg_temp_check);
+	if (ret)
+		pr_info("%s : chg_temp_check is Empty\n", __func__);
+
+	if (pdata->chg_temp_check) {
+		ret = of_property_read_u32(np, "battery,chg_high_temp_1st",
+					   &temp);
+		pdata->chg_high_temp_1st = (int)temp;
+		if (ret)
+			pr_info("%s : chg_high_temp_threshold is Empty\n", __func__);
+
+		ret = of_property_read_u32(np, "battery,chg_high_temp_2nd",
+					   &temp);
+		pdata->chg_high_temp_2nd = (int)temp;
+		if (ret)
+			pr_info("%s : chg_high_temp_threshold is Empty\n", __func__);
+
+		ret = of_property_read_u32(np, "battery,chg_high_temp_recovery",
+					   &temp);
+		pdata->chg_high_temp_recovery = (int)temp;
+		if (ret)
+			pr_info("%s : chg_temp_recovery is Empty\n", __func__);
+
+		ret = of_property_read_u32(np, "battery,chg_charging_limit_current",
+					   &pdata->chg_charging_limit_current);
+		if (ret)
+			pr_info("%s : chg_charging_limit_current is Empty\n", __func__);
+
+		ret = of_property_read_u32(np, "battery,chg_charging_limit_current_2nd",
+					   &pdata->chg_charging_limit_current_2nd);
+		if (ret)
+			pr_info("%s : chg_charging_limit_current_2nd is Empty\n", __func__);
+
+		ret = of_property_read_u32(np, "battery,chg_skip_check_time",
+					   &pdata->chg_skip_check_time);
+		if (ret)
+			pr_info("%s : chg_skip_check_time is Empty\n", __func__);
+
+		ret = of_property_read_u32(np, "battery,chg_skip_check_capacity",
+					   &pdata->chg_skip_check_capacity);
+		if (ret)
+			pr_info("%s : chg_skip_check_capacity is Empty\n", __func__);
+	}
+
+	ret = of_property_read_u32(np, "battery,wpc_temp_check",
+		&pdata->wpc_temp_check);
+	if (ret)
+		pr_info("%s : wpc_temp_check is Empty\n", __func__);
+
+	if (pdata->wpc_temp_check) {
+		ret = of_property_read_u32(np, "battery,wpc_high_temp",
+					   &temp);
+		pdata->wpc_high_temp = (int)temp;
+		if (ret)
+			pr_info("%s : wpc_high_temp is Empty\n", __func__);
+
+		ret = of_property_read_u32(np, "battery,wpc_high_temp_recovery",
+					   &temp);
+		pdata->wpc_high_temp_recovery = (int)temp;
+		if (ret)
+			pr_info("%s : wpc_high_temp_recovery is Empty\n", __func__);
+
+		ret = of_property_read_u32(np, "battery,wpc_heat_temp_recovery",
+					   &temp);
+		pdata->wpc_heat_temp_recovery = (int)temp;
+		if (ret)
+			pr_info("%s : wpc_heat_temp_recovery is Empty\n", __func__);
+
+		ret = of_property_read_u32(np, "battery,wpc_hv_lcd_on_input_limit_current",
+				   &pdata->wpc_hv_lcd_on_input_limit_current);
+		if (ret)
+			pr_info("%s : wpc_hv_lcd_on_input_limit_current is Empty\n", __func__);
+
+		ret = of_property_read_u32(np, "battery,wpc_charging_limit_current",
+				   &pdata->wpc_charging_limit_current);
+		if (ret)
+			pr_info("%s : wpc_charging_limit_current is Empty\n", __func__);
+
+		ret = of_property_read_u32(np, "battery,wpc_skip_check_time",
+					   &pdata->wpc_skip_check_time);
+		if (ret)
+			pr_info("%s : wpc_skip_check_time is Empty\n", __func__);
+
+		ret = of_property_read_u32(np, "battery,wpc_skip_check_capacity",
+					   &pdata->wpc_skip_check_capacity);
+		if (ret)
+			pr_info("%s : wpc_skip_check_capacity is Empty\n", __func__);
+
+		ret = of_property_read_u32(np, "battery,wpc_lcd_on_high_temp",
+					   &pdata->wpc_lcd_on_high_temp);
+		if (ret)
+			pr_info("%s : wpc_lcd_on_high_temp is Empty\n", __func__);
+
+		ret = of_property_read_u32(np, "battery,wpc_lcd_on_high_temp_rec",
+					   &pdata->wpc_lcd_on_high_temp_rec);
+		if (ret)
+			pr_info("%s : wpc_lcd_on_high_temp_rec is Empty\n", __func__);
+	}
+
+	ret = of_property_read_u32(np, "battery,wc_full_input_limit_current",
+		&pdata->wc_full_input_limit_current);
+	if (ret)
+		pr_info("%s : wc_full_input_limit_current is Empty\n", __func__);	
+
+	ret = of_property_read_u32(np, "battery,wc_heating_input_limit_current",
+		&pdata->wc_heating_input_limit_current);
+	if (ret)
+		pr_info("%s : wc_heating_input_limit_current is Empty\n", __func__);	
+
+	ret = of_property_read_u32(np, "battery,wc_heating_time",
+		&pdata->wc_heating_time);
+	if (ret)
+		pr_info("%s : wc_heating_time is Empty\n", __func__);	
+
+	ret = of_property_read_u32(np, "battery,wc_cv_current",
+		&pdata->wc_cv_current);
+	if (ret)
+		pr_info("%s : wc_cv_current is Empty\n", __func__);	
+
+	ret = of_property_read_u32(np, "battery,sleep_mode_limit_current",
+			&pdata->sleep_mode_limit_current);
+	if (ret)
+		pr_info("%s : sleep_mode_limit_current is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,inbat_voltage",
+			&pdata->inbat_voltage);
+	if (ret)
+		pr_info("%s : inbat_voltage is Empty\n", __func__);
+
+	if (pdata->inbat_voltage) {
+		p = of_get_property(np, "battery,inbat_voltage_table_adc", &len);
+		if (!p)
+			return 1;
+
+		len = len / sizeof(u32);
+
+		pdata->inbat_adc_table_size = len;
+
+		pdata->inbat_adc_table =
+			kzalloc(sizeof(sec_bat_adc_table_data_t) *
+					pdata->inbat_adc_table_size, GFP_KERNEL);
+
+		for(i = 0; i < pdata->inbat_adc_table_size; i++) {
+			ret = of_property_read_u32_index(np,
+							 "battery,inbat_voltage_table_adc", i, &temp);
+			pdata->inbat_adc_table[i].adc = (int)temp;
+			if (ret)
+				pr_info("%s : inbat_adc_table(adc) is Empty\n",
+						__func__);
+
+			ret = of_property_read_u32_index(np,
+							 "battery,inbat_voltage_table_data", i, &temp);
+			pdata->inbat_adc_table[i].data = (int)temp;
+			if (ret)
+				pr_info("%s : inbat_adc_table(data) is Empty\n",
+						__func__);
+		}
+	}
+
+	p = of_get_property(np, "battery,input_current_limit", &len);
+	if (!p)
+		return 1;
+
+	len = len / sizeof(u32);
+
+	pdata->charging_current =
+		kzalloc(sizeof(sec_charging_current_t) * len,
+			GFP_KERNEL);
+
+	for(i = 0; i < len; i++) {
+		ret = of_property_read_u32_index(np,
+			 "battery,input_current_limit", i,
+			 &pdata->charging_current[i].input_current_limit);
+		if (ret)
+			pr_info("%s : Input_current_limit is Empty\n",
+				__func__);
+
+		ret = of_property_read_u32_index(np,
+			 "battery,fast_charging_current", i,
+			 &pdata->charging_current[i].fast_charging_current);
+		if (ret)
+			pr_info("%s : Fast charging current is Empty\n",
+				__func__);
+
+		ret = of_property_read_u32_index(np,
+			 "battery,full_check_current_1st", i,
+			 &pdata->charging_current[i].full_check_current_1st);
+		if (ret)
+			pr_info("%s : Full check current 1st is Empty\n",
+				__func__);
+
+		ret = of_property_read_u32_index(np,
+			 "battery,full_check_current_2nd", i,
+			 &pdata->charging_current[i].full_check_current_2nd);
+		if (ret)
+			pr_info("%s : Full check current 2nd is Empty\n",
+				__func__);
+	}
+	ret = of_property_read_u32(np, "battery,pre_afc_input_current",
+		&pdata->pre_afc_input_current);
+	if (ret) {
+		pr_info("%s : pre_afc_input_current is Empty\n", __func__);
+		pdata->pre_afc_input_current = 1000;
+	}
+
+	ret = of_property_read_u32(np, "battery,pre_wc_afc_input_current",
+		&pdata->pre_wc_afc_input_current);
+	if (ret) {
+		pr_info("%s : pre_wc_afc_input_current is Empty\n", __func__);
+		pdata->pre_wc_afc_input_current = 500;
+	}
+
+	ret = of_property_read_u32(np, "battery,store_mode_afc_input_current",
+		&pdata->store_mode_afc_input_current);
+	if (ret) {
+		pr_info("%s : store_mode_afc_input_current is Empty\n", __func__);
+		pdata->store_mode_afc_input_current = 440;
+	}
+
+	ret = of_property_read_u32(np, "battery,store_mode_hv_wireless_input_current",
+		&pdata->store_mode_hv_wireless_input_current);
+	if (ret) {
+		pr_info("%s : store_mode_hv_wireless_input_current is Empty\n", __func__);
+		pdata->store_mode_hv_wireless_input_current = 400;
+	}
+
+	ret = of_property_read_u32(np, "battery,adc_check_count",
+		&pdata->adc_check_count);
+	if (ret)
+		pr_info("%s : Adc check count is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,temp_adc_type",
+		&pdata->temp_adc_type);
+	if (ret)
+		pr_info("%s : Temp adc type is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,cable_check_type",
+		&pdata->cable_check_type);
+	if (ret)
+		pr_info("%s : Cable check type is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,cable_source_type",
+		&pdata->cable_source_type);
+	if (ret)
+		pr_info("%s : Cable source type is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,polling_type",
+		&pdata->polling_type);
+	if (ret)
+		pr_info("%s : Polling type is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,monitor_initial_count",
+		&pdata->monitor_initial_count);
+	if (ret)
+		pr_info("%s : Monitor initial count is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,battery_check_type",
+		&pdata->battery_check_type);
+	if (ret)
+		pr_info("%s : Battery check type is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,check_count",
+		&pdata->check_count);
+	if (ret)
+		pr_info("%s : Check count is Empty\n", __func__);
+
+	pdata->bat_irq_gpio = of_get_named_gpio(np, "battery,bat_irq_gpio", 0);
+	pr_info("%s : bat_irq_gpio = %d\n", __func__, pdata->bat_irq_gpio);
+
+	ret = of_property_read_u32(np, "battery,bat_irq_attr", &pdata->bat_irq_attr);
+	if(ret)
+		pr_info("%s : bat_irq_attr is Empty, irq_attr\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,check_adc_max",
+		&pdata->check_adc_max);
+	if (ret)
+		pr_info("%s : Check adc max is Empty\n", __func__);
+
+        ret = of_property_read_u32(np, "battery,check_adc_min",
+                &pdata->check_adc_min);
+	if (ret)
+		pr_info("%s : Check adc min is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,ovp_uvlo_check_type",
+		&pdata->ovp_uvlo_check_type);
+	if (ret)
+		pr_info("%s : Ovp Uvlo check type is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,temp_check_type",
+		&pdata->temp_check_type);
+	if (ret)
+		pr_info("%s : Temp check type is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,temp_check_count",
+		&pdata->temp_check_count);
+	if (ret)
+		pr_info("%s : Temp check count is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,temp_highlimit_threshold_normal",
+				   &temp);
+	pdata->temp_highlimit_threshold_normal =  (int)temp;
+	if (ret)
+		pr_info("%s : Temp highlimit threshold normal is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,temp_highlimit_recovery_normal",
+				   &temp);
+	pdata->temp_highlimit_recovery_normal =  (int)temp;
+	if (ret)
+		pr_info("%s : Temp highlimit recovery normal is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,temp_high_threshold_normal",
+				   &temp);
+	pdata->temp_high_threshold_normal =  (int)temp;
+	if (ret)
+		pr_info("%s : Temp high threshold normal is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,temp_high_recovery_normal",
+				   &temp);
+	pdata->temp_high_recovery_normal =  (int)temp;
+	if (ret)
+		pr_info("%s : Temp high recovery normal is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,temp_low_threshold_normal",
+				   &temp);
+	pdata->temp_low_threshold_normal =  (int)temp;
+	if (ret)
+		pr_info("%s : Temp low threshold normal is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,temp_low_recovery_normal",
+				   &temp);
+	pdata->temp_low_recovery_normal =  (int)temp;
+	if (ret)
+		pr_info("%s : Temp low recovery normal is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,temp_highlimit_threshold_lpm",
+				   &temp);
+	pdata->temp_highlimit_threshold_lpm = (int)temp;
+	if (ret)
+		pr_info("%s : Temp highlimit threshold lpm is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,temp_highlimit_recovery_lpm",
+				   &temp);
+	pdata->temp_highlimit_recovery_lpm = (int)temp;
+	if (ret)
+		pr_info("%s : Temp highlimit recovery lpm is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,temp_high_threshold_lpm",
+				   &temp);
+	pdata->temp_high_threshold_lpm = (int)temp;
+	if (ret)
+		pr_info("%s : Temp high threshold lpm is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,temp_high_recovery_lpm",
+				   &temp);
+	pdata->temp_high_recovery_lpm = (int)temp;
+	if (ret)
+		pr_info("%s : Temp high recovery lpm is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,temp_low_threshold_lpm",
+				   &temp);
+	pdata->temp_low_threshold_lpm = (int)temp;
+	if (ret)
+		pr_info("%s : Temp low threshold lpm is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,temp_low_recovery_lpm",
+				   &temp);
+	pdata->temp_low_recovery_lpm = (int)temp;
+	if (ret)
+		pr_info("%s : Temp low recovery lpm is Empty\n", __func__);
+
+	pr_info("%s : HIGHLIMIT_THRESHOLD_NOLMAL(%d), HIGHLIMIT_RECOVERY_NORMAL(%d)\n"
+		"HIGH_THRESHOLD_NORMAL(%d), HIGH_RECOVERY_NORMAL(%d) LOW_THRESHOLD_NORMAL(%d), LOW_RECOVERY_NORMAL(%d)\n"
+		"HIGHLIMIT_THRESHOLD_LPM(%d), HIGHLIMIT_RECOVERY_LPM(%d)\n"
+		"HIGH_THRESHOLD_LPM(%d), HIGH_RECOVERY_LPM(%d) LOW_THRESHOLD_LPM(%d), LOW_RECOVERY_LPM(%d)\n",
+		__func__,
+		pdata->temp_highlimit_threshold_normal, pdata->temp_highlimit_recovery_normal,
+		pdata->temp_high_threshold_normal, pdata->temp_high_recovery_normal,
+		pdata->temp_low_threshold_normal, pdata->temp_low_recovery_normal,
+		pdata->temp_highlimit_threshold_lpm, pdata->temp_highlimit_recovery_lpm,
+		pdata->temp_high_threshold_lpm, pdata->temp_high_recovery_lpm,
+		pdata->temp_low_threshold_lpm, pdata->temp_low_recovery_lpm);
+
+	ret = of_property_read_u32(np, "battery,full_check_type",
+		&pdata->full_check_type);
+	if (ret)
+		pr_info("%s : Full check type is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,full_check_type_2nd",
+		&pdata->full_check_type_2nd);
+	if (ret)
+		pr_info("%s : Full check type 2nd is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,full_check_count",
+		&pdata->full_check_count);
+	if (ret)
+		pr_info("%s : Full check count is Empty\n", __func__);
+
+        ret = of_property_read_u32(np, "battery,chg_gpio_full_check",
+                &pdata->chg_gpio_full_check);
+	if (ret)
+		pr_info("%s : Chg gpio full check is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,chg_polarity_full_check",
+		&pdata->chg_polarity_full_check);
+	if (ret)
+		pr_info("%s : Chg polarity full check is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,full_condition_type",
+		&pdata->full_condition_type);
+	if (ret)
+		pr_info("%s : Full condition type is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,full_condition_soc",
+		&pdata->full_condition_soc);
+	if (ret)
+		pr_info("%s : Full condition soc is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,full_condition_vcell",
+		&pdata->full_condition_vcell);
+	if (ret)
+		pr_info("%s : Full condition vcell is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,recharge_check_count",
+		&pdata->recharge_check_count);
+	if (ret)
+		pr_info("%s : Recharge check count is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,recharge_condition_type",
+		&pdata->recharge_condition_type);
+	if (ret)
+		pr_info("%s : Recharge condition type is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,recharge_condition_soc",
+		&pdata->recharge_condition_soc);
+	if (ret)
+		pr_info("%s : Recharge condition soc is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,recharge_condition_vcell",
+		&pdata->recharge_condition_vcell);
+	if (ret)
+		pr_info("%s : Recharge condition vcell is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,charging_total_time",
+		(unsigned int *)&pdata->charging_total_time);
+	if (ret)
+		pr_info("%s : Charging total time is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,recharging_total_time",
+		(unsigned int *)&pdata->recharging_total_time);
+	if (ret)
+		pr_info("%s : Recharging total time is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,charging_reset_time",
+		(unsigned int *)&pdata->charging_reset_time);
+	if (ret)
+		pr_info("%s : Charging reset time is Empty\n", __func__);
+
+	ret = of_property_read_u32(np,
+			"battery,expired_time", &temp);
+	if (ret) {
+		pr_info("expired time is empty\n");
+		pdata->expired_time = 3 * 60 * 60;
+	} else {
+		pdata->expired_time = (unsigned int) temp;
+	}
+	pdata->expired_time *= 1000;
+	battery->expired_time = pdata->expired_time;
+
+	ret = of_property_read_u32(np,
+			"battery,recharging_expired_time", &temp);
+	if (ret) {
+		pr_info("expired time is empty\n");
+		pdata->recharging_expired_time = 90 * 60;
+	} else {
+		pdata->recharging_expired_time = (unsigned int) temp;
+	}
+	pdata->recharging_expired_time *= 1000;
+
+	ret = of_property_read_u32(np,
+			"battery,standard_curr", &pdata->standard_curr);
+	if (ret) {
+		pr_info("standard_curr is empty\n");
+		pdata->standard_curr = 2150;
+	}
+	
+	ret = of_property_read_u32(np, "battery,charging_reset_time",
+		(unsigned int *)&pdata->charging_reset_time);
+	if (ret)
+		pr_info("%s : Charging reset time is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,chg_float_voltage",
+		(unsigned int *)&pdata->chg_float_voltage);
+	if (ret) {
+		pr_info("%s: chg_float_voltage is Empty\n", __func__);
+		pdata->chg_float_voltage = 4350;
+	}
+
+	if( of_property_read_bool(np, "battery,factory_store_mode_en"))
+		pdata->factory_store_mode_en = true;
+	else
+		pdata->factory_store_mode_en = false;
+	pr_info("%s: Factory Store mode : %d \n",__func__,pdata->factory_store_mode_en);
+	
+#if defined(CONFIG_BATTERY_SWELLING_SELF_DISCHARGING)
+	ret = of_property_read_u32(np, "battery,self_discharging_type",
+				(unsigned int *)&pdata->self_discharging_type);
+	if (ret) {
+		pr_info("%s: Self discharging type is Empty, Set default\n",
+			__func__);
+		pdata->self_discharging_type = 0;
+	}
+
+	pdata->factory_discharging = of_get_named_gpio(np, "battery,factory_discharging", 0);
+	if (pdata->factory_discharging < 0)
+		pdata->factory_discharging = 0;
+
+	pdata->self_discharging_en = of_property_read_bool(np,
+							   "battery,self_discharging_en");
+
+	ret = of_property_read_u32(np, "battery,force_discharging_limit",
+				   &temp);
+	pdata->force_discharging_limit = (int)temp;
+	if (ret)
+		pr_info("%s : Force Discharging limit is Empty", __func__);
+
+	ret = of_property_read_u32(np, "battery,force_discharging_recov",
+				   &temp);
+	pdata->force_discharging_recov = (int)temp;
+	if (ret)
+		pr_info("%s : Force Discharging recov is Empty", __func__);
+
+	pr_info("%s : FORCE_DISCHARGING_LIMT(%d), FORCE_DISCHARGING_RECOV(%d)\n",
+		__func__, pdata->force_discharging_limit, pdata->force_discharging_recov);
+
+	if (!pdata->self_discharging_type) {
+		ret = of_property_read_u32(np, "battery,discharging_adc_min",
+			(unsigned int *)&pdata->discharging_adc_min);
+		if (ret)
+			pr_info("%s : Discharging ADC Min is Empty", __func__);
+
+		ret = of_property_read_u32(np, "battery,discharging_adc_max",
+			(unsigned int *)&pdata->discharging_adc_max);;
+		if (ret)
+			pr_info("%s : Discharging ADC Max is Empty", __func__);
+	}
+
+	ret = of_property_read_u32(np, "battery,self_discharging_voltage_limit",
+				   (unsigned int *)&pdata->self_discharging_voltage_limit);
+	if (ret)
+		pr_info("%s : Force Discharging recov is Empty", __func__);
+
+	ret = of_property_read_u32(np, "battery,discharging_ntc_limit",
+				   (unsigned int *)&pdata->discharging_ntc_limit);
+	if (ret)
+		pr_info("%s : Discharging NTC LIMIT is Empty", __func__);
+#endif
+#if defined(CONFIG_BATTERY_SWELLING)
+	ret = of_property_read_u32(np, "battery,chg_float_voltage",
+		(unsigned int *)&pdata->swelling_normal_float_voltage);
+	if (ret)
+		pr_info("%s: chg_float_voltage is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,swelling_high_temp_block",
+				   &temp);
+	pdata->swelling_high_temp_block = (int)temp;
+	if (ret)
+		pr_info("%s: swelling high temp block is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,swelling_high_temp_recov",
+				   &temp);
+	pdata->swelling_high_temp_recov = (int)temp;
+	if (ret)
+		pr_info("%s: swelling high temp recovery is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,swelling_low_temp_2step_mode",
+				   &pdata->swelling_low_temp_2step_mode);
+	if (ret) {
+		pr_info("%s: swelling_low_temp_2step_mode is Empty\n", __func__);
+		pdata->swelling_low_temp_2step_mode = 0;
+	}
+	
+	if(pdata->swelling_low_temp_2step_mode) {
+		ret = of_property_read_u32(np, "battery,swelling_low_temp_block_1st",
+				   &temp);
+		pdata->swelling_low_temp_block_1st = (int)temp;
+		if (ret)
+			pr_info("%s: swelling low temp block is Empty\n", __func__);
+			
+		ret = of_property_read_u32(np, "battery,swelling_low_temp_recov_1st",
+				   &temp);
+		pdata->swelling_low_temp_recov_1st = (int)temp;
+		if (ret)
+			pr_info("%s: swelling low temp recovery is Empty\n", __func__);
+		
+		ret = of_property_read_u32(np, "battery,swelling_low_temp_block_2nd",
+				   &temp);
+		pdata->swelling_low_temp_block_2nd = (int)temp;
+		if (ret)
+			pr_info("%s: swelling low temp block is Empty\n", __func__);
+
+		ret = of_property_read_u32(np, "battery,swelling_low_temp_recov_2nd",
+				   &temp);
+		pdata->swelling_low_temp_recov_2nd = (int)temp;
+		if (ret)
+			pr_info("%s: swelling low temp recovery is Empty\n", __func__);
+	}
+	else {
+		ret = of_property_read_u32(np, "battery,swelling_low_temp_block",
+				   &temp);
+		pdata->swelling_low_temp_block_1st = (int)temp;
+		pdata->swelling_low_temp_block_2nd = (int)temp;
+		if (ret)
+			pr_info("%s: swelling low temp block is Empty\n", __func__);
+
+		ret = of_property_read_u32(np, "battery,swelling_low_temp_recov",
+				   &temp);
+		pdata->swelling_low_temp_recov_1st = (int)temp;
+		pdata->swelling_low_temp_recov_2nd = (int)temp;
+		if (ret)
+			pr_info("%s: swelling low temp recovery is Empty\n", __func__);	
+	}
+
+	ret = of_property_read_u32(np, "battery,swelling_low_temp_current", 
+					&pdata->swelling_low_temp_current);
+	if (ret) {
+		pr_info("%s: swelling_low_temp_current is Empty, Defualt value 600mA \n", __func__);
+		pdata->swelling_low_temp_current = 600;
+	}
+
+	ret = of_property_read_u32(np, "battery,swelling_low_temp_topoff", 
+					&pdata->swelling_low_temp_topoff);
+	if (ret) {
+		pr_info("%s: swelling_low_temp_topoff is Empty, Defualt value 200mA \n", __func__);
+		pdata->swelling_low_temp_topoff = 200;
+	}
+
+	ret = of_property_read_u32(np, "battery,swelling_high_temp_current", 
+					&pdata->swelling_high_temp_current);
+	if (ret) {
+		pr_info("%s: swelling_high_temp_current is Empty, Defualt value 1300mA \n", __func__);
+		pdata->swelling_high_temp_current = 1300;
+	}
+
+	ret = of_property_read_u32(np, "battery,swelling_high_temp_topoff", 
+					&pdata->swelling_high_temp_topoff);
+	if (ret) {
+		pr_info("%s: swelling_high_temp_topoff is Empty, Defualt value 200mA \n", __func__);
+		pdata->swelling_high_temp_topoff = 200;
+	}
+
+	ret = of_property_read_u32(np, "battery,swelling_drop_float_voltage",
+		(unsigned int *)&pdata->swelling_drop_float_voltage);
+	if (ret) {
+		pr_info("%s: swelling drop float voltage is Empty, Default value 4250mV \n", __func__);
+		pdata->swelling_drop_float_voltage = 4250;
+	}
+
+	ret = of_property_read_u32(np, "battery,swelling_offset_voltage",
+		(unsigned int *)&pdata->swelling_offset_voltage);
+	if (ret) {
+		pr_info("%s: swelling offset voltage is Empty, Default value 0mV \n", __func__);
+		pdata->swelling_offset_voltage = 0;
+	}
+
+	ret = of_property_read_u32(np, "battery,swelling_high_rechg_voltage",
+		(unsigned int *)&pdata->swelling_high_rechg_voltage);
+	if (ret) {
+		pr_info("%s: swelling_high_rechg_voltage is Empty\n", __func__);
+		pdata->swelling_high_rechg_voltage = 4150;
+	}
+
+	ret = of_property_read_u32(np, "battery,swelling_low_rechg_voltage",
+		(unsigned int *)&pdata->swelling_low_rechg_voltage);
+	if (ret) {
+		pr_info("%s: swelling_low_rechg_voltage is Empty\n", __func__);
+				pdata->swelling_low_rechg_voltage = 4050;
+	}
+
+	pr_info("%s : SWELLING_HIGH_TEMP(%d) SWELLING_HIGH_TEMP_RECOVERY(%d)\n"
+		"SWELLING_LOW_TEMP_1st(%d) SWELLING_LOW_TEMP_RECOVERY_1st(%d) "
+		"SWELLING_LOW_TEMP_2nd(%d) SWELLING_LOW_TEMP_RECOVERY_2nd(%d) "
+		"SWELLING_LOW_CURRENT(%d, %d), SWELLING_HIGH_CURRENT(%d, %d)\n",
+		__func__, pdata->swelling_high_temp_block, pdata->swelling_high_temp_recov,
+		pdata->swelling_low_temp_block_1st, pdata->swelling_low_temp_recov_1st,
+		pdata->swelling_low_temp_block_2nd, pdata->swelling_low_temp_recov_2nd,
+		pdata->swelling_low_temp_current, pdata->swelling_low_temp_topoff,
+		pdata->swelling_high_temp_current, pdata->swelling_high_temp_topoff);
+#endif
+
+#if defined(CONFIG_CALC_TIME_TO_FULL)
+	ret = of_property_read_u32(np, "battery,ttf_hv_charge_current", 
+					&pdata->ttf_hv_charge_current);
+	if (ret) {
+		pr_info("%s: ttf_hv_charge_current is Empty, Defualt value 0 \n", __func__);
+		pdata->ttf_hv_charge_current =
+			pdata->charging_current[POWER_SUPPLY_TYPE_HV_MAINS].fast_charging_current;
+	}
+	ret = of_property_read_u32(np, "battery,ttf_hv_wireless_charge_current", 
+					&pdata->ttf_hv_wireless_charge_current);
+	if (ret) {
+		pr_info("%s: ttf_hv_wireless_charge_current is Empty, Defualt value 0 \n", __func__);
+		pdata->ttf_hv_wireless_charge_current =
+			pdata->charging_current[POWER_SUPPLY_TYPE_HV_WIRELESS].fast_charging_current - 300;
+	}
+#endif
+
+#if defined(CONFIG_SW_SELF_DISCHARGING)
+	ret = of_property_read_u32(np, "battery,self_discharging_temp_block",
+		(unsigned int *)&pdata->self_discharging_temp_block);
+	if (ret)
+		pr_info("%s: sw self_discharging_temp_block is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,self_discharging_volt_block",
+		(unsigned int *)&pdata->self_discharging_volt_block);
+	if (ret)
+		pr_info("%s: sw self_discharging_volt_block is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,self_discharging_temp_recov",
+		(unsigned int *)&pdata->self_discharging_temp_recov);
+	if (ret)
+		pr_info("%s: sw self_discharging_temp_recov is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,self_discharging_temp_pollingtime",
+		(unsigned int *)&pdata->self_discharging_temp_pollingtime);
+	if (ret)
+		pr_info("%s: sw self_discharging_temp_pollingtime is Empty\n", __func__);
+#endif
+
+#if defined(CONFIG_WIRELESS_FIRMWARE_UPDATE)
+	/* wpc_det */
+	ret = pdata->wpc_det = of_get_named_gpio(np, "battery,wpc_det", 0);
+	if (ret < 0) {
+		pr_info("%s : can't get wpc_det\n", __func__);
+	}
+#endif
+
+	/* wpc_en */
+	ret = pdata->wpc_en = of_get_named_gpio(np, "battery,wpc_en", 0);
+	if (ret < 0) {
+		pr_info("%s : can't get wpc_en\n", __func__);
+	}
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	p = of_get_property(np, "battery,age_data", &len);
+	if (p) {
+		battery->pdata->num_age_step = len / sizeof(sec_age_data_t);
+		battery->pdata->age_data = kzalloc(len, GFP_KERNEL);
+		ret = of_property_read_u32_array(np, "battery,age_data",
+				 (u32 *)battery->pdata->age_data, len/sizeof(u32));
+		if (ret) {
+			pr_err("%s: [Long life] failed to read battery->pdata->age_data: %d\n",
+					__func__, ret);
+			kfree(battery->pdata->age_data);
+			battery->pdata->age_data = NULL;
+			battery->pdata->num_age_step = 0;
+		}
+		pr_err("%s: [Long life] num_age_step : %d\n", __func__, battery->pdata->num_age_step);
+		for (len = 0; len < battery->pdata->num_age_step; ++len) {
+			pr_err("[%d/%d]cycle:%d, float:%d, full_v:%d, recharge_v:%d, soc:%d\n",
+				len, battery->pdata->num_age_step-1,
+				battery->pdata->age_data[len].cycle,
+				battery->pdata->age_data[len].float_voltage,
+				battery->pdata->age_data[len].full_condition_vcell,
+				battery->pdata->age_data[len].recharge_condition_vcell,
+				battery->pdata->age_data[len].full_condition_soc);
+		}
+	} else {
+		battery->pdata->num_age_step = 0;
+		pr_err("%s: [Long life] there is no age_data\n", __func__);
+	}
+#endif
+
+	ret = of_property_read_u32(np, "battery,siop_event_check_type",
+			&pdata->siop_event_check_type);
+	ret = of_property_read_u32(np, "battery,siop_call_cc_current",
+			&pdata->siop_call_cc_current);
+	ret = of_property_read_u32(np, "battery,siop_call_cv_current",
+			&pdata->siop_call_cv_current);
+
+	ret = of_property_read_u32(np, "battery,siop_input_limit_current",
+			&pdata->siop_input_limit_current);
+	if (ret)
+		pdata->siop_input_limit_current = SIOP_INPUT_LIMIT_CURRENT;
+
+	ret = of_property_read_u32(np, "battery,siop_charging_limit_current",
+			&pdata->siop_charging_limit_current);
+	if (ret)
+		pdata->siop_charging_limit_current = SIOP_CHARGING_LIMIT_CURRENT;
+
+	ret = of_property_read_u32(np, "battery,siop_hv_input_limit_current",
+			&pdata->siop_hv_input_limit_current);
+	if (ret)
+		pdata->siop_hv_input_limit_current = SIOP_HV_INPUT_LIMIT_CURRENT;
+
+	ret = of_property_read_u32(np, "battery,siop_hv_charging_limit_current",
+			&pdata->siop_hv_charging_limit_current);
+	if (ret)
+		pdata->siop_hv_charging_limit_current = SIOP_HV_CHARGING_LIMIT_CURRENT;
+
+	ret = of_property_read_u32(np, "battery,siop_wireless_input_limit_current",
+			&pdata->siop_wireless_input_limit_current);
+	if (ret)
+		pdata->siop_wireless_input_limit_current = SIOP_WIRELESS_INPUT_LIMIT_CURRENT;
+
+	ret = of_property_read_u32(np, "battery,siop_wireless_charging_limit_current",
+			&pdata->siop_wireless_charging_limit_current);
+	if (ret)
+		pdata->siop_wireless_charging_limit_current = SIOP_WIRELESS_CHARGING_LIMIT_CURRENT;
+
+	ret = of_property_read_u32(np, "battery,siop_hv_wireless_input_limit_current",
+			&pdata->siop_hv_wireless_input_limit_current);
+	if (ret)
+		pdata->siop_hv_wireless_input_limit_current = SIOP_HV_WIRELESS_INPUT_LIMIT_CURRENT;
+
+	ret = of_property_read_u32(np, "battery,siop_hv_wireless_charging_limit_current",
+			&pdata->siop_hv_wireless_charging_limit_current);
+	if (ret)
+		pdata->siop_hv_wireless_charging_limit_current = SIOP_HV_WIRELESS_CHARGING_LIMIT_CURRENT;
+
+	pr_info("%s: vendor : %s, technology : %d, cable_check_type : %d\n"
+		"cable_source_type : %d, event_waiting_time : %d\n"
+		"polling_type : %d, initial_count : %d, check_count : %d\n"
+		"check_adc_max : %d, check_adc_min : %d\n"
+		"ovp_uvlo_check_type : %d, thermal_source : %d\n"
+		"temp_check_type : %d, temp_check_count : %d\n",
+		__func__,
+		pdata->vendor, pdata->technology,pdata->cable_check_type,
+		pdata->cable_source_type, pdata->event_waiting_time,
+		pdata->polling_type, pdata->monitor_initial_count,
+		pdata->check_count, pdata->check_adc_max, pdata->check_adc_min,
+		pdata->ovp_uvlo_check_type, pdata->thermal_source,
+		pdata->temp_check_type, pdata->temp_check_count);
+
+#if defined(CONFIG_STEP_CHARGING)
+	sec_step_charging_init(battery, dev);
+#endif
+
+	pdata->always_enable = of_property_read_bool(np,
+				"battery,always_enable");
+
+	pdata->chg_eoc_dualpath = of_property_read_bool(np,
+				"battery,chg_eoc_dualpath");
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_OF
+extern sec_battery_platform_data_t sec_battery_pdata;
+#endif
+
+#if !defined(CONFIG_MUIC_NOTIFIER)
+static void cable_initial_check(struct sec_battery_info *battery)
+{
+	union power_supply_propval value;
+
+	pr_info("%s : current_cable_type : (%d)\n", __func__, battery->cable_type);
+
+	if (POWER_SUPPLY_TYPE_BATTERY !=  battery->cable_type) {
+		if (battery->cable_type == POWER_SUPPLY_TYPE_POWER_SHARING) {
+			value.intval =  battery->cable_type;
+			psy_do_property("ps", set,
+					POWER_SUPPLY_PROP_ONLINE, value);
+		} else {
+			value.intval =  battery->cable_type;
+			psy_do_property("battery", set,
+					POWER_SUPPLY_PROP_ONLINE, value);
+		}
+	} else {
+		psy_do_property(battery->pdata->charger_name, get,
+				POWER_SUPPLY_PROP_ONLINE, value);
+		if (value.intval == POWER_SUPPLY_TYPE_WIRELESS) {
+			value.intval = 1;
+			psy_do_property("wireless", set,
+				POWER_SUPPLY_PROP_ONLINE, value);
+		}
+	}
+}
+#endif
+
+static int sec_battery_probe(struct platform_device *pdev)
+{
+	sec_battery_platform_data_t *pdata = NULL;
+	struct sec_battery_info *battery;
+	int ret = 0;
+#ifndef CONFIG_OF
+	int i;
+#endif
+
+	union power_supply_propval value;
+
+	dev_dbg(&pdev->dev,
+		"%s: SEC Battery Driver Loading\n", __func__);
+
+	battery = kzalloc(sizeof(*battery), GFP_KERNEL);
+	if (!battery)
+		return -ENOMEM;
+
+	if (pdev->dev.of_node) {
+		pdata = devm_kzalloc(&pdev->dev,
+				sizeof(sec_battery_platform_data_t),
+				GFP_KERNEL);
+		if (!pdata) {
+			dev_err(&pdev->dev, "Failed to allocate memory\n");
+			ret = -ENOMEM;
+			goto err_bat_free;
+		}
+
+		battery->pdata = pdata;
+		if (sec_bat_parse_dt(&pdev->dev, battery)) {
+			dev_err(&pdev->dev,
+				"%s: Failed to get battery dt\n", __func__);
+			ret = -EINVAL;
+			goto err_bat_free;
+		}
+	} else {
+		pdata = dev_get_platdata(&pdev->dev);
+		battery->pdata = pdata;
+	}
+
+	platform_set_drvdata(pdev, battery);
+
+        battery->dev = &pdev->dev;
+
+	mutex_init(&battery->adclock);
+	mutex_init(&battery->iolock);
+	mutex_init(&battery->misclock);
+
+	dev_dbg(battery->dev, "%s: ADC init\n", __func__);
+
+#ifdef CONFIG_OF
+	adc_init(pdev, battery);
+#else
+	for (i = 0; i < SEC_BAT_ADC_CHANNEL_NUM; i++)
+		adc_init(pdev, pdata, i);
+#endif
+	wake_lock_init(&battery->monitor_wake_lock, WAKE_LOCK_SUSPEND,
+		       "sec-battery-monitor");
+	wake_lock_init(&battery->cable_wake_lock, WAKE_LOCK_SUSPEND,
+		       "sec-battery-cable");
+	wake_lock_init(&battery->vbus_wake_lock, WAKE_LOCK_SUSPEND,
+		       "sec-battery-vbus");
+	wake_lock_init(&battery->afc_wake_lock, WAKE_LOCK_SUSPEND,
+		       "sec-battery-afc");
+	wake_lock_init(&battery->siop_wake_lock, WAKE_LOCK_SUSPEND,
+		       "sec-battery-siop");
+	wake_lock_init(&battery->siop_level_wake_lock, WAKE_LOCK_SUSPEND,
+			"sec-battery-siop_level");
+	wake_lock_init(&battery->siop_event_wake_lock, WAKE_LOCK_SUSPEND,
+			"sec-battery-siop_event");
+	wake_lock_init(&battery->wc_headroom_wake_lock, WAKE_LOCK_SUSPEND,
+			"sec-battery-wc_headroom");
+#if defined(CONFIG_SW_SELF_DISCHARGING)
+	wake_lock_init(&battery->self_discharging_wake_lock, WAKE_LOCK_SUSPEND,
+			   "sec-battery-self-discharging");
+#endif
+#if defined(CONFIG_UPDATE_BATTERY_DATA)
+	wake_lock_init(&battery->batt_data_wake_lock, WAKE_LOCK_SUSPEND,
+			"sec-battery-update-data");
+#endif
+	wake_lock_init(&battery->misc_event_wake_lock, WAKE_LOCK_SUSPEND,
+			"sec-battery-misc-event");
+
+	/* initialization of battery info */
+	sec_bat_set_charging_status(battery,
+			POWER_SUPPLY_STATUS_DISCHARGING);
+	battery->health = POWER_SUPPLY_HEALTH_GOOD;
+	battery->present = true;
+	battery->is_jig_on = false;
+	battery->wdt_kick_disable = 0;
+
+	battery->polling_count = 1;	/* initial value = 1 */
+	battery->polling_time = pdata->polling_time[
+		SEC_BATTERY_POLLING_TIME_DISCHARGING];
+	battery->polling_in_sleep = false;
+	battery->polling_short = false;
+
+	battery->check_count = 0;
+	battery->check_adc_count = 0;
+	battery->check_adc_value = 0;
+
+	battery->charging_start_time = 0;
+	battery->charging_passed_time = 0;
+	battery->wc_heating_start_time = 0;
+	battery->wc_heating_passed_time = 0;
+	battery->charging_next_time = 0;
+	battery->charging_fullcharged_time = 0;
+	battery->siop_level = 100;
+	battery->siop_event = 0;
+	battery->wc_enable = 1;
+	battery->pre_chg_temp = 0;
+#if defined(CONFIG_SAMSUNG_BATTERY_ENG_TEST)
+	battery->stability_test = 0;
+	battery->eng_not_full_status = 0;
+#endif
+	battery->ps_enable = false;
+	battery->wc_status = SEC_WIRELESS_PAD_NONE;
+	battery->wc_cv_mode = false;
+	battery->wire_status = POWER_SUPPLY_TYPE_BATTERY;
+
+#if defined(CONFIG_BATTERY_SWELLING)
+	battery->swelling_mode = SWELLING_MODE_NONE;
+#endif
+	battery->charging_block = false;
+	battery->chg_limit = SEC_BATTERY_CHG_TEMP_NONE;
+	battery->wc_heat_limit = SEC_BATTERY_WC_HEAT_NONE;
+	battery->pad_limit = SEC_BATTERY_WPC_TEMP_NONE;
+
+	battery->temp_highlimit_threshold =
+		pdata->temp_highlimit_threshold_normal;
+	battery->temp_highlimit_recovery =
+		pdata->temp_highlimit_recovery_normal;
+	battery->temp_high_threshold =
+		pdata->temp_high_threshold_normal;
+	battery->temp_high_recovery =
+		pdata->temp_high_recovery_normal;
+	battery->temp_low_recovery =
+		pdata->temp_low_recovery_normal;
+	battery->temp_low_threshold =
+		pdata->temp_low_threshold_normal;
+
+	battery->charging_mode = SEC_BATTERY_CHARGING_NONE;
+	battery->is_recharging = false;
+	battery->cable_type = POWER_SUPPLY_TYPE_BATTERY;
+	battery->test_mode = 0;
+	battery->factory_mode = false;
+	battery->store_mode = false;
+	battery->ignore_store_mode = false;
+	battery->slate_mode = false;
+	slate_mode_state = battery->slate_mode;
+	battery->is_hc_usb = false;
+	battery->safety_timer_set = true;
+	battery->stop_timer = false;
+	battery->prev_safety_time = 0;
+	battery->lcd_status = false;
+	battery->current_event = 0;
+	battery->ignore_siop = false;
+
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	battery->batt_cycle = -1;
+	battery->pdata->age_step = 0;
+#endif
+
+	battery->skip_chg_temp_check = false;
+	battery->skip_wpc_temp_check = false;
+	battery->wpc_temp_mode = false;
+	battery->health_change = false;
+#if defined(CONFIG_BATTERY_SWELLING_SELF_DISCHARGING)
+	battery->self_discharging = false;
+	battery->force_discharging = false;
+	battery->factory_self_discharging_mode_on = false;
+#endif
+#if defined(CONFIG_SW_SELF_DISCHARGING)
+	battery->sw_self_discharging = false;
+#endif
+
+#if 0 //temp block
+	if(charging_night_mode == 49)
+		sleep_mode = true;
+	else
+		sleep_mode = false;
+#endif
+	if (battery->pdata->charger_name == NULL)
+		battery->pdata->charger_name = "sec-charger";
+	if (battery->pdata->fuelgauge_name == NULL)
+		battery->pdata->fuelgauge_name = "sec-fuelgauge";
+
+	battery->psy_bat.name = "battery",
+	battery->psy_bat.type = POWER_SUPPLY_TYPE_BATTERY,
+	battery->psy_bat.properties = sec_battery_props,
+	battery->psy_bat.num_properties = ARRAY_SIZE(sec_battery_props),
+	battery->psy_bat.get_property = sec_bat_get_property,
+	battery->psy_bat.set_property = sec_bat_set_property,
+	battery->psy_usb.name = "usb",
+	battery->psy_usb.type = POWER_SUPPLY_TYPE_USB,
+	battery->psy_usb.supplied_to = supply_list,
+	battery->psy_usb.num_supplicants = ARRAY_SIZE(supply_list),
+	battery->psy_usb.properties = sec_power_props,
+	battery->psy_usb.num_properties = ARRAY_SIZE(sec_power_props),
+	battery->psy_usb.get_property = sec_usb_get_property,
+	battery->psy_ac.name = "ac",
+	battery->psy_ac.type = POWER_SUPPLY_TYPE_MAINS,
+	battery->psy_ac.supplied_to = supply_list,
+	battery->psy_ac.num_supplicants = ARRAY_SIZE(supply_list),
+	battery->psy_ac.properties = sec_ac_props,
+	battery->psy_ac.num_properties = ARRAY_SIZE(sec_ac_props),
+	battery->psy_ac.get_property = sec_ac_get_property;
+	battery->psy_wireless.name = "wireless",
+	battery->psy_wireless.type = POWER_SUPPLY_TYPE_WIRELESS,
+	battery->psy_wireless.supplied_to = supply_list,
+	battery->psy_wireless.num_supplicants = ARRAY_SIZE(supply_list),
+	battery->psy_wireless.properties = sec_power_props,
+	battery->psy_wireless.num_properties = ARRAY_SIZE(sec_power_props),
+	battery->psy_wireless.get_property = sec_wireless_get_property;
+	battery->psy_wireless.set_property = sec_wireless_set_property;
+	battery->psy_ps.name = "ps",
+	battery->psy_ps.type = POWER_SUPPLY_TYPE_POWER_SHARING,
+	battery->psy_ps.supplied_to = supply_list,
+	battery->psy_ps.num_supplicants = ARRAY_SIZE(supply_list),
+	battery->psy_ps.properties = sec_ps_props,
+	battery->psy_ps.num_properties = ARRAY_SIZE(sec_ps_props),
+	battery->psy_ps.get_property = sec_ps_get_property;
+	battery->psy_ps.set_property = sec_ps_set_property;
+
+#if defined (CONFIG_BATTERY_SWELLING_SELF_DISCHARGING)
+	if (battery->pdata->factory_discharging) {
+		ret = gpio_request(battery->pdata->factory_discharging, "FACTORY_DISCHARGING");
+		if (ret) {
+			pr_err("failed to request GPIO %u\n", battery->pdata->factory_discharging);
+			goto err_wake_lock;
+		}
+	}
+#endif
+
+	/* create work queue */
+	battery->monitor_wqueue =
+	    alloc_workqueue(dev_name(&pdev->dev), WQ_MEM_RECLAIM, 1);
+	if (!battery->monitor_wqueue) {
+		dev_err(battery->dev,
+			"%s: Fail to Create Workqueue\n", __func__);
+		goto err_irq;
+	}
+
+	INIT_DELAYED_WORK(&battery->monitor_work, sec_bat_monitor_work);
+	INIT_DELAYED_WORK(&battery->cable_work, sec_bat_cable_work);
+#if defined(CONFIG_CALC_TIME_TO_FULL)
+	INIT_DELAYED_WORK(&battery->timetofull_work, sec_bat_time_to_full_work);
+#endif
+	INIT_DELAYED_WORK(&battery->afc_work, sec_bat_afc_work);
+	INIT_DELAYED_WORK(&battery->wc_afc_work, sec_bat_wc_afc_work);
+	INIT_DELAYED_WORK(&battery->siop_work, sec_bat_siop_work);
+	INIT_DELAYED_WORK(&battery->siop_event_work, sec_bat_siop_event_work);
+	INIT_DELAYED_WORK(&battery->siop_level_work, sec_bat_siop_level_work);
+	INIT_DELAYED_WORK(&battery->wc_headroom_work, sec_bat_wc_headroom_work);
+#if defined(CONFIG_WIRELESS_FIRMWARE_UPDATE)
+	INIT_DELAYED_WORK(&battery->fw_init_work, sec_bat_fw_init_work);
+#endif
+#if defined(CONFIG_UPDATE_BATTERY_DATA)
+	INIT_DELAYED_WORK(&battery->batt_data_work, sec_bat_update_data_work);
+#endif
+	INIT_DELAYED_WORK(&battery->misc_event_work, sec_bat_misc_event_work);
+
+	switch (pdata->polling_type) {
+	case SEC_BATTERY_MONITOR_WORKQUEUE:
+		INIT_DELAYED_WORK(&battery->polling_work,
+			sec_bat_polling_work);
+		break;
+	case SEC_BATTERY_MONITOR_ALARM:
+		battery->last_poll_time = ktime_get_boottime();
+		alarm_init(&battery->polling_alarm, ALARM_BOOTTIME,
+			sec_bat_alarm);
+		break;
+	default:
+		break;
+	}
+
+	/* init power supplier framework */
+	ret = power_supply_register(&pdev->dev, &battery->psy_ps);
+	if (ret) {
+		dev_err(battery->dev,
+			"%s: Failed to Register psy_ps\n", __func__);
+		goto err_workqueue;
+	}
+
+	ret = power_supply_register(&pdev->dev, &battery->psy_wireless);
+	if (ret) {
+		dev_err(battery->dev,
+			"%s: Failed to Register psy_wireless\n", __func__);
+		goto err_supply_unreg_ps;
+	}
+
+	ret = power_supply_register(&pdev->dev, &battery->psy_usb);
+	if (ret) {
+		dev_err(battery->dev,
+			"%s: Failed to Register psy_usb\n", __func__);
+		goto err_supply_unreg_wireless;
+	}
+
+	ret = power_supply_register(&pdev->dev, &battery->psy_ac);
+	if (ret) {
+		dev_err(battery->dev,
+			"%s: Failed to Register psy_ac\n", __func__);
+		goto err_supply_unreg_usb;
+	}
+
+	ret = power_supply_register(&pdev->dev, &battery->psy_bat);
+	if (ret) {
+		dev_err(battery->dev,
+			"%s: Failed to Register psy_bat\n", __func__);
+		goto err_supply_unreg_ac;
+	}
+
+	if (battery->pdata->bat_gpio_init && !battery->pdata->bat_gpio_init()) {
+		dev_err(battery->dev,
+			"%s: Failed to Initialize GPIO\n", __func__);
+		goto err_supply_unreg_bat;
+	}
+
+	if (battery->pdata->bat_irq_gpio > 0) {
+		battery->pdata->bat_irq = gpio_to_irq(battery->pdata->bat_irq_gpio);
+		dev_info(battery->dev,
+					"%s: irq = %d\n", __func__, battery->pdata->bat_irq);
+		if (battery->pdata->bat_irq > 0) {
+			ret = request_threaded_irq(battery->pdata->bat_irq,
+				NULL, sec_bat_irq_thread,
+				battery->pdata->bat_irq_attr
+				| IRQF_ONESHOT,
+				"battery-irq", battery);
+			if (ret) {
+				dev_err(battery->dev, "%s: Failed to Request IRQ (bat_int)\n", __func__);
+				goto err_supply_unreg_bat;
+			}
+
+			ret = enable_irq_wake(battery->pdata->bat_irq);
+			if (ret < 0)
+				dev_err(battery->dev,
+					"%s: Failed to Enable Wakeup Source(%d)(bat_int)\n",
+					__func__, ret);
+		}
+	}
+
+	ret = sec_bat_create_attrs(battery->psy_bat.dev);
+	if (ret) {
+		dev_err(battery->dev,
+			"%s : Failed to create_attrs\n", __func__);
+		goto err_req_irq;
+	}
+
+	value.intval = POWER_SUPPLY_TYPE_MAINS;
+	psy_do_property(battery->pdata->charger_name, get,
+		POWER_SUPPLY_PROP_CURRENT_AVG, value);
+	battery->wired_input_current = value.intval;
+	pr_info("%s battery->wired_input_current : %d\n", __func__, battery->wired_input_current);
+	value.intval = POWER_SUPPLY_TYPE_WIRELESS;
+	psy_do_property(battery->pdata->charger_name, get,
+		POWER_SUPPLY_PROP_CURRENT_AVG, value);
+	battery->wireless_input_current = value.intval;
+	pr_info("%s battery->wireless_input_current : %d\n", __func__, battery->wireless_input_current);
+	psy_do_property(battery->pdata->charger_name, get,
+		POWER_SUPPLY_PROP_CURRENT_NOW, value);
+	battery->charging_current = value.intval;
+	pr_info("%s battery->charging_current : %d\n", __func__, battery->charging_current);
+
+	/* initialize battery level*/
+	value.intval = 0;
+	psy_do_property(battery->pdata->fuelgauge_name, get,
+			POWER_SUPPLY_PROP_CAPACITY, value);
+	battery->capacity = value.intval;
+
+#if defined(CONFIG_WIRELESS_FIRMWARE_UPDATE)
+	/* queue_delayed_work_on(0, battery->monitor_wqueue, &battery->fw_init_work, 0); */
+#endif
+
+	value.intval = 0;
+	psy_do_property(battery->pdata->wireless_charger_name, set,
+					POWER_SUPPLY_PROP_CHARGE_TYPE, value);
+
+#if defined(CONFIG_STORE_MODE) && !defined(CONFIG_SEC_FACTORY)
+	battery->store_mode = true;
+	if (battery->capacity <= 5)
+		battery->ignore_store_mode = true;
+
+	battery->pdata->wpc_high_temp -= 30;
+	battery->pdata->wpc_high_temp_recovery -= 30;
+	battery->pdata->wpc_skip_check_capacity = 0;
+	battery->pdata->wpc_skip_check_time = 0;
+#endif
+
+#if defined(CONFIG_MUIC_NOTIFIER)
+	muic_notifier_register(&battery->batt_nb,
+			       batt_handle_notification,
+			       MUIC_NOTIFY_DEV_CHARGER);
+#else
+	cable_initial_check(battery);
+#endif
+#if defined(CONFIG_VBUS_NOTIFIER)
+	vbus_notifier_register(&battery->vbus_nb,
+				vbus_handle_notification,
+				VBUS_NOTIFY_DEV_CHARGER);
+#endif
+
+	value.intval = true;
+	psy_do_property(battery->pdata->charger_name, set,
+		POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX, value);
+
+#if defined(CONFIG_AFC_CHARGER_MODE)
+	value.intval = 1;
+	psy_do_property(battery->pdata->charger_name, set,
+			POWER_SUPPLY_PROP_AFC_CHARGER_MODE,
+			value);
+#endif
+
+	psy_do_property("battery", get,
+				POWER_SUPPLY_PROP_ONLINE, value);
+
+	if ((value.intval == POWER_SUPPLY_TYPE_BATTERY) ||
+	    (value.intval == POWER_SUPPLY_TYPE_HV_PREPARE_MAINS)) {
+		dev_info(&pdev->dev,
+			"%s: SEC Battery Driver Monitorwork\n", __func__);
+		wake_lock(&battery->monitor_wake_lock);
+		queue_delayed_work_on(0, battery->monitor_wqueue, &battery->monitor_work, 0);
+	}
+
+	if (battery->pdata->check_battery_callback)
+		battery->present = battery->pdata->check_battery_callback();
+
+	dev_info(battery->dev,
+		"%s: SEC Battery Driver Loaded\n", __func__);
+	return 0;
+
+err_req_irq:
+	if (battery->pdata->bat_irq)
+		free_irq(battery->pdata->bat_irq, battery);
+err_supply_unreg_bat:
+	power_supply_unregister(&battery->psy_bat);
+err_supply_unreg_ac:
+	power_supply_unregister(&battery->psy_ac);
+err_supply_unreg_usb:
+	power_supply_unregister(&battery->psy_usb);
+err_supply_unreg_wireless:
+	power_supply_unregister(&battery->psy_wireless);
+err_supply_unreg_ps:
+	power_supply_unregister(&battery->psy_ps);
+err_workqueue:
+	destroy_workqueue(battery->monitor_wqueue);
+err_irq:
+#if defined(CONFIG_BATTERY_SWELLING_SELF_DISCHARGING)
+	if (battery->pdata->factory_discharging)
+		gpio_free(battery->pdata->factory_discharging);
+#endif
+	wake_lock_destroy(&battery->monitor_wake_lock);
+	wake_lock_destroy(&battery->cable_wake_lock);
+	wake_lock_destroy(&battery->vbus_wake_lock);
+	wake_lock_destroy(&battery->afc_wake_lock);
+	wake_lock_destroy(&battery->siop_wake_lock);
+	wake_lock_destroy(&battery->siop_level_wake_lock);
+	wake_lock_destroy(&battery->siop_event_wake_lock);
+	wake_lock_destroy(&battery->wc_headroom_wake_lock);
+#if defined(CONFIG_SW_SELF_DISCHARGING)
+	wake_lock_destroy(&battery->self_discharging_wake_lock);
+#endif
+#if defined(CONFIG_UPDATE_BATTERY_DATA)
+	wake_lock_destroy(&battery->batt_data_wake_lock);
+#endif
+	wake_lock_destroy(&battery->misc_event_wake_lock);
+	mutex_destroy(&battery->adclock);
+	mutex_destroy(&battery->iolock);
+	mutex_destroy(&battery->misclock);
+	kfree(pdata);
+err_bat_free:
+	kfree(battery);
+
+	return ret;
+}
+
+static int __devexit sec_battery_remove(struct platform_device *pdev)
+{
+	struct sec_battery_info *battery = platform_get_drvdata(pdev);
+#ifndef CONFIG_OF
+	int i;
+#endif
+
+	dev_dbg(battery->dev, "%s: Start\n", __func__);
+
+	switch (battery->pdata->polling_type) {
+	case SEC_BATTERY_MONITOR_WORKQUEUE:
+		cancel_delayed_work(&battery->polling_work);
+		break;
+	case SEC_BATTERY_MONITOR_ALARM:
+		alarm_cancel(&battery->polling_alarm);
+		break;
+	default:
+		break;
+	}
+
+	flush_workqueue(battery->monitor_wqueue);
+	destroy_workqueue(battery->monitor_wqueue);
+	wake_lock_destroy(&battery->monitor_wake_lock);
+	wake_lock_destroy(&battery->cable_wake_lock);
+	wake_lock_destroy(&battery->vbus_wake_lock);
+	wake_lock_destroy(&battery->afc_wake_lock);
+	wake_lock_destroy(&battery->siop_wake_lock);
+	wake_lock_destroy(&battery->siop_level_wake_lock);
+	wake_lock_destroy(&battery->siop_event_wake_lock);
+#if defined(CONFIG_SW_SELF_DISCHARGING)
+	wake_lock_destroy(&battery->self_discharging_wake_lock);
+#endif
+	wake_lock_destroy(&battery->misc_event_wake_lock);
+	mutex_destroy(&battery->adclock);
+	mutex_destroy(&battery->iolock);
+	mutex_destroy(&battery->misclock);
+#ifdef CONFIG_OF
+	adc_exit(battery);
+#else
+	for (i = 0; i < SEC_BAT_ADC_CHANNEL_NUM; i++)
+		adc_exit(battery->pdata, i);
+#endif
+	power_supply_unregister(&battery->psy_ps);
+	power_supply_unregister(&battery->psy_wireless);
+	power_supply_unregister(&battery->psy_ac);
+	power_supply_unregister(&battery->psy_usb);
+	power_supply_unregister(&battery->psy_bat);
+
+	dev_dbg(battery->dev, "%s: End\n", __func__);
+	kfree(battery);
+
+	return 0;
+}
+
+static int sec_battery_prepare(struct device *dev)
+{
+	struct sec_battery_info *battery
+		= dev_get_drvdata(dev);
+
+	dev_dbg(battery->dev, "%s: Start\n", __func__);
+
+	switch (battery->pdata->polling_type) {
+	case SEC_BATTERY_MONITOR_WORKQUEUE:
+		cancel_delayed_work(&battery->polling_work);
+		break;
+	case SEC_BATTERY_MONITOR_ALARM:
+		alarm_cancel(&battery->polling_alarm);
+		break;
+	default:
+		break;
+	}
+	cancel_delayed_work_sync(&battery->monitor_work);
+
+	battery->polling_in_sleep = true;
+
+	sec_bat_set_polling(battery);
+
+	/* cancel work for polling
+	 * that is set in sec_bat_set_polling()
+	 * no need for polling in sleep
+	 */
+	if (battery->pdata->polling_type ==
+		SEC_BATTERY_MONITOR_WORKQUEUE)
+		cancel_delayed_work(&battery->polling_work);
+
+	dev_dbg(battery->dev, "%s: End\n", __func__);
+
+	return 0;
+}
+
+static int sec_battery_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int sec_battery_resume(struct device *dev)
+{
+	return 0;
+}
+
+static void sec_battery_complete(struct device *dev)
+{
+	struct sec_battery_info *battery
+		= dev_get_drvdata(dev);
+
+	dev_dbg(battery->dev, "%s: Start\n", __func__);
+
+	/* cancel current alarm and reset after monitor work */
+	if (battery->pdata->polling_type == SEC_BATTERY_MONITOR_ALARM)
+		alarm_cancel(&battery->polling_alarm);
+
+	wake_lock(&battery->monitor_wake_lock);
+	queue_delayed_work_on(0, battery->monitor_wqueue,
+		&battery->monitor_work, 0);
+
+	dev_dbg(battery->dev, "%s: End\n", __func__);
+
+	return;
+}
+
+static void sec_battery_shutdown(struct device *dev)
+{
+	struct sec_battery_info *battery
+		= dev_get_drvdata(dev);
+
+#if defined(CONFIG_BATTERY_SWELLING_SELF_DISCHARGING)
+	if (battery->force_discharging) {
+		pr_info("SELF DISCHARGING IC DISENABLE\n");
+		sec_bat_self_discharging_control(battery, false);
+	}
+#endif
+
+	switch (battery->pdata->polling_type) {
+	case SEC_BATTERY_MONITOR_WORKQUEUE:
+		cancel_delayed_work(&battery->polling_work);
+		break;
+	case SEC_BATTERY_MONITOR_ALARM:
+		alarm_cancel(&battery->polling_alarm);
+		break;
+	default:
+		break;
+	}
+}
+
+#ifdef CONFIG_OF
+static struct of_device_id sec_battery_dt_ids[] = {
+	{ .compatible = "samsung,sec-battery" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, sec_battery_dt_ids);
+#endif /* CONFIG_OF */
+
+static const struct dev_pm_ops sec_battery_pm_ops = {
+	.prepare = sec_battery_prepare,
+	.suspend = sec_battery_suspend,
+	.resume = sec_battery_resume,
+	.complete = sec_battery_complete,
+};
+
+static struct platform_driver sec_battery_driver = {
+	.driver = {
+		   .name = "sec-battery",
+		   .owner = THIS_MODULE,
+		   .pm = &sec_battery_pm_ops,
+		   .shutdown = sec_battery_shutdown,
+#ifdef CONFIG_OF
+		.of_match_table = sec_battery_dt_ids,
+#endif
+	},
+	.probe = sec_battery_probe,
+	.remove = sec_battery_remove,
+};
+
+static int __init sec_battery_init(void)
+{
+	return platform_driver_register(&sec_battery_driver);
+}
+
+static void __exit sec_battery_exit(void)
+{
+	platform_driver_unregister(&sec_battery_driver);
+}
+
+late_initcall(sec_battery_init);
+module_exit(sec_battery_exit);
+
+MODULE_DESCRIPTION("Samsung Battery Driver");
+MODULE_AUTHOR("Samsung Electronics");
+MODULE_LICENSE("GPL");
diff -Naur linux-3.18.14/drivers/battery/sec_charger.c samsung/drivers/battery/sec_charger.c
--- linux-3.18.14/drivers/battery/sec_charger.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery/sec_charger.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,409 @@
+/*
+ *  sec_charger.c
+ *  Samsung Mobile Charger Driver
+ *
+ *  Copyright (C) 2012 Samsung Electronics
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/battery/sec_charger.h>
+
+static enum power_supply_property sec_charger_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_CHARGE_TYPE,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+};
+
+static int sec_chg_get_property(struct power_supply *psy,
+			    enum power_supply_property psp,
+			    union power_supply_propval *val)
+{
+	struct sec_charger_info *charger =
+		container_of(psy, struct sec_charger_info, psy_chg);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = charger->charging_current ? 1 : 0;
+		break;
+	case POWER_SUPPLY_PROP_STATUS:
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+	case POWER_SUPPLY_PROP_HEALTH:
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		if (!sec_hal_chg_get_property(charger->client, psp, val))
+			return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int sec_chg_set_property(struct power_supply *psy,
+			    enum power_supply_property psp,
+			    const union power_supply_propval *val)
+{
+	struct sec_charger_info *charger =
+		container_of(psy, struct sec_charger_info, psy_chg);
+
+	switch (psp) {
+	/* val->intval : type */
+	case POWER_SUPPLY_PROP_STATUS:
+		charger->status = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		charger->cable_type = val->intval;
+		if (val->intval == POWER_SUPPLY_TYPE_BATTERY)
+			charger->is_charging = false;
+		else
+			charger->is_charging = true;
+
+		/* current setting */
+		charger->charging_current =
+			charger->pdata->charging_current[
+			val->intval].fast_charging_current;
+
+		if (!sec_hal_chg_set_property(charger->client, psp, val))
+			return -EINVAL;
+		break;
+	/* val->intval : charging current */
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		charger->charging_current = val->intval;
+
+		if (!sec_hal_chg_set_property(charger->client, psp, val))
+			return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static void sec_chg_isr_work(struct work_struct *work)
+{
+	struct sec_charger_info *charger =
+		container_of(work, struct sec_charger_info, isr_work.work);
+	union power_supply_propval val;
+	int full_check_type;
+
+	dev_info(&charger->client->dev,
+		"%s: Charger Interrupt\n", __func__);
+
+	psy_do_property("battery", get,
+		POWER_SUPPLY_PROP_CHARGE_NOW, val);
+	if (val.intval == SEC_BATTERY_CHARGING_1ST)
+		full_check_type = charger->pdata->full_check_type;
+	else
+		full_check_type = charger->pdata->full_check_type_2nd;
+
+	if (full_check_type == SEC_BATTERY_FULLCHARGED_CHGINT) {
+		if (!sec_hal_chg_get_property(charger->client,
+			POWER_SUPPLY_PROP_STATUS, &val))
+			return;
+
+		switch (val.intval) {
+		case POWER_SUPPLY_STATUS_DISCHARGING:
+			dev_err(&charger->client->dev,
+				"%s: Interrupted but Discharging\n", __func__);
+			break;
+
+		case POWER_SUPPLY_STATUS_NOT_CHARGING:
+			dev_err(&charger->client->dev,
+				"%s: Interrupted but NOT Charging\n", __func__);
+			break;
+
+		case POWER_SUPPLY_STATUS_FULL:
+			dev_info(&charger->client->dev,
+				"%s: Interrupted by Full\n", __func__);
+			psy_do_property("battery", set,
+				POWER_SUPPLY_PROP_STATUS, val);
+			break;
+
+		case POWER_SUPPLY_STATUS_CHARGING:
+			dev_err(&charger->client->dev,
+				"%s: Interrupted but Charging\n", __func__);
+			break;
+
+		case POWER_SUPPLY_STATUS_UNKNOWN:
+		default:
+			dev_err(&charger->client->dev,
+				"%s: Invalid Charger Status\n", __func__);
+			break;
+		}
+	}
+
+	if (charger->pdata->ovp_uvlo_check_type ==
+		SEC_BATTERY_OVP_UVLO_CHGINT) {
+		if (!sec_hal_chg_get_property(charger->client,
+			POWER_SUPPLY_PROP_HEALTH, &val))
+			return;
+
+		switch (val.intval) {
+		case POWER_SUPPLY_HEALTH_OVERHEAT:
+		case POWER_SUPPLY_HEALTH_COLD:
+			dev_err(&charger->client->dev,
+				"%s: Interrupted but Hot/Cold\n", __func__);
+			break;
+
+		case POWER_SUPPLY_HEALTH_DEAD:
+			dev_err(&charger->client->dev,
+				"%s: Interrupted but Dead\n", __func__);
+			break;
+
+		case POWER_SUPPLY_HEALTH_OVERVOLTAGE:
+		case POWER_SUPPLY_HEALTH_UNDERVOLTAGE:
+			dev_info(&charger->client->dev,
+				"%s: Interrupted by OVP/UVLO\n", __func__);
+			psy_do_property("battery", set,
+				POWER_SUPPLY_PROP_HEALTH, val);
+			break;
+
+		case POWER_SUPPLY_HEALTH_UNSPEC_FAILURE:
+			dev_err(&charger->client->dev,
+				"%s: Interrupted but Unspec\n", __func__);
+			break;
+
+		case POWER_SUPPLY_HEALTH_GOOD:
+			dev_err(&charger->client->dev,
+				"%s: Interrupted but Good\n", __func__);
+			break;
+
+		case POWER_SUPPLY_HEALTH_UNKNOWN:
+		default:
+			dev_err(&charger->client->dev,
+				"%s: Invalid Charger Health\n", __func__);
+			break;
+		}
+	}
+}
+
+static irqreturn_t sec_chg_irq_thread(int irq, void *irq_data)
+{
+	struct sec_charger_info *charger = irq_data;
+
+		schedule_delayed_work(&charger->isr_work, 0);
+
+	return IRQ_HANDLED;
+}
+
+static int sec_chg_create_attrs(struct device *dev)
+{
+	int i, rc;
+
+	for (i = 0; i < ARRAY_SIZE(sec_charger_attrs); i++) {
+		rc = device_create_file(dev, &sec_charger_attrs[i]);
+		if (rc)
+			goto create_attrs_failed;
+	}
+	goto create_attrs_succeed;
+
+create_attrs_failed:
+	dev_err(dev, "%s: failed (%d)\n", __func__, rc);
+	while (i--)
+		device_remove_file(dev, &sec_charger_attrs[i]);
+create_attrs_succeed:
+	return rc;
+}
+
+ssize_t sec_chg_show_attrs(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	const ptrdiff_t offset = attr - sec_charger_attrs;
+	int i = 0;
+
+	switch (offset) {
+	case CHG_REG:
+	case CHG_DATA:
+	case CHG_REGS:
+		i = sec_hal_chg_show_attrs(dev, offset, buf);
+		break;
+	default:
+		i = -EINVAL;
+		break;
+	}
+
+	return i;
+}
+
+ssize_t sec_chg_store_attrs(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	const ptrdiff_t offset = attr - sec_charger_attrs;
+	int ret = 0;
+
+	switch (offset) {
+	case CHG_REG:
+	case CHG_DATA:
+		ret = sec_hal_chg_store_attrs(dev, offset, buf, count);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static int __devinit sec_charger_probe(
+						struct i2c_client *client,
+						const struct i2c_device_id *id)
+{
+	struct i2c_adapter *adapter =
+		to_i2c_adapter(client->dev.parent);
+	struct sec_charger_info *charger;
+	int ret = 0;
+
+	dev_dbg(&client->dev,
+		"%s: SEC Charger Driver Loading\n", __func__);
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE))
+		return -EIO;
+
+	charger = kzalloc(sizeof(*charger), GFP_KERNEL);
+	if (!charger)
+		return -ENOMEM;
+
+	charger->client = client;
+	charger->pdata = client->dev.platform_data;
+
+	i2c_set_clientdata(client, charger);
+
+	charger->psy_chg.name		= "sec-charger";
+	charger->psy_chg.type		= POWER_SUPPLY_TYPE_UNKNOWN;
+	charger->psy_chg.get_property	= sec_chg_get_property;
+	charger->psy_chg.set_property	= sec_chg_set_property;
+	charger->psy_chg.properties	= sec_charger_props;
+	charger->psy_chg.num_properties	= ARRAY_SIZE(sec_charger_props);
+
+	if (!charger->pdata->chg_gpio_init()) {
+		dev_err(&client->dev,
+			"%s: Failed to Initialize GPIO\n", __func__);
+		goto err_free;
+	}
+
+	if (!sec_hal_chg_init(charger->client)) {
+		dev_err(&client->dev,
+			"%s: Failed to Initialize Charger\n", __func__);
+		goto err_free;
+	}
+
+	ret = power_supply_register(&client->dev, &charger->psy_chg);
+	if (ret) {
+		dev_err(&client->dev,
+			"%s: Failed to Register psy_chg\n", __func__);
+		goto err_free;
+	}
+
+	if (charger->pdata->chg_irq) {
+		INIT_DELAYED_WORK_DEFERRABLE(
+			&charger->isr_work, sec_chg_isr_work);
+
+		ret = request_threaded_irq(charger->pdata->chg_irq,
+				NULL, sec_chg_irq_thread,
+				charger->pdata->chg_irq_attr,
+				"charger-irq", charger);
+		if (ret) {
+			dev_err(&client->dev,
+				"%s: Failed to Reqeust IRQ\n", __func__);
+			goto err_supply_unreg;
+		}
+
+			ret = enable_irq_wake(charger->pdata->chg_irq);
+			if (ret < 0)
+				dev_err(&client->dev,
+					"%s: Failed to Enable Wakeup Source(%d)\n",
+					__func__, ret);
+		}
+
+	ret = sec_chg_create_attrs(charger->psy_chg.dev);
+	if (ret) {
+		dev_err(&client->dev,
+			"%s : Failed to create_attrs\n", __func__);
+		goto err_req_irq;
+	}
+
+	dev_dbg(&client->dev,
+		"%s: SEC Charger Driver Loaded\n", __func__);
+	return 0;
+
+err_req_irq:
+	if (charger->pdata->chg_irq)
+		free_irq(charger->pdata->chg_irq, charger);
+err_supply_unreg:
+	power_supply_unregister(&charger->psy_chg);
+err_free:
+	kfree(charger);
+
+	return ret;
+}
+
+static int __devexit sec_charger_remove(
+						struct i2c_client *client)
+{
+	return 0;
+}
+
+static int sec_charger_suspend(struct i2c_client *client,
+				pm_message_t state)
+{
+	if (!sec_hal_chg_suspend(client))
+		dev_err(&client->dev,
+			"%s: Failed to Suspend Charger\n", __func__);
+
+	return 0;
+}
+
+static int sec_charger_resume(struct i2c_client *client)
+{
+	if (!sec_hal_chg_resume(client))
+		dev_err(&client->dev,
+			"%s: Failed to Resume Charger\n", __func__);
+
+	return 0;
+}
+
+static void sec_charger_shutdown(struct i2c_client *client)
+{
+}
+
+static const struct i2c_device_id sec_charger_id[] = {
+	{"sec-charger", 0},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, sec_charger_id);
+
+static struct i2c_driver sec_charger_driver = {
+	.driver = {
+		.name	= "sec-charger",
+	},
+	.probe	= sec_charger_probe,
+	.remove	= __devexit_p(sec_charger_remove),
+	.suspend	= sec_charger_suspend,
+	.resume		= sec_charger_resume,
+	.shutdown	= sec_charger_shutdown,
+	.id_table	= sec_charger_id,
+};
+
+static int __init sec_charger_init(void)
+{
+	return i2c_add_driver(&sec_charger_driver);
+}
+
+static void __exit sec_charger_exit(void)
+{
+	i2c_del_driver(&sec_charger_driver);
+}
+
+module_init(sec_charger_init);
+module_exit(sec_charger_exit);
+
+MODULE_DESCRIPTION("Samsung Charger Driver");
+MODULE_AUTHOR("Samsung Electronics");
+MODULE_LICENSE("GPL");
diff -Naur linux-3.18.14/drivers/battery/sec_fuelgauge.c samsung/drivers/battery/sec_fuelgauge.c
--- linux-3.18.14/drivers/battery/sec_fuelgauge.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery/sec_fuelgauge.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,660 @@
+/*
+ *  sec_fuelgauge.c
+ *  Samsung Mobile Fuel Gauge Driver
+ *
+ *  Copyright (C) 2012 Samsung Electronics
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#define DEBUG
+
+#include <linux/battery/sec_fuelgauge.h>
+#include <linux/of_gpio.h>
+
+static struct device_attribute sec_fg_attrs[] = {
+	SEC_FG_ATTR(reg),
+	SEC_FG_ATTR(data),
+	SEC_FG_ATTR(regs),
+};
+
+static enum power_supply_property sec_fuelgauge_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_VOLTAGE_AVG,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CURRENT_AVG,
+	POWER_SUPPLY_PROP_CHARGE_FULL,
+	POWER_SUPPLY_PROP_ENERGY_NOW,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_TEMP_AMBIENT,
+};
+
+/* capacity is  0.1% unit */
+static void sec_fg_get_scaled_capacity(
+				struct sec_fuelgauge_info *fuelgauge,
+				union power_supply_propval *val)
+{
+	val->intval = (val->intval < fuelgauge->pdata->capacity_min) ?
+		0 : ((val->intval - fuelgauge->pdata->capacity_min) * 1000 /
+		(fuelgauge->capacity_max - fuelgauge->pdata->capacity_min));
+
+	dev_dbg(&fuelgauge->client->dev,
+		"%s: scaled capacity (%d.%d)\n",
+		__func__, val->intval/10, val->intval%10);
+}
+
+/* capacity is integer */
+static void sec_fg_get_atomic_capacity(
+				struct sec_fuelgauge_info *fuelgauge,
+				union power_supply_propval *val)
+{
+	if (fuelgauge->pdata->capacity_calculation_type &
+		SEC_FUELGAUGE_CAPACITY_TYPE_ATOMIC) {
+	if (fuelgauge->capacity_old < val->intval)
+		val->intval = fuelgauge->capacity_old + 1;
+	else if (fuelgauge->capacity_old > val->intval)
+		val->intval = fuelgauge->capacity_old - 1;
+	}
+
+	/* keep SOC stable in abnormal status */
+	if (fuelgauge->pdata->capacity_calculation_type &
+		SEC_FUELGAUGE_CAPACITY_TYPE_SKIP_ABNORMAL) {
+		if (!fuelgauge->is_charging &&
+			fuelgauge->capacity_old < val->intval) {
+			dev_err(&fuelgauge->client->dev,
+				"%s: capacity (old %d : new %d)\n",
+				__func__, fuelgauge->capacity_old, val->intval);
+			val->intval = fuelgauge->capacity_old;
+		}
+	}
+
+	/* updated old capacity */
+	fuelgauge->capacity_old = val->intval;
+}
+
+static int sec_fg_get_property(struct power_supply *psy,
+			    enum power_supply_property psp,
+			    union power_supply_propval *val)
+{
+	struct sec_fuelgauge_info *fuelgauge =
+		container_of(psy, struct sec_fuelgauge_info, psy_fg);
+	int soc_type = val->intval;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+	case POWER_SUPPLY_PROP_VOLTAGE_AVG:
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+	case POWER_SUPPLY_PROP_ENERGY_NOW:
+	case POWER_SUPPLY_PROP_CAPACITY:
+	case POWER_SUPPLY_PROP_TEMP:
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		if (!sec_hal_fg_get_property(fuelgauge->client, psp, val))
+			return -EINVAL;
+		if (psp == POWER_SUPPLY_PROP_CAPACITY) {
+			if (soc_type == SEC_FUELGAUGE_CAPACITY_TYPE_RAW)
+				break;
+
+			if (fuelgauge->pdata->capacity_calculation_type &
+				(SEC_FUELGAUGE_CAPACITY_TYPE_SCALE |
+				 SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE))
+				sec_fg_get_scaled_capacity(fuelgauge, val);
+
+			/* capacity should be between 0% and 100%
+			 * (0.1% degree)
+			 */
+			if (val->intval > 1000)
+				val->intval = 1000;
+			if (val->intval < 0)
+				val->intval = 0;
+
+			/* get only integer part */
+			val->intval /= 10;
+
+			/* check whether doing the wake_unlock */
+			if ((val->intval > fuelgauge->pdata->fuel_alert_soc) &&
+				fuelgauge->is_fuel_alerted) {
+				wake_unlock(&fuelgauge->fuel_alert_wake_lock);
+				sec_hal_fg_fuelalert_init(fuelgauge->client,
+					fuelgauge->pdata->fuel_alert_soc);
+			}
+			
+			/* (Only for atomic capacity)
+			 * In initial time, capacity_old is 0.
+			 * and in resume from sleep,
+			 * capacity_old is too different from actual soc.
+			 * should update capacity_old
+			 * by val->intval in booting or resume.
+			 */
+			if (fuelgauge->initial_update_of_soc) {
+				/* updated old capacity */
+				fuelgauge->capacity_old = val->intval;
+				fuelgauge->initial_update_of_soc = false;
+				break;
+			}
+
+			if (fuelgauge->pdata->capacity_calculation_type &
+				(SEC_FUELGAUGE_CAPACITY_TYPE_ATOMIC |
+				 SEC_FUELGAUGE_CAPACITY_TYPE_SKIP_ABNORMAL))
+				sec_fg_get_atomic_capacity(fuelgauge, val);
+		}
+		break;
+	case POWER_SUPPLY_PROP_STATUS:
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+		return -ENODATA;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int sec_fg_calculate_dynamic_scale(
+				struct sec_fuelgauge_info *fuelgauge)
+{
+	union power_supply_propval raw_soc_val;
+
+	raw_soc_val.intval = SEC_FUELGAUGE_CAPACITY_TYPE_RAW;
+	if (!sec_hal_fg_get_property(fuelgauge->client,
+		POWER_SUPPLY_PROP_CAPACITY,
+		&raw_soc_val))
+		return -EINVAL;
+	raw_soc_val.intval /= 10;
+
+	if (raw_soc_val.intval <
+		fuelgauge->pdata->capacity_max -
+		fuelgauge->pdata->capacity_max_margin) {
+		fuelgauge->capacity_max =
+			fuelgauge->pdata->capacity_max -
+			fuelgauge->pdata->capacity_max_margin;
+		dev_dbg(&fuelgauge->client->dev, "%s: capacity_max (%d)",
+			__func__, fuelgauge->capacity_max);
+	} else {
+		fuelgauge->capacity_max =
+			(raw_soc_val.intval >
+			fuelgauge->pdata->capacity_max +
+			fuelgauge->pdata->capacity_max_margin) ?
+			(fuelgauge->pdata->capacity_max +
+			fuelgauge->pdata->capacity_max_margin) :
+			raw_soc_val.intval;
+		dev_dbg(&fuelgauge->client->dev, "%s: raw soc (%d)",
+			__func__, fuelgauge->capacity_max);
+	}
+
+	fuelgauge->capacity_max =
+		(fuelgauge->capacity_max * 99 / 100);
+
+	/* update capacity_old for sec_fg_get_atomic_capacity algorithm */
+	fuelgauge->capacity_old = 100;
+
+	dev_info(&fuelgauge->client->dev, "%s: %d is used for capacity_max\n",
+		__func__, fuelgauge->capacity_max);
+
+	return fuelgauge->capacity_max;
+}
+
+static int sec_fg_set_property(struct power_supply *psy,
+			    enum power_supply_property psp,
+			    const union power_supply_propval *val)
+{
+	struct sec_fuelgauge_info *fuelgauge =
+		container_of(psy, struct sec_fuelgauge_info, psy_fg);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		if (val->intval == POWER_SUPPLY_STATUS_FULL)
+			sec_hal_fg_full_charged(fuelgauge->client);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+		if (val->intval == POWER_SUPPLY_TYPE_BATTERY) {
+			if (fuelgauge->pdata->capacity_calculation_type &
+				SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE)
+				sec_fg_calculate_dynamic_scale(fuelgauge);
+		}
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		fuelgauge->cable_type = val->intval;
+		if (val->intval == POWER_SUPPLY_TYPE_BATTERY)
+			fuelgauge->is_charging = false;
+		else
+			fuelgauge->is_charging = true;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		if (val->intval == SEC_FUELGAUGE_CAPACITY_TYPE_RESET) {
+			fuelgauge->initial_update_of_soc = true;
+			if (!sec_hal_fg_reset(fuelgauge->client))
+				return -EINVAL;
+			else
+				break;
+		}
+	case POWER_SUPPLY_PROP_TEMP:
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		if (!sec_hal_fg_set_property(fuelgauge->client, psp, val))
+			return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static void sec_fg_isr_work(struct work_struct *work)
+{
+	struct sec_fuelgauge_info *fuelgauge =
+		container_of(work, struct sec_fuelgauge_info, isr_work.work);
+
+	/* process for fuel gauge chip */
+	sec_hal_fg_fuelalert_process(fuelgauge, fuelgauge->is_fuel_alerted);
+
+	/* process for others */
+	if (fuelgauge->pdata->fuelalert_process != NULL)
+		fuelgauge->pdata->fuelalert_process(fuelgauge->is_fuel_alerted);
+}
+
+static irqreturn_t sec_fg_irq_thread(int irq, void *irq_data)
+{
+	struct sec_fuelgauge_info *fuelgauge = irq_data;
+	bool fuel_alerted;
+
+	if (fuelgauge->pdata->fuel_alert_soc >= 0) {
+		fuel_alerted =
+			sec_hal_fg_is_fuelalerted(fuelgauge->client);
+
+		dev_info(&fuelgauge->client->dev,
+			"%s: Fuel-alert %salerted!\n",
+			__func__, fuel_alerted ? "" : "NOT ");
+
+		if (fuel_alerted == fuelgauge->is_fuel_alerted) {
+			if (!fuelgauge->pdata->repeated_fuelalert) {
+				dev_dbg(&fuelgauge->client->dev,
+					"%s: Fuel-alert Repeated (%d)\n",
+					__func__, fuelgauge->is_fuel_alerted);
+				return IRQ_HANDLED;
+			}
+		}
+
+		if (fuel_alerted)
+			wake_lock(&fuelgauge->fuel_alert_wake_lock);
+		else
+			wake_unlock(&fuelgauge->fuel_alert_wake_lock);
+
+		schedule_delayed_work(&fuelgauge->isr_work, 0);
+
+		fuelgauge->is_fuel_alerted = fuel_alerted;
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int sec_fg_create_attrs(struct device *dev)
+{
+	int i, rc;
+
+	for (i = 0; i < ARRAY_SIZE(sec_fg_attrs); i++) {
+		rc = device_create_file(dev, &sec_fg_attrs[i]);
+		if (rc)
+			goto create_attrs_failed;
+	}
+	goto create_attrs_succeed;
+
+create_attrs_failed:
+	dev_err(dev, "%s: failed (%d)\n", __func__, rc);
+	while (i--)
+		device_remove_file(dev, &sec_fg_attrs[i]);
+create_attrs_succeed:
+	return rc;
+}
+
+ssize_t sec_fg_show_attrs(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	const ptrdiff_t offset = attr - sec_fg_attrs;
+	int i = 0;
+
+	switch (offset) {
+	case FG_REG:
+	case FG_DATA:
+	case FG_REGS:
+		i = sec_hal_fg_show_attrs(dev, offset, buf);
+		break;
+	default:
+		i = -EINVAL;
+		break;
+	}
+
+	return i;
+}
+
+ssize_t sec_fg_store_attrs(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	const ptrdiff_t offset = attr - sec_fg_attrs;
+	int ret = 0;
+
+	switch (offset) {
+	case FG_REG:
+	case FG_DATA:
+		ret = sec_hal_fg_store_attrs(dev, offset, buf, count);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+#ifdef CONFIG_OF
+static int fuelgauge_parse_dt(struct device *dev,
+			struct sec_fuelgauge_info *fuelgauge)
+{
+	struct device_node *np = dev->of_node;
+	sec_battery_platform_data_t *pdata = fuelgauge->pdata;
+	int ret;
+#if 0
+	int ta_int_gpio;
+	sec_battery_platform_data_t sec_battery_pdata;
+#endif
+
+	/* reset, irq gpio info */
+	if (np == NULL) {
+		pr_err("%s np NULL\n", __func__);
+	} else {
+		pdata->fg_irq = of_get_named_gpio(np, "fuelgauge,fuel_int", 0);
+		if (pdata->fg_irq < 0) {
+			pr_err("%s error reading fg_irq = %d\n", __func__, pdata->fg_irq);
+			pdata->fg_irq = 0;
+		}
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_max",
+				&pdata->capacity_max);
+		if (ret < 0)
+			pr_err("%s error reading capacity_max %d\n", __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_max_margin",
+				&pdata->capacity_max_margin);
+		if (ret < 0)
+			pr_err("%s error reading capacity_max_margin %d\n", __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_min",
+				&pdata->capacity_min);
+		if (ret < 0)
+			pr_err("%s error reading capacity_min %d\n", __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_calculation_type",
+				&pdata->capacity_calculation_type);
+		if (ret < 0)
+			pr_err("%s error reading capacity_calculation_type %d\n",
+					__func__, ret);
+		ret = of_property_read_u32(np, "fuelgauge,fuel_alert_soc",
+				&pdata->fuel_alert_soc);
+		if (ret < 0)
+			pr_err("%s error reading pdata->fuel_alert_soc %d\n",
+					__func__, ret);
+		pdata->repeated_fuelalert = of_property_read_bool(np,
+				"fuelgaguge,repeated_fuelalert");
+
+		pr_info("%s fg_irq: %d, capacity_max: %d\n"
+			"cpacity_max_margin: %d, capacity_min: %d\n"
+			"calculation_type: 0x%x, fuel_alert_soc: %d,\n"
+			"repeated_fuelalert: %d\n",
+			__func__, pdata->fg_irq,
+			pdata->capacity_max, pdata->capacity_max_margin,
+			pdata->capacity_min, pdata->capacity_calculation_type,
+			pdata->fuel_alert_soc, pdata->repeated_fuelalert);
+	}
+	return 0;
+}
+#endif
+
+static int __devinit sec_fuelgauge_probe(struct i2c_client *client,
+						const struct i2c_device_id *id)
+{
+	struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
+	struct sec_fuelgauge_info *fuelgauge;
+	sec_battery_platform_data_t *pdata = NULL;
+	struct battery_data_t *battery_data = NULL;
+	int ret = 0;
+	union power_supply_propval raw_soc_val;
+
+	dev_info(&client->dev,
+		"%s: SEC Fuelgauge Driver Loading\n", __func__);
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE))
+		return -EIO;
+
+	fuelgauge = kzalloc(sizeof(*fuelgauge), GFP_KERNEL);
+	if (!fuelgauge)
+		return -ENOMEM;
+
+	mutex_init(&fuelgauge->fg_lock);
+
+	fuelgauge->client = client;
+	
+	if (client->dev.of_node) {
+		int error;
+		pdata = devm_kzalloc(&client->dev,
+			sizeof(sec_battery_platform_data_t),
+				GFP_KERNEL);
+		if (!pdata) {
+			dev_err(&client->dev, "Failed to allocate memory\n");
+			ret = -ENOMEM;
+			goto err_free;
+		}
+		battery_data = devm_kzalloc(&client->dev,
+			sizeof(struct battery_data_t),
+				GFP_KERNEL);
+		if (!battery_data) {
+			dev_err(&client->dev, "Failed to allocate memory\n");
+			devm_kfree(&client->dev, pdata);
+			ret = -ENOMEM;
+			goto err_free;
+		}
+		pdata->battery_data = (void *)battery_data;
+		fuelgauge->pdata = pdata;
+		error = fuelgauge_parse_dt(&client->dev, fuelgauge);
+		if (error) {
+			dev_err(&client->dev,
+				"%s: Failed to get fuel_int\n", __func__);
+		}
+	} else	{
+		dev_err(&client->dev,
+			"%s: Failed to get of_node\n", __func__);
+		fuelgauge->pdata = client->dev.platform_data;
+	}
+
+	i2c_set_clientdata(client, fuelgauge);
+
+	if (!sec_hal_fg_init(fuelgauge->client)) {
+		dev_err(&client->dev,
+			"%s: Failed to Initialize Fuelgauge\n", __func__);
+		goto err_free;
+	}
+
+	fuelgauge->psy_fg.name		= "sec-fuelgauge";
+	fuelgauge->psy_fg.type		= POWER_SUPPLY_TYPE_UNKNOWN;
+	fuelgauge->psy_fg.get_property	= sec_fg_get_property;
+	fuelgauge->psy_fg.set_property	= sec_fg_set_property;
+	fuelgauge->psy_fg.properties	= sec_fuelgauge_props;
+	fuelgauge->psy_fg.num_properties =
+		ARRAY_SIZE(sec_fuelgauge_props);
+	fuelgauge->capacity_max = fuelgauge->pdata->capacity_max;
+	raw_soc_val.intval = SEC_FUELGAUGE_CAPACITY_TYPE_RAW;
+	sec_hal_fg_get_property(fuelgauge->client,
+			POWER_SUPPLY_PROP_CAPACITY, &raw_soc_val);
+	raw_soc_val.intval /= 10;
+	if(raw_soc_val.intval > fuelgauge->pdata->capacity_max)
+		sec_fg_calculate_dynamic_scale(fuelgauge);
+/*
+	if (!fuelgauge->pdata->fg_gpio_init()) {
+		dev_err(&client->dev,
+			"%s: Failed to Initialize GPIO\n", __func__);
+		goto err_free;
+	}
+*/
+	ret = power_supply_register(&client->dev, &fuelgauge->psy_fg);
+	if (ret) {
+		dev_err(&client->dev,
+			"%s: Failed to Register psy_fg\n", __func__);
+		goto err_free;
+	}
+
+	if (fuelgauge->pdata->fg_irq) {
+		fuelgauge->fg_irq = gpio_to_irq(fuelgauge->pdata->fg_irq);
+		INIT_DELAYED_WORK(
+			&fuelgauge->isr_work, sec_fg_isr_work);
+
+		ret = request_threaded_irq(fuelgauge->fg_irq,
+				NULL, sec_fg_irq_thread,
+			        IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING | IRQF_ONESHOT,
+				"fuelgauge-irq", fuelgauge);
+		if (ret) {
+			dev_err(&client->dev,
+				"%s: Failed to Reqeust IRQ\n", __func__);
+			goto err_supply_unreg;
+		}
+
+		ret = enable_irq_wake(fuelgauge->fg_irq);
+		if (ret < 0)
+			dev_err(&client->dev,
+				"%s: Failed to Enable Wakeup Source(%d)\n",
+				__func__, ret);
+	}
+
+	fuelgauge->is_fuel_alerted = false;
+	if (fuelgauge->pdata->fuel_alert_soc >= 0) {
+		if (sec_hal_fg_fuelalert_init(fuelgauge->client,
+			fuelgauge->pdata->fuel_alert_soc))
+			wake_lock_init(&fuelgauge->fuel_alert_wake_lock,
+				WAKE_LOCK_SUSPEND, "fuel_alerted");
+		else {
+			dev_err(&client->dev,
+				"%s: Failed to Initialize Fuel-alert\n",
+				__func__);
+			goto err_irq;
+		}
+	}
+
+	fuelgauge->initial_update_of_soc = true;
+
+	ret = sec_fg_create_attrs(fuelgauge->psy_fg.dev);
+	if (ret) {
+		dev_err(&client->dev,
+			"%s : Failed to create_attrs\n", __func__);
+		goto err_irq;
+	}
+
+	dev_info(&client->dev,
+		"%s: SEC Fuelgauge Driver Loaded\n", __func__);
+	return 0;
+
+err_irq:
+	if (fuelgauge->fg_irq)
+		free_irq(fuelgauge->fg_irq, fuelgauge);
+	wake_lock_destroy(&fuelgauge->fuel_alert_wake_lock);
+err_supply_unreg:
+	power_supply_unregister(&fuelgauge->psy_fg);
+err_free:
+	mutex_destroy(&fuelgauge->fg_lock);
+	kfree(fuelgauge);
+
+	return ret;
+}
+
+static int __devexit sec_fuelgauge_remove(
+						struct i2c_client *client)
+{
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+
+	if (fuelgauge->pdata->fuel_alert_soc >= 0)
+		wake_lock_destroy(&fuelgauge->fuel_alert_wake_lock);
+
+	return 0;
+}
+
+static int sec_fuelgauge_suspend(struct device *dev)
+{
+	struct sec_fuelgauge_info *fuelgauge = dev_get_drvdata(dev);
+
+	if (!sec_hal_fg_suspend(fuelgauge->client))
+		dev_err(&fuelgauge->client->dev,
+			"%s: Failed to Suspend Fuelgauge\n", __func__);
+
+	return 0;
+}
+
+static int sec_fuelgauge_resume(struct device *dev)
+{
+	struct sec_fuelgauge_info *fuelgauge = dev_get_drvdata(dev);
+
+	if (!sec_hal_fg_resume(fuelgauge->client))
+		dev_err(&fuelgauge->client->dev,
+			"%s: Failed to Resume Fuelgauge\n", __func__);
+
+	fuelgauge->initial_update_of_soc = true;
+
+	return 0;
+}
+
+static void sec_fuelgauge_shutdown(struct i2c_client *client)
+{
+}
+
+static const struct i2c_device_id sec_fuelgauge_id[] = {
+	{"sec-fuelgauge", 0},
+	{}
+};
+
+static const struct dev_pm_ops sec_fuelgauge_pm_ops = {
+	.suspend = sec_fuelgauge_suspend,
+	.resume  = sec_fuelgauge_resume,
+};
+
+MODULE_DEVICE_TABLE(i2c, sec_fuelgauge_id);
+
+#if defined(CONFIG_OF)
+static struct of_device_id sec_fuelgauge_i2c_dt_ids[] = {
+	{ .compatible = "sec-fuelgauge,i2c" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, sec_fuelgauge_i2c_dt_ids);
+#endif /* CONFIG_OF */
+
+static struct i2c_driver sec_fuelgauge_driver = {
+	.driver = {
+		   .name = "sec-fuelgauge",
+		   .owner = THIS_MODULE,
+#ifdef CONFIG_PM
+			.pm = &sec_fuelgauge_pm_ops,
+#endif
+#if defined(CONFIG_OF)
+		.of_match_table	= sec_fuelgauge_i2c_dt_ids,
+#endif /* CONFIG_OF */
+		   },
+	.probe	= sec_fuelgauge_probe,
+	.remove	= __devexit_p(sec_fuelgauge_remove),
+	.shutdown   = sec_fuelgauge_shutdown,
+	.id_table   = sec_fuelgauge_id,
+};
+
+static int __init sec_fuelgauge_init(void)
+{
+	dev_info(0, "%s: \n", __func__);
+	return i2c_add_driver(&sec_fuelgauge_driver);
+}
+
+static void __exit sec_fuelgauge_exit(void)
+{
+	i2c_del_driver(&sec_fuelgauge_driver);
+}
+
+module_init(sec_fuelgauge_init);
+module_exit(sec_fuelgauge_exit);
+
+MODULE_DESCRIPTION("Samsung Fuel Gauge Driver");
+MODULE_AUTHOR("Samsung Electronics");
+MODULE_LICENSE("GPL");
diff -Naur linux-3.18.14/drivers/battery/sm5703_charger.c samsung/drivers/battery/sm5703_charger.c
--- linux-3.18.14/drivers/battery/sm5703_charger.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery/sm5703_charger.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,1601 @@
+/* drivers/battery/sm5703_charger.c
+ * SM5703 Charger Driver
+ *
+ * Copyright (C) 2013 Siliconmitus Technology Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ */
+
+#include <linux/battery/charger/sm5703_charger.h>
+#include <linux/sec_batt.h>
+#include <linux/wakelock.h>
+
+#ifdef CONFIG_SM5703_MUIC
+#include <linux/i2c/sm5703-muic.h>
+#endif
+
+#include <linux/mfd/sm5703.h>
+
+#ifdef CONFIG_FLED_SM5703
+#include <linux/leds/sm5703_fled.h>
+#include <linux/leds/smfled.h>
+#endif
+
+#include <linux/version.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/of_gpio.h>
+
+#ifdef CONFIG_USB_HOST_NOTIFY
+#include <linux/usb_notify.h>
+#endif
+
+#define ENABLE_AICL 1
+
+#define EN_NOBAT_IRQ	0
+#define EN_DONE_IRQ		1
+#define EN_TOPOFF_IRQ	1
+#define EN_CHGON_IRQ	0
+#define EN_AICL_IRQ		1
+#define EN_OTGFAIL_IRQ	1
+
+#define MINVAL(a, b) ((a <= b) ? a : b)
+
+#ifndef EN_TEST_READ
+#define EN_TEST_READ 1
+#endif
+
+#define ENABLE 1
+#define DISABLE 0
+
+static int sm5703_reg_map[] = {
+	SM5703_INTMSK1,
+	SM5703_INTMSK2,
+	SM5703_INTMSK3,
+	SM5703_INTMSK4,
+	SM5703_STATUS1,
+	SM5703_STATUS2,
+	SM5703_STATUS3,
+	SM5703_STATUS4,
+	SM5703_CNTL,		
+	SM5703_VBUSCNTL,
+	SM5703_CHGCNTL1,
+	SM5703_CHGCNTL2,
+	SM5703_CHGCNTL3,
+	SM5703_CHGCNTL4,
+	SM5703_CHGCNTL5,
+	SM5703_CHGCNTL6,
+	SM5703_OTGCURRENTCNTL,
+	SM5703_Q3LIMITCNTL,
+	SM5703_STATUS5,
+};
+
+typedef struct sm5703_charger_data {
+	struct i2c_client	*i2c;
+	sm5703_mfd_chip_t	*sm5703;
+	struct power_supply	psy_chg;
+	struct power_supply	psy_otg;
+	sm5703_charger_platform_data_t *pdata;
+	struct wake_lock aicl_wake_lock;
+	struct delayed_work aicl_work;
+	int input_current;
+	int charging_current;
+	int topoff_current;
+	int cable_type;
+	bool aicl_state;
+	bool is_charging;
+	int charge_mode;
+	struct mutex io_lock;
+	/* register programming */
+	int reg_addr;
+	int reg_data;
+	int nchgen;
+
+	bool ovp;
+	bool is_mdock;
+	struct workqueue_struct *wq;
+	int status;
+#ifdef CONFIG_FLED_SM5703
+	struct sm_fled_info *fled_info;
+#endif
+} sm5703_charger_data_t;
+
+static enum power_supply_property sec_charger_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_CHARGE_TYPE,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_CURRENT_MAX,
+	POWER_SUPPLY_PROP_CURRENT_AVG,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL,
+	POWER_SUPPLY_PROP_CHARGING_ENABLED,
+};
+
+static enum power_supply_property sm5703_otg_props[] = {
+	POWER_SUPPLY_PROP_ONLINE,
+};
+
+int otg_enable_flag;
+
+static int sm5703_get_charging_health(
+		struct sm5703_charger_data *charger);
+
+static void sm5703_read_regs(struct i2c_client *i2c, char *str)
+{
+	u8 data = 0;
+	int i = 0;
+	for (i = SM5703_INTMSK1; i < ARRAY_SIZE(sm5703_reg_map); i++) {
+		data = sm5703_reg_read(i2c, sm5703_reg_map[i]);
+		sprintf(str+strlen(str), "0x%02x, ", data);
+	}
+}
+
+static void sm5703_test_read(struct i2c_client *i2c)
+{
+	int data;
+	char str[1000] = {0,};
+	int i;
+
+	/* SM5703 REG: 0x04 ~ 0x13 */
+	for (i = SM5703_INTMSK1; i <= SM5703_CHGCNTL6; i++) {
+		data = sm5703_reg_read(i2c, i);
+		sprintf(str+strlen(str), "0x%0x = 0x%02x, ", i, data);
+	}
+
+	sprintf(str+strlen(str), "0x%0x = 0x%02x, ",SM5703_OTGCURRENTCNTL,
+		sm5703_reg_read(i2c, SM5703_OTGCURRENTCNTL));
+	sprintf(str+strlen(str), "0x%0x = 0x%02x, ", SM5703_STATUS5,
+		sm5703_reg_read(i2c, SM5703_STATUS5));
+	sprintf(str+strlen(str), "0x%0x = 0x%02x, ", SM5703_Q3LIMITCNTL,
+		sm5703_reg_read(i2c, SM5703_Q3LIMITCNTL));
+	pr_info("%s: %s\n", __func__, str);
+}
+
+#define SM5703_FLEDCNTL6			0x19
+static void sm5703_charger_otg_control(struct sm5703_charger_data *charger,
+		bool enable)
+{
+	pr_info("%s: called charger otg control : %s\n", __func__,
+			enable ? "on" : "off");
+
+	otg_enable_flag = enable;
+
+	if (!enable) {
+		sm5703_assign_bits(charger->i2c,
+			SM5703_FLEDCNTL6, SM5703_BSTOUT_MASK,
+			SM5703_BSTOUT_4P5);
+#ifdef CONFIG_FLED_SM5703
+		/* turn off OTG */
+		if (charger->fled_info == NULL)
+			charger->fled_info = sm_fled_get_info_by_name(NULL);
+		if (charger->fled_info)
+			sm5703_boost_notification(charger->fled_info, 0);
+#else
+		sm5703_assign_bits(charger->i2c,
+			SM5703_CNTL, SM5703_OPERATION_MODE_MASK,
+			SM5703_OPERATION_MODE_CHARGING_ON);
+#endif
+	} else {
+		sm5703_assign_bits(charger->i2c,
+			SM5703_FLEDCNTL6, SM5703_BSTOUT_MASK,
+			SM5703_BSTOUT_5P0);
+#ifdef CONFIG_FLED_SM5703
+		if (charger->fled_info == NULL)
+			charger->fled_info = sm_fled_get_info_by_name(NULL);
+		if (charger->fled_info)
+			sm5703_boost_notification(charger->fled_info, 1);
+#else
+		sm5703_assign_bits(charger->i2c,
+			SM5703_CNTL, SM5703_OPERATION_MODE_MASK,
+			SM5703_OPERATION_MODE_USB_OTG_MODE);
+#endif
+		charger->cable_type = POWER_SUPPLY_TYPE_OTG;
+	}
+}
+
+static void sm5703_enable_charger_switch(struct sm5703_charger_data *charger,
+		int onoff)
+{
+#ifdef CONFIG_CHARGER_SM5703_DUALPATH
+	union power_supply_propval batt_pres;
+#endif
+
+	if (onoff > 0) {
+		pr_info("%s: turn on charger\n", __func__);
+#ifdef CONFIG_FLED_SM5703
+		if (charger->fled_info == NULL)
+			charger->fled_info = sm_fled_get_info_by_name(NULL);
+		if (charger->fled_info)
+			sm5703_charger_notification(charger->fled_info,1);
+#else
+		sm5703_assign_bits(charger->i2c,
+			SM5703_CNTL, SM5703_OPERATION_MODE_MASK,
+			SM5703_OPERATION_MODE_CHARGING_ON);
+#endif
+		charger->nchgen = false;
+		gpio_direction_output(charger->pdata->chgen_gpio,
+			charger->nchgen); /* nCHG enable */
+
+		pr_info("%s : STATUS OF CHARGER ON(0)/OFF(1): %d\n",
+			__func__, charger->nchgen);
+	} else {
+		pr_info("%s: turn off charger\n", __func__);
+
+		charger->nchgen = true;
+#ifdef CONFIG_FLED_SM5703
+		if (charger->fled_info == NULL)
+			charger->fled_info = sm_fled_get_info_by_name(NULL);
+		if (charger->fled_info)
+			sm5703_charger_notification(charger->fled_info,0);
+#endif
+		gpio_direction_output(charger->pdata->chgen_gpio,
+			charger->nchgen); /* nCHG disable */
+		pr_info("%s : STATUS OF CHARGER ON(0)/OFF(1): %d\n",
+			__func__, charger->nchgen);
+
+#ifdef CONFIG_CHARGER_SM5703_DUALPATH
+		psy_do_property("battery", get,
+					POWER_SUPPLY_PROP_PRESENT, batt_pres);
+		if(batt_pres.intval == false) {
+			sm5703_assign_bits(charger->i2c,
+					SM5703_CNTL, SM5703_OPERATION_MODE_MASK,
+					SM5703_OPERATION_MODE_SUSPEND);
+			pr_info("%s: Set SM5703 mode to Suspend, W/O for VF check \n", __func__);
+		}
+#endif
+	}
+}
+
+static void sm5703_enable_autostop(struct sm5703_charger_data *charger,
+		int onoff)
+{
+	pr_info("%s:[BATT] Autostop set(%d)\n", __func__, onoff);
+
+	mutex_lock(&charger->io_lock);
+
+	if (onoff)
+		sm5703_set_bits(charger->i2c, SM5703_CHGCNTL4, SM5703_AUTOSTOP_MASK);
+	else
+		sm5703_clr_bits(charger->i2c, SM5703_CHGCNTL4, SM5703_AUTOSTOP_MASK);
+
+	mutex_unlock(&charger->io_lock);    
+}
+
+static int sm5703_set_topoff_timer(struct sm5703_charger_data *charger,
+				unsigned int topoff_timer)
+{
+	struct i2c_client *i2c = charger->sm5703->i2c_client;
+
+	sm5703_assign_bits(i2c,
+		SM5703_CHGCNTL5, SM5703_TOPOFF_TIMER_MASK,
+		((topoff_timer & SM5703_TOPOFF_TIMER) << SM5703_TOPOFF_TIMER_SHIFT));
+	pr_info("%s : TOPOFF timer set (timer=0x%x)\n",
+		__func__, topoff_timer);
+
+	return 0;
+}
+
+static void sm5703_enable_autoset(struct sm5703_charger_data *charger,
+		int onoff)
+{
+	pr_info("%s:[BATT] Autoset set(%d)\n", __func__, onoff);
+
+	mutex_lock(&charger->io_lock);
+
+	if (onoff)
+		sm5703_set_bits(charger->i2c, SM5703_CNTL, SM5703_AUTOSET_MASK);
+	else
+		sm5703_clr_bits(charger->i2c, SM5703_CNTL, SM5703_AUTOSET_MASK);
+
+	mutex_unlock(&charger->io_lock);
+}
+
+static void sm5703_enable_aiclen(struct sm5703_charger_data *charger,
+		int onoff)
+{
+	pr_info("%s:[BATT] AICLEN set(%d)\n", __func__, onoff);
+
+	mutex_lock(&charger->io_lock);
+
+	if (onoff)
+		sm5703_set_bits(charger->i2c, SM5703_CHGCNTL5, SM5703_AICLEN_MASK);
+	else
+		sm5703_clr_bits(charger->i2c, SM5703_CHGCNTL5, SM5703_AICLEN_MASK);
+
+	mutex_unlock(&charger->io_lock);    
+}
+
+static void sm5703_set_aiclth(struct sm5703_charger_data *charger,
+		int aiclth)
+{
+	int data = 0, temp = 0;
+
+	mutex_lock(&charger->io_lock);
+	data = sm5703_reg_read(charger->i2c, SM5703_CHGCNTL5);
+	data &= ~SM5703_AICLTH;
+
+	if (aiclth >= 4900)
+		aiclth = 4900;
+
+	if(aiclth <= 4300)
+		data &= ~SM5703_AICLTH;
+	else {
+		temp = (aiclth - 4300)/100;
+		data |= temp;
+	}
+
+	sm5703_reg_write(charger->i2c, SM5703_CHGCNTL5, data);
+
+	data = sm5703_reg_read(charger->i2c, SM5703_CHGCNTL5);
+	pr_info("%s : SM5703_CHGCNTL5 (AICHTH) : 0x%02x\n",
+			__func__, data);    
+	mutex_unlock(&charger->io_lock);
+}
+
+static void sm5703_set_freqsel(struct sm5703_charger_data *charger,
+		int freqsel_hz)
+{
+	int data = 0;
+
+	mutex_lock(&charger->io_lock);
+	data = sm5703_reg_read(charger->i2c, SM5703_CHGCNTL6);
+	data &= ~SM5703_FREQSEL_MASK;
+	data |= (freqsel_hz << SM5703_FREQSEL_SHIFT);
+
+	sm5703_reg_write(charger->i2c, SM5703_CHGCNTL6, data);
+
+	data = sm5703_reg_read(charger->i2c, SM5703_CHGCNTL6);
+	pr_info("%s : SM5703_CHGCNTL6 (FREQSEL) : 0x%02x\n",
+			__func__, data);    
+	mutex_unlock(&charger->io_lock);
+}
+
+static void sm5703_set_input_current_limit(struct sm5703_charger_data *charger,
+		int current_limit)
+{
+	int data = 0, temp = 0;
+
+	mutex_lock(&charger->io_lock);
+	data = sm5703_reg_read(charger->i2c, SM5703_VBUSCNTL);
+	data &= ~SM5703_VBUSLIMIT;
+
+	if (charger->input_current < current_limit && charger->aicl_state) {
+		pr_info("%s: skip set input current limit(%d <--> %d), aicl_state(%d)\n",
+			__func__, charger->input_current, current_limit, charger->aicl_state);
+	} else {
+#ifdef CONFIG_CHARGER_SM5703_SOFT_START_CHARGING
+		/* Soft Start Charging */
+		if ((charger->cable_type != POWER_SUPPLY_TYPE_BATTERY) && !lpcharge) {
+			data = sm5703_reg_read(charger->i2c, SM5703_VBUSCNTL);
+			data &= ~SM5703_VBUSLIMIT;
+			sm5703_reg_write(charger->i2c, SM5703_VBUSCNTL, data);
+			msleep(100);
+		}
+#endif
+		if (current_limit > 100) {
+			temp = ((current_limit - 100) / 50) | data;
+			sm5703_reg_write(charger->i2c, SM5703_VBUSCNTL, temp);
+		}
+
+		data = sm5703_reg_read(charger->i2c, SM5703_VBUSCNTL);
+		pr_info("%s : SM5703_VBUSCNTL (Input current limit) : 0x%02x\n",
+				__func__, data);
+	}
+
+	mutex_unlock(&charger->io_lock);
+}
+
+static int sm5703_get_input_current_limit(struct sm5703_charger_data *charger)
+{
+	int ret, current_limit = 0;
+	ret = sm5703_reg_read(charger->i2c, SM5703_VBUSCNTL);
+	if (ret < 0)
+		return ret;
+	ret&=SM5703_VBUSLIMIT_MASK;
+
+	current_limit = (100 + (ret*50));
+
+	return current_limit;
+}
+
+static void sm5703_set_regulation_voltage(struct sm5703_charger_data *charger,
+		int float_voltage)
+{
+	int data = 0;
+
+	data = sm5703_reg_read(charger->i2c, SM5703_CHGCNTL3);
+
+	data &= ~SM5703_BATREG_MASK;
+
+	if ((float_voltage) <= 4120)
+		data = 0x00;
+	else if ((float_voltage) >= 4430)
+		data = 0x1f;
+	else
+		data = ((float_voltage - 4120) / 10);
+
+	mutex_lock(&charger->io_lock);
+	sm5703_reg_write(charger->i2c, SM5703_CHGCNTL3, data);
+	data = sm5703_reg_read(charger->i2c, SM5703_CHGCNTL3);
+	pr_info("%s : SM5703_CHGCNTL3 (Battery regulation voltage) : 0x%02x\n",
+			__func__, data);
+	mutex_unlock(&charger->io_lock);
+}
+
+#if defined(CONFIG_BATTERY_SWELLING) || defined(CONFIG_BATTERY_SWELLING_SELF_DISCHARGING)
+static int sm5703_get_regulation_voltage(struct sm5703_charger_data *charger)
+{
+	int data = 0;
+
+	data = sm5703_reg_read(charger->i2c, SM5703_CHGCNTL3);
+	data &= SM5703_BATREG_MASK;
+
+	return (4120 + (data * 10));
+}
+#endif
+
+static void sm5703_set_fast_charging_current(struct sm5703_charger_data *charger,
+		int charging_current)
+{
+	int data = 0;
+
+	if(charging_current <= 100)
+		charging_current = 100;
+	else if (charging_current >= 2500)
+		charging_current = 2500;
+
+	data = (charging_current - 100) / 50;
+
+	sm5703_reg_write(charger->i2c, SM5703_CHGCNTL2, data);
+
+	data = sm5703_reg_read(charger->i2c, SM5703_CHGCNTL2);
+	pr_info("%s : SM5703_CHGCNTL2 (fastchg current) : 0x%02x\n",
+			__func__, data);
+
+}
+
+static int sm5703_get_fast_charging_current(struct sm5703_charger_data *charger)
+{
+	int data = sm5703_reg_read(charger->i2c, SM5703_CHGCNTL2);
+	int charging_current = 0;
+
+	if (data < 0)
+		return data;
+
+	data &= SM5703_FASTCHG_MASK;
+
+	charging_current = (100 + (data*50));
+
+	return charging_current;
+}
+
+static int sm5703_get_topoff_current(struct sm5703_charger_data *charger)
+{
+	int ret, data = 0, topoff_current = 0;
+	mutex_lock(&charger->io_lock);
+	ret = sm5703_reg_read(charger->i2c, SM5703_CHGCNTL4);
+	mutex_unlock(&charger->io_lock);
+	if (ret < 0) {
+		pr_info("%s: warning --> fail to read i2c register(%d)\n", __func__, ret);
+		return ret;
+	}
+
+	data = ((ret & SM5703_TOPOFF_MASK) >> SM5703_TOPOFF_SHIFT);  
+
+	topoff_current = (100 + (data*25));
+
+	return topoff_current;
+}
+
+static void sm5703_set_topoff_current(struct sm5703_charger_data *charger,
+		int current_limit)
+{
+	int data = 0, temp = 0;
+
+	pr_info("%s : Set Termination\n", __func__);
+
+	data = sm5703_reg_read(charger->i2c, SM5703_CHGCNTL4);
+
+	data &= ~SM5703_TOPOFF_MASK;
+
+	if(current_limit <= 100)
+		current_limit = 100;
+	else if (current_limit >= 475)
+		current_limit = 475;
+
+	temp = (current_limit - 100) / 25;
+	data |= (temp << SM5703_TOPOFF_SHIFT);
+
+	sm5703_reg_write(charger->i2c, SM5703_CHGCNTL4, data);
+
+	data = sm5703_reg_read(charger->i2c, SM5703_CHGCNTL4);
+	pr_info("%s : SM5703_CHGCNTL4 (Top-off current threshold) : 0x%02x\n",
+			__func__, data);    
+}
+
+static void sm5703_set_otgcurrent(struct sm5703_charger_data *charger,
+		int otg_current)
+{
+	int data = 0;
+
+	data = sm5703_reg_read(charger->i2c, SM5703_OTGCURRENTCNTL);
+
+	data &= ~SM5703_OTGCURRENT_MASK;
+
+	if (otg_current <= 500)
+		data = 0x00;
+	else if (otg_current <= 700)
+		data = 0x01;
+	else if (otg_current <= 900)
+		data = 0x02;    
+	else
+		data = 0x3;
+
+	mutex_lock(&charger->io_lock);
+	sm5703_reg_write(charger->i2c, SM5703_OTGCURRENTCNTL, data);
+	data = sm5703_reg_read(charger->i2c, SM5703_OTGCURRENTCNTL);
+	pr_info("%s : SM5703_OTGCURRENTCNTL (OTG current) : 0x%02x\n",
+			__func__, data);
+	mutex_unlock(&charger->io_lock);
+}
+
+static void sm5703_set_bst_iq3limit(struct sm5703_charger_data *charger,
+		int iq3limit)
+{
+	int data = 0;
+
+	mutex_lock(&charger->io_lock);
+	data = sm5703_reg_read(charger->i2c, SM5703_Q3LIMITCNTL);
+	data &= ~SM5703_BST_IQ3LIMIT_MASK;
+	data |= (iq3limit << SM5703_BST_IQ3LIMIT_SHIFT);
+
+	sm5703_reg_write(charger->i2c, SM5703_Q3LIMITCNTL, data);
+
+	data = sm5703_reg_read(charger->i2c, SM5703_Q3LIMITCNTL);
+	pr_info("%s : SM5703_Q3LIMITCNTL (BST_IQ3LIMIT) : 0x%02x\n",
+			__func__, data);
+	mutex_unlock(&charger->io_lock);
+}
+
+enum {
+	SM5703_AICL_4300MV = 0,
+	SM5703_AICL_4400MV,
+	SM5703_AICL_4500MV,
+	SM5703_AICL_4600MV,
+	SM5703_AICL_4700MV,
+	SM5703_AICL_4800MV,
+	SM5703_AICL_4900MV,
+};
+
+#if ENABLE_AICL
+/* Dedicated charger (non-USB) device
+ * will use lower AICL level to get better performance
+ */
+static void sm5703_set_aicl_level(struct sm5703_charger_data *charger)
+{
+	int aicl;
+	switch(charger->cable_type) {
+		case POWER_SUPPLY_TYPE_USB ... POWER_SUPPLY_TYPE_USB_ACA:
+			aicl = SM5703_AICL_4500MV;
+			break;
+		default:
+			aicl = SM5703_AICL_4500MV;
+	}
+	mutex_lock(&charger->io_lock);
+	sm5703_assign_bits(charger->i2c,
+			SM5703_CHGCNTL5, SM5703_AICLTH_MASK, aicl);
+	mutex_unlock(&charger->io_lock);
+}
+#endif /*ENABLE_AICL*/
+
+#if 0 //temp block
+static void sm5703_configure_charger(struct sm5703_charger_data *charger)
+{
+	/* check aicl state */
+	if ((sm5703_reg_read(charger->i2c, SM5703_STATUS1) & 0x01) &&
+			!charger->aicl_state) {
+		charger->aicl_state = true;
+		wake_lock(&charger->aicl_wake_lock);
+		queue_delayed_work_on(0, charger->wq, &charger->aicl_work, msecs_to_jiffies(50));
+	}
+}
+#endif
+
+/* here is set init charger data */
+static bool sm5703_chg_init(struct sm5703_charger_data *charger)
+{
+	sm5703_mfd_chip_t *chip = i2c_get_clientdata(charger->i2c);
+	int ret;
+	chip->charger = charger;
+
+	/* AUTOSTOP */
+	sm5703_enable_autostop(chip->charger, (int)charger->pdata->chg_autostop);
+	/* AUTOSET */
+	sm5703_enable_autoset(chip->charger, (int)charger->pdata->chg_autoset);
+	/* AICLEN */
+	sm5703_enable_aiclen(chip->charger, (int)charger->pdata->chg_aiclen);
+	/* AICLTH */
+	sm5703_set_aiclth(chip->charger, (int)charger->pdata->chg_aiclth);
+	/* FREQSEL */
+	sm5703_set_freqsel(chip->charger, SM5703_FREQSEL_1P5MHZ);
+	/* Auto-Stop configuration for Emergency status */
+	sm5703_set_topoff_timer(charger, SM5703_TOPOFF_TIMER_45m);
+
+	/* MUST set correct regulation voltage first
+	 * Before MUIC pass cable type information to charger
+	 * charger would be already enabled (default setting)
+	 * it might cause EOC event by incorrect regulation voltage */
+	sm5703_set_regulation_voltage(charger,
+			charger->pdata->chg_float_voltage);
+
+	sm5703_set_otgcurrent(charger, 1200); /* OTGCURRENT : 1.2A */
+
+	sm5703_set_bst_iq3limit(charger, SM5703_BST_IQ3LIMIT_0P7X);
+
+	ret = sm5703_reg_read(charger->i2c, SM5703_STATUS3);
+	if (ret < 0)
+		pr_info("Error : can't get charging status (%d)\n", ret);
+
+	if (ret & SM5703_STATUS3_TOPOFF) {
+		pr_info("%s: W/A Charger already topoff state. Charger Off\n",
+				__func__);
+		sm5703_enable_charger_switch(charger, 0);
+		msleep(100);
+		sm5703_enable_charger_switch(charger, 1);
+	}
+
+	sm5703_test_read(charger->i2c);
+
+	return true;
+}
+
+
+static int sm5703_get_charging_status(struct sm5703_charger_data *charger)
+{
+	int status = POWER_SUPPLY_STATUS_UNKNOWN;
+	int ret;
+	int nCHG = 0;
+
+	ret = sm5703_reg_read(charger->i2c, SM5703_STATUS3);
+	if (ret<0) {
+		pr_info("Error : can't get charging status (%d)\n", ret);
+
+	}
+
+	nCHG = gpio_get_value(charger->pdata->chgen_gpio);
+
+	if ((ret & SM5703_STATUS3_DONE) || (ret & SM5703_STATUS3_TOPOFF)) {
+		status = POWER_SUPPLY_STATUS_FULL;
+		pr_info("%s : Status, Power Supply Full \n", __func__);
+	} else if (ret & SM5703_STATUS3_CHGON) {
+		status = POWER_SUPPLY_STATUS_CHARGING;    
+	} else {
+		if (nCHG)
+			status = POWER_SUPPLY_STATUS_DISCHARGING;
+		else
+			status = POWER_SUPPLY_STATUS_NOT_CHARGING;
+	}
+
+	/* TEMP_TEST : when OTG is enabled(charging_current -1), handle OTG func. */
+	if (charger->charging_current < 0) {
+		/* For OTG mode, SM5703 would still report "charging" */
+		status = POWER_SUPPLY_STATUS_DISCHARGING;
+		ret = sm5703_reg_read(charger->i2c, SM5703_STATUS1);
+		if (ret & SM5703_STATUS1_OTGFAIL) {
+			pr_info("%s: otg overcurrent limit\n", __func__);
+			sm5703_charger_otg_control(charger, false);
+		}
+
+	}
+
+	return status;
+}
+
+static int sm5703_get_charging_health(struct sm5703_charger_data *charger)
+{
+	int vbus_status = sm5703_reg_read(charger->i2c, SM5703_STATUS5);
+	int health = POWER_SUPPLY_HEALTH_GOOD;
+	int chg_cntl = 0, nCHG = 0;
+
+	pr_info("%s : charger->is_charging = %d, charger->cable_type = %d, charger->aicl_state = %d\n",
+		__func__, charger->is_charging, charger->cable_type, charger->aicl_state);
+
+	chg_cntl = sm5703_reg_read(charger->i2c, SM5703_CNTL);
+	nCHG = gpio_get_value(charger->pdata->chgen_gpio);
+	pr_info("%s: SM5703_CNTL, nCHG : 0x%x, %d\n", __func__, chg_cntl, nCHG);
+
+	/* temp for test */
+	pr_info("%s : vbus_status = %d\n", __func__, vbus_status);
+
+	if (vbus_status < 0) {
+		health = POWER_SUPPLY_HEALTH_UNKNOWN;
+		pr_info("%s : Health : %d, vbus_status : %d\n", __func__, health,vbus_status);
+
+		return (int)health;
+	}
+
+	if (vbus_status & SM5703_STATUS5_VBUSOK)
+		health = POWER_SUPPLY_HEALTH_GOOD;
+	else if (vbus_status & SM5703_STATUS5_VBUSOVP)
+		health = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+	else if (vbus_status & SM5703_STATUS5_VBUSUVLO)
+		health = POWER_SUPPLY_HEALTH_UNDERVOLTAGE;
+	else
+		health = POWER_SUPPLY_HEALTH_UNKNOWN;
+
+	pr_info("%s : Health : %d\n", __func__, health);
+
+	return (int)health;
+}
+
+static int sec_chg_get_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		union power_supply_propval *val)
+{
+
+	int chg_curr, aicr, vbus_status;
+	struct sm5703_charger_data *charger =
+		container_of(psy, struct sm5703_charger_data, psy_chg);
+
+	switch (psp) {
+		case POWER_SUPPLY_PROP_ONLINE:
+			vbus_status = sm5703_reg_read(charger->i2c, SM5703_STATUS5);
+			if (charger->cable_type != POWER_SUPPLY_TYPE_BATTERY &&
+				!(vbus_status & SM5703_STATUS5_VBUSOK))
+					charger->cable_type = POWER_SUPPLY_TYPE_BATTERY;
+
+			val->intval = charger->cable_type;
+			pr_info("%s: Charger Cable type : %d\n", __func__, charger->cable_type);
+			break;
+		case POWER_SUPPLY_PROP_STATUS:
+			val->intval = sm5703_get_charging_status(charger);
+			break;
+		case POWER_SUPPLY_PROP_HEALTH:
+			val->intval = sm5703_get_charging_health(charger);
+			break;
+		case POWER_SUPPLY_PROP_CURRENT_MAX:
+			sm5703_test_read(charger->i2c);
+			val->intval = sm5703_get_input_current_limit(charger);
+			break;
+		case POWER_SUPPLY_PROP_CURRENT_AVG:
+		case POWER_SUPPLY_PROP_CURRENT_NOW:
+			if (charger->charging_current) {
+				aicr = sm5703_get_input_current_limit(charger);
+				chg_curr = sm5703_get_fast_charging_current(charger);
+				val->intval = MINVAL(aicr, chg_curr);
+			} else
+				val->intval = 0;
+			break;
+		case POWER_SUPPLY_PROP_CURRENT_FULL:
+			val->intval = sm5703_get_topoff_current(charger);
+			break;
+#if defined(CONFIG_BATTERY_SWELLING) || defined(CONFIG_BATTERY_SWELLING_SELF_DISCHARGING)
+		case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+			val->intval = sm5703_get_regulation_voltage(charger);
+		break;
+#endif
+		case POWER_SUPPLY_PROP_CHARGE_TYPE:
+			if (!charger->is_charging || charger->cable_type == POWER_SUPPLY_TYPE_BATTERY) {
+				val->intval = POWER_SUPPLY_CHARGE_TYPE_NONE;
+			} else if (charger->input_current <= SLOW_CHARGING_CURRENT_STANDARD) {
+				val->intval = POWER_SUPPLY_CHARGE_TYPE_SLOW;
+				pr_info("%s: slow-charging mode\n", __func__);
+			} else
+				val->intval = POWER_SUPPLY_CHARGE_TYPE_FAST;
+			break;
+		case POWER_SUPPLY_PROP_CHARGING_ENABLED:
+			val->intval = charger->is_charging;
+			break;
+		case POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL:
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sec_chg_set_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		const union power_supply_propval *val)
+{
+	struct sm5703_charger_data *charger =
+		container_of(psy, struct sm5703_charger_data, psy_chg);
+	int buck_state = ENABLE;
+
+	switch (psp) {
+		case POWER_SUPPLY_PROP_STATUS:
+			charger->status = val->intval;
+			break;
+			/* val->intval : type */
+		case POWER_SUPPLY_PROP_ONLINE:
+			charger->cable_type = val->intval;
+			charger->aicl_state = false;
+			charger->input_current = charger->pdata->charging_current
+					[charger->cable_type].input_current_limit;
+			pr_info("%s:[BATT] cable_type(%d), input_current(%d)\n",
+				__func__, charger->cable_type, charger->input_current);
+#if ENABLE_AICL
+			sm5703_set_aicl_level(charger);
+#endif /*DISABLE_AICL*/
+			break;
+		case POWER_SUPPLY_PROP_CURRENT_MAX:
+			{
+				int input_current = val->intval;
+				if (charger->input_current < input_current) {
+					input_current = charger->input_current;
+				}
+				sm5703_set_input_current_limit(charger, input_current);
+			}
+			break;
+		case POWER_SUPPLY_PROP_CURRENT_AVG:
+		case POWER_SUPPLY_PROP_CURRENT_NOW:
+			charger->charging_current = val->intval;
+			/* set charging current */
+			if (charger->is_charging) {
+				/* Fast charge and Termination current */
+				pr_info("%s : fast charging current (%dmA)\n",
+						__func__, charger->charging_current);
+				sm5703_set_fast_charging_current(charger, charger->charging_current);
+			}
+
+			if (sec_bat_get_slate_mode() == ENABLE) {
+				sm5703_assign_bits(charger->i2c,
+					SM5703_CNTL, SM5703_OPERATION_MODE_MASK,
+					SM5703_OPERATION_MODE_SUSPEND);
+				pr_info("%s: SM5703 OPERATION MODE SUSPEND\n",__func__);
+			} else {
+				sm5703_enable_charger_switch(charger, charger->is_charging);
+			}
+#if EN_TEST_READ
+			sm5703_test_read(charger->i2c);
+#endif
+			break;
+		case POWER_SUPPLY_PROP_CURRENT_FULL:
+			sm5703_set_topoff_current(charger, val->intval);
+			break;
+#if defined(CONFIG_BATTERY_SWELLING) || defined(CONFIG_BATTERY_SWELLING_SELF_DISCHARGING)
+		case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+			pr_info("%s: float voltage(%d)\n", __func__, val->intval);
+			charger->pdata->chg_float_voltage = val->intval;
+			sm5703_set_regulation_voltage(charger, val->intval);
+			break;
+#endif
+		case POWER_SUPPLY_PROP_HEALTH:
+			/* charger->ovp = val->intval; */
+			break;
+		case POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL:
+			sm5703_charger_otg_control(charger, val->intval);
+			break;
+		case POWER_SUPPLY_PROP_CHARGING_ENABLED:
+			charger->charge_mode = val->intval;
+			switch (charger->charge_mode) {
+			case SEC_BAT_CHG_MODE_BUCK_OFF:
+				buck_state = DISABLE;
+			case SEC_BAT_CHG_MODE_CHARGING_OFF:
+				charger->is_charging = false;
+				break;
+			case SEC_BAT_CHG_MODE_CHARGING:
+				charger->is_charging = true;
+				break;
+			}
+			/*sm5702_set_buck(charger, buck_state);*/
+			sm5703_enable_charger_switch(charger, charger->is_charging);
+
+			if (sec_bat_get_slate_mode() == ENABLE) {
+				sm5703_assign_bits(charger->i2c,
+					SM5703_CNTL, SM5703_OPERATION_MODE_MASK,
+					SM5703_OPERATION_MODE_SUSPEND);
+				pr_info("%s: SM5703 OPERATION MODE SUSPEND\n",__func__);
+			} else {
+				sm5703_enable_charger_switch(charger, charger->is_charging);
+			}
+			break;
+		case POWER_SUPPLY_PROP_ENERGY_NOW:
+			/* charger off when jig detected */
+			if (val->intval)
+				sm5703_enable_charger_switch(charger, false);
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sm5703_otg_get_property(struct power_supply *psy,
+				enum power_supply_property psp,
+				union power_supply_propval *val)
+{
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = otg_enable_flag;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int sm5703_otg_set_property(struct power_supply *psy,
+				enum power_supply_property psp,
+				const union power_supply_propval *val)
+{
+	union power_supply_propval value;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		value.intval = val->intval;
+		pr_info("%s: OTG %s\n", __func__, value.intval > 0 ? "on" : "off");
+		psy_do_property("sm5703-charger", set,
+					POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL, value);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+ssize_t sm5703_chg_show_attrs(struct device *dev,
+		const ptrdiff_t offset, char *buf)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct sm5703_charger_data *charger =
+		container_of(psy, struct sm5703_charger_data, psy_chg);
+	int i = 0;
+	char *str = NULL;
+
+	switch (offset) {
+	case CHG_REG:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%x\n",
+				charger->reg_addr);
+		break;
+	case CHG_DATA:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%x\n",
+				charger->reg_data);
+		break;
+	case CHG_REGS:
+		str = kzalloc(sizeof(char) * 256, GFP_KERNEL);
+		if (!str)
+			return -ENOMEM;
+
+		sm5703_read_regs(charger->i2c, str);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%s\n",
+				str);
+
+		kfree(str);
+		break;
+	default:
+		i = -EINVAL;
+		break;
+	}
+
+	return i;
+}
+
+ssize_t sm5703_chg_store_attrs(struct device *dev,
+		const ptrdiff_t offset,
+		const char *buf, size_t count)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct sm5703_charger_data *charger =
+		container_of(psy, struct sm5703_charger_data, psy_chg);
+
+	int ret = 0;
+	int x = 0;
+	uint8_t data = 0;
+
+	switch (offset) {
+	case CHG_REG:
+		if (sscanf(buf, "%x\n", &x) == 1) {
+			charger->reg_addr = x;
+			data = sm5703_reg_read(charger->i2c,
+					charger->reg_addr);
+			charger->reg_data = data;
+			dev_dbg(dev, "%s: (read) addr = 0x%x, data = 0x%x\n",
+					__func__, charger->reg_addr, charger->reg_data);
+			ret = count;
+		}
+		break;
+	case CHG_DATA:
+		if (sscanf(buf, "%x\n", &x) == 1) {
+			data = (u8)x;
+
+			dev_dbg(dev, "%s: (write) addr = 0x%x, data = 0x%x\n",
+					__func__, charger->reg_addr, data);
+			ret = sm5703_reg_write(charger->i2c,
+					charger->reg_addr, data);
+			if (ret < 0) {
+				dev_dbg(dev, "I2C write fail Reg0x%x = 0x%x\n",
+						(int)charger->reg_addr, (int)data);
+			}
+			ret = count;
+		}
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+struct sm5703_chg_irq_handler {
+	char *name;
+	int irq_index;
+	irqreturn_t (*handler)(int irq, void *data);
+};
+#if EN_NOBAT_IRQ
+static irqreturn_t sm5703_chg_nobat_irq_handler(int irq, void *data)
+{
+	struct sm5703_charger_data *info = data;
+	struct i2c_client *iic = info->sm5703->i2c_client;
+
+	/* set full charged flag
+	 * until TA/USB unplug event / stop charging by PSY
+	 */
+
+	pr_info("%s : Nobat\n", __func__);
+
+#if EN_TEST_READ
+	sm5703_test_read(iic);
+#endif
+
+	return IRQ_HANDLED;
+}
+#endif /*EN_NOBAT_IRQ*/
+
+#if EN_DONE_IRQ
+static irqreturn_t sm5703_chg_done_irq_handler(int irq, void *data)
+{
+	struct sm5703_charger_data *info = data;
+	struct i2c_client *iic = info->sm5703->i2c_client;
+
+	/* set full charged flag
+	 * until TA/USB unplug event / stop charging by PSY
+	 */
+
+	pr_info("%s : Full charged(done)\n", __func__);
+
+#if EN_TEST_READ
+	sm5703_test_read(iic);
+#endif
+
+	return IRQ_HANDLED;
+}
+#endif/*EN_DONE_IRQ*/
+
+#if EN_TOPOFF_IRQ
+static irqreturn_t sm5703_chg_topoff_irq_handler(int irq, void *data)
+{
+	struct sm5703_charger_data *info = data;
+	struct i2c_client *iic = info->sm5703->i2c_client;
+
+	/* set full charged flag
+	 * until TA/USB unplug event / stop charging by PSY
+	 */
+
+	pr_info("%s : Full charged(topoff)\n", __func__);
+
+#if EN_TEST_READ
+	sm5703_test_read(iic);
+#endif
+
+	return IRQ_HANDLED;
+}
+#endif /*EN_TOPOFF_IRQ*/
+
+static void sm5703_chg_aicl_work(struct work_struct *work)
+{
+	struct sm5703_charger_data *charger =
+		container_of(work, struct sm5703_charger_data, aicl_work.work);
+	int reg_data = 0, temp = 0, aicl_state;
+	int current_limit = charger->input_current;
+
+	mutex_lock(&charger->io_lock);
+	/* disable aicl irq */
+	sm5703_assign_bits(charger->i2c, SM5703_INTMSK1, 0x01, 0x01);
+
+	/* reduce input current */
+	reg_data = sm5703_reg_read(charger->i2c, SM5703_VBUSCNTL);
+	reg_data &= ~SM5703_VBUSLIMIT;
+	do {
+		current_limit -= REDUCE_CURRENT_STEP;
+		temp = ((current_limit - 100) / 50) | reg_data;
+		sm5703_reg_write(charger->i2c, SM5703_VBUSCNTL, temp);
+		msleep(200);
+		aicl_state = sm5703_reg_read(charger->i2c, SM5703_STATUS1) & 0x01;
+		pr_info("%s: aicl state(%d), current limit(%d), max(%d)\n",
+			__func__, aicl_state, current_limit, charger->input_current);
+	} while (aicl_state && current_limit > MINIMUM_INPUT_CURRENT);
+	charger->input_current = current_limit;
+
+	/* check slow charging */
+	if (charger->input_current <= SLOW_CHARGING_CURRENT_STANDARD &&
+		charger->cable_type != POWER_SUPPLY_TYPE_BATTERY) {
+		union power_supply_propval value;
+		psy_do_property("battery", set,
+			POWER_SUPPLY_PROP_CHARGE_TYPE, value);
+		pr_info("%s: slow charging on : input current(%dmA), cable type(%d)\n",
+			__func__, charger->input_current, charger->cable_type);
+	}
+
+	/* enable aicl irq */
+	sm5703_assign_bits(charger->i2c, SM5703_INTMSK1, 0x01, 0x00);
+	mutex_unlock(&charger->io_lock);
+
+	wake_unlock(&charger->aicl_wake_lock);
+}
+
+#if EN_AICL_IRQ
+static irqreturn_t sm5703_chg_aicl_irq_handler(int irq, void *data)
+{
+	struct sm5703_charger_data *info = data;
+	struct i2c_client *iic = info->sm5703->i2c_client;
+
+#if EN_TEST_READ
+	sm5703_test_read(iic);
+#endif
+
+	pr_info("%s: cable type:%d, current max:%d, aicl_state:%d\n",
+		__func__, info->cable_type, info->input_current, info->aicl_state);
+
+	if (info->cable_type != POWER_SUPPLY_TYPE_BATTERY &&
+		info->input_current > MINIMUM_INPUT_CURRENT &&
+		!info->aicl_state) {
+		info->aicl_state = true;
+		wake_lock(&info->aicl_wake_lock);
+		queue_delayed_work_on(0, info->wq, &info->aicl_work, msecs_to_jiffies(50));
+	}
+	return IRQ_HANDLED;
+}
+#endif
+
+#if EN_CHGON_IRQ
+static irqreturn_t sm5703_chg_chgon_irq_handler(int irq, void *data)
+{
+	struct sm5703_charger_data *info = data;
+	struct i2c_client *iic = info->sm5703->i2c_client;
+
+	pr_info("%s : Chgon\n", __func__);
+
+#if EN_TEST_READ
+	sm5703_test_read(iic);
+#endif
+
+	return IRQ_HANDLED;
+}
+#endif /*EN_CHGON_IRQ*/
+
+#if EN_OTGFAIL_IRQ
+static irqreturn_t sm5703_chg_otgfail_irq_handler(int irq, void *data)
+{
+	struct sm5703_charger_data *info = data;
+	/* struct i2c_client *iic = info->sm5703->i2c_client; */
+	int ret;
+
+#ifdef CONFIG_USB_HOST_NOTIFY
+	struct otg_notify *o_notify;
+
+	o_notify = get_otg_notify();
+#endif
+	pr_info("%s : OTG Failed\n", __func__);
+
+	ret = sm5703_reg_read(info->sm5703->i2c_client, SM5703_STATUS1);
+	if (ret & SM5703_STATUS1_OTGFAIL) {
+		pr_info("%s: otg overcurrent limit\n", __func__);
+#ifdef CONFIG_USB_HOST_NOTIFY
+		send_otg_notify(o_notify, NOTIFY_EVENT_OVERCURRENT, 0);
+#endif
+		sm5703_charger_otg_control(info, false);
+	}
+
+	return IRQ_HANDLED;
+}
+#endif /*EN_CHGON_IRQ*/
+
+const struct sm5703_chg_irq_handler sm5703_chg_irq_handlers[] = {
+#if EN_NOBAT_IRQ    
+	{
+		.name = "NOBAT",
+		.handler = sm5703_chg_nobat_irq_handler,
+		.irq_index = SM5703_NOBAT_IRQ,
+	},
+#endif /*EN_NOBAT_IRQ*/
+#if EN_DONE_IRQ
+	{
+		.name = "DONE",
+		.handler = sm5703_chg_done_irq_handler,
+		.irq_index = SM5703_DONE_IRQ,
+	},
+#endif/*EN_DONE_IRQ*/	
+#if EN_TOPOFF_IRQ	
+	{
+		.name = "TOPOFF",
+		.handler = sm5703_chg_topoff_irq_handler,
+		.irq_index = SM5703_TOPOFF_IRQ,
+	},
+#endif /*EN_TOPOFF_IRQ*/
+#if EN_CHGON_IRQ
+	{
+		.name = "CHGON",
+		.handler = sm5703_chg_chgon_irq_handler,
+		.irq_index = SM5703_CHGON_IRQ,
+	},
+#endif /*EN_CHGON_IRQ*/
+#if EN_AICL_IRQ
+	{
+		.name = SM5703_AICL_IRQ_NAME,
+		.handler = sm5703_chg_aicl_irq_handler,
+		.irq_index = SM5703_AICL_IRQ,
+	},
+#endif /* EN_AICL_IRQ */
+#if EN_OTGFAIL_IRQ
+	{
+		.name = "OTGFAIL",
+		.handler = sm5703_chg_otgfail_irq_handler,
+		.irq_index = SM5703_OTGFAIL_IRQ,
+	},
+#endif /* EN_OTGFAIL_IRQ */
+};
+
+
+static int register_irq(struct platform_device *pdev,
+		struct sm5703_charger_data *info)
+{
+	int irq;
+	int i, j;
+	int ret;
+	const struct sm5703_chg_irq_handler *irq_handler = sm5703_chg_irq_handlers;
+	const char *irq_name;
+	for (i = 0; i < ARRAY_SIZE(sm5703_chg_irq_handlers); i++) {
+		irq_name = sm5703_get_irq_name_by_index(irq_handler[i].irq_index);
+		irq = platform_get_irq_byname(pdev, irq_name);
+		ret = request_threaded_irq(irq, NULL, irq_handler[i].handler,
+				IRQF_ONESHOT | IRQF_TRIGGER_FALLING |
+				IRQF_NO_SUSPEND, irq_name, info);
+		if (ret < 0) {
+			pr_err("%s : Failed to request IRQ (%s): #%d: %d\n",
+					__func__, irq_name, irq, ret);
+			goto err_irq;
+		}
+
+		pr_info("%s : Register IRQ%d(%s) successfully\n",
+				__func__, irq, irq_name);
+	}
+
+	return 0;
+err_irq:
+	for (j = 0; j < i; j++) {
+		irq_name = sm5703_get_irq_name_by_index(irq_handler[j].irq_index);
+		irq = platform_get_irq_byname(pdev, irq_name);
+		free_irq(irq, info);
+	}
+
+	return ret;
+}
+
+static void unregister_irq(struct platform_device *pdev,
+		struct sm5703_charger_data *info)
+{
+	int irq;
+	int i;
+	const char *irq_name;
+	const struct sm5703_chg_irq_handler *irq_handler = sm5703_chg_irq_handlers;
+
+	for (i = 0; i < ARRAY_SIZE(sm5703_chg_irq_handlers); i++) {
+		irq_name = sm5703_get_irq_name_by_index(irq_handler[i].irq_index);
+		irq = platform_get_irq_byname(pdev, irq_name);
+		free_irq(irq, info);
+	}
+}
+
+#ifdef CONFIG_OF
+static int sec_bat_read_u32_index_dt(const struct device_node *np,
+		const char *propname,
+		u32 index, u32 *out_value)
+{
+	struct property *prop = of_find_property(np, propname, NULL);
+	u32 len = (index + 1) * sizeof(*out_value);
+
+	if (!prop)
+		return (-EINVAL);
+	if (!prop->value)
+		return (-ENODATA);
+	if (len > prop->length)
+		return (-EOVERFLOW);
+
+	*out_value = be32_to_cpup(((__be32 *)prop->value) + index);
+
+	return 0;
+}
+
+static int sm5703_charger_parse_dt(struct device *dev,
+		struct sm5703_charger_platform_data *pdata)
+{
+	struct device_node *np = of_find_node_by_name(NULL, "charger");
+	const u32 *p;
+	int ret, i, len;
+
+	ret = of_property_read_u32(np, "chg_autostop", &pdata->chg_autostop);
+	if (ret < 0) {
+		pr_info("%s : cannot get chg autostop\n", __func__);
+		pdata->chg_autostop = 0;
+	}
+
+	ret = of_property_read_u32(np, "chg_autoset", &pdata->chg_autoset);
+	if (ret < 0) {
+		pr_info("%s : cannot get chg autoset\n", __func__);
+		pdata->chg_autoset = 0;
+	}
+
+	ret = of_property_read_u32(np, "chg_aiclen", &pdata->chg_aiclen);
+	if (ret < 0) {
+		pr_info("%s : cannot get chg aiclen\n", __func__);
+		pdata->chg_aiclen = 0;
+	}
+
+	ret = of_property_read_u32(np, "chg_aiclth", &pdata->chg_aiclth);
+	if (ret < 0) {
+		pr_info("%s : cannot get chg aiclth\n", __func__);
+		pdata->chg_aiclth = 4500;
+	}
+
+	ret = of_property_read_u32(np, "fg_vol_val", &pdata->fg_vol_val);
+	if (ret < 0) {
+		pr_info("%s : cannot get fg_vol_val\n", __func__);
+		pdata->fg_vol_val = 4350;
+	}
+
+	ret = of_property_read_u32(np, "fg_soc_val", &pdata->fg_soc_val);
+	if (ret < 0) {
+		pr_info("%s : cannot get fg_soc_val\n", __func__);
+		pdata->fg_soc_val = 95;
+	}
+
+	ret = of_property_read_u32(np, "fg_curr_avr_val",
+		&pdata->fg_curr_avr_val);
+	if (ret < 0) {
+		pr_info("%s : cannot get fg_curr_avr_val\n", __func__);
+		pdata->fg_curr_avr_val = 150;
+	}
+
+	ret = of_property_read_u32(np, "battery,chg_float_voltage",
+			&pdata->chg_float_voltage);
+	if (ret < 0) {
+		pr_info("%s : cannot get chg float voltage\n", __func__);
+		pdata->chg_float_voltage = 4350;
+	}
+
+	pdata->chgen_gpio = of_get_named_gpio(np, "battery,chg_gpio_en", 0);
+	if (pdata->chgen_gpio < 0) {
+		pr_err("%s : cannot get chgen gpio : %d\n",
+			__func__, pdata->chgen_gpio);
+		return -ENODATA;	
+	} else {
+		pr_info("%s: chgen gpio : %d\n", __func__, pdata->chgen_gpio);
+	}
+
+	np = of_find_node_by_name(NULL, "battery");
+	if (!np) {
+		pr_info("%s : np NULL\n", __func__);
+		return -ENODATA;
+	}
+
+	ret = of_property_read_string(np,
+		"battery,charger_name", (char const **)&pdata->charger_name);
+	if (ret) {
+		pdata->charger_name = "sm5703-charger";
+		pr_info("%s: Charger name is Empty. Set default.\n", __func__);
+	}
+
+	ret = of_property_read_u32(np, "battery,full_check_type_2nd",
+			&pdata->full_check_type_2nd);
+	if (ret)
+		pr_info("%s : Full check type 2nd is Empty\n", __func__);
+
+	p = of_get_property(np, "battery,input_current_limit", &len);
+
+	len = len / sizeof(u32);
+
+	pdata->charging_current =
+		kzalloc(sizeof(sec_charging_current_t) * len, GFP_KERNEL);
+
+	for(i = 0; i < len; i++) {
+		ret = sec_bat_read_u32_index_dt(np,
+			"battery,input_current_limit", i,
+			&pdata->charging_current[i].input_current_limit);
+	}
+
+	dev_info(dev,"sm5703 charger parse dt retval = %d\n", ret);
+	return ret;
+}
+
+static struct of_device_id sm5703_charger_match_table[] = {
+	{ .compatible = "siliconmitus,sm5703-charger",},
+	{},
+};
+#else
+static int sm5703_charger_parse_dt(struct device *dev,
+		struct sm5703_charger_platform_data *pdata)
+{
+	return -ENOSYS;
+}
+#define sm5703_charger_match_table NULL
+#endif /* CONFIG_OF */
+
+static int sm5703_charger_probe(struct platform_device *pdev)
+{
+	sm5703_mfd_chip_t *chip = dev_get_drvdata(pdev->dev.parent);
+#ifndef CONFIG_OF
+	struct sm5703_mfd_platform_data *mfd_pdata =
+				dev_get_platdata(chip->dev);
+#endif	
+	struct sm5703_charger_data *charger;
+	int ret = 0;
+
+	otg_enable_flag = 0;
+
+	pr_info("%s:[BATT] SM5703 Charger driver probe..\n", __func__);
+
+	charger = kzalloc(sizeof(*charger), GFP_KERNEL);
+	if (!charger)
+		return -ENOMEM;
+
+	mutex_init(&charger->io_lock);
+	charger->sm5703= chip;
+	charger->i2c = chip->i2c_client;
+
+#ifdef CONFIG_OF	
+	charger->pdata = devm_kzalloc(&pdev->dev,
+			sizeof(*(charger->pdata)), GFP_KERNEL);
+	if (!charger->pdata) {
+		dev_err(&pdev->dev, "Failed to allocate memory\n");
+		ret = -ENOMEM;
+		goto err_parse_dt_nomem;
+	}
+	ret = sm5703_charger_parse_dt(&pdev->dev, charger->pdata);
+	if (ret < 0)
+		goto err_parse_dt;
+#else		
+	charger->pdata = mfd_pdata->charger_platform_data;
+#endif
+
+	platform_set_drvdata(pdev, charger);
+
+	if (charger->pdata->charger_name == NULL)
+		charger->pdata->charger_name = "sm5703-charger";
+
+	charger->psy_chg.name			= charger->pdata->charger_name;
+	charger->psy_chg.type			= POWER_SUPPLY_TYPE_UNKNOWN;
+	charger->psy_chg.get_property	= sec_chg_get_property;
+	charger->psy_chg.set_property	= sec_chg_set_property;
+	charger->psy_chg.properties		= sec_charger_props;
+	charger->psy_chg.num_properties	= ARRAY_SIZE(sec_charger_props);
+	charger->psy_otg.name			= "otg";
+	charger->psy_otg.type			= POWER_SUPPLY_TYPE_OTG;
+	charger->psy_otg.get_property	= sm5703_otg_get_property;
+	charger->psy_otg.set_property	= sm5703_otg_set_property;
+	charger->psy_otg.properties		= sm5703_otg_props;
+	charger->psy_otg.num_properties	= ARRAY_SIZE(sm5703_otg_props);
+
+	charger->ovp = 0;
+	charger->is_mdock = false;
+	sm5703_chg_init(charger);
+
+	charger->wq = create_workqueue("sm5703chg_workqueue");
+	wake_lock_init(&charger->aicl_wake_lock, WAKE_LOCK_SUSPEND, "sm5703-aicl");
+#if EN_AICL_IRQ
+	INIT_DELAYED_WORK(&charger->aicl_work, sm5703_chg_aicl_work);
+#endif
+	ret = power_supply_register(&pdev->dev, &charger->psy_chg);
+	if (ret) {
+		pr_err("%s: Failed to Register psy_chg\n", __func__);
+		goto err_power_supply_register;
+	}
+
+	ret = power_supply_register(&pdev->dev, &charger->psy_otg);
+	if (ret) {
+		pr_err("%s: Failed to Register otg_chg\n", __func__);
+		goto err_power_supply_register_otg;
+	}
+
+	ret = register_irq(pdev, charger);
+	if (ret < 0)
+		goto err_reg_irq;
+
+	ret = gpio_request(charger->pdata->chgen_gpio, "sm5703_nCHGEN");
+	if (ret) {
+		pr_info("%s : Request GPIO %d failed\n",
+				__func__, (int)charger->pdata->chgen_gpio);
+	}
+
+	sm5703_test_read(charger->i2c);
+	pr_info("%s:[BATT] SM5703 charger driver loaded OK\n", __func__);
+
+	return 0;
+err_reg_irq:
+	power_supply_unregister(&charger->psy_otg);
+err_power_supply_register_otg:
+	power_supply_unregister(&charger->psy_chg);
+err_power_supply_register:
+	destroy_workqueue(charger->wq);
+	wake_lock_destroy(&charger->aicl_wake_lock);
+err_parse_dt:
+err_parse_dt_nomem:
+	mutex_destroy(&charger->io_lock);
+	kfree(charger);
+	return ret;
+}
+
+static int sm5703_charger_remove(struct platform_device *pdev)
+{
+	struct sm5703_charger_data *charger =
+		platform_get_drvdata(pdev);
+	unregister_irq(pdev, charger);
+	power_supply_unregister(&charger->psy_chg);
+	destroy_workqueue(charger->wq);
+	wake_lock_destroy(&charger->aicl_wake_lock);
+	mutex_destroy(&charger->io_lock);
+	kfree(charger);
+	return 0;
+}
+
+#if defined CONFIG_PM
+static int sm5703_charger_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int sm5703_charger_resume(struct device *dev)
+{
+	return 0;
+}
+#else
+#define sm5703_charger_suspend NULL
+#define sm5703_charger_resume NULL
+#endif
+
+static void sm5703_charger_shutdown(struct device *dev)
+{
+	pr_info("%s: SM5703 Charger driver shutdown\n", __func__);
+}
+
+static SIMPLE_DEV_PM_OPS(sm5703_charger_pm_ops, sm5703_charger_suspend,
+		sm5703_charger_resume);
+
+static struct platform_driver sm5703_charger_driver = {
+	.driver		= {
+		.name	= "sm5703-charger",
+		.owner	= THIS_MODULE,
+		.of_match_table = sm5703_charger_match_table,
+		.pm		= &sm5703_charger_pm_ops,
+		.shutdown = sm5703_charger_shutdown,
+	},
+	.probe		= sm5703_charger_probe,
+	.remove		= sm5703_charger_remove,
+};
+
+static int __init sm5703_charger_init(void)
+{
+	int ret = 0;
+
+	pr_info("%s \n", __func__);
+	ret = platform_driver_register(&sm5703_charger_driver);
+
+	return ret;
+}
+device_initcall(sm5703_charger_init);
+
+static void __exit sm5703_charger_exit(void)
+{
+	platform_driver_unregister(&sm5703_charger_driver);
+}
+module_exit(sm5703_charger_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Charger driver for SM5703");
diff -Naur linux-3.18.14/drivers/battery/sm5703_fuelgauge.c samsung/drivers/battery/sm5703_fuelgauge.c
--- linux-3.18.14/drivers/battery/sm5703_fuelgauge.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery/sm5703_fuelgauge.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,1955 @@
+/* drivers/battery/sm5703_fuelgauge.c
+ * SM5703 Voltage Tracking Fuelgauge Driver
+ *
+ * Copyright (C) 2013
+ * Author: Dongik Sin <dongik.sin@samsung.com>
+ * Modified by SW Jung
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ */
+#include <linux/battery/fuelgauge/sm5703_fuelgauge.h>
+#include <linux/battery/fuelgauge/sm5703_fuelgauge_impl.h>
+#if defined(CONFIG_STMP_SUPPORT_FG_ALERT)
+#include <linux/input/stmpe1801_key.h>
+#endif
+#include <linux/uaccess.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/fs.h>
+#include <linux/math64.h>
+#include <linux/compiler.h>
+
+#define FG_DET_BAT_PRESENT 1
+
+#define MINVAL(a, b) ((a <= b) ? a : b)
+
+static void sm5703_fuelgauge_fuelalert_init(struct sm5703_fuelgauge_data *fuelgauge,
+		int soc);
+
+static void fg_vbatocv_check(struct i2c_client *client);
+
+enum battery_table_type {
+	DISCHARGE_TABLE = 0,
+	CHARGE_TABLE,
+	Q_TABLE,
+	TABLE_MAX,
+};
+
+static enum power_supply_property sm5703_fuelgauge_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_VOLTAGE_AVG,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CURRENT_AVG,
+	POWER_SUPPLY_PROP_CHARGE_FULL,
+	POWER_SUPPLY_PROP_ENERGY_NOW,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_TEMP_AMBIENT,
+	POWER_SUPPLY_PROP_CAPACITY_LEVEL,
+};
+
+static bool sm5703_fg_reg_init(struct sm5703_fuelgauge_data *fuelgauge,
+                int manual_ocv_write);
+
+static inline int sm5703_fg_read_device(struct i2c_client *client,
+		int reg, int bytes, void *dest)
+{
+	int ret;
+
+	if (bytes > 1)
+		ret = i2c_smbus_read_i2c_block_data(client, reg, bytes, dest);
+	else {
+		ret = i2c_smbus_read_byte_data(client, reg);
+		if (ret < 0)
+			return ret;
+		*(unsigned char *)dest = (unsigned char)ret;
+	}
+	return ret;
+}
+
+static int32_t sm5703_fg_i2c_read_word(struct i2c_client *client,
+		uint8_t reg_addr)
+{
+	uint16_t data = 0;
+	int ret;
+	ret = sm5703_fg_read_device(client, reg_addr, 2, &data);
+	/* dev_dbg(&client->dev, "%s: ret = %d, addr = 0x%x, data = 0x%x\n",
+			__func__, ret, reg_addr, data); */
+
+	if (ret < 0)
+		return ret;
+	else
+		return data;
+
+	/* not use big endian */
+	/* return (int32_t)be16_to_cpu(data); */
+}
+
+static int32_t sm5703_fg_i2c_write_word(struct i2c_client *client,
+		uint8_t reg_addr,uint16_t data)
+{
+	int ret;
+
+	/* not use big endian */
+	/* data = cpu_to_be16(data); */
+	ret = i2c_smbus_write_i2c_block_data(client, reg_addr,
+		2, (uint8_t *)&data);
+
+	/* dev_dbg(&client->dev, "%s: ret = %d, addr = 0x%x, data = 0x%x\n",
+			__func__, ret, reg_addr, data);
+	*/
+
+	return ret;
+}
+
+#if 0
+static void sm5703_pr_ver_info(struct i2c_client *client)
+{
+	dev_info(&client->dev, "SM5703 Fuel-Gauge Ver %s\n", FG_DRIVER_VER);
+}
+#endif
+
+static void sm5703_fg_test_read(struct i2c_client *client)
+{
+	int ret, ret1, ret2, ret3, ret4;
+
+	ret = sm5703_fg_i2c_read_word(client, SM5703_REG_CNTL);
+	dev_info(&client->dev, "%s: sm5703 FG 0x01 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(client, 0x30);
+	dev_info(&client->dev, "%s: sm5703 FG 0x30 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(client, 0x31);
+	dev_info(&client->dev, "%s: sm5703 FG 0x31 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(client, 0x32);
+	dev_info(&client->dev, "%s: sm5703 FG 0x32 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(client, 0x33);
+	dev_info(&client->dev, "%s: sm5703 FG 0x33 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(client, 0x34);
+	dev_info(&client->dev, "%s: sm5703 FG 0x34 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(client, 0x35);
+	dev_info(&client->dev, "%s: sm5703 FG 0x35 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(client, 0x36);
+	dev_info(&client->dev, "%s: sm5703 FG 0x36 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(client, 0x37);
+	dev_info(&client->dev, "%s: sm5703 FG 0x37 = 0x%x \n", __func__, ret);
+
+	ret = sm5703_fg_i2c_read_word(client, 0x40);
+	dev_info(&client->dev, "%s: sm5703 FG 0x40 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(client, 0x41);
+	dev_info(&client->dev, "%s: sm5703 FG 0x41 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(client, 0x42);
+	dev_info(&client->dev, "%s: sm5703 FG 0x42 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(client, 0x43);
+	dev_info(&client->dev, "%s: sm5703 FG 0x43 = 0x%x \n", __func__, ret);
+
+	ret1 = sm5703_fg_i2c_read_word(client, 0xAC);
+	ret2 = sm5703_fg_i2c_read_word(client, 0xAD);
+	ret3 = sm5703_fg_i2c_read_word(client, 0xAE);
+	ret4 = sm5703_fg_i2c_read_word(client, 0xAF);
+	pr_info("0xAC=0x%04x, 0xAD=0x%04x, 0xAE=0x%04x, 0xAF=0x%04x \n", ret1, ret2, ret3, ret4);
+
+	ret1 = sm5703_fg_i2c_read_word(client, 0xBC);
+	ret2 = sm5703_fg_i2c_read_word(client, 0xBD);
+	ret3 = sm5703_fg_i2c_read_word(client, 0xBE);
+	ret4 = sm5703_fg_i2c_read_word(client, 0xBF);
+	pr_info("0xBC=0x%04x, 0xBD=0x%04x, 0xBE=0x%04x, 0xBF=0x%04x \n", ret1, ret2, ret3, ret4);
+
+	ret1 = sm5703_fg_i2c_read_word(client, 0xCC);
+	ret2 = sm5703_fg_i2c_read_word(client, 0xCD);
+	ret3 = sm5703_fg_i2c_read_word(client, 0xCE);
+	ret4 = sm5703_fg_i2c_read_word(client, 0xCF);
+	pr_info("0xCC=0x%04x, 0xCD=0x%04x, 0xCE=0x%04x, 0xCF=0x%04x \n", ret1, ret2, ret3, ret4);
+
+	ret1 = sm5703_fg_i2c_read_word(client, 0x85);
+	ret2 = sm5703_fg_i2c_read_word(client, 0x86);
+	ret3 = sm5703_fg_i2c_read_word(client, 0x87);
+	ret4 = sm5703_fg_i2c_read_word(client, 0x28);
+	pr_info("0x85=0x%04x, 0x86=0x%04x, 0x87=0x%04x, 0x28=0x%04x \n", ret1, ret2, ret3, ret4);
+}
+
+static int sm5703_get_temperature(struct sm5703_fuelgauge_data *fuelgauge)
+{
+	int ret;
+
+	int temp;/* = 250; 250 means 25.0oC*/
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, SM5703_REG_TEMPERATURE);
+	if (ret<0) {
+		pr_err("%s: read temp reg fail", __func__);
+		temp = 0;
+	} else {
+		/* integer bit */
+		temp = ((ret & 0x7F00) >> 8) * 10;
+		/* integer + fractional bit */
+		temp = temp + (((ret & 0x00ff) * 10) / 256);
+		if (ret & 0x8000) {
+			temp *= -1;
+		}
+	}
+	fuelgauge->info.temperature = temp;
+
+	dev_info(&fuelgauge->i2c->dev,
+		"%s: read = 0x%x, temperature = %d\n", __func__, ret, temp);
+
+	return temp;
+}
+
+static unsigned int sm5703_get_ocv(struct sm5703_fuelgauge_data *fuelgauge)
+{
+	int ret;
+	unsigned int ocv;/* = 3500; 3500 means 3500mV */
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, SM5703_REG_OCV);
+	if (ret<0) {
+		pr_err("%s: read ocv reg fail\n", __func__);
+		ocv = 4000;
+	} else {
+		/* integer bit */
+		ocv = ((ret&0x0700)>>8) * 1000;
+		/* integer + fractional bit */
+		ocv = ocv + (((ret&0x00ff)*1000)/256);
+	}
+
+	fuelgauge->info.batt_ocv = ocv;
+
+	dev_info(&fuelgauge->i2c->dev, "%s: read = 0x%x, ocv = %d\n", __func__, ret, ocv);
+
+	return ocv;
+}
+
+static u32 sm5703_get_soc(struct sm5703_fuelgauge_data *fuelgauge)
+{
+	int ret;
+	u32 soc;
+	int ta_exist;
+	int curr_cal;
+	int temp_cal_fact;
+	union power_supply_propval value;
+
+	fg_vbatocv_check(fuelgauge->i2c);
+
+	ta_exist = fuelgauge->is_charging && (fuelgauge->info.batt_current >= 0);
+
+	dev_dbg(&fuelgauge->i2c->dev, "%s: is_charging = %d, ta_exist = %d\n", __func__, fuelgauge->is_charging, ta_exist);
+
+	if(ta_exist)
+		curr_cal = fuelgauge->info.curr_cal + (fuelgauge->info.charge_offset_cal << 8);
+	else
+		curr_cal = fuelgauge->info.curr_cal;
+	dev_dbg(&fuelgauge->i2c->dev, "%s: curr_cal = 0x%x\n", __func__, curr_cal);
+
+	/* abnormal case.... SW reset */
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, SM5703_REG_FG_OP_STATUS);
+	if ((ret & 0x00FF) != DISABLE_RE_INIT) {
+		ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, SM5703_REG_CNTL);
+		pr_info( "%s: SM5703 FG abnormal case!!!! SM5703_REG_CNTL : 0x%x\n", __func__, ret);
+		if (ret == 0x2008) {
+			pr_info( "%s: SM5703 FG abnormal case.... SW reset\n", __func__);
+			/* SW reset code */
+			sm5703_fg_i2c_write_word(fuelgauge->i2c, 0x90, 0x0008);
+			/* delay 200ms */
+			msleep(200);
+			/* init code */
+			sm5703_fg_reg_init(fuelgauge, 1);
+		}
+	}
+
+	sm5703_get_temperature(fuelgauge);
+	sm5703_get_ocv(fuelgauge);
+	temp_cal_fact = fuelgauge->info.temp_std - (fuelgauge->info.temperature / 10);
+	temp_cal_fact = temp_cal_fact / fuelgauge->info.temp_offset;
+	temp_cal_fact = temp_cal_fact * fuelgauge->info.temp_offset_cal;
+	curr_cal = curr_cal + (temp_cal_fact << 8);
+
+	/* compensate soc in case of low bat_temp */
+	psy_do_property("battery", get, POWER_SUPPLY_PROP_TEMP, value);
+	if ((value.intval / 10) < 25) {
+		curr_cal = curr_cal + ((((25 - (value.intval / 10)) / 6) * 3) << 8);
+	}
+
+	dev_info(&fuelgauge->i2c->dev, "%s: fg_get_soc : temp_std = %d, temperature = %d, temp_offset = %d, temp_offset_cal = 0x%x, curr_cal = 0x%x, bat_temp = %d\n",
+		__func__, fuelgauge->info.temp_std, fuelgauge->info.temperature, fuelgauge->info.temp_offset, fuelgauge->info.temp_offset_cal, curr_cal, value.intval);
+
+	sm5703_fg_i2c_write_word(fuelgauge->i2c, SM5703_REG_CURR_CAL, curr_cal);
+
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, SM5703_REG_SOC);
+	if (ret < 0) {
+		pr_err("%s: read soc reg fail\n", __func__);
+		soc = 500;
+	} else {
+		/* integer bit */
+		soc = ((ret & 0xff00) >> 8) * 10;
+		/* integer + fractional bit */
+		soc = soc + (((ret & 0x00ff) * 10) / 256);
+	}
+
+	fuelgauge->info.batt_soc = soc;
+
+	dev_info(&fuelgauge->i2c->dev, "%s: read = 0x%x, soc = %d\n", __func__, ret, soc);
+
+	/* temp for SM5703 FG debug */
+	sm5703_fg_test_read(fuelgauge->i2c);
+
+	return soc;
+}
+
+static unsigned int sm5703_get_vbat(struct sm5703_fuelgauge_data *fuelgauge)
+{
+	int ret;
+
+	unsigned int vbat;/* = 3500; 3500 means 3500mV*/
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, SM5703_REG_VOLTAGE);
+	if (ret < 0) {
+		pr_err("%s: read vbat reg fail", __func__);
+		vbat = 4000;
+	} else {
+		/* integer bit */
+		vbat = ((ret & 0x0700) >> 8) * 1000;
+		/* integer + fractional bit */
+		vbat = vbat + (((ret&0x00ff) * 1000) / 256);
+	}
+
+	fuelgauge->info.batt_voltage = vbat;
+
+	if ((fuelgauge->force_dec_mode == SM5703_COLD_MODE) && vbat > 3400) {
+		fuelgauge->force_dec_mode = SM5703_RECOVERY_MODE;
+		wake_unlock(&fuelgauge->fuel_alert_wake_lock);
+		sm5703_fuelgauge_fuelalert_init(fuelgauge,
+				fuelgauge->pdata->fuel_alert_soc);
+		pr_info("%s : COLD MODE DISABLE\n", __func__);
+	}
+
+	dev_dbg(&fuelgauge->i2c->dev, "%s: read = 0x%x, vbat = %d\n", __func__, ret, vbat);
+
+	return vbat;
+}
+
+static unsigned int sm5703_get_avgvbat(struct sm5703_fuelgauge_data *fuelgauge)
+{
+	int ret, cnt;
+	u32 vbat; /* = 3500; 3500 means 3500mV*/
+	u32 old_vbat = 0;
+
+	for (cnt = 0; cnt < 5; cnt++) {
+		ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, SM5703_REG_VOLTAGE);
+		if (ret < 0) {
+			pr_err("%s: read vbat reg fail", __func__);
+			vbat = 4000;
+		} else {
+			/* integer bit */
+			vbat = ((ret & 0x0700) >> 8) * 1000;
+			/* integer + fractional bit */
+			vbat = vbat + (((ret&0x00ff) * 1000) / 256);
+		}
+
+		if (cnt == 0)
+			old_vbat = vbat;
+		else
+			old_vbat = vbat / 2 + old_vbat / 2;
+	}
+
+	fuelgauge->info.batt_avgvoltage = old_vbat;
+	dev_dbg(&fuelgauge->i2c->dev, "%s: batt_avgvoltage = %d\n",
+			__func__, fuelgauge->info.batt_avgvoltage);
+
+	return old_vbat;
+}
+
+static int sm5703_get_curr(struct sm5703_fuelgauge_data *fuelgauge)
+{
+	int ret;
+	int curr;/* = 1000; 1000 means 1000mA*/
+
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, SM5703_REG_CURRENT);
+	if (ret<0) {
+		pr_err("%s: read curr reg fail", __func__);
+		curr = 0;
+	} else {
+		/* integer bit */
+		curr = ((ret&0x0700) >> 8) * 1000;
+		/* integer + fractional bit */
+		curr = curr + (((ret & 0x00ff) * 1000) / 256);
+		if(ret & 0x8000) {
+			curr *= -1;
+		}
+	}
+
+	fuelgauge->info.batt_current = curr;
+	dev_dbg(&fuelgauge->i2c->dev, "%s: read = 0x%x, curr = %d\n",
+		__func__, ret, curr);
+
+	return curr;
+}
+
+static int sm5703_get_avgcurr(struct sm5703_fuelgauge_data *fuelgauge)
+{
+	int ret, cnt;
+	int curr;/* = 1000; 1000 means 1000mA*/
+	int old_curr = 0;
+
+	for (cnt = 0; cnt < 5; cnt++) {
+		ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, SM5703_REG_CURRENT);
+		if (ret < 0) {
+			pr_err("%s: read curr reg fail", __func__);
+			curr = 0;
+		} else {
+			/* integer bit */
+			curr = ((ret&0x0700) >> 8) * 1000;
+			/* integer + fractional bit */
+			curr = curr + (((ret & 0x00ff) * 1000) / 256);
+			if(ret & 0x8000) {
+				curr *= -1;
+			}
+		}
+
+		if (cnt == 0)
+			old_curr = curr;
+		else
+			old_curr = curr / 2 + old_curr / 2;
+	}
+
+	fuelgauge->info.batt_avgcurrent = old_curr;
+	dev_dbg(&fuelgauge->i2c->dev, "%s: batt_avgcurrent = %d\n",
+		__func__, fuelgauge->info.batt_avgcurrent);
+
+	return old_curr;
+}
+
+
+static unsigned int sm5703_get_device_id(struct i2c_client *client)
+{
+	int ret;
+	ret = sm5703_fg_i2c_read_word(client, SM5703_REG_DEVICE_ID);
+	/* ret &= 0x00ff; */
+
+	dev_info(&client->dev, "%s: device_id = 0x%x\n", __func__, ret);
+
+	return ret;
+}
+
+static bool sm5703_fg_check_reg_init_need(struct i2c_client *client)
+{
+	int ret;
+
+	ret = sm5703_fg_i2c_read_word(client, SM5703_REG_FG_OP_STATUS);
+
+	if((ret & 0x00FF) == DISABLE_RE_INIT) {
+		dev_dbg(&client->dev, "%s: return 0\n", __func__);
+		return 0;
+	} else {
+		dev_dbg(&client->dev, "%s: return 1\n", __func__);
+		return 1;
+	}
+}
+
+static int calculate_iocv(struct i2c_client *client)
+{
+	int i;
+	int max=0, min=0, sum=0, l_avg=0, s_avg=0, l_minmax_offset=0;
+	int ret=0;
+
+	for (i = SM5703_REG_IOCV_B_L_MIN; i <= SM5703_REG_IOCV_B_L_MAX; i++) {
+		ret = sm5703_fg_i2c_read_word(client, i);
+		if (i == SM5703_REG_IOCV_B_L_MIN) {
+			max = ret;
+			min = ret;
+			sum = ret;
+		} else {
+			if(ret > max)
+				max = ret;
+			else if(ret < min)
+				min = ret;
+			sum = sum + ret;
+		}
+	}
+	sum = sum - max - min;
+	l_minmax_offset = max - min;
+	l_avg = sum / (SM5703_REG_IOCV_B_L_MAX-SM5703_REG_IOCV_B_L_MIN-1);
+	dev_info(&client->dev,
+		"%s: iocv_l_max=0x%x, iocv_l_min=0x%x, iocv_l_sum=0x%x, iocv_l_avg=0x%x \n",
+		__func__, max, min, sum, l_avg);
+
+	ret = sm5703_fg_i2c_read_word(client, SM5703_REG_END_V_IDX);
+	pr_info("%s: iocv_status_read = addr : 0x%x , data : 0x%x\n",
+		__func__, SM5703_REG_END_V_IDX, ret);
+
+	if ((ret & 0x0030) == 0x0030) {
+		for (i = SM5703_REG_IOCV_B_S_MIN; i <= SM5703_REG_IOCV_B_S_MAX; i++) {
+			ret = sm5703_fg_i2c_read_word(client, i);
+			if (i == SM5703_REG_IOCV_B_S_MIN) {
+				max = ret;
+				min = ret;
+				sum = ret;
+			} else {
+				if(ret > max)
+					max = ret;
+				else if(ret < min)
+					min = ret;
+				sum = sum + ret;
+			}
+		}
+		sum = sum - max - min;
+		s_avg = sum / (SM5703_REG_IOCV_B_S_MAX-SM5703_REG_IOCV_B_S_MIN-1);
+		dev_info(&client->dev,
+			"%s: iocv_s_max=0x%x, iocv_s_min=0x%x, iocv_s_sum=0x%x, iocv_s_avg=0x%x \n",
+			__func__, max, min, sum, s_avg);
+	}
+
+	if (((abs(l_avg - s_avg) > 0x29) && (l_minmax_offset < 0xCC)) || (s_avg == 0)){
+		ret = l_avg;
+	} else {
+		ret = s_avg;
+	}
+
+	return ret;
+}
+
+static void fg_vbatocv_check(struct i2c_client *client)
+{
+	int ret;
+	int ta_exist;
+	union power_supply_propval value;
+	struct sm5703_fuelgauge_data *fuelgauge = i2c_get_clientdata(client);
+
+	ta_exist = fuelgauge->is_charging && (fuelgauge->info.batt_current >= 0);
+
+	/* iocv error case cover start */
+	if ((abs(fuelgauge->info.batt_current) < 40) ||
+		((ta_exist) &&
+		(abs(fuelgauge->info.batt_current) < 100))) {
+		/* 30mV over */
+		if(abs(fuelgauge->info.batt_ocv-fuelgauge->info.batt_voltage) > 30) {
+			fuelgauge->info.iocv_error_count ++;
+		}
+		if(fuelgauge->info.iocv_error_count > 5) /* prevent to overflow */
+			fuelgauge->info.iocv_error_count = 6;
+	} else {
+		fuelgauge->info.iocv_error_count = 0;
+	}
+
+	dev_info(&client->dev, "%s: iocv_error_count (%d)\n",
+		__func__, fuelgauge->info.iocv_error_count);
+
+	if (fuelgauge->info.iocv_error_count > 5) {
+		dev_info(&client->dev,
+			"%s: p_v - v = (%d)\n", __func__,
+			fuelgauge->info.p_batt_voltage - fuelgauge->info.batt_voltage);
+
+		if (abs(fuelgauge->info.p_batt_voltage - fuelgauge->info.batt_voltage)>15) { /* 15mV over */
+			fuelgauge->info.iocv_error_count = 0;
+		} else {
+			/* mode change to mix RS manual mode */
+			dev_info(&client->dev, "%s: mode change to mix RS manual mode\n", __func__);
+			/* RS manual value write */
+			sm5703_fg_i2c_write_word(client, SM5703_REG_RS_MAN, fuelgauge->info.rs_value[0]);
+			/* run update */
+			sm5703_fg_i2c_write_word(client, SM5703_REG_PARAM_RUN_UPDATE, 0);
+			sm5703_fg_i2c_write_word(client, SM5703_REG_PARAM_RUN_UPDATE, 1);
+			/* mode change */
+			ret = sm5703_fg_i2c_read_word(client, SM5703_REG_CNTL);
+			ret = (ret | ENABLE_MIX_MODE) | ENABLE_RS_MAN_MODE; /* +RS_MAN_MODE */
+			sm5703_fg_i2c_write_word(client, SM5703_REG_CNTL, ret);
+		}
+	} else {
+		psy_do_property("battery", get,	POWER_SUPPLY_PROP_TEMP, value);
+		if((value.intval / 10) > 15)
+		{
+			if((fuelgauge->info.p_batt_voltage < fuelgauge->info.n_tem_poff) &&
+				(fuelgauge->info.batt_voltage < fuelgauge->info.n_tem_poff) &&
+				(!ta_exist)) {
+				dev_info(&client->dev,
+					"%s: mode change to normal tem mix RS manual mode\n", __func__);
+				/* mode change to mix RS manual mode */
+				/* RS manual value write */
+				if((fuelgauge->info.p_batt_voltage < (fuelgauge->info.n_tem_poff - fuelgauge->info.n_tem_poff_offset)) &&
+					(fuelgauge->info.batt_voltage < (fuelgauge->info.n_tem_poff - fuelgauge->info.n_tem_poff_offset))) {
+					sm5703_fg_i2c_write_word(client, SM5703_REG_RS_MAN, fuelgauge->info.rs_value[0]>>1);
+				} else {
+					sm5703_fg_i2c_write_word(client, SM5703_REG_RS_MAN, fuelgauge->info.rs_value[0]);
+				}
+				/* run update*/
+				sm5703_fg_i2c_write_word(client, SM5703_REG_PARAM_RUN_UPDATE, 0);
+				sm5703_fg_i2c_write_word(client, SM5703_REG_PARAM_RUN_UPDATE, 1);
+
+				/* mode change */
+				ret = sm5703_fg_i2c_read_word(client, SM5703_REG_CNTL);
+				ret = (ret | ENABLE_MIX_MODE) | ENABLE_RS_MAN_MODE; // +RS_MAN_MODE
+				sm5703_fg_i2c_write_word(client, SM5703_REG_CNTL, ret);
+			} else {
+				dev_info(&client->dev, "%s: mode change to mix RS auto mode\n", __func__);
+
+				/* mode change to mix RS auto mode */
+				ret = sm5703_fg_i2c_read_word(client, SM5703_REG_CNTL);
+				ret = (ret | ENABLE_MIX_MODE) & ~ENABLE_RS_MAN_MODE; // -RS_MAN_MODE
+				sm5703_fg_i2c_write_word(client, SM5703_REG_CNTL, ret);
+			}
+		} else {
+			if((fuelgauge->info.p_batt_voltage < fuelgauge->info.l_tem_poff) &&
+				(fuelgauge->info.batt_voltage < fuelgauge->info.l_tem_poff) &&
+				(!ta_exist)) {
+				dev_info(&client->dev,
+				"%s: mode change to normal tem mix RS manual mode\n", __func__);
+				/* mode change to mix RS manual mode */
+				/* RS manual value write */
+				if((fuelgauge->info.p_batt_voltage < (fuelgauge->info.l_tem_poff - fuelgauge->info.l_tem_poff_offset)) &&
+					(fuelgauge->info.batt_voltage < (fuelgauge->info.l_tem_poff - fuelgauge->info.l_tem_poff_offset))) {
+					sm5703_fg_i2c_write_word(client, SM5703_REG_RS_MAN, fuelgauge->info.rs_value[0]>>1);
+				} else {
+					sm5703_fg_i2c_write_word(client, SM5703_REG_RS_MAN, fuelgauge->info.rs_value[0]);
+				}
+				/* run update */
+				sm5703_fg_i2c_write_word(client, SM5703_REG_PARAM_RUN_UPDATE, 0);
+				sm5703_fg_i2c_write_word(client, SM5703_REG_PARAM_RUN_UPDATE, 1);
+
+				/* mode change */
+				ret = sm5703_fg_i2c_read_word(client, SM5703_REG_CNTL);
+				ret = (ret | ENABLE_MIX_MODE) | ENABLE_RS_MAN_MODE; /* +RS_MAN_MODE */
+				sm5703_fg_i2c_write_word(client, SM5703_REG_CNTL, ret);
+			} else {
+				dev_info(&client->dev, "%s: mode change to mix RS auto mode\n", __func__);
+
+				/* mode change to mix RS auto mode */
+				ret = sm5703_fg_i2c_read_word(client, SM5703_REG_CNTL);
+				ret = (ret | ENABLE_MIX_MODE) & ~ENABLE_RS_MAN_MODE; /* -RS_MAN_MODE */
+				sm5703_fg_i2c_write_word(client, SM5703_REG_CNTL, ret);
+			}
+		}
+	}
+	fuelgauge->info.p_batt_voltage = fuelgauge->info.batt_voltage;
+	fuelgauge->info.p_batt_current = fuelgauge->info.batt_current;
+	/* iocv error case cover end */
+}
+
+/* capacity is  0.1% unit */
+static void sm5703_fg_get_scaled_capacity(
+	struct sm5703_fuelgauge_data *fuelgauge,
+	union power_supply_propval *val)
+{
+	val->intval = (val->intval < fuelgauge->pdata->capacity_min) ?
+		0 : ((val->intval - fuelgauge->pdata->capacity_min) * 1000 /
+		(fuelgauge->capacity_max - fuelgauge->pdata->capacity_min));
+
+	dev_dbg(&fuelgauge->i2c->dev,
+			"%s: scaled capacity (%d.%d)\n",
+			__func__, val->intval/10, val->intval%10);
+}
+
+/* capacity is integer */
+static void sm5703_fg_get_atomic_capacity(
+	struct sm5703_fuelgauge_data *fuelgauge,
+	union power_supply_propval *val)
+{
+	if (fuelgauge->pdata->capacity_calculation_type &
+			SEC_FUELGAUGE_CAPACITY_TYPE_ATOMIC) {
+		if (fuelgauge->capacity_old < val->intval)
+			val->intval = fuelgauge->capacity_old + 1;
+		else if (fuelgauge->capacity_old > val->intval)
+			val->intval = fuelgauge->capacity_old - 1;
+	}
+
+	/* keep SOC stable in abnormal status */
+	if (fuelgauge->pdata->capacity_calculation_type &
+			SEC_FUELGAUGE_CAPACITY_TYPE_SKIP_ABNORMAL) {
+		if (!fuelgauge->is_charging &&
+				fuelgauge->capacity_old < val->intval) {
+			dev_err(&fuelgauge->i2c->dev,
+					"%s: capacity (old %d : new %d)\n",
+					__func__, fuelgauge->capacity_old, val->intval);
+			val->intval = fuelgauge->capacity_old;
+		}
+	}
+
+	/* updated old capacity */
+	fuelgauge->capacity_old = val->intval;
+}
+
+static int sm5703_fg_check_capacity_max(
+		struct sm5703_fuelgauge_data *fuelgauge, int capacity_max)
+{
+	int new_capacity_max = capacity_max;
+
+	if (new_capacity_max < (fuelgauge->pdata->capacity_max -
+				fuelgauge->pdata->capacity_max_margin - 10)) {
+		new_capacity_max =
+			(fuelgauge->pdata->capacity_max -
+			 fuelgauge->pdata->capacity_max_margin);
+
+		dev_info(&fuelgauge->i2c->dev, "%s: set capacity max(%d --> %d)\n",
+				__func__, capacity_max, new_capacity_max);
+	} else if (new_capacity_max > (fuelgauge->pdata->capacity_max +
+				fuelgauge->pdata->capacity_max_margin)) {
+		new_capacity_max =
+			(fuelgauge->pdata->capacity_max +
+			 fuelgauge->pdata->capacity_max_margin);
+
+		dev_info(&fuelgauge->i2c->dev, "%s: set capacity max(%d --> %d)\n",
+				__func__, capacity_max, new_capacity_max);
+	}
+
+	return new_capacity_max;
+}
+
+static int sm5703_fg_calculate_dynamic_scale(
+		struct sm5703_fuelgauge_data *fuelgauge, int capacity)
+{
+	union power_supply_propval raw_soc_val;
+	raw_soc_val.intval = sm5703_get_soc(fuelgauge);
+
+	if (raw_soc_val.intval <
+			fuelgauge->pdata->capacity_max -
+			fuelgauge->pdata->capacity_max_margin) {
+		fuelgauge->capacity_max =
+			fuelgauge->pdata->capacity_max -
+			fuelgauge->pdata->capacity_max_margin;
+		pr_info("%s: capacity_max (%d)", __func__,
+				fuelgauge->capacity_max);
+	} else {
+		fuelgauge->capacity_max =
+			(raw_soc_val.intval >
+			 fuelgauge->pdata->capacity_max +
+			 fuelgauge->pdata->capacity_max_margin) ?
+			(fuelgauge->pdata->capacity_max +
+			 fuelgauge->pdata->capacity_max_margin) :
+			raw_soc_val.intval;
+		pr_info("%s: raw soc (%d)", __func__,
+				fuelgauge->capacity_max);
+	}
+
+	if (capacity != 100) {
+		fuelgauge->capacity_max = sm5703_fg_check_capacity_max(
+			fuelgauge, (fuelgauge->capacity_max * 100 / (capacity + 1)));
+		fuelgauge->capacity_old = capacity;
+	} else {
+		fuelgauge->capacity_max =
+			(fuelgauge->capacity_max * 99 / 100);
+
+		sm5703_fg_get_scaled_capacity(fuelgauge, &raw_soc_val);
+		fuelgauge->capacity_old = min((raw_soc_val.intval / 10), 100);
+	}
+
+	pr_info("%s: %d is used for capacity_max, capacity(%d)\n",
+			__func__, fuelgauge->capacity_max, capacity);
+
+	return fuelgauge->capacity_max;
+}
+
+static void sm5703_fuelgauge_fuelalert_init(struct sm5703_fuelgauge_data *fuelgauge,
+		int soc)
+{
+	int ret;
+
+	dev_dbg(&fuelgauge->i2c->dev, "%s: sec_hal_fg_fuelalert_init\n", __func__);
+
+	/* remove interrupt */
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, SM5703_REG_INTFG);
+
+	/* check status ? need add action */
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, SM5703_REG_STATUS);
+
+	/* remove all mask */
+	sm5703_fg_i2c_write_word(fuelgauge->i2c, SM5703_REG_INTFG_MASK, 0);
+
+	/* set volt and soc alert threshold */
+	ret = 0x0320; /* 3125mV */
+	sm5703_fg_i2c_write_word(fuelgauge->i2c, SM5703_REG_V_ALARM, ret);
+
+	ret = soc << 8;
+	sm5703_fg_i2c_write_word(fuelgauge->i2c, SM5703_REG_SOC_ALARM, ret);
+
+	/* update parameters */
+	sm5703_fg_i2c_write_word(fuelgauge->i2c, SM5703_REG_PARAM_RUN_UPDATE, 0);
+	sm5703_fg_i2c_write_word(fuelgauge->i2c, SM5703_REG_PARAM_RUN_UPDATE, 1);
+
+	/* enable low soc, low voltage alert */
+	fuelgauge->info.irq_ctrl = ENABLE_L_SOC_INT | ENABLE_L_VOL_INT;
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, SM5703_REG_CNTL);
+	ret = (ret & 0xFFF0) | fuelgauge->info.irq_ctrl;
+	sm5703_fg_i2c_write_word(fuelgauge->i2c, SM5703_REG_CNTL, ret);
+
+	/* reset soc alert flag */
+	fuelgauge->info.soc_alert_flag = false;
+	fuelgauge->is_fuel_alerted = false;
+
+	return;
+}
+
+#ifdef ENABLE_BATT_LONG_LIFE
+int get_v_max_index_by_cycle(struct sm5703_fuelgauge_data *fuelgauge)
+{
+	int cycle_index=0, len;
+
+	for (len = fuelgauge->pdata->num_age_step-1; len >= 0; --len) {
+		if(fuelgauge->chg_full_soc == fuelgauge->pdata->age_data[len].full_condition_soc) {
+			cycle_index=len;
+			break;
+		}
+	}
+	pr_info("%s: chg_full_soc = %d, index = %d \n", __func__, fuelgauge->chg_full_soc, cycle_index);
+
+	return cycle_index;
+}
+#endif
+
+static bool sm5703_fg_reg_init(struct sm5703_fuelgauge_data *fuelgauge,
+		int manual_ocv_write)
+{
+	int i, j, value, ret;
+	uint8_t table_reg;
+	int write_table[3][16];
+
+	dev_info(&fuelgauge->i2c->dev, "%s: sm5703_fg_reg_init START!!\n", __func__);
+
+	/* start first param_ctrl unlock */
+	sm5703_fg_i2c_write_word(fuelgauge->i2c,
+		SM5703_REG_PARAM_CTRL, SM5703_FG_PARAM_UNLOCK_CODE);
+
+	/* RCE write */
+	for (i = 0; i < 3; i++) {
+		sm5703_fg_i2c_write_word(fuelgauge->i2c,
+			SM5703_REG_RCE0+i, fuelgauge->info.rce_value[i]);
+		dev_dbg(&fuelgauge->i2c->dev,
+			"%s: RCE write RCE%d = 0x%x : 0x%x\n",
+			__func__,
+			i, SM5703_REG_RCE0+i, fuelgauge->info.rce_value[i]);
+	}
+
+	/* DTCD write */
+	sm5703_fg_i2c_write_word(fuelgauge->i2c,
+		SM5703_REG_DTCD, fuelgauge->info.dtcd_value);
+	dev_dbg(&fuelgauge->i2c->dev,
+		"%s: DTCD write DTCD = 0x%x : 0x%x\n",
+		__func__,
+		SM5703_REG_DTCD, fuelgauge->info.dtcd_value);
+
+	/* RS write */
+	sm5703_fg_i2c_write_word(fuelgauge->i2c,
+		SM5703_REG_RS, fuelgauge->info.rs_value[0]);
+	dev_dbg(&fuelgauge->i2c->dev,
+		"%s: RS write RS = 0x%x : 0x%x\n",
+		__func__,
+		SM5703_REG_RS, fuelgauge->info.rs_value[0]);
+
+
+	/* VIT_PERIOD write */
+	sm5703_fg_i2c_write_word(fuelgauge->i2c,
+		SM5703_REG_VIT_PERIOD, fuelgauge->info.vit_period);
+	dev_dbg(&fuelgauge->i2c->dev,
+		"%s: VIT_PERIOD write VIT_PERIOD = 0x%x : 0x%x\n",
+		__func__,
+		SM5703_REG_VIT_PERIOD, fuelgauge->info.vit_period);
+
+	/* TABLE_LEN write & pram unlock */
+	sm5703_fg_i2c_write_word(fuelgauge->i2c,
+		SM5703_REG_PARAM_CTRL,
+		SM5703_FG_PARAM_UNLOCK_CODE | SM5703_FG_TABLE_LEN);
+
+#ifdef ENABLE_BATT_LONG_LIFE
+	i = get_v_max_index_by_cycle(fuelgauge);
+	pr_info("%s: v_max_now is change %x -> %x \n", __func__, fuelgauge->info.v_max_now, fuelgauge->info.v_max_table[i]);
+	pr_info("%s: q_max_now is change %x -> %x \n", __func__, fuelgauge->info.q_max_now, fuelgauge->info.q_max_table[i]);
+	fuelgauge->info.v_max_now = fuelgauge->info.v_max_table[i];
+	fuelgauge->info.q_max_now = fuelgauge->info.q_max_table[i];
+#endif
+
+	for (i=TABLE_MAX-1; i >= 0; i--){
+		for(j=0; j <= SM5703_FG_TABLE_LEN; j++){
+#ifdef ENABLE_BATT_LONG_LIFE
+			if(i == Q_TABLE){
+				write_table[i][j] = fuelgauge->info.battery_table[i][j];
+				if(j == SM5703_FG_TABLE_LEN){
+					write_table[i][SM5703_FG_TABLE_LEN-1] = fuelgauge->info.q_max_now;
+					write_table[i][SM5703_FG_TABLE_LEN] = fuelgauge->info.q_max_now + (fuelgauge->info.q_max_now/1000);
+				}
+			}else{
+				write_table[i][j] = fuelgauge->info.battery_table[i][j];
+				if(j == SM5703_FG_TABLE_LEN-1){
+					write_table[i][SM5703_FG_TABLE_LEN-1] = fuelgauge->info.v_max_now;
+
+					if(write_table[i][SM5703_FG_TABLE_LEN-1] < write_table[i][SM5703_FG_TABLE_LEN-2]){
+						write_table[i][SM5703_FG_TABLE_LEN-2] = write_table[i][SM5703_FG_TABLE_LEN-1] - 0x18; // ~11.7mV
+						write_table[Q_TABLE][SM5703_FG_TABLE_LEN-2] = (write_table[Q_TABLE][SM5703_FG_TABLE_LEN-1]*99)/100;
+					}
+				}
+			}
+#else
+		write_table[i][j] = fuelgauge->info.battery_table[i][j];
+#endif
+
+		}
+	}
+
+	for (i=0; i < 3; i++) {
+		table_reg = SM5703_REG_TABLE_START + (i<<4);
+		for(j=0; j <= SM5703_FG_TABLE_LEN; j++) {
+			sm5703_fg_i2c_write_word(fuelgauge->i2c, (table_reg + j), write_table[i][j]);
+			msleep(10);
+			if(write_table[i][j] != sm5703_fg_i2c_read_word(fuelgauge->i2c, (table_reg + j))){
+				pr_info("%s: TABLE write FAIL retry[%d][%d] = 0x%x : 0x%x\n",
+					__func__, i, j, (table_reg + j), write_table[i][j]);
+					sm5703_fg_i2c_write_word(fuelgauge->i2c, (table_reg + j), write_table[i][j]);
+			}
+			pr_info("%s: TABLE write OK [%d][%d] = 0x%x : 0x%x\n",
+				__func__, i, j, (table_reg + j), write_table[i][j]);
+		}
+	}
+
+	/* MIX_MODE write */
+	sm5703_fg_i2c_write_word(fuelgauge->i2c,
+		SM5703_REG_RS_MIX_FACTOR, fuelgauge->info.rs_value[1]);
+	sm5703_fg_i2c_write_word(fuelgauge->i2c,
+		SM5703_REG_RS_MAX, fuelgauge->info.rs_value[2]);
+	sm5703_fg_i2c_write_word(fuelgauge->i2c,
+		SM5703_REG_RS_MIN, fuelgauge->info.rs_value[3]);
+	sm5703_fg_i2c_write_word(fuelgauge->i2c,
+		SM5703_REG_MIX_RATE, fuelgauge->info.mix_value[0]);
+	sm5703_fg_i2c_write_word(fuelgauge->i2c,
+		SM5703_REG_MIX_INIT_BLANK, fuelgauge->info.mix_value[1]);
+
+	dev_dbg(&fuelgauge->i2c->dev,
+		"%s: RS_MIX_FACTOR = 0x%x, RS_MAX = 0x%x, RS_MIN = 0x%x,\
+		MIX_RATE = 0x%x, MIX_INIT_BLANK = 0x%x\n",		\
+		__func__, fuelgauge->info.rs_value[1],
+		fuelgauge->info.rs_value[2],
+		fuelgauge->info.rs_value[3],
+		fuelgauge->info.mix_value[0],
+		fuelgauge->info.mix_value[1]);
+
+	/* CAL write */
+	sm5703_fg_i2c_write_word(fuelgauge->i2c,
+		SM5703_REG_VOLT_CAL, fuelgauge->info.volt_cal);
+	sm5703_fg_i2c_write_word(fuelgauge->i2c,
+		SM5703_REG_CURR_CAL, fuelgauge->info.curr_cal);
+
+	dev_dbg(&fuelgauge->i2c->dev, "%s: VOLT_CAL = 0x%x, CURR_CAL = 0x%x\n",
+		__func__, fuelgauge->info.volt_cal, fuelgauge->info.curr_cal);
+
+	/* top off soc set */
+	if(sm5703_get_device_id(fuelgauge->i2c) < 3) {
+		if(fuelgauge->info.topoff_soc >= 5)
+			fuelgauge->info.topoff_soc = 5; /* 93% */
+		else if(fuelgauge->info.topoff_soc >= 3)
+			fuelgauge->info.topoff_soc = fuelgauge->info.topoff_soc - 3;
+		else if(fuelgauge->info.topoff_soc >= 0)
+			fuelgauge->info.topoff_soc = fuelgauge->info.topoff_soc + 5;
+	}
+	sm5703_fg_i2c_write_word(fuelgauge->i2c,
+		SM5703_REG_TOPOFFSOC, fuelgauge->info.topoff_soc);
+
+	/* INIT_last -  control register set */
+	value = sm5703_fg_i2c_read_word(fuelgauge->i2c, SM5703_REG_CNTL);
+	value &= 0xDFFF;
+	value |= ENABLE_MIX_MODE | ENABLE_TEMP_MEASURE | (fuelgauge->info.enable_topoff_soc << 13);
+
+	/* surge reset defence */
+	if (manual_ocv_write) {
+		value = value | ENABLE_MANUAL_OCV;
+	}
+
+	pr_info("%s: SM5703_REG_CNTL reg : 0x%x\n", __func__, value);
+
+	ret = sm5703_fg_i2c_write_word(fuelgauge->i2c, SM5703_REG_CNTL, value);
+	if (ret < 0)
+		dev_dbg(&fuelgauge->i2c->dev,
+		"%s: fail control register set(%d)\n", __func__, ret);
+
+	/* Lock */
+	value = SM5703_FG_PARAM_LOCK_CODE | SM5703_FG_TABLE_LEN;
+	sm5703_fg_i2c_write_word(fuelgauge->i2c,
+		SM5703_REG_PARAM_CTRL, value);
+	dev_info(&fuelgauge->i2c->dev,
+		"%s: LAST PARAM CTRL VALUE = 0x%x : 0x%x\n",
+		__func__, SM5703_REG_PARAM_CTRL, value);
+
+	/* surge reset defence */
+	if (manual_ocv_write)
+		value = ((fuelgauge->info.batt_ocv << 8) / 125);
+	else
+		value = calculate_iocv(fuelgauge->i2c);
+
+	sm5703_fg_i2c_write_word(fuelgauge->i2c, SM5703_REG_IOCV_MAN, value);
+	pr_info( "%s: IOCV_MAN_WRITE = %d : 0x%x\n",
+			__func__, fuelgauge->info.batt_ocv, value);
+
+	return 1;
+}
+
+static bool sm5703_fg_init(struct sm5703_fuelgauge_data *fuelgauge)
+{
+	int ret;
+	int ta_exist, reg_val;
+	union power_supply_propval value;
+
+	/* SM5703 i2c read check */
+	ret = sm5703_get_device_id(fuelgauge->i2c);
+	if (ret < 0) {
+		dev_dbg(&fuelgauge->i2c->dev,
+			"%s: fail to do i2c read(%d)\n", __func__, ret);
+
+		return false;
+	}
+
+	/* enable_topoff set */
+	reg_val = sm5703_fg_i2c_read_word(fuelgauge->i2c, SM5703_REG_CNTL);
+	reg_val &= 0xDFFF;
+	reg_val |= (fuelgauge->info.enable_topoff_soc << 13);
+
+	pr_info("%s: SM5703_REG_CNTL reg : 0x%x\n", __func__, reg_val);
+
+	sm5703_fg_i2c_write_word(fuelgauge->i2c, SM5703_REG_CNTL, reg_val);
+
+#ifdef ENABLE_BATT_LONG_LIFE
+	fuelgauge->info.q_max_now = sm5703_fg_i2c_read_word(fuelgauge->i2c, 0xCE);
+	pr_info("%s: q_max_now = 0x%x\n", __func__, fuelgauge->info.q_max_now);
+	fuelgauge->info.q_max_now = sm5703_fg_i2c_read_word(fuelgauge->i2c, 0xCE);
+	pr_info("%s: q_max_now = 0x%x\n", __func__, fuelgauge->info.q_max_now);
+#endif
+
+	value.intval = POWER_SUPPLY_HEALTH_UNKNOWN;
+	psy_do_property("sm5703-charger", get,
+			POWER_SUPPLY_PROP_HEALTH, value);
+	dev_dbg(&fuelgauge->i2c->dev,
+		"%s: get POWER_SUPPLY_PROP_HEALTH = 0x%x\n",
+		__func__, value.intval);
+
+	ta_exist = fuelgauge->is_charging && (fuelgauge->info.batt_current >= 0);
+	dev_dbg(&fuelgauge->i2c->dev,
+		"%s: is_charging = %d, ta_exist = %d\n",
+		__func__, fuelgauge->is_charging, ta_exist);
+
+	/* get first voltage measure to avgvoltage */
+	fuelgauge->info.batt_avgvoltage = sm5703_get_avgvbat(fuelgauge);
+
+	/* get first temperature */
+	fuelgauge->info.temperature = sm5703_get_temperature(fuelgauge);
+
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, 0x30);
+	pr_info("%s: sm5703 FG 0x30 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, 0x31);
+	pr_info("%s: sm5703 FG 0x31 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, 0x32);
+	pr_info("%s: sm5703 FG 0x32 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, 0x33);
+	pr_info("%s: sm5703 FG 0x33 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, 0x34);
+	pr_info("%s: sm5703 FG 0x34 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, 0x35);
+	pr_info("%s: sm5703 FG 0x35 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, 0x36);
+	pr_info("%s: sm5703 FG 0x36 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, 0x37);
+	pr_info("%s: sm5703 FG 0x37 = 0x%x \n", __func__, ret);
+
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, 0x40);
+	pr_info("%s: sm5703 FG 0x40 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, 0x41);
+	pr_info("%s: sm5703 FG 0x41 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, 0x42);
+	pr_info("%s: sm5703 FG 0x42 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, 0x43);
+	pr_info("%s: sm5703 FG 0x43 = 0x%x \n", __func__, ret);
+
+	return true;
+}
+
+static bool sm5703_fg_reset(struct sm5703_fuelgauge_data *fuelgauge)
+{
+	int value;
+
+	dev_info(&fuelgauge->i2c->dev, "%s: sec_hal_fg_reset\n", __func__);
+
+	value = sm5703_fg_i2c_read_word(fuelgauge->i2c, SM5703_REG_CNTL);
+	value &= 0xF0;
+
+	/* SW reset code */
+	sm5703_fg_i2c_write_word(fuelgauge->i2c, 0x90, 0x0008);
+
+	/* delay 400ms */
+	msleep(400);
+
+	/* Restore for SM5703_REG_CNTL[7:4] */
+	value |= sm5703_fg_i2c_read_word(fuelgauge->i2c, SM5703_REG_CNTL);
+	sm5703_fg_i2c_write_word(fuelgauge->i2c, SM5703_REG_CNTL, value);
+
+	/* init code */
+	if(sm5703_fg_check_reg_init_need(fuelgauge->i2c))
+		sm5703_fg_reg_init(fuelgauge, 0);
+
+	return true;
+}
+
+static void sm5703_fg_reset_capacity_by_jig_connection(struct sm5703_fuelgauge_data *fuelgauge)
+{
+	int ret;
+
+#ifndef ENABLE_BATT_LONG_LIFE
+	if (fuelgauge->pdata->model_type == J2LTE) {
+#ifdef USE_SUSPEND_LATE
+		int retry = 0;
+
+		while(fuelgauge->is_sleep_state == true){
+			pr_info("%s sleep_state retry=%d\n", __func__, retry);
+			usleep_range(10 * 1000, 10 * 1000);
+			if (++retry > 5)
+				break;
+		}
+#endif
+	}
+#endif
+
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, SM5703_REG_CNTL);
+	ret &= 0xFFEF;
+	sm5703_fg_i2c_write_word(fuelgauge->i2c, SM5703_REG_CNTL, ret);
+}
+
+static int sm5703_fg_get_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		union power_supply_propval *val)
+{
+	struct sm5703_fuelgauge_data *fuelgauge =
+		container_of(psy, struct sm5703_fuelgauge_data, psy_fg);
+
+	switch (psp) {
+		case POWER_SUPPLY_PROP_STATUS:
+		case POWER_SUPPLY_PROP_CHARGE_FULL:
+		case POWER_SUPPLY_PROP_ENERGY_NOW:
+			return -ENODATA;
+		/* Cell voltage (VCELL, mV) */
+		case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+			val->intval = sm5703_get_vbat(fuelgauge);
+			break;
+		/* Additional Voltage Information (mV) */
+		case POWER_SUPPLY_PROP_VOLTAGE_AVG:
+			switch (val->intval) {
+				case SEC_BATTERY_VOLTAGE_AVERAGE:
+					val->intval = sm5703_get_avgvbat(fuelgauge);
+					break;
+				case SEC_BATTERY_VOLTAGE_OCV:
+					val->intval = sm5703_get_ocv(fuelgauge);
+					break;
+			}
+			break;
+		/* Current (mA) */
+		case POWER_SUPPLY_PROP_CURRENT_NOW:
+			val->intval = sm5703_get_curr(fuelgauge);
+			break;
+		/* Average Current (mA) */
+		case POWER_SUPPLY_PROP_CURRENT_AVG:
+			val->intval = sm5703_get_avgcurr(fuelgauge);
+			break;
+		case POWER_SUPPLY_PROP_CAPACITY:
+			if (val->intval == SEC_FUELGAUGE_CAPACITY_TYPE_RAW) {
+				val->intval = sm5703_get_soc(fuelgauge) * 10;
+			} else {
+				val->intval = sm5703_get_soc(fuelgauge);
+
+				if (fuelgauge->pdata->capacity_calculation_type &
+						(SEC_FUELGAUGE_CAPACITY_TYPE_SCALE |
+						 SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE))
+					sm5703_fg_get_scaled_capacity(fuelgauge, val);
+
+				/* capacity should be between 0% and 100%
+				 * (0.1% degree)
+				 */
+				if (val->intval > 1000)
+					val->intval = 1000;
+				if (val->intval < 0)
+					val->intval = 0;
+
+				/* get only integer part */
+				val->intval /= 10;
+
+				if (!fuelgauge->is_charging &&
+						(fuelgauge->force_dec_mode == SM5703_COLD_MODE)) {
+					pr_info("%s : SW V EMPTY. Decrease SOC\n", __func__);
+					val->intval = 0;
+				} else if ((fuelgauge->force_dec_mode == SM5703_RECOVERY_MODE) &&
+						(val->intval == fuelgauge->capacity_old)) {
+					fuelgauge->force_dec_mode = SM5703_NORMAL_MODE;
+				}
+
+				/* check whether doing the wake_unlock */
+				if ((val->intval > fuelgauge->pdata->fuel_alert_soc) &&
+						fuelgauge->is_fuel_alerted) {
+					wake_unlock(&fuelgauge->fuel_alert_wake_lock);
+					sm5703_fuelgauge_fuelalert_init(fuelgauge,
+							fuelgauge->pdata->fuel_alert_soc);
+				}
+
+				/* (Only for atomic capacity)
+				 * In initial time, capacity_old is 0.
+				 * and in resume from sleep,
+				 * capacity_old is too different from actual soc.
+				 * should update capacity_old
+				 * by val->intval in booting or resume.
+				 */
+				if (fuelgauge->initial_update_of_soc &&
+						fuelgauge->force_dec_mode == SM5703_NORMAL_MODE) {
+					/* updated old capacity */
+					fuelgauge->capacity_old = val->intval;
+					fuelgauge->initial_update_of_soc = false;
+					break;
+				}
+
+				if (fuelgauge->pdata->capacity_calculation_type &
+						(SEC_FUELGAUGE_CAPACITY_TYPE_ATOMIC |
+						 SEC_FUELGAUGE_CAPACITY_TYPE_SKIP_ABNORMAL))
+					sm5703_fg_get_atomic_capacity(fuelgauge, val);
+			}
+			break;
+		/* Battery Temperature */
+		case POWER_SUPPLY_PROP_TEMP:
+		/* Target Temperature */
+		case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+			val->intval = sm5703_get_temperature(fuelgauge);
+			break;
+		case POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:
+			val->intval = fuelgauge->capacity_max;
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sm5703_fg_set_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		const union power_supply_propval *val)
+{
+	struct sm5703_fuelgauge_data *fuelgauge =
+		container_of(psy, struct sm5703_fuelgauge_data, psy_fg);
+
+	switch (psp) {
+		case POWER_SUPPLY_PROP_STATUS:
+			break;
+		case POWER_SUPPLY_PROP_CHARGE_FULL:
+			if (fuelgauge->pdata->capacity_calculation_type &
+					SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE) {
+				sm5703_fg_calculate_dynamic_scale(fuelgauge, val->intval);
+#ifdef ENABLE_BATT_LONG_LIFE
+				pr_info("%s: POWER_SUPPLY_PROP_CHARGE_FULL : q_max_now = 0x%x \n", __func__, fuelgauge->info.q_max_now);
+				if(fuelgauge->info.q_max_now != 
+					fuelgauge->info.q_max_table[get_v_max_index_by_cycle(fuelgauge)]){
+					if (!sm5703_fg_reset(fuelgauge))
+						return -EINVAL;
+				}
+#endif
+			}
+			break;
+		case POWER_SUPPLY_PROP_ONLINE:
+			fuelgauge->cable_type = val->intval;
+			if (val->intval == POWER_SUPPLY_TYPE_BATTERY) {
+				fuelgauge->is_charging = false;
+			} else {
+				fuelgauge->is_charging = true;
+				if (fuelgauge->force_dec_mode != SM5703_NORMAL_MODE) {
+					fuelgauge->force_dec_mode = SM5703_NORMAL_MODE;
+					fuelgauge->initial_update_of_soc = true;
+					wake_unlock(&fuelgauge->fuel_alert_wake_lock);
+					sm5703_fuelgauge_fuelalert_init(fuelgauge,
+							fuelgauge->pdata->fuel_alert_soc);
+				}
+
+				if (fuelgauge->info.is_low_batt_alarm) {
+					pr_info("%s: Reset low_batt_alarm\n",
+							__func__);
+					fuelgauge->info.is_low_batt_alarm = false;
+				}
+			}
+			break;
+		case POWER_SUPPLY_PROP_CAPACITY:
+			if (val->intval == SEC_FUELGAUGE_CAPACITY_TYPE_RESET) {
+				fuelgauge->initial_update_of_soc = true;
+
+				if (!sm5703_fg_reset(fuelgauge))
+					return -EINVAL;
+				else
+					break;
+
+			}
+			break;
+		case POWER_SUPPLY_PROP_TEMP:
+			break;
+		case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+			break;
+		case POWER_SUPPLY_PROP_ENERGY_NOW:
+			sm5703_fg_reset_capacity_by_jig_connection(fuelgauge);
+			break;
+		case POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:
+			dev_info(&fuelgauge->i2c->dev,
+					"%s: capacity_max changed, %d -> %d\n",
+					__func__, fuelgauge->capacity_max, val->intval);
+			fuelgauge->capacity_max = sm5703_fg_check_capacity_max(fuelgauge, val->intval);
+			fuelgauge->initial_update_of_soc = true;
+			break;
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+		case POWER_SUPPLY_PROP_CAPACITY_LEVEL:
+			pr_info("%s: full condition soc changed, %d -> %d\n",
+				__func__, fuelgauge->chg_full_soc, val->intval);
+			fuelgauge->chg_full_soc = val->intval;
+			break;
+#endif
+		default:
+			return -EINVAL;
+	}
+	return 0;
+}
+
+static void sm5703_fg_isr_work(struct work_struct *work)
+{
+	struct sm5703_fuelgauge_data *fuelgauge =
+		container_of(work, struct sm5703_fuelgauge_data, isr_work.work);
+	int fg_alert_status;
+
+	fg_alert_status = sm5703_fg_i2c_read_word(fuelgauge->i2c, SM5703_REG_STATUS);
+	dev_info(&fuelgauge->i2c->dev, "%s: fg_alert_status(0x%x)\n",
+		__func__, fg_alert_status);
+
+	fg_alert_status &= fuelgauge->info.irq_ctrl;
+	if (!fg_alert_status) {
+		wake_unlock(&fuelgauge->fuel_alert_wake_lock);
+	}
+
+	if (fg_alert_status & ENABLE_L_VOL_INT) {
+		pr_info("%s : Battery Voltage is Very Low!! SW V EMPTY ENABLE\n", __func__);
+		fuelgauge->force_dec_mode = SM5703_COLD_MODE;
+	}
+}
+
+#if defined(CONFIG_STMP_SUPPORT_FG_ALERT)
+static void sm5703_fg_isr(void *irq_data)
+{
+	struct sm5703_fuelgauge_data *fuelgauge = irq_data;
+	int fg_irq;
+
+	/* clear interrupt */
+	fg_irq = sm5703_fg_i2c_read_word(fuelgauge->i2c, SM5703_REG_INTFG);
+	dev_info(&fuelgauge->i2c->dev, "%s: fg_irq(0x%x)\n", __func__, fg_irq);
+
+	if (!fuelgauge->is_fuel_alerted) {
+		wake_lock(&fuelgauge->fuel_alert_wake_lock);
+		fuelgauge->is_fuel_alerted = true;
+		schedule_delayed_work(&fuelgauge->isr_work, 0);
+	}
+}
+#else
+static irqreturn_t sm5703_fg_irq_thread(int irq, void *irq_data)
+{
+	struct sm5703_fuelgauge_data *fuelgauge = irq_data;
+	int fg_irq;
+
+	/* clear interrupt */
+	fg_irq = sm5703_fg_i2c_read_word(fuelgauge->i2c, SM5703_REG_INTFG);
+	dev_info(&fuelgauge->i2c->dev, "%s: fg_irq(0x%x)\n",
+		__func__, fg_irq);
+
+	if (!fuelgauge->is_fuel_alerted) {
+		wake_lock(&fuelgauge->fuel_alert_wake_lock);
+		fuelgauge->is_fuel_alerted = true;
+		schedule_delayed_work(&fuelgauge->isr_work, 0);
+	}
+	return IRQ_HANDLED;
+}
+#endif
+
+#ifdef CONFIG_OF
+#define PROPERTY_NAME_SIZE 128
+
+#define PINFO(format, args...) \
+	printk(KERN_INFO "%s() line-%d: " format, \
+			__func__, __LINE__, ## args)
+
+#define DECL_PARAM_PROP(_id, _name) {.id = _id, .name = _name,}
+
+static int get_battery_id(struct sm5703_fuelgauge_data *fuelgauge)
+{
+    /* sm5703fg does not support this function */
+    return 0;
+}
+
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+static int temp_parse_dt(struct sm5703_fuelgauge_data *fuelgauge)
+{
+	struct device_node *np = of_find_node_by_name(NULL, "battery");
+	int len=0, ret;
+	const u32 *p;
+
+	if (np == NULL) {
+		pr_err("%s np NULL\n", __func__);
+	} else {
+		p = of_get_property(np, "battery,age_data", &len);
+		if (p) {
+
+			pr_info("%s --------- 1  %d \n", __func__,len);
+			fuelgauge->pdata->num_age_step = len / sizeof(sec_age_data_t);
+			pr_info("%s --------- 2\n", __func__);
+			fuelgauge->pdata->age_data = kzalloc(len, GFP_KERNEL);
+			pr_info("%s --------- 3\n", __func__);
+			ret = of_property_read_u32_array(np, "battery,age_data",
+					 (u32 *)fuelgauge->pdata->age_data, len/sizeof(u32));
+			pr_info("%s --------- 4\n", __func__);
+			if (ret) {
+				pr_err("%s failed to read battery->pdata->age_data: %d\n",
+						__func__, ret);
+				kfree(fuelgauge->pdata->age_data);
+				fuelgauge->pdata->age_data = NULL;
+				fuelgauge->pdata->num_age_step = 0;
+			}
+			pr_info("%s num_age_step : %d\n", __func__, fuelgauge->pdata->num_age_step);
+			for (len = 0; len < fuelgauge->pdata->num_age_step; ++len) {
+				pr_info("[%d/%d]cycle:%d, float:%d, full_v:%d, recharge_v:%d, soc:%d\n",
+					len, fuelgauge->pdata->num_age_step-1,
+					fuelgauge->pdata->age_data[len].cycle,
+					fuelgauge->pdata->age_data[len].float_voltage,
+					fuelgauge->pdata->age_data[len].full_condition_vcell,
+					fuelgauge->pdata->age_data[len].recharge_condition_vcell,
+					fuelgauge->pdata->age_data[len].full_condition_soc);
+			}
+		} else {
+			fuelgauge->pdata->num_age_step = 0;
+			pr_err("%s there is not age_data\n", __func__);
+		}
+	}
+	return 0;
+}
+#endif
+
+static int sm5703_fg_parse_dt(struct sm5703_fuelgauge_data *fuelgauge)
+{
+	char prop_name[PROPERTY_NAME_SIZE];
+	int battery_id = -1;
+#ifdef ENABLE_BATT_LONG_LIFE
+	int v_max_table[5];
+	int q_max_table[5];
+#endif
+	int table[16];
+	int rce_value[3];
+	int rs_value[4];
+	int mix_value[2];
+	int topoff_soc[2];
+	int set_temp_poff[4] = {3400,100,3300,80};
+
+	int ret;
+	int i, j;
+
+	struct device_node *np = of_find_node_by_name(NULL, "sm5703-fuelgauge");
+
+	if (np == NULL) {
+		pr_err("%s np NULL\n", __func__);
+	} else {
+		fuelgauge->pdata->fg_irq = of_get_named_gpio(np, "fuelgauge,fuel_int", 0);
+		if (fuelgauge->pdata->fg_irq < 0)
+			pr_err("%s error reading fg_irq = %d\n",
+				__func__, fuelgauge->pdata->fg_irq);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_max",
+				&fuelgauge->pdata->capacity_max);
+		if (ret < 0)
+			pr_err("%s error reading capacity_max %d\n", __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_max_margin",
+				&fuelgauge->pdata->capacity_max_margin);
+		if (ret < 0)
+			pr_err("%s error reading capacity_max_margin %d\n", __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_min",
+				&fuelgauge->pdata->capacity_min);
+		if (ret < 0)
+			pr_err("%s error reading capacity_min %d\n", __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_calculation_type",
+				&fuelgauge->pdata->capacity_calculation_type);
+		if (ret < 0)
+			pr_err("%s error reading capacity_calculation_type %d\n",
+					__func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,fuel_alert_soc",
+				&fuelgauge->pdata->fuel_alert_soc);
+		if (ret < 0)
+			pr_err("%s error reading pdata->fuel_alert_soc %d\n",
+					__func__, ret);
+
+#ifndef ENABLE_BATT_LONG_LIFE
+		ret = of_property_read_u32(np, "fuelgauge,model_type",
+			&fuelgauge->pdata->model_type);
+		if (ret < 0)
+			pr_err("%s error reading pdata->model_type %d\n",
+					__func__, ret);
+#endif
+	}
+
+	pr_info("%s: fg_irq : %d, capacity_max : %d, capacity_max_margin : %d, capacity_min : %d\n",
+		__func__, fuelgauge->pdata->fg_irq, fuelgauge->pdata->capacity_max,
+		fuelgauge->pdata->capacity_max_margin, fuelgauge->pdata->capacity_min);
+
+	/* get battery_params node */
+	np = of_find_node_by_name(of_node_get(np), "battery_params");
+	if (np == NULL) {
+		PINFO("Cannot find child node \"battery_params\"\n");
+		return -EINVAL;
+	}
+
+	/* get battery_id */
+	if (of_property_read_u32(np, "battery,id", &battery_id) < 0)
+		PINFO("not battery,id property\n");
+	if (battery_id == -1)
+		battery_id = get_battery_id(fuelgauge);
+	PINFO("battery id = %d\n", battery_id);
+
+#ifdef ENABLE_BATT_LONG_LIFE
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "v_max_table");
+	ret = of_property_read_u32_array(np, prop_name, v_max_table, fuelgauge->pdata->num_age_step);
+
+	if(ret < 0){
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+
+		for (i = 0; i <fuelgauge->pdata->num_age_step; i++){
+			fuelgauge->info.v_max_table[i] = fuelgauge->info.battery_table[DISCHARGE_TABLE][SM5703_FG_TABLE_LEN-1];
+			PINFO("%s = <v_max_table[%d] 0x%x>\n", prop_name, i, fuelgauge->info.v_max_table[i]);
+		}
+	}else{
+		for (i = 0; i < fuelgauge->pdata->num_age_step; i++){
+			fuelgauge->info.v_max_table[i] = v_max_table[i];
+			PINFO("%s = <v_max_table[%d] 0x%x>\n", prop_name, i, fuelgauge->info.v_max_table[i]);
+		}
+	}
+
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "q_max_table");
+	ret = of_property_read_u32_array(np, prop_name, q_max_table,fuelgauge->pdata->num_age_step);
+
+	if(ret < 0){
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+
+		for (i = 0; i < fuelgauge->pdata->num_age_step; i++){
+			fuelgauge->info.q_max_table[i] = 100;
+			PINFO("%s = <q_max_table[%d] %d>\n", prop_name, i, fuelgauge->info.q_max_table[i]);
+		}
+	}else{
+		for (i = 0; i < fuelgauge->pdata->num_age_step; i++){
+			fuelgauge->info.q_max_table[i] = q_max_table[i];
+			PINFO("%s = <q_max_table[%d] %d>\n", prop_name, i, fuelgauge->info.q_max_table[i]);
+		}
+	}
+	fuelgauge->chg_full_soc = fuelgauge->pdata->age_data[0].full_condition_soc;
+	fuelgauge->info.v_max_now = fuelgauge->info.v_max_table[0];
+	fuelgauge->info.q_max_now = fuelgauge->info.q_max_table[0];
+	PINFO("%s = <v_max_now = 0x%x>, <q_max_now = 0x%x>, <chg_full_soc = %d>\n", prop_name, fuelgauge->info.v_max_now, fuelgauge->info.q_max_now, fuelgauge->chg_full_soc);
+#endif
+
+	/* get battery_table */
+	for (i = DISCHARGE_TABLE; i < TABLE_MAX; i++) {
+		snprintf(prop_name, PROPERTY_NAME_SIZE,
+				"battery%d,%s%d", battery_id, "battery_table", i);
+
+		ret = of_property_read_u32_array(np, prop_name, table, 16);
+		if (ret < 0) {
+			PINFO("Can get prop %s (%d)\n", prop_name, ret);
+		}
+		for (j = 0; j <= SM5703_FG_TABLE_LEN; j++) {
+			fuelgauge->info.battery_table[i][j] = table[j];
+			PINFO("%s = <table[%d][%d] 0x%x>\n", prop_name, i, j, table[j]);
+		}
+	}
+
+	/* get rce */
+	for (i = 0; i < 3; i++) {
+		snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "rce_value");
+		ret = of_property_read_u32_array(np, prop_name, rce_value, 3);
+		if (ret < 0) {
+			PINFO("Can get prop %s (%d)\n", prop_name, ret);
+		}
+		fuelgauge->info.rce_value[i] = rce_value[i];
+	}
+	PINFO("%s = <0x%x 0x%x 0x%x>\n", prop_name, rce_value[0], rce_value[1], rce_value[2]);
+
+	/* get dtcd_value */
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "dtcd_value");
+	ret = of_property_read_u32_array(np, prop_name, &fuelgauge->info.dtcd_value, 1);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	PINFO("%s = <0x%x>\n",prop_name, fuelgauge->info.dtcd_value);
+
+	/* get rs_value */
+	for (i = 0; i < 4; i++) {
+		snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "rs_value");
+		ret = of_property_read_u32_array(np, prop_name, rs_value, 4);
+		if (ret < 0) {
+			PINFO("Can get prop %s (%d)\n", prop_name, ret);
+		}
+		fuelgauge->info.rs_value[i] = rs_value[i];
+	}
+	PINFO("%s = <0x%x 0x%x 0x%x 0x%x>\n", prop_name, rs_value[0], rs_value[1], rs_value[2], rs_value[3]);
+
+	/* get vit_period */
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "vit_period");
+	ret = of_property_read_u32_array(np, prop_name, &fuelgauge->info.vit_period, 1);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	PINFO("%s = <0x%x>\n",prop_name, fuelgauge->info.vit_period);
+
+	/* get mix_value */
+	for (i = 0; i < 2; i++) {
+		snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "mix_value");
+		ret = of_property_read_u32_array(np, prop_name, mix_value, 2);
+		if (ret < 0) {
+			PINFO("Can get prop %s (%d)\n", prop_name, ret);
+		}
+		fuelgauge->info.mix_value[i] = mix_value[i];
+	}
+	PINFO("%s = <0x%x 0x%x>\n", prop_name, mix_value[0], mix_value[1]);
+
+	/* battery_type */
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "battery_type");
+	ret = of_property_read_u32_array(np, prop_name, &fuelgauge->info.battery_type, 1);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	PINFO("%s = <%d>\n", prop_name, fuelgauge->info.battery_type);
+
+	/* TOP OFF SOC */
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "topoff_soc");
+	ret = of_property_read_u32_array(np, prop_name, topoff_soc, 2);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	fuelgauge->info.enable_topoff_soc = topoff_soc[0];
+	fuelgauge->info.topoff_soc = topoff_soc[1];
+	PINFO("%s = <0x%x 0x%x>\n", prop_name, fuelgauge->info.enable_topoff_soc, fuelgauge->info.topoff_soc);
+
+	/* VOL & CURR CAL */
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "volt_cal");
+	ret = of_property_read_u32_array(np, prop_name, &fuelgauge->info.volt_cal, 1);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	PINFO("%s = <0x%x>\n", prop_name, fuelgauge->info.volt_cal);
+
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "curr_cal");
+	ret = of_property_read_u32_array(np, prop_name, &fuelgauge->info.curr_cal, 1);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	PINFO("%s = <0x%x>\n", prop_name, fuelgauge->info.curr_cal);
+
+	/* temp_std */
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "temp_std");
+	ret = of_property_read_u32_array(np, prop_name, &fuelgauge->info.temp_std, 1);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	PINFO("%s = <%d>\n", prop_name, fuelgauge->info.temp_std);
+
+	/* temp_offset */
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "temp_offset");
+	ret = of_property_read_u32_array(np, prop_name, &fuelgauge->info.temp_offset, 1);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	PINFO("%s = <%d>\n", prop_name, fuelgauge->info.temp_offset);
+
+	/* temp_offset_cal */
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "temp_offset_cal");
+	ret = of_property_read_u32_array(np, prop_name, &fuelgauge->info.temp_offset_cal, 1);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	PINFO("%s = <0x%x>\n", prop_name, fuelgauge->info.temp_offset_cal);
+
+	/* charge_offset_cal */
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "charge_offset_cal");
+	ret = of_property_read_u32_array(np, prop_name, &fuelgauge->info.charge_offset_cal, 1);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	PINFO("%s = <0x%x>\n", prop_name, fuelgauge->info.charge_offset_cal);
+
+	/* tem poff level */
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "tem_poff");
+	ret = of_property_read_u32_array(np, prop_name, set_temp_poff, 4);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	fuelgauge->info.n_tem_poff = set_temp_poff[0];
+	fuelgauge->info.n_tem_poff_offset = set_temp_poff[1];
+	fuelgauge->info.l_tem_poff = set_temp_poff[2];
+	fuelgauge->info.l_tem_poff_offset = set_temp_poff[3];
+
+	PINFO("%s = <%d, %d, %d, %d>\n", prop_name,
+		fuelgauge->info.n_tem_poff, fuelgauge->info.n_tem_poff_offset,
+		fuelgauge->info.l_tem_poff, fuelgauge->info.l_tem_poff_offset);
+
+	np = of_find_node_by_name(NULL, "battery");
+	if (!np) {
+		pr_info("%s : np NULL\n", __func__);
+		return -ENODATA;
+	}
+
+	ret = of_property_read_string(np, "battery,fuelgauge_name",
+		(char const **)&fuelgauge->pdata->fuelgauge_name);
+	if (ret)
+		pr_info("%s: fuelgauge name is Empty.\n", __func__);
+
+	return 0;
+}
+
+static struct of_device_id sm5703_fuelgauge_match_table[] = {
+	{ .compatible = "samsung,sm5703-fuelgauge",},
+	{},
+};
+#else
+static int sm5703_fg_parse_dt(struct sm5703_fuelgauge_data *fuelgauge)
+{
+	return -ENOSYS;
+}
+
+#define sm5703_fuelgauge_match_table NULL
+#endif /* CONFIG_OF */
+
+static int sm5703_fuelgauge_probe(struct i2c_client *client,
+		const struct i2c_device_id *id)
+{
+	struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
+	struct sm5703_fuelgauge_data *fuelgauge;
+#ifdef ENABLE_BATT_LONG_LIFE
+	sec_battery_platform_data_t *pdata = NULL;
+#endif
+	union power_supply_propval raw_soc_val;
+	int ret = 0;
+
+	pr_info("%s: SM5703 Fuelgauge Driver Loading\n", __func__);
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE))
+		return -EIO;
+
+	fuelgauge = kzalloc(sizeof(*fuelgauge), GFP_KERNEL);
+	if (!fuelgauge)
+		return -ENOMEM;
+
+	mutex_init(&fuelgauge->fg_lock);
+
+	fuelgauge->i2c = client;
+
+#ifdef ENABLE_BATT_LONG_LIFE
+	if (client->dev.of_node) {
+		pdata = devm_kzalloc(&client->dev, sizeof(sec_battery_platform_data_t),GFP_KERNEL);
+		if (!pdata) {
+			dev_err(&client->dev, "Failed to allocate memory\n");
+			ret = -ENOMEM;
+			goto err_parse_dt_nomem;
+		}
+		fuelgauge->pdata = pdata;
+#else
+	if (client->dev.of_node) {
+		fuelgauge->pdata = devm_kzalloc(&client->dev, sizeof(*(fuelgauge->pdata)),
+				GFP_KERNEL);
+		if (!fuelgauge->pdata) {
+			dev_err(&client->dev, "Failed to allocate memory\n");
+			ret = -ENOMEM;
+			goto err_parse_dt_nomem;
+		}
+#endif
+
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+		temp_parse_dt(fuelgauge);
+#endif
+		ret = sm5703_fg_parse_dt(fuelgauge);
+		if (ret < 0)
+			goto err_parse_dt;
+	} else {
+		fuelgauge->pdata = client->dev.platform_data;
+	}
+
+	i2c_set_clientdata(client, fuelgauge);
+
+	if (fuelgauge->pdata->fuelgauge_name == NULL)
+		fuelgauge->pdata->fuelgauge_name = "sm5703-fuelgauge";
+
+	fuelgauge->psy_fg.name          = fuelgauge->pdata->fuelgauge_name;
+	fuelgauge->psy_fg.type          = POWER_SUPPLY_TYPE_UNKNOWN;
+	fuelgauge->psy_fg.get_property  = sm5703_fg_get_property;
+	fuelgauge->psy_fg.set_property  = sm5703_fg_set_property;
+	fuelgauge->psy_fg.properties    = sm5703_fuelgauge_props;
+	fuelgauge->psy_fg.num_properties =
+		ARRAY_SIZE(sm5703_fuelgauge_props);
+
+	fuelgauge->capacity_max = fuelgauge->pdata->capacity_max;
+	raw_soc_val.intval = sm5703_get_soc(fuelgauge);
+
+	if (raw_soc_val.intval > fuelgauge->capacity_max)
+		sm5703_fg_calculate_dynamic_scale(fuelgauge, 100);
+
+	ret = sm5703_fg_init(fuelgauge);
+	if (ret < 0) {
+		pr_err("%s: Failed to Initialize Fuelgauge\n", __func__); 
+		/* goto err_data_free; */
+	}
+
+	ret = power_supply_register(&client->dev, &fuelgauge->psy_fg);
+	if (ret) {
+		pr_err("%s: Failed to Register psy_fg\n", __func__);
+		goto err_data_free;
+	}
+
+	if (fuelgauge->pdata->fuel_alert_soc >= 0) {
+		sm5703_fuelgauge_fuelalert_init(fuelgauge,
+					fuelgauge->pdata->fuel_alert_soc);
+		wake_lock_init(&fuelgauge->fuel_alert_wake_lock,
+					WAKE_LOCK_SUSPEND, "fuel_alerted");
+
+#if defined(CONFIG_STMP_SUPPORT_FG_ALERT)
+		INIT_DELAYED_WORK(
+					&fuelgauge->isr_work, sm5703_fg_isr_work);
+		ret = stmpe_request_irq(6, sm5703_fg_isr,
+							STMPE_TRIGGER_FALLING,
+							"SM5703-Fuelgauge", fuelgauge);
+		if(ret) {
+			pr_err("%s: Failed register to STMPE (%d)\n", __func__, ret);
+			goto err_supply_unreg;
+		}
+#else
+		if (fuelgauge->pdata->fg_irq > 0) {
+			INIT_DELAYED_WORK(
+					&fuelgauge->isr_work, sm5703_fg_isr_work);
+
+			fuelgauge->fg_irq = gpio_to_irq(fuelgauge->pdata->fg_irq);
+			dev_info(&client->dev,
+					"%s: fg_irq = %d\n", __func__, fuelgauge->fg_irq);
+			if (fuelgauge->fg_irq > 0) {
+				ret = request_threaded_irq(fuelgauge->fg_irq,
+						NULL, sm5703_fg_irq_thread,
+						IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING
+						| IRQF_ONESHOT,
+						"fuelgauge-irq", fuelgauge);
+				if (ret) {
+					dev_err(&client->dev,
+							"%s: Failed to Reqeust IRQ\n", __func__);
+					goto err_supply_unreg;
+				}
+
+				ret = enable_irq_wake(fuelgauge->fg_irq);
+				if (ret < 0)
+					dev_err(&client->dev,
+							"%s: Failed to Enable Wakeup Source(%d)\n",
+							__func__, ret);
+			} else {
+				dev_err(&client->dev, "%s: Failed gpio_to_irq(%d)\n",
+						__func__, fuelgauge->fg_irq);
+				goto err_supply_unreg;
+			}
+		}
+#endif
+	}
+
+	fuelgauge->initial_update_of_soc = true;
+	fuelgauge->force_dec_mode = SM5703_NORMAL_MODE;
+
+#ifdef USE_SUSPEND_LATE
+	fuelgauge->is_sleep_state = false;
+#endif
+
+	pr_info("%s: SM5703 Fuelgauge Driver Loaded\n", __func__);
+	return 0;
+
+err_supply_unreg:
+	power_supply_unregister(&fuelgauge->psy_fg);
+err_data_free:
+	if (client->dev.of_node)
+		kfree(fuelgauge->pdata);
+
+err_parse_dt:
+err_parse_dt_nomem:
+	mutex_destroy(&fuelgauge->fg_lock);
+	kfree(fuelgauge);
+
+	return ret;
+}
+
+static const struct i2c_device_id sm5703_fuelgauge_id[] = {
+	{"sm5703-fuelgauge", 0},
+	{}
+};
+
+static void sm5703_fuelgauge_shutdown(struct i2c_client *client)
+{
+}
+
+static int sm5703_fuelgauge_remove(struct i2c_client *client)
+{
+	struct sm5703_fuelgauge_data *fuelgauge = i2c_get_clientdata(client);
+
+	if (fuelgauge->pdata->fuel_alert_soc >= 0)
+		wake_lock_destroy(&fuelgauge->fuel_alert_wake_lock);
+
+	return 0;
+}
+
+#if defined CONFIG_PM
+static int sm5703_fuelgauge_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int sm5703_fuelgauge_resume(struct device *dev)
+{
+	struct sm5703_fuelgauge_data *fuelgauge = dev_get_drvdata(dev);
+
+	fuelgauge->initial_update_of_soc = true;
+
+	return 0;
+}
+
+#ifdef USE_SUSPEND_LATE
+static int sm5703_suspend_late(struct device *dev)
+{
+	struct sm5703_fuelgauge_data *fuelgauge = dev_get_drvdata(dev);
+
+	fuelgauge->is_sleep_state = true;
+
+	return 0;
+}
+
+static int sm5703_resume_noirq(struct device *dev)
+{
+	struct sm5703_fuelgauge_data *fuelgauge = dev_get_drvdata(dev);
+
+	fuelgauge->is_sleep_state = false;
+
+	return 0;
+}
+#endif
+
+#else
+#define sm5703_fuelgauge_suspend NULL
+#define sm5703_fuelgauge_resume NULL
+#endif
+
+const struct dev_pm_ops sm5703_fuelgauge_pm_ops = {
+	.suspend = sm5703_fuelgauge_suspend,
+	.resume = sm5703_fuelgauge_resume,
+#ifdef USE_SUSPEND_LATE
+	.suspend_late = sm5703_suspend_late,
+	.resume_noirq = sm5703_resume_noirq,
+#endif
+};
+
+static struct i2c_driver sm5703_fuelgauge_driver = {
+	.driver = {
+		.name = "sm5703-fuelgauge",
+		.owner = THIS_MODULE,
+		.pm = &sm5703_fuelgauge_pm_ops,
+		.of_match_table = sm5703_fuelgauge_match_table,
+	},
+	.probe  = sm5703_fuelgauge_probe,
+	.remove = sm5703_fuelgauge_remove,
+	.shutdown   = sm5703_fuelgauge_shutdown,
+	.id_table   = sm5703_fuelgauge_id,
+};
+
+static int __init sm5703_fuelgauge_init(void)
+{
+	pr_info("%s: SM5703 Fuelgauge Init\n", __func__);
+	return i2c_add_driver(&sm5703_fuelgauge_driver);
+}
+
+static void __exit sm5703_fuelgauge_exit(void)
+{
+	i2c_del_driver(&sm5703_fuelgauge_driver);
+}
+module_init(sm5703_fuelgauge_init);
+module_exit(sm5703_fuelgauge_exit);
+
+MODULE_DESCRIPTION("Samsung SM5703 Fuel Gauge Driver");
+MODULE_AUTHOR("Samsung Electronics");
+MODULE_LICENSE("GPL");
diff -Naur linux-3.18.14/drivers/battery/sm5705_charger.c samsung/drivers/battery/sm5705_charger.c
--- linux-3.18.14/drivers/battery/sm5705_charger.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery/sm5705_charger.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,2059 @@
+
+/*
+ *  /drivers/battery/sm5705_charger_1.c
+ *
+ *  SM5705 Charger driver for SEC_BATTERY Flatform support
+ *
+ *  Copyright (C) 2015 Silicon Mitus,
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#define pr_fmt(fmt)	"sm5705-charger: %s: " fmt, __func__
+
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/power_supply.h>
+#include <linux/mfd/sm5705.h>
+#include <linux/spinlock.h>
+#ifdef CONFIG_USB_HOST_NOTIFY
+#include <linux/usb_notify.h>
+#endif
+#if defined(CONFIG_VBUS_NOTIFIER)
+#include <linux/vbus_notifier.h>
+#endif
+#include <linux/of_gpio.h>
+
+#include <linux/battery/charger/sm5705_charger.h>
+#include <linux/battery/charger/sm5705_charger_oper.h>
+
+//#define SM5705_CHG_FULL_DEBUG 1
+
+#define ENABLE 1
+#define DISABLE 0
+
+enum {
+	SM5705_CHG_SRC_VBUS = 0x0,
+	SM5705_CHG_SRC_WPC,
+	SM5705_CHG_SRC_MAX,
+};
+
+enum {
+	SM5705_CHG_OTG_CURRENT_0_5A     = 0x0,
+	SM5705_CHG_OTG_CURRENT_0_7A,
+	SM5705_CHG_OTG_CURRENT_0_9A,
+	SM5705_CHG_OTG_CURRENT_1_5A,
+};
+
+enum {
+	SM5705_CHG_BST_IQ3LIMIT_2_0A    = 0x0,
+	SM5705_CHG_BST_IQ3LIMIT_2_8A,
+	SM5705_CHG_BST_IQ3LIMIT_3_5A,
+	SM5705_CHG_BST_IQ3LIMIT_4_0A,
+};
+
+/* Interrupt status Index & Offset */
+enum {
+	SM5705_INT_STATUS1 = 0x0,
+	SM5705_INT_STATUS2,
+	SM5705_INT_STATUS3,
+	SM5705_INT_STATUS4,
+	SM5705_INT_MAX,
+};
+
+enum {
+	SM5705_INT_STATUS1_VBUSPOK          = 0x0,
+	SM5705_INT_STATUS1_VBUSUVLO,
+	SM5705_INT_STATUS1_VBUSOVP,
+	SM5705_INT_STATUS1_VBUSLIMIT,
+	SM5705_INT_STATUS1_WPCINPOK,
+	SM5705_INT_STATUS1_WPCINUVLO,
+	SM5705_INT_STATUS1_WPCINOVP,
+	SM5705_INT_STATUS1_WPCINLIMIT,
+};
+
+enum {
+	SM5705_INT_STATUS2_AICL             = 0x0,
+	SM5705_INT_STATUS2_BATOVP,
+	SM5705_INT_STATUS2_NOBAT,
+	SM5705_INT_STATUS2_CHGON,
+	SM5705_INT_STATUS2_Q4FULLON,
+	SM5705_INT_STATUS2_TOPOFF,
+	SM5705_INT_STATUS2_DONE,
+	SM5705_INT_STATUS2_WDTMROFF,
+};
+
+enum {
+	SM5705_INT_STATUS3_THEMREG          = 0x0,
+	SM5705_INT_STATUS3_THEMSHDN,
+	SM5705_INT_STATUS3_OTGFAIL,
+	SM5705_INT_STATUS3_DISLIMIT,
+	SM5705_INT_STATUS3_PRETMROFF,
+	SM5705_INT_STATUS3_FASTTMROFF,
+	SM5705_INT_STATUS3_LOWBATT,
+	SM5705_INT_STATUS3_nEQ4,
+};
+
+enum {
+	SM5705_INT_STATUS4_FLED1SHORT       = 0x0,
+	SM5705_INT_STATUS4_FLED1OPEN,
+	SM5705_INT_STATUS4_FLED2SHORT,
+	SM5705_INT_STATUS4_FLED2OPEN,
+	SM5705_INT_STATUS4_BOOSTPOK_NG,
+	SM5705_INT_STATUS4_BOOSTPOL,
+	SM5705_INT_STATUS4_ABSTMR1OFF,
+	SM5705_INT_STATUS4_SBPS,
+};
+
+#if defined(SM5705_USED_WIRELESS_CHARGER)
+#define __n_is_cable_type_for_wireless(cable_type) \
+					((cable_type != POWER_SUPPLY_TYPE_WIRELESS) && \
+					(cable_type != POWER_SUPPLY_TYPE_HV_WIRELESS) && \
+					(cable_type != POWER_SUPPLY_TYPE_PMA_WIRELESS) && \
+					(cable_type != POWER_SUPPLY_TYPE_HV_WIRELESS_ETX))
+
+#define __is_cable_type_for_wireless(cable_type)  \
+					((cable_type == POWER_SUPPLY_TYPE_WIRELESS) || \
+					(cable_type == POWER_SUPPLY_TYPE_PMA_WIRELESS))
+
+#define __is_cable_type_for_hv_wireless(cable_type)  \
+					((cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS) || \
+					(cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS_ETX))
+#else
+#define __n_is_cable_type_for_wireless(cable_type)  (true)
+#define __is_cable_type_for_wireless(cable_type)    (false)
+#define __is_cable_type_for_hv_wireless(cable_type) (false)
+#endif
+
+#define __is_cable_type_for_hv_mains(cable_type)  \
+					((cable_type == POWER_SUPPLY_TYPE_HV_MAINS) || \
+					(cable_type == POWER_SUPPLY_TYPE_HV_PREPARE_MAINS) || \
+					(cable_type == POWER_SUPPLY_TYPE_HV_ERR))
+
+static struct device_attribute sm5705_charger_attrs[] = {
+	SM5705_CHARGER_ATTR(chip_id),
+};
+
+/**
+ *  SM5705 Charger device register control functions
+ */
+
+#if defined(SM5705_WATCHDOG_RESET_ACTIVATE)
+static struct sm5705_charger_data *g_sm5705_charger;
+static int sm5705_CHG_set_WATCHDOG_TMR(struct sm5705_charger_data *charger,
+				unsigned char wdt_timer)
+{
+	sm5705_update_reg(charger->i2c,
+		SM5705_REG_CHGCNTL8, ((wdt_timer & 0x3) << 5), (0x3 << 5));
+	pr_info("WATCHDOG_TMR set (timer=%d)\n", wdt_timer);
+
+	return 0;
+}
+
+static int sm5705_CHG_set_ENWATCHDOG(struct sm5705_charger_data *charger,
+				bool enable, bool enchg_reon)
+{
+	unsigned char reg_val = (enchg_reon << 4) | (enable << 3);
+
+	sm5705_update_reg(charger->i2c, SM5705_REG_CNTL, reg_val, (0x3 << 3));
+	pr_info("ENWATCHDOG set (enable=%d, enCHG_REON=%d)\n", enable, enchg_reon);
+
+	return 0;
+}
+
+static void sm5705_CHG_set_WDTMR_RST(struct sm5705_charger_data *charger)
+{
+	sm5705_update_reg(charger->i2c, SM5705_REG_CHGCNTL8, (0x1 << 7), (0x1 << 7));
+}
+#endif
+
+static bool sm5705_CHG_get_INT_STATUS(struct sm5705_charger_data *charger,
+				unsigned char index, unsigned char offset)
+{
+	unsigned char reg_val;
+	int ret;
+
+	ret = sm5705_read_reg(charger->i2c, SM5705_REG_STATUS1 + index, &reg_val);
+	if (ret < 0) {
+		pr_err("fail to I2C read REG:SM5705_REG_INT%d\n", 1 + index);
+		return 0;
+	}
+
+	reg_val = (reg_val & (1 << offset)) >> offset;
+
+	return reg_val;
+}
+
+static int sm5705_CHG_set_TOPOFF_TMR(struct sm5705_charger_data *charger,
+				unsigned char topoff_timer)
+{
+	sm5705_update_reg(charger->i2c,
+		SM5705_REG_CHGCNTL8, ((topoff_timer & 0x3) << 3), (0x3 << 3));
+	pr_info("TOPOFF_TMR set (timer=%d)\n", topoff_timer);
+
+	return 0;
+}
+
+static int sm5705_CHG_enable_AUTOSTOP(struct sm5705_charger_data *charger,
+				bool enable)
+{
+	int ret;
+
+	ret = sm5705_update_reg(charger->i2c, SM5705_REG_CHGCNTL4, (enable << 6), (1 << 6));
+	if (ret < 0) {
+		pr_err("fail to update REG:SM5705_REG_CHGCNTL4 in AUTOSTOP[6]\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static unsigned char _calc_BATREG_offset_to_float_mV(unsigned short mV)
+{
+	unsigned char offset;
+
+	if (mV < 4000) {
+		offset = 0x0;     /* BATREG = 3.8V */
+	} else if (mV < 4010) {
+		offset = 0x1;     /* BATREG = 4.0V */
+	} else if (mV < 4630) {
+		offset = (((mV - 4010) / 10) + 2);    /* BATREG = 4.01 ~ 4.62 */
+	} else {
+		offset = 0x15;    /* default Offset : 4.2V */
+	}
+
+	return offset;
+}
+
+static int sm5705_CHG_set_BATREG(struct sm5705_charger_data *charger,
+				unsigned short float_mV)
+{
+	unsigned char offset = _calc_BATREG_offset_to_float_mV(float_mV);
+	int ret;
+
+	pr_info("set BATREG voltage(%dmV - offset=0x%x)\n", float_mV, offset);
+
+	ret = sm5705_update_reg(charger->i2c, SM5705_REG_CHGCNTL4, offset, 0x3F);
+	if (ret < 0) {
+		pr_err("fail to update REG:SM5705_REG_CHGCNTL4 in BATREG[5:0]\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static unsigned short _calc_float_mV_to_BATREG_offset(unsigned char offset)
+{
+	return ((offset - 2) * 10) + 4010;
+}
+
+static unsigned short sm5705_CHG_get_BATREG(struct sm5705_charger_data *charger)
+{
+	unsigned char offset;
+	int ret;
+
+	ret = sm5705_read_reg(charger->i2c, SM5705_REG_CHGCNTL4, &offset);
+	if (ret < 0) {
+		pr_err("fail to read REG:SM5705_REG_CHGCNTL4\n");
+		return 0;
+	}
+
+	return _calc_float_mV_to_BATREG_offset(offset & 0x3F);
+}
+
+static unsigned char _calc_TOPOFF_offset_to_topoff_mA(unsigned short mA)
+{
+	unsigned char offset;
+
+	if (mA < 100) {
+		offset = 0x0;
+	} else if (mA < 480) {
+		offset = (mA - 100) / 25;
+	} else {
+		offset = 0xF;
+	}
+
+	return offset;
+}
+
+static int sm5705_CHG_set_TOPOFF(struct sm5705_charger_data *charger,
+				unsigned short topoff_mA)
+{
+	unsigned char offset = _calc_TOPOFF_offset_to_topoff_mA(topoff_mA);
+	int ret;
+
+	pr_info("set TOP-OFF current(%dmA - offset=0x%x)\n", topoff_mA, offset);
+
+	ret = sm5705_update_reg(charger->i2c, SM5705_REG_CHGCNTL5, offset, 0xF);
+	if (ret < 0) {
+		pr_err("fail to update REG:SM5705_REG_CHGCNTL5 in TOPOFF[3:0]\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int sm5705_CHG_set_FREQSEL(struct sm5705_charger_data *charger,
+                unsigned char freq_index)
+{
+	int ret;
+
+	pr_info("set BUCK&BOOST freq=0x%x\n", freq_index);
+
+	ret = sm5705_update_reg(charger->i2c, SM5705_REG_CHGCNTL5, ((freq_index & 0x3) << 4), (0x3 << 4));
+	if (ret < 0) {
+		pr_err("fail to update REG:SM5705_REG_CHGCNTL5 in FREQSEL[5:4]\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static unsigned char _calc_AICL_threshold_offset_to_mV(unsigned short aiclth_mV)
+{
+	unsigned char offset;
+
+	if (aiclth_mV < 4500) {
+		offset = 0x0;
+	} else if (aiclth_mV < 4900) {
+		offset = (aiclth_mV - 4500) / 100;
+	} else {
+		offset = 0x3;
+	}
+
+	return offset;
+}
+
+static int sm5705_CHG_set_AICLTH(struct sm5705_charger_data *charger,
+				unsigned short aiclth_mV)
+{
+	unsigned char offset = _calc_AICL_threshold_offset_to_mV(aiclth_mV);
+	int ret;
+
+	pr_info("set AICL threshold (%dmV - offset=0x%x)\n", aiclth_mV, offset);
+
+	ret = sm5705_update_reg(charger->i2c, SM5705_REG_CHGCNTL7, (offset << 6), 0xC0);
+	if (ret < 0) {
+		pr_err("fail to update REG:SM5705_REG_CHGCNTL7 in AICLTH[7:6]\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int sm5705_CHG_set_OVPSEL(struct sm5705_charger_data *charger, bool enable)
+{
+	int ret;
+
+	pr_info("set OVPSEL=%d\n", enable);
+
+	ret = sm5705_update_reg(charger->i2c, SM5705_REG_CHGCNTL7, (enable << 2), (1 << 2));
+	if (ret < 0) {
+		pr_err("fail to update REG:SM5705_REG_CHGCNTL7 in OVPSEL[2]\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int sm5705_CHG_enable_AICL(struct sm5705_charger_data *charger, bool enable)
+{
+	int ret;
+
+	ret = sm5705_update_reg(charger->i2c, SM5705_REG_CHGCNTL7, (enable << 5), (1 << 5));
+	if (ret < 0) {
+		pr_err("fail to update REG:SM5705_REG_CHGCNTL7 in AICLEN[5]\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int sm5705_CHG_set_BST_IQ3LIMIT(struct sm5705_charger_data *charger,
+				unsigned char index)
+{
+	if (index > SM5705_CHG_BST_IQ3LIMIT_4_0A) {
+		pr_err("invalid limit current index (index=0x%x)\n", index);
+		return -EINVAL;
+	}
+
+	sm5705_update_reg(charger->i2c, SM5705_REG_CHGCNTL6, ((index & 0x3)), 0x3);
+
+	pr_info("BST IQ3LIMIT set (index=0x%x)\n", index);
+
+	return 0;
+}
+
+#if defined(SM5705_I2C_RESET_ACTIVATE)
+static int sm5705_CHG_set_ENI2CRESET(struct sm5705_charger_data *charger, bool enable)
+{
+	sm5705_update_reg(charger->i2c, SM5705_REG_CHGCNTL6, (enable << 4), (0x1 << 4));
+	pr_info("ENI2CRESET set (enable=%d)\n", enable);
+	return 0;
+}
+#endif
+
+#if defined(SM5705_MANUAL_RESET_ACTIVATE)
+static int sm5705_CHG_set_ENMRSTB(struct sm5705_charger_data *charger,
+				unsigned char timer)
+{
+	sm5705_update_reg(charger->i2c, SM5705_REG_CHGCNTL8, (timer & 0x3), 0x3);
+	pr_info("ENMRSTB set (timer=%d)\n", timer);
+	return 0;
+}
+#endif
+
+static int sm5705_CHG_enable_AUTOSET(struct sm5705_charger_data *charger, bool enable)
+{
+	int ret;
+
+	ret = sm5705_update_reg(charger->i2c, SM5705_REG_CHGCNTL7, (enable << 1), (1 << 1));
+	if (ret < 0) {
+		pr_err("fail to update REG:SM5705_REG_CHGCNTL7 in AUTOSET[1]\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static unsigned char _calc_FASTCHG_current_offset_to_mA(unsigned short mA)
+{
+	unsigned char offset;
+
+	if (mA < 100) {
+		offset = 0x00;
+	} else {
+		offset = ((mA - 100) / 50) & 0x3F;
+	}
+
+	return offset;
+}
+
+static int sm5705_CHG_set_FASTCHG(struct sm5705_charger_data *charger,
+				unsigned char index, unsigned short FASTCHG_mA)
+{
+	unsigned char offset = _calc_FASTCHG_current_offset_to_mA(FASTCHG_mA);
+
+	pr_info("FASTCHG src=%d, current=%dmA offset=0x%x\n", index, FASTCHG_mA, offset);
+
+	if (index > SM5705_CHG_SRC_WPC) {
+		return -EINVAL;
+	}
+
+	sm5705_write_reg(charger->i2c, SM5705_REG_CHGCNTL2 + index, offset);
+
+	return 0;
+}
+
+static unsigned char _calc_INPUT_LIMIT_current_offset_to_mA(unsigned char index,
+				unsigned short mA)
+{
+	unsigned char offset;
+
+	if (mA < 100) {
+		offset = 0x10;
+	} else {
+		if (index == SM5705_CHG_SRC_VBUS) {
+			offset = ((mA - 100) / 25) & 0x7F;       /* max = 3275mA */
+		} else {
+			offset = ((mA - 100) / 25) & 0x3F;       /* max = 1650mA */
+		}
+	}
+
+	return offset;
+}
+
+static int sm5705_CHG_set_INPUT_LIMIT(struct sm5705_charger_data *charger,
+				unsigned char index, unsigned short LIMIT_mA)
+{
+	unsigned char offset = _calc_INPUT_LIMIT_current_offset_to_mA(index, LIMIT_mA);
+
+	pr_info("set Input LIMIT src=%d, current=%dmA offset=0x%x\n", index, LIMIT_mA, offset);
+
+	if (index > SM5705_CHG_SRC_WPC) {
+		return -EINVAL;
+	}
+
+	sm5705_write_reg(charger->i2c, SM5705_REG_VBUSCNTL + index, offset);
+
+	return 0;
+}
+
+static unsigned short _calc_INPUT_LIMIT_current_mA_to_offset(unsigned char index,
+				unsigned char offset)
+{
+	return (offset * 25) + 100;
+}
+
+static unsigned short sm5705_CHG_get_INPUT_LIMIT(struct sm5705_charger_data *charger,
+				unsigned char index)
+{
+	unsigned short LIMIT_mA;
+	unsigned char offset;
+
+	if (index > SM5705_CHG_SRC_WPC) {
+		pr_err("invalid charger source index = %d\n", index);
+		return 0;
+	}
+
+	sm5705_read_reg(charger->i2c, SM5705_REG_VBUSCNTL + index, &offset);
+
+	LIMIT_mA = _calc_INPUT_LIMIT_current_mA_to_offset(index, offset);
+
+#ifdef SM5705_CHG_FULL_DEBUG
+	pr_info("get INPUT LIMIT src=%d, offset=0x%x, current=%dmA\n", index, offset, LIMIT_mA);
+#endif
+
+	return LIMIT_mA;
+}
+
+static unsigned short _calc_FASTCHG_current_mA_to_offset(unsigned char index,
+				unsigned char offset)
+{
+	return (offset * 50) + 100;
+}
+
+static unsigned short sm5705_CHG_get_FASTCHG(struct sm5705_charger_data *charger,
+				unsigned char index)
+{
+	unsigned short FASTCHG_mA;
+	unsigned char offset;
+
+	if (index > SM5705_CHG_SRC_WPC) {
+		pr_err("invalid charger source index = %d\n", index);
+		return 0;
+	}
+
+	sm5705_read_reg(charger->i2c, SM5705_REG_CHGCNTL2 + index, &offset);
+
+	FASTCHG_mA = _calc_FASTCHG_current_mA_to_offset(index, offset);
+
+	pr_info("get FASTCHG src=%d, offset=0x%x, current=%dmA\n", index, offset, FASTCHG_mA);
+
+	return FASTCHG_mA;
+}
+
+/* monitering REG_MAP */
+static unsigned char sm5705_CHG_read_reg(struct sm5705_charger_data *charger,
+				unsigned char reg)
+{
+	unsigned char reg_val = 0x0;
+
+	sm5705_read_reg(charger->i2c, reg, &reg_val);
+
+	return reg_val;
+}
+
+static void sm5705_chg_test_read(struct sm5705_charger_data *charger)
+{
+	char str[1000] = {0,};
+	int i;
+
+	for (i = SM5705_REG_INTMSK1; i <= SM5705_REG_FLED1CNTL1; i++) {
+		sprintf(str+strlen(str), "0x%02X:0x%02x, ", i, sm5705_CHG_read_reg(charger, i));
+	}
+
+	sprintf(str+strlen(str), "0x%02X:0x%02x, ", SM5705_REG_FLEDCNTL6,
+		sm5705_CHG_read_reg(charger, SM5705_REG_FLEDCNTL6));
+	sprintf(str+strlen(str), "0x%02X:0x%02x, ", SM5705_REG_SBPSCNTL,
+		sm5705_CHG_read_reg(charger, SM5705_REG_SBPSCNTL));
+
+	pr_info("[CHG] %s\n", str);
+}
+
+/**
+ *  SM5705 Charger Driver support functions
+ */
+
+#if defined(CONFIG_BATTERY_SWELLING_SELF_DISCHARGING)
+static bool sm5705_charger_get_discharging_force_status(struct sm5705_charger_data *charger)
+{
+	unsigned char reg;
+	if (sm5705_call_fg_device_id() <= 2) {
+		pr_info("unsupported this function under rev02.\n");
+		return false;
+	}
+	reg = sm5705_CHG_read_reg(charger, SM5705_REG_FACTORY);
+	pr_info("enable:(%s), reg[0x%02X]:0x%02x\n",
+		(reg & SM5705_EN_DISCHG_FORCE_MASK) ? "ON" : "OFF" , SM5705_REG_FACTORY, reg);
+
+	if (reg & SM5705_EN_DISCHG_FORCE_MASK)
+		return true;
+	else
+		return false;
+}
+
+static void sm5705_charger_en_discharing_force(struct sm5705_charger_data *charger, bool enable)
+{
+	unsigned char reg;
+	if (sm5705_call_fg_device_id() <= 2) {
+		pr_info("unsupported this function under rev02.\n");
+		return;
+	}
+
+	if (enable)
+		sm5705_update_reg(charger->i2c, SM5705_REG_FACTORY,
+			SM5705_EN_DISCHG_FORCE_MASK, SM5705_EN_DISCHG_FORCE_MASK);
+	else
+		sm5705_update_reg(charger->i2c, SM5705_REG_FACTORY,
+			0, SM5705_EN_DISCHG_FORCE_MASK);
+
+	reg = sm5705_CHG_read_reg(charger, SM5705_REG_FACTORY);
+	pr_info("enable(%s), reg[0x%02X]:0x%02x\n",
+		enable ? "ON" : "OFF", SM5705_REG_FACTORY, reg);
+}
+#endif
+
+static bool sm5705_charger_check_oper_otg_mode_on(void)
+{
+	unsigned char current_status = sm5705_charger_oper_get_current_status();
+	bool ret;
+
+	if (current_status & (1 << SM5705_CHARGER_OP_EVENT_OTG)) {
+		ret = true;
+	} else {
+		ret = false;
+	}
+
+	return ret;
+}
+
+static bool sm5705_charger_get_charging_on_status(struct sm5705_charger_data *charger)
+{
+	return sm5705_CHG_get_INT_STATUS(charger, SM5705_INT_STATUS2, SM5705_INT_STATUS2_CHGON);
+}
+
+static bool sm5705_charger_get_power_source_status(struct sm5705_charger_data *charger)
+{
+	int gpio = gpio_get_value(charger->pdata->chg_gpio_en);
+
+	return ((gpio & 0x1)  == 0);    /* charging pin active LOW */
+}
+
+static int sm5705_get_input_current(struct sm5705_charger_data *charger)
+{
+	int get_current;
+
+	if (!(__n_is_cable_type_for_wireless(charger->cable_type))) {
+		get_current = sm5705_CHG_get_INPUT_LIMIT(charger, SM5705_CHG_SRC_WPC);
+	} else {
+		get_current = sm5705_CHG_get_INPUT_LIMIT(charger, SM5705_CHG_SRC_VBUS);
+	}
+#ifdef SM5705_CHG_FULL_DEBUG
+	pr_info("src_type=%d, current=%d\n",
+		__n_is_cable_type_for_wireless(charger->cable_type), get_current);
+#endif
+
+	return get_current;
+}
+
+static int sm5705_get_charge_current(struct sm5705_charger_data *charger)
+{
+	int get_current;
+
+	if (!(__n_is_cable_type_for_wireless(charger->cable_type))) {
+		get_current = sm5705_CHG_get_FASTCHG(charger, SM5705_CHG_SRC_WPC);
+	} else {
+		get_current = sm5705_CHG_get_FASTCHG(charger, SM5705_CHG_SRC_VBUS);
+	}
+	pr_info("src_type=%d, current=%d\n",
+		__n_is_cable_type_for_wireless(charger->cable_type), get_current);
+
+	return get_current;
+}
+
+static void sm5705_enable_charging_on_switch(struct sm5705_charger_data *charger,
+				bool enable)
+{
+	if ((enable == 0) & sm5705_CHG_get_INT_STATUS(charger, SM5705_INT_STATUS1, SM5705_INT_STATUS1_VBUSPOK)) {
+		sm5705_CHG_set_FREQSEL(charger, SM5705_BUCK_BOOST_FREQ_1_5MHz);
+	} else {
+		sm5705_CHG_set_FREQSEL(charger, SM5705_BUCK_BOOST_FREQ_3MHz);
+	}
+
+	gpio_direction_output(charger->pdata->chg_gpio_en, !(enable));
+
+	if (!enable) {
+		/* SET: charging-off condition */
+		charger->charging_current = 0;
+		charger->topoff_pending = 0;
+	}
+
+	sm5705_chg_test_read(charger);
+	pr_info("turn-%s Charging enable pin\n", enable ? "ON" : "OFF");
+}
+
+static int sm5705_set_charge_current(struct sm5705_charger_data *charger,
+				unsigned short charge_current)
+{
+	if (!(__n_is_cable_type_for_wireless(charger->cable_type))) {
+		sm5705_CHG_set_FASTCHG(charger, SM5705_CHG_SRC_WPC, charge_current);
+	} else {
+		sm5705_CHG_set_FASTCHG(charger, SM5705_CHG_SRC_VBUS, charge_current);
+	}
+
+	return 0;
+}
+
+static int sm5705_set_input_current(struct sm5705_charger_data *charger,
+				unsigned short input_current)
+{
+	if (!input_current) {
+		pr_info("skip process, input_current = 0\n");
+		return 0;
+	}
+
+	if (!(__n_is_cable_type_for_wireless(charger->cable_type))) {
+		sm5705_CHG_set_INPUT_LIMIT(charger, SM5705_CHG_SRC_WPC, input_current);
+	} else {
+		sm5705_CHG_set_INPUT_LIMIT(charger, SM5705_CHG_SRC_VBUS, input_current);
+	}
+
+	return 0;
+}
+
+/**
+ *  SM5705 Power-supply class management functions
+ */
+static void sm5705_set_operation_mode(struct sm5705_charger_data *charger)
+{
+	int prev_op_mode, prev_status;
+	prev_op_mode = sm5705_charger_oper_get_current_op_mode();
+	prev_status = sm5705_charger_oper_get_current_status();
+
+	if (charger->cable_type == POWER_SUPPLY_TYPE_OTG ||
+		charger->cable_type == POWER_SUPPLY_TYPE_POWER_SHARING) {
+		sm5705_charger_oper_push_event(SM5705_CHARGER_OP_EVENT_VBUS, DISABLE);
+	} else if (charger->cable_type == POWER_SUPPLY_TYPE_BATTERY) {
+		/* set default value */
+		sm5705_charger_oper_push_event(SM5705_CHARGER_OP_EVENT_VBUS, DISABLE);
+		sm5705_charger_oper_push_event(SM5705_CHARGER_OP_EVENT_OTG, DISABLE);
+
+		if (charger->pdata->support_slow_charging)
+			cancel_delayed_work(&charger->aicl_work);
+	} else {
+#if defined(SM5705_USED_WIRELESS_CHARGER)
+		if (__is_cable_type_for_wireless(charger->cable_type) ||
+			__is_cable_type_for_hv_wireless(charger->cable_type)) {
+			sm5705_charger_oper_push_event(SM5705_CHARGER_OP_EVENT_VBUS, DISABLE);
+			sm5705_charger_oper_push_event(SM5705_CHARGER_OP_EVENT_WPC, ENABLE);
+		} else {
+			sm5705_charger_oper_push_event(SM5705_CHARGER_OP_EVENT_WPC, DISABLE);
+			sm5705_charger_oper_push_event(SM5705_CHARGER_OP_EVENT_VBUS, ENABLE);
+		}
+#else
+		sm5705_charger_oper_push_event(SM5705_CHARGER_OP_EVENT_VBUS, ENABLE);
+#endif
+		if (charger->pdata->support_slow_charging) {
+			pr_info("request aicl work for 5V-TA\n");
+			queue_delayed_work(charger->wqueue, &charger->aicl_work, msecs_to_jiffies(3000));
+		}
+	}
+
+	pr_info("cable = %d, op_mode(%d->%d), op_status(0x%x->0x%x)\n",
+		charger->cable_type,
+		prev_op_mode, sm5705_charger_oper_get_current_op_mode(),
+		prev_status, sm5705_charger_oper_get_current_status());
+}
+
+static void psy_chg_set_usb_hc(struct sm5705_charger_data *charger, int value)
+{
+	if (value) {
+		/* set input/charging current for usb up to TA's current */
+		charger->pdata->charging_current[POWER_SUPPLY_TYPE_USB].fast_charging_current =
+			charger->pdata->charging_current[POWER_SUPPLY_TYPE_MAINS].fast_charging_current;
+		charger->pdata->charging_current[POWER_SUPPLY_TYPE_USB].input_current_limit =
+			charger->pdata->charging_current[POWER_SUPPLY_TYPE_MAINS].input_current_limit;
+	} else {
+		/* restore input/charging current for usb */
+		charger->pdata->charging_current[POWER_SUPPLY_TYPE_USB].fast_charging_current =
+			charger->pdata->charging_current[POWER_SUPPLY_TYPE_BATTERY].input_current_limit;
+		charger->pdata->charging_current[POWER_SUPPLY_TYPE_USB].input_current_limit =
+			charger->pdata->charging_current[POWER_SUPPLY_TYPE_BATTERY].input_current_limit;
+	}
+}
+
+#if defined(SM5705_SUPPORT_OTG_CONTROL)
+static void psy_chg_set_charge_otg_control(struct sm5705_charger_data *charger, int otg_en)
+{
+	union power_supply_propval value;
+
+	psy_do_property("wireless", get, POWER_SUPPLY_PROP_ONLINE, value);
+
+	if (otg_en && !value.intval) {
+		/* OTG - Enable */
+		sm5705_charger_oper_push_event(SM5705_CHARGER_OP_EVENT_VBUS, DISABLE);
+		sm5705_charger_oper_push_event(SM5705_CHARGER_OP_EVENT_OTG, ENABLE);
+		pr_info("OTG enable, cable(%d)\n", charger->cable_type);
+	} else {
+		/* OTG - Disable */
+		if (charger->cable_type == POWER_SUPPLY_TYPE_BATTERY)
+			sm5705_charger_oper_push_event(SM5705_CHARGER_OP_EVENT_VBUS, DISABLE);
+		sm5705_charger_oper_push_event(SM5705_CHARGER_OP_EVENT_OTG, DISABLE);
+		pr_info("OTG disable, cable(%d)\n", charger->cable_type);
+	}
+}
+#endif
+
+#if defined(SM5705_SUPPORT_AICL_CONTROL)
+static void psy_chg_set_aicl_control(struct sm5705_charger_data *charger, int aicl_en)
+{
+	if (aicl_en) {
+		sm5705_CHG_enable_AICL(charger, 1);
+		pr_info("CHGIN AICL ENABLE\n");
+	} else {
+		sm5705_CHG_enable_AICL(charger, 0);
+		pr_info("CHGIN AICL DISABLE\n");
+	}
+}
+#endif
+
+#if defined(CONFIG_AFC_CHARGER_MODE)
+extern void muic_charger_init(void);
+static void psy_chg_set_afc_charger_mode(struct sm5705_charger_data *charger, int afc_mode)
+{
+	pr_info("afc_charger_mode value = %d\n", afc_mode);
+	muic_charger_init();
+}
+#endif
+
+static int sm5705_chg_set_property(struct power_supply *psy,
+				enum power_supply_property psp, const union power_supply_propval *val)
+{
+	struct sm5705_charger_data *charger =
+		container_of(psy, struct sm5705_charger_data, psy_chg);
+	int buck_state = ENABLE;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		pr_info("POWER_SUPPLY_PROP_STATUS - status=%d\n", val->intval);
+		charger->status = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		pr_info("POWER_SUPPLY_PROP_ONLINE - cable(%d->%d)\n",
+			charger->cable_type, val->intval);
+		charger->cable_type = val->intval;
+		charger->input_current = charger->pdata->charging_current
+				[charger->cable_type].input_current_limit;
+		sm5705_set_operation_mode(charger);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		pr_info("POWER_SUPPLY_PROP_CURRENT_MAX - current=%d\n", val->intval);
+		{
+			int input_current = val->intval;
+			if (charger->input_current < input_current) {
+				input_current = charger->input_current;
+			}
+		sm5705_set_input_current(charger, val->intval);
+		}		
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		pr_info("POWER_SUPPLY_PROP_CURRENT_AVG/NOW - current=%d\n", val->intval);
+		charger->charging_current = val->intval;
+		if (charger->is_charging) {
+			/* Fast charge and Termination current */
+			pr_info("%s : fast charging current (%dmA)\n",
+				__func__, charger->charging_current);
+			sm5705_set_charge_current(charger, charger->charging_current);
+		}
+			break;
+	case POWER_SUPPLY_PROP_CURRENT_FULL:
+		if (charger->pdata->full_check_type_2nd == SEC_BATTERY_FULLCHARGED_CHGPSY) {
+			sm5705_CHG_set_TOPOFF(charger, val->intval);
+		}
+		break;
+#if defined(CONFIG_AFC_CHARGER_MODE)
+	case POWER_SUPPLY_PROP_AFC_CHARGER_MODE:
+		psy_chg_set_afc_charger_mode(charger, val->intval);
+		break;
+#endif
+#if defined(CONFIG_BATTERY_SWELLING) || defined(CONFIG_BATTERY_SWELLING_SELF_DISCHARGING)
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+		charger->pdata->chg_float_voltage = val->intval;
+		sm5705_CHG_set_BATREG(charger, val->intval);
+		break;
+#endif
+	case POWER_SUPPLY_PROP_USB_HC:
+		pr_info("POWER_SUPPLY_PROP_USB_HC - value=%d\n", val->intval);
+		psy_chg_set_usb_hc(charger, val->intval);
+		break;
+#if defined(SM5705_SUPPORT_OTG_CONTROL)
+	case POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL:
+		pr_info("POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL - otg_en=%d\n", val->intval);
+		psy_chg_set_charge_otg_control(charger, val->intval);
+		break;
+#endif
+#if defined(SM5705_SUPPORT_AICL_CONTROL)
+	case POWER_SUPPLY_PROP_CHARGE_AICL_CONTROL:
+		pr_info("POWER_SUPPLY_PROP_CHARGE_AICL_CONTROL - aicl_en=%d\n", val->intval);
+		psy_chg_set_aicl_control(charger, val->intval);
+		break;
+#endif
+	case POWER_SUPPLY_PROP_CHARGING_ENABLED:
+		charger->charge_mode = val->intval;
+		switch (charger->charge_mode) {
+		case SEC_BAT_CHG_MODE_BUCK_OFF:
+			buck_state = DISABLE;
+		case SEC_BAT_CHG_MODE_CHARGING_OFF:
+			charger->is_charging = false;
+			break;
+		case SEC_BAT_CHG_MODE_CHARGING:
+			charger->is_charging = true;
+			break;
+		}
+		sm5705_enable_charging_on_switch(charger, charger->is_charging);
+		break;
+	case POWER_SUPPLY_PROP_ENERGY_NOW:
+		/* WA: abnormal swiching case in JIG cable */
+		if (sm5705_call_fg_device_id() <= 2 && !charger->is_rev2_wa_done) {
+			if (val->intval) {
+				pr_info("queue_delayed_work, op_mode_switch_work\n");
+				cancel_delayed_work(&charger->op_mode_switch_work);
+				queue_delayed_work(charger->wqueue, &charger->op_mode_switch_work,
+						msecs_to_jiffies(8000)); /* delay 8sec */
+			} else {
+				cancel_delayed_work(&charger->op_mode_switch_work);
+			}
+		}
+		/* charger off when jig detected */
+		if (val->intval)
+			sm5705_enable_charging_on_switch(charger, false);
+		break;
+#if defined(CONFIG_BATTERY_SWELLING_SELF_DISCHARGING)
+	case POWER_SUPPLY_PROP_RESISTANCE:
+		sm5705_charger_en_discharing_force(charger, val->intval);
+		break;
+#endif
+	case POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX:
+		break;
+	default:
+		pr_err("un-known Power-supply property type (psp=%d)\n", psp);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int psy_chg_get_charge_source_type(struct sm5705_charger_data *charger)
+{
+	int src_type;
+
+	if (sm5705_CHG_get_INT_STATUS(charger, SM5705_INT_STATUS1, SM5705_INT_STATUS1_VBUSPOK)) {
+		src_type = POWER_SUPPLY_TYPE_MAINS;
+	} else if (sm5705_CHG_get_INT_STATUS(charger, SM5705_INT_STATUS1, SM5705_INT_STATUS1_WPCINPOK)) {
+		src_type = POWER_SUPPLY_TYPE_WIRELESS;
+	} else {
+		src_type = POWER_SUPPLY_TYPE_BATTERY;
+	}
+
+	return src_type;
+}
+
+static bool _decide_charge_full_status(struct sm5705_charger_data *charger)
+{
+	if ((sm5705_CHG_get_INT_STATUS(charger, SM5705_INT_STATUS2, SM5705_INT_STATUS2_TOPOFF)) ||
+		(sm5705_CHG_get_INT_STATUS(charger, SM5705_INT_STATUS2, SM5705_INT_STATUS2_DONE))) {
+		return charger->topoff_pending;
+	}
+
+	return false;
+}
+
+
+static int psy_chg_get_charger_state(struct sm5705_charger_data *charger)
+{
+	int status = POWER_SUPPLY_STATUS_UNKNOWN;
+
+	if (_decide_charge_full_status(charger)) {
+		status = POWER_SUPPLY_STATUS_FULL;
+	} else if(sm5705_charger_get_charging_on_status(charger)){
+		status = POWER_SUPPLY_STATUS_CHARGING;
+	} else {
+		if (sm5705_charger_get_power_source_status(charger)) {
+			status = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		} else {
+			status = POWER_SUPPLY_STATUS_DISCHARGING;
+		}
+	}
+
+	return status;
+}
+
+static int psy_chg_get_charge_type(struct sm5705_charger_data *charger)
+{
+	int charge_type;
+
+	if (sm5705_charger_get_charging_on_status(charger)) {
+		if (sm5705_get_input_current(charger) == SLOW_CHARGING_CURRENT_STANDARD) {
+			charge_type = POWER_SUPPLY_CHARGE_TYPE_SLOW;
+		} else {
+			charge_type = POWER_SUPPLY_CHARGE_TYPE_FAST;
+		}
+	} else {
+		charge_type = POWER_SUPPLY_CHARGE_TYPE_NONE;
+	}
+
+	return charge_type;
+}
+
+static int psy_chg_get_charging_health(struct sm5705_charger_data *charger)
+{
+	int state;
+	unsigned char reg_data;
+
+	sm5705_read_reg(charger->i2c, SM5705_REG_STATUS1, &reg_data);
+
+	pr_info("is_charging=%d(%d), cable_type=%d, input_limit=%d, chg_curr=%d, REG_STATUS1=0x%x\n",
+		charger->is_charging, sm5705_charger_get_power_source_status(charger),
+		charger->cable_type, charger->input_current, charger->charging_current,
+		reg_data);
+
+	if (charger->cable_type != POWER_SUPPLY_TYPE_WIRELESS) {
+		if (reg_data & (1 << SM5705_INT_STATUS1_VBUSPOK)) {
+			state = POWER_SUPPLY_HEALTH_GOOD;
+		} else if (reg_data & (1 << SM5705_INT_STATUS1_VBUSOVP)) {
+			state = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+		} else if (reg_data & (1 << SM5705_INT_STATUS1_VBUSUVLO)) {
+			state = POWER_SUPPLY_HEALTH_UNDERVOLTAGE;
+		} else {
+			state = POWER_SUPPLY_HEALTH_UNKNOWN;
+		}
+	} else {
+		if (reg_data & (1 << SM5705_INT_STATUS1_WPCINPOK)) {
+			state = POWER_SUPPLY_HEALTH_GOOD;
+		} else if (reg_data & (1 << SM5705_INT_STATUS1_WPCINOVP)) {
+			state = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+		} else if (reg_data & (1 << SM5705_INT_STATUS1_WPCINUVLO)) {
+			state = POWER_SUPPLY_HEALTH_UNDERVOLTAGE;
+		} else {
+			state = POWER_SUPPLY_HEALTH_UNKNOWN;
+		}
+	}
+
+	return (int)state;
+}
+
+static int sm5705_chg_create_attrs(struct device *dev)
+{
+	int i, rc;
+
+	for (i = 0; i < ARRAY_SIZE(sm5705_charger_attrs); i++) {
+		rc = device_create_file(dev, &sm5705_charger_attrs[i]);
+		if (rc)
+			goto create_attrs_failed;
+	}
+	return rc;
+
+create_attrs_failed:
+	pr_err("failed (%d)\n", rc);
+	while (i--)
+		device_remove_file(dev, &sm5705_charger_attrs[i]);
+	return rc;
+}
+
+ssize_t sm5705_chg_show_attrs(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	const ptrdiff_t offset = attr - sm5705_charger_attrs;
+	int i = 0;
+
+	switch (offset){
+	case CHIP_ID:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%s\n", "SM5705");
+		break;
+	default:
+		return -EINVAL;
+	}
+	return i;
+}
+
+ssize_t sm5705_chg_store_attrs(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	const ptrdiff_t offset = attr - sm5705_charger_attrs;
+	int ret = 0;
+
+	switch(offset){
+	case CHIP_ID:
+		ret = count;
+		break;
+	default:
+		ret = -EINVAL;
+	}
+	return ret;
+}
+
+static int sm5705_chg_get_property(struct power_supply *psy,
+				enum power_supply_property psp, union power_supply_propval *val)
+{
+	struct sm5705_charger_data *charger =
+		container_of(psy, struct sm5705_charger_data, psy_chg);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = psy_chg_get_charge_source_type(charger);
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = sm5705_CHG_get_INT_STATUS(charger,
+						SM5705_INT_STATUS2, SM5705_INT_STATUS2_NOBAT);
+		break;
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = psy_chg_get_charger_state(charger);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+		val->intval = psy_chg_get_charge_type(charger);
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = psy_chg_get_charging_health(charger);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		val->intval = sm5705_get_input_current(charger);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = sm5705_get_charge_current(charger);
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+		val->intval = sm5705_CHG_get_BATREG(charger);
+		break;
+#if defined(CONFIG_AFC_CHARGER_MODE)
+	case POWER_SUPPLY_PROP_AFC_CHARGER_MODE:
+		return -ENODATA;
+#endif
+#if defined(SM5705_SUPPORT_OTG_CONTROL)
+	case POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL:
+		val->intval = sm5705_charger_check_oper_otg_mode_on();
+		break;
+#endif
+#if defined(SM5705_SUPPORT_AICL_CONTROL)
+	case POWER_SUPPLY_PROP_CHARGE_AICL_CONTROL:
+		return -ENODATA;
+#endif
+	case POWER_SUPPLY_PROP_CHARGING_ENABLED:
+		val->intval = sm5705_charger_get_power_source_status(charger);
+		break;
+	case POWER_SUPPLY_PROP_ENERGY_NOW:
+		return -ENODATA;
+#if defined(CONFIG_BATTERY_SWELLING_SELF_DISCHARGING)
+	case POWER_SUPPLY_PROP_RESISTANCE:
+		val->intval = sm5705_charger_get_discharging_force_status(charger);
+		break;
+#endif
+	default:
+		pr_err("un-known Power-supply property type (psp=%d)\n", psp);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static enum power_supply_property sm5705_charger_props[] = {
+};
+
+static int sm5705_otg_get_property(struct power_supply *psy,
+				enum power_supply_property psp, union power_supply_propval *val)
+{
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = sm5705_charger_check_oper_otg_mode_on();
+		pr_info("POWER_SUPPLY_PROP_ONLINE - %s\n", (val->intval) ? "ON" : "OFF");
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int sm5705_otg_set_property(struct power_supply *psy,
+				enum power_supply_property psp, const union power_supply_propval *val)
+{
+	union power_supply_propval value;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		pr_info("POWER_SUPPLY_PROP_ONLINE - %s\n", (val->intval) ? "ON" : "OFF");
+#if defined(SM5705_SUPPORT_OTG_CONTROL)
+		value.intval = val->intval;
+		psy_do_property("sm5705-charger", set, POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL, value);
+#else
+		if (val->intval) {
+			value.intval = POWER_SUPPLY_TYPE_OTG;
+		} else {
+			value.intval = POWER_SUPPLY_TYPE_BATTERY;
+		}
+		psy_do_property("sm5705-charger", set, POWER_SUPPLY_PROP_ONLINE, value);
+#endif
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static enum power_supply_property sm5705_otg_props[] = {
+	POWER_SUPPLY_PROP_ONLINE,
+};
+
+/**
+ *  SM5705 Charger IRQ & Work-queue service management functions
+ */
+ static void sm5705_op_mode_switch_work(struct work_struct *work)
+{
+	struct sm5705_charger_data *charger =
+		container_of(work, struct sm5705_charger_data, op_mode_switch_work.work);
+
+	pr_info("schedule work start.\n");
+
+	charger->is_rev2_wa_done = true;
+	/* OP Mode switch : CHG_ON(init) -> USB_OTG -> CHG_ON -> FLASH_BOOST -> CHG_ON */
+	sm5705_update_reg(charger->i2c, SM5705_REG_CNTL, SM5705_CHARGER_OP_MODE_USB_OTG, 0x07);
+	msleep(2000);
+	sm5705_update_reg(charger->i2c, SM5705_REG_CNTL, SM5705_CHARGER_OP_MODE_CHG_ON, 0x07);
+	msleep(3000);
+	sm5705_update_reg(charger->i2c, SM5705_REG_CNTL, SM5705_CHARGER_OP_MODE_FLASH_BOOST, 0x07);
+	msleep(2000);
+	sm5705_update_reg(charger->i2c, SM5705_REG_CNTL, SM5705_CHARGER_OP_MODE_CHG_ON, 0x07);
+
+	pr_info("schedule work done.\n");
+}
+
+#if EN_TOPOFF_IRQ
+static void sm5705_topoff_work(struct work_struct *work)
+{
+	struct sm5705_charger_data *charger =
+		container_of(work, struct sm5705_charger_data, topoff_work.work);
+	bool topoff = 1;
+	int i;
+
+	pr_info("schedule work start.\n");
+
+	for (i=0; i < 3; ++i) {
+		topoff &= sm5705_CHG_get_INT_STATUS(charger, SM5705_INT_STATUS2, SM5705_INT_STATUS2_TOPOFF);
+		msleep(150);
+
+		pr_info("%dth Check TOP-OFF state=%d\n", i, topoff);
+	}
+
+	charger->topoff_pending = topoff;
+
+	pr_info("schedule work done.\n");
+}
+#endif /*EN_TOPOFF_IRQ*/
+
+static void _reduce_input_limit_current(struct sm5705_charger_data *charger, int cur)
+{
+	unsigned short vbus_limit_current = sm5705_CHG_get_INPUT_LIMIT(charger, SM5705_CHG_SRC_VBUS);
+
+	if ((vbus_limit_current <= MINIMUM_INPUT_CURRENT) || (vbus_limit_current <= cur)) {
+		return;
+	}
+
+	vbus_limit_current = ((vbus_limit_current - cur) < MINIMUM_INPUT_CURRENT) ?
+		MINIMUM_INPUT_CURRENT : vbus_limit_current - cur;
+	sm5705_CHG_set_INPUT_LIMIT(charger, SM5705_CHG_SRC_VBUS, vbus_limit_current);
+
+	charger->input_current = sm5705_get_input_current(charger);
+
+	pr_info("vbus_limit_current=%d, charger->input_current=%d\n",
+		vbus_limit_current, charger->input_current);
+}
+
+static void _check_slow_charging(struct sm5705_charger_data *charger, int input_current)
+{
+	/* under 400mA considered as slow charging concept for VZW */
+	if (input_current <= SLOW_CHARGING_CURRENT_STANDARD &&
+		charger->cable_type != POWER_SUPPLY_TYPE_BATTERY) {
+		union power_supply_propval value;
+
+		pr_info("slow charging on : input current(%dmA), cable type(%d)\n",
+			input_current, charger->cable_type);
+
+		value.intval = POWER_SUPPLY_CHARGE_TYPE_SLOW;
+		psy_do_property("battery", set, POWER_SUPPLY_PROP_CHARGE_TYPE, value);
+	}
+}
+
+static bool _check_aicl_state(struct sm5705_charger_data *charger)
+{
+	return sm5705_CHG_get_INT_STATUS(charger, SM5705_INT_STATUS2, SM5705_INT_STATUS2_AICL);
+}
+
+static void sm5705_aicl_work(struct work_struct *work)
+{
+	struct sm5705_charger_data *charger =
+		container_of(work, struct sm5705_charger_data, aicl_work.work);
+	int prev_current_max, max_count, now_count = 0;
+
+	if (!charger->pdata->support_slow_charging || sm5705_call_fg_device_id() <= 2) {
+		pr_info("don't support AICL work at REV.2\n");
+		return;
+	}
+
+	if (!sm5705_charger_get_charging_on_status(charger) ||
+		__is_cable_type_for_hv_mains(charger->cable_type)) {
+		pr_info("don't need AICL work\n");
+		return;
+	}
+
+	pr_info("schedule work start.\n");
+
+	/* Reduce input limit current */
+	max_count = charger->input_current / REDUCE_CURRENT_STEP;
+	prev_current_max = charger->input_current;
+	while (_check_aicl_state(charger) && (now_count++ < max_count)) {
+		_reduce_input_limit_current(charger, REDUCE_CURRENT_STEP);
+		msleep(AICL_VALID_CHECK_DELAY_TIME);
+	}
+	if (prev_current_max > charger->input_current) {
+		pr_info("charging_current_max(%d --> %d)\n",
+			prev_current_max, charger->input_current);
+		_check_slow_charging(charger, charger->input_current);
+	}
+
+	pr_info("schedule work done.\n");
+}
+
+#if defined(SM5705_USED_WIRELESS_CHARGER)
+static void wc_afc_detect_work(struct work_struct *work)
+{
+	struct sm5705_charger_data *charger = container_of(work, struct sm5705_charger_data, wc_afc_work.work);
+
+	pr_info("schedule work start.\n");
+
+	if (__is_cable_type_for_wireless(charger->cable_type) && \
+		sm5705_charger_get_charging_on_status(charger) && charger->wc_afc_detect) {
+		charger->wc_afc_detect = false;
+
+		if (charger->input_current >=
+			charger->pdata->charging_current[POWER_SUPPLY_TYPE_WIRELESS].input_current_limit) {
+			charger->input_current =
+				charger->pdata->charging_current[POWER_SUPPLY_TYPE_WIRELESS].input_current_limit;
+		}
+		pr_info("current_max(%d)\n", charger->input_current);
+	}
+
+	pr_info("schedule work doen.\n");
+}
+
+static void wpc_detect_work(struct work_struct *work)
+{
+	struct sm5705_charger_data *charger = container_of(work, struct sm5705_charger_data, wpc_work.work);
+	union power_supply_propval value;
+	int wpcin_state;
+
+	pr_info("schedule work start.\n");
+
+#if defined(CONFIG_WIRELESS_CHARGER_P9220)
+	wpcin_state = !gpio_get_value(charger->pdata->irq_gpio);
+#else
+	wpcin_state = gpio_get_value(charger->pdata->wpc_det);
+#endif
+	pr_info("wc_w_state = %d \n", wpcin_state);
+
+	if ((charger->irq_wpcin_state == 0) && (wpcin_state == 1)) {
+		value.intval = 1;
+		psy_do_property("wireless", set, POWER_SUPPLY_PROP_ONLINE, value);
+		value.intval = POWER_SUPPLY_TYPE_WIRELESS;
+		psy_do_property(charger->pdata->wireless_charger_name, set, POWER_SUPPLY_PROP_ONLINE, value);
+
+		pr_info("wpc activated, set V_INT as PN\n");
+	} else if ((charger->irq_wpcin_state == 1) && (wpcin_state == 0)) {
+		value.intval = 0;
+		psy_do_property("wireless", set, POWER_SUPPLY_PROP_ONLINE, value);
+
+		pr_info("wpc deactivated, set V_INT as PD\n");
+	}
+
+	pr_info("w(%d to %d)\n", charger->irq_wpcin_state, wpcin_state);
+
+	charger->irq_wpcin_state = wpcin_state;
+
+	wake_unlock(&charger->wpc_wake_lock);
+
+	pr_info("%s: schedule work done.\n");
+}
+#endif
+
+static unsigned char _get_valid_vbus_status(struct sm5705_charger_data *charger)
+{
+	unsigned char vbusin, prev_vbusin = 0xff;
+	int stable_count = 0;
+
+	while (1) {
+		sm5705_read_reg(charger->i2c, SM5705_REG_STATUS1, &vbusin);
+		vbusin &= 0xF;
+
+		if (prev_vbusin == vbusin) {
+			stable_count++;
+		} else {
+			pr_info("VBUS status mismatch (0x%x / 0x%x), Reset stable count\n",
+				vbusin, prev_vbusin);
+			stable_count = 0;
+		}
+
+		if (stable_count == 10) {
+			break;
+		}
+
+		prev_vbusin = vbusin;
+		msleep(10);
+	}
+
+	return vbusin;
+}
+
+static int _check_vbus_power_supply_status(struct sm5705_charger_data *charger,
+				unsigned char vbus_status, int prev_battery_health)
+{
+	int battery_health = prev_battery_health;
+
+	if (vbus_status & (1 << SM5705_INT_STATUS1_VBUSPOK)) {
+		if (prev_battery_health == POWER_SUPPLY_HEALTH_OVERVOLTAGE) {
+			pr_info("overvoltage->normal\n");
+			battery_health = POWER_SUPPLY_HEALTH_GOOD;
+		} else if (prev_battery_health == POWER_SUPPLY_HEALTH_UNDERVOLTAGE){
+			pr_info("undervoltage->normal\n");
+			battery_health = POWER_SUPPLY_HEALTH_GOOD;
+		}
+	} else {
+		if ((vbus_status & (1 << SM5705_INT_STATUS1_VBUSOVP)) &&
+			(prev_battery_health != POWER_SUPPLY_HEALTH_OVERVOLTAGE)) {
+			pr_info("charger is over voltage\n");
+			battery_health = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+		} else if ((vbus_status & (1 << SM5705_INT_STATUS1_VBUSUVLO)) &&
+			(prev_battery_health != POWER_SUPPLY_HEALTH_UNDERVOLTAGE) &&
+			__n_is_cable_type_for_wireless(charger->cable_type) &&
+			(charger->cable_type != POWER_SUPPLY_TYPE_BATTERY)) {
+			pr_info("vBus is undervoltage\n");
+			battery_health = POWER_SUPPLY_HEALTH_UNDERVOLTAGE;
+		}
+	}
+
+	return battery_health;
+}
+
+static irqreturn_t sm5705_chg_vbus_in_isr(int irq, void *data)
+{
+	struct sm5705_charger_data *charger = data;
+	union power_supply_propval value;
+	unsigned char vbus_status;
+	int prev_battery_health;
+
+	pr_info("start.\n");
+
+	vbus_status = _get_valid_vbus_status(charger);
+
+	psy_do_property("battery", get,POWER_SUPPLY_PROP_HEALTH, value);
+	prev_battery_health = value.intval;
+
+	value.intval = _check_vbus_power_supply_status(charger, vbus_status, prev_battery_health);
+	if (prev_battery_health != value.intval) {
+		psy_do_property("battery", set, POWER_SUPPLY_PROP_HEALTH, value);
+	}
+	pr_info("battery change status [%d] -> [%d] (VBUS_REG:0x%x)\n",
+		prev_battery_health, value.intval, vbus_status);
+
+	/*
+	if (prev_battery_health == POWER_SUPPLY_HEALTH_UNDERVOLTAGE &&
+		value.intval == POWER_SUPPLY_HEALTH_GOOD) {
+		sm5705_set_input_current(charger, charger->input_current);
+	}
+	 */
+	pr_info("done.\n");
+
+	return IRQ_HANDLED;
+}
+
+#if EN_TOPOFF_IRQ
+static irqreturn_t sm5705_chg_topoff_isr(int irq, void *data)
+{
+	struct sm5705_charger_data *charger = data;
+
+	pr_info("IRQ=%d\n", irq);
+
+	charger->topoff_pending = 0;
+	queue_delayed_work(charger->wqueue, &charger->topoff_work, msecs_to_jiffies(500));
+
+	return IRQ_HANDLED;
+}
+#endif /*EN_TOPOFF_IRQ*/
+
+#if EN_OTGFAIL_IRQ
+static irqreturn_t sm5705_chg_otgfail_isr(int irq, void *data)
+{
+	struct sm5705_charger_data *charger = data;
+	unsigned char reg_data;
+
+#ifdef CONFIG_USB_HOST_NOTIFY
+	struct otg_notify *o_notify = get_otg_notify();
+#endif
+	pr_info("IRQ=%d : OTG Failed\n", irq);
+
+	sm5705_read_reg(charger->i2c, SM5705_REG_STATUS3, &reg_data);
+	if (reg_data & SM5705_STATUS3_OTGFAIL) {
+		pr_info("otg overcurrent limit\n");
+#ifdef CONFIG_USB_HOST_NOTIFY
+		send_otg_notify(o_notify, NOTIFY_EVENT_OVERCURRENT, 0);
+#endif
+		psy_chg_set_charge_otg_control(charger, false);
+	}
+
+	return IRQ_HANDLED;
+}
+#endif /*EN_OTGFAIL_IRQ*/
+
+static irqreturn_t sm5705_chg_done_isr(int irq, void *data)
+{
+	struct sm5705_charger_data *charger = data;
+
+	pr_info("%s: start.\n", __func__);
+
+	/* nCHG pin toggle */
+	gpio_direction_output(charger->pdata->chg_gpio_en, charger->is_charging);
+	msleep(10);
+	gpio_direction_output(charger->pdata->chg_gpio_en, !(charger->is_charging));
+
+	return IRQ_HANDLED;
+}
+
+#if defined(SM5705_USED_WIRELESS_CHARGER)
+static irqreturn_t sm5705_chg_wpcin_pok_isr(int irq, void *data)
+{
+	struct sm5705_charger_data *charger = data;
+	unsigned long delay;
+
+#ifdef CONFIG_SAMSUNG_BATTERY_FACTORY
+	delay = msecs_to_jiffies(0);
+#else
+	if (charger->irq_wpcin_state)
+		delay = msecs_to_jiffies(500);
+	else
+		delay = msecs_to_jiffies(0);
+#endif
+	pr_info("IRQ=%d delay = %ld\n", irq, delay);
+
+	wake_lock(&charger->wpc_wake_lock);
+	queue_delayed_work(charger->wqueue, &charger->wpc_work, delay);
+
+	return IRQ_HANDLED;
+}
+#endif
+
+/**
+ *  SM5705 Charger driver management functions
+ **/
+ #if defined(SM5705_WATCHDOG_RESET_ACTIVATE)
+void sm5705_charger_watchdog_timer_keepalive(void)
+{
+    if (g_sm5705_charger) {
+        sm5705_CHG_set_WDTMR_RST(g_sm5705_charger);
+    }
+}
+#endif
+
+#ifdef CONFIG_OF
+static int _parse_sm5705_charger_node_propertys(struct device *dev,
+				struct device_node *np, sec_charger_platform_data_t *pdata)
+{
+	pdata->chg_gpio_en = of_get_named_gpio(np, "battery,chg_gpio_en", 0); //nCHGEN
+	if (IS_ERR_VALUE(pdata->chg_gpio_en)) {
+		pr_info("can't parsing dt:battery,chg_gpio_en\n");
+		return -ENOENT;
+	}
+	pr_info("battery charge enable pin = %d\n", pdata->chg_gpio_en);
+
+#if defined(CONFIG_CHARGING_VZWCONCEPT)
+	pdata->support_slow_charging = true;
+#else
+	pdata->support_slow_charging = of_property_read_bool(np, "battery,support_slow_charging");
+#endif
+
+	return 0;
+}
+
+static int _get_of_charging_current_table_max_size(struct device *dev, struct device_node *np)
+{
+	const unsigned int *propertys;
+	int len;
+
+	propertys = of_get_property(np, "battery,input_current_limit", &len);
+	if (unlikely(!propertys)) {
+		pr_info("can't parsing dt:battery,input_current_limit\n");
+	} else {
+		pr_info("dt:battery,input_current_limit length=%d\n", len);
+	}
+
+	return len / sizeof(unsigned int);
+}
+
+static int _parse_battery_node_propertys(struct device *dev, struct device_node *np,
+				sec_charger_platform_data_t *pdata)
+{
+	int i, array_max_size, ret;
+
+	ret = of_property_read_u32(np, "battery,chg_float_voltage", &pdata->chg_float_voltage);
+	if (IS_ERR_VALUE(ret)) {
+		pr_err("can't parsing dt:battery,chg_float_voltage\n");
+	}
+
+#if defined(SM5705_USED_WIRELESS_CHARGER)
+	ret = of_property_read_string(np,"battery,wirelss_charger_name",
+				(char const **)&pdata->wireless_charger_name);
+	if (IS_ERR_VALUE(ret)) {
+		pr_err("can't parsing dt:battery,wirelss_charger_name\n");
+	}
+	pr_info("wireless charger name=%s\n", pdata->wireless_charger_name);
+
+#if defined(CONFIG_WIRELESS_CHARGER_INBATTERY)
+	pdata->wpc_det = of_get_named_gpio(np, "battery,wpc_det", 0);
+	if (IS_ERR_VALUE(pdata->wpc_det)) {
+		pr_err("can't parsing dt:battery,wpc_det\n");
+		return -ENOENT;
+	}
+	pr_info("WPC detect pin = %d\n", pdata->wpc_det);
+#endif
+
+#if defined(CONFIG_WIRELESS_CHARGER_HIGH_VOLTAGE)
+	ret = of_property_read_u32(np, "battery,wpc_charging_limit_current",
+				&pdata->wpc_charging_limit_current);
+	if (IS_ERR_VALUE(ret)) {
+		pr_err("can't parsing dt:battery,wpc_charging_limit_current\n");
+	}
+
+	ret = of_property_read_u32(np, "battery,sleep_mode_limit_current",
+				&pdata->sleep_mode_limit_current);
+	if (IS_ERR_VALUE(ret)) {
+		pr_err("can't parsing dt:battery,sleep_mode_limit_current\n");
+	}
+#endif
+
+	ret = of_property_read_u32(np, "battery,wireless_cc_cv", &pdata->wireless_cc_cv);
+	if (IS_ERR_VALUE(ret)) {
+		pr_err("can't parsing dt:battery,wireless_cc_cv\n");
+	}
+#endif
+
+	ret = of_property_read_u32(np, "battery,full_check_type_2nd", &pdata->full_check_type_2nd);
+	if (IS_ERR_VALUE(ret)) {
+		pr_err("can't parsing dt:battery,full_check_type_2nd\n");
+	}
+
+	array_max_size = _get_of_charging_current_table_max_size(dev, np);
+	if (array_max_size == 0) {
+		return -ENOENT;
+	}
+	pr_info("charging current table max size = %d\n", array_max_size);
+
+	pdata->charging_current = kzalloc(sizeof(sec_charging_current_t) * array_max_size, GFP_KERNEL);
+	if (unlikely(!pdata->charging_current)) {
+		pr_err("fail to allocate memory for charging current table\n");
+		return -ENOMEM;
+	}
+
+	for(i = 0; i < array_max_size; ++i) {
+		of_property_read_u32_index(np, "battery,input_current_limit",
+			i, &pdata->charging_current[i].input_current_limit);
+	}
+
+	pr_info("dt:battery node parse done.\n");
+
+	return 0;
+}
+
+
+static int sm5705_charger_parse_dt(struct sm5705_charger_data *charger,
+				struct sec_charger_platform_data *pdata)
+{
+	struct device_node *np;
+	int ret;
+
+	np = of_find_node_by_name(NULL, "sm5705-charger");
+	if (np == NULL) {
+		pr_err("fail to find dt_node:sm5705-charger\n");
+		return -ENOENT;
+	} else {
+		ret = _parse_sm5705_charger_node_propertys(charger->dev, np, pdata);
+	}
+
+	np = of_find_node_by_name(NULL, "battery");
+	if (np == NULL) {
+		pr_err("fail to find dt_node:battery\n");
+		return -ENOENT;
+	} else {
+		ret = _parse_battery_node_propertys(charger->dev, np, pdata);
+		if (IS_ERR_VALUE(ret)) {
+			return ret;
+		}
+	}
+
+	return ret;
+}
+#endif
+
+static sec_charger_platform_data_t *_get_sm5705_charger_platform_data
+				(struct platform_device *pdev, struct sm5705_charger_data *charger)
+{
+#ifdef CONFIG_OF
+	sec_charger_platform_data_t *pdata;
+	int ret;
+
+	pdata = kzalloc(sizeof(sec_charger_platform_data_t), GFP_KERNEL);
+	if (!pdata) {
+		pr_err("fail to memory allocate for sec_charger_platform_data\n");
+		return NULL;
+	}
+
+	ret = sm5705_charger_parse_dt(charger, pdata);
+	if (IS_ERR_VALUE(ret)) {
+		pr_err("fail to parse sm5705 charger device tree (ret=%d)\n", ret);
+		kfree(pdata);
+		return NULL;
+	}
+#else
+	struct sm5705_platform_data *sm5705_pdata = dev_get_platdata(sm5705->dev);
+	struct sm5705_dev *sm5705 = dev_get_drvdata(pdev->dev.parent);
+	sec_charger_platform_data_t *pdata;
+
+	pdata = sm5705_pdata->charger_data;
+	if (!pdata) {
+		pr_err("fail to get sm5705 charger platform data\n");
+		return NULL;
+	}
+#endif
+
+	pr_info("Get valid platform data done. (pdata=%p)\n", pdata);
+	return pdata;
+}
+
+static int _init_sm5705_charger_info(struct platform_device *pdev,
+				struct sm5705_dev *sm5705, struct sm5705_charger_data *charger)
+{
+	struct sm5705_platform_data *pdata = dev_get_platdata(sm5705->dev);
+	int ret;
+	mutex_init(&charger->charger_mutex);
+
+	if (pdata == NULL) {
+		pr_err("can't get sm5705_platform_data\n");
+		return -EINVAL;
+	}
+
+	pr_info("init process start..\n");
+
+	/* setup default charger configuration parameter & flagment */
+	charger->wc_afc_detect = false;
+	charger->input_current = 500;
+	charger->topoff_pending = false;
+	charger->is_charging = false;
+	charger->cable_type = POWER_SUPPLY_TYPE_BATTERY;
+	charger->is_mdock = false;
+	charger->is_rev2_wa_done = false;
+
+	/* Request GPIO pin - CHG_IN */
+	if (charger->pdata->chg_gpio_en) {
+		ret = gpio_request(charger->pdata->chg_gpio_en, "sm5705_nCHGEN");
+		if (ret) {
+			pr_err("fail to request GPIO %u\n", charger->pdata->chg_gpio_en);
+			return ret;
+		}
+	}
+
+	/* initialize delayed workqueue */
+	charger->wqueue = create_singlethread_workqueue(dev_name(charger->dev));
+	if (!charger->wqueue) {
+		pr_err("fail to Create Workqueue\n");
+		return -ENOMEM;
+	}
+
+#if defined(SM5705_USED_WIRELESS_CHARGER)
+	INIT_DELAYED_WORK(&charger->wpc_work, wpc_detect_work);
+	INIT_DELAYED_WORK(&charger->wc_afc_work, wc_afc_detect_work);
+#endif
+	if (charger->pdata->support_slow_charging)
+		INIT_DELAYED_WORK(&charger->aicl_work, sm5705_aicl_work);
+#if EN_TOPOFF_IRQ
+	INIT_DELAYED_WORK(&charger->topoff_work, sm5705_topoff_work);
+#endif
+	INIT_DELAYED_WORK(&charger->op_mode_switch_work, sm5705_op_mode_switch_work);
+
+#if defined(SM5705_SW_SOFT_START)
+	wake_lock_init(&charger->softstart_wake_lock, WAKE_LOCK_SUSPEND, "charger-softstart");
+#endif
+	wake_lock_init(&charger->wpc_wake_lock, WAKE_LOCK_SUSPEND, "charger-wpc");
+	wake_lock_init(&charger->check_slow_wake_lock, WAKE_LOCK_SUSPEND, "charger-check-slow");
+	wake_lock_init(&charger->aicl_wake_lock, WAKE_LOCK_SUSPEND, "charger-aicl");
+
+	/* Get IRQ service routine number */
+	charger->irq_wpcin_pok = pdata->irq_base + SM5705_WPCINPOK_IRQ;
+	charger->irq_vbus_pok = pdata->irq_base + SM5705_VBUSPOK_IRQ;
+	charger->irq_aicl = pdata->irq_base + SM5705_AICL_IRQ;
+#if EN_TOPOFF_IRQ
+	charger->irq_topoff = pdata->irq_base + SM5705_TOPOFF_IRQ;
+#endif
+#if EN_OTGFAIL_IRQ
+	charger->irq_otgfail = pdata->irq_base + SM5705_OTGFAIL_IRQ;
+#endif
+	charger->irq_done = pdata->irq_base + SM5705_DONE_IRQ;
+
+	pr_info("init process done..\n");
+
+	return 0;
+}
+
+static void sm5705_charger_initialize(struct sm5705_charger_data *charger)
+{
+	pr_info("charger initial hardware condition process start. (float_voltage=%d)\n",
+		charger->pdata->chg_float_voltage);
+
+	/* Auto-Stop configuration for Emergency status */
+	sm5705_CHG_set_TOPOFF(charger, 300);
+	sm5705_CHG_set_TOPOFF_TMR(charger, SM5705_TOPOFF_TIMER_45m);
+	sm5705_CHG_enable_AUTOSTOP(charger, 1);
+
+	sm5705_CHG_set_BATREG(charger, charger->pdata->chg_float_voltage);
+
+	sm5705_CHG_set_AICLTH(charger, 4500);
+	sm5705_CHG_enable_AICL(charger, 1);
+
+	sm5705_CHG_enable_AUTOSET(charger, 1);
+
+	sm5705_CHG_set_BST_IQ3LIMIT(charger, SM5705_CHG_BST_IQ3LIMIT_3_5A);
+
+	sm5705_CHG_set_OVPSEL(charger, 1); /* fix OVPSEL */
+
+	/* SM5705 Charger Reset contdition initialize */
+#if defined(SM5705_I2C_RESET_ACTIVATE)
+	sm5705_CHG_set_ENI2CRESET(charger, 1);
+#endif
+
+#if defined(SM5705_MANUAL_RESET_ACTIVATE)
+	sm5705_CHG_set_ENMRSTB(charger, SM5705_MANUAL_RESET_TIMER);
+#endif
+
+#if defined(SM5705_WATCHDOG_RESET_ACTIVATE)
+	sm5705_CHG_set_WATCHDOG_TMR(charger, SM5705_WATCHDOG_RESET_TIMER);
+	sm5705_CHG_set_ENWATCHDOG(charger, 1, 1);
+	g_sm5705_charger= charger;
+#endif
+
+	sm5705_chg_test_read(charger);
+
+	pr_info("charger initial hardware condition process done.\n");
+}
+
+static int sm5705_charger_probe(struct platform_device *pdev)
+{
+	struct sm5705_dev *sm5705 = dev_get_drvdata(pdev->dev.parent);
+	struct sm5705_platform_data *pdata = dev_get_platdata(sm5705->dev);
+	struct sm5705_charger_data *charger;
+	int ret = 0;
+
+	pr_info("Sm5705 Charger Driver Probing start\n");
+
+	charger = kzalloc(sizeof(struct sm5705_charger_data), GFP_KERNEL);
+	if (!charger) {
+		pr_err("fail to memory allocate for sm5705 charger handler\n");
+		return -ENOMEM;
+	}
+
+	charger->dev = &pdev->dev;
+	charger->i2c = sm5705->i2c;
+	charger->pdata = _get_sm5705_charger_platform_data(pdev, charger);
+	if (charger->pdata == NULL) {
+		pr_err("fail to get charger platform data\n");
+		goto err_free;
+	}
+
+	ret = _init_sm5705_charger_info(pdev, sm5705, charger);
+	if (IS_ERR_VALUE(ret)) {
+		pr_err("can't initailize sm5705 charger");
+		goto err_free;
+	}
+	platform_set_drvdata(pdev, charger);
+
+	sm5705_charger_initialize(charger);
+
+	charger->psy_chg.name = "sm5705-charger";
+	charger->psy_chg.type = POWER_SUPPLY_TYPE_UNKNOWN;
+	charger->psy_chg.get_property = sm5705_chg_get_property;
+	charger->psy_chg.set_property = sm5705_chg_set_property;
+	charger->psy_chg.properties	= sm5705_charger_props;
+	charger->psy_chg.num_properties	= ARRAY_SIZE(sm5705_charger_props);
+	ret = power_supply_register(&pdev->dev, &charger->psy_chg);
+	if (ret) {
+		pr_err("fail to register psy_chg\n");
+		goto err_power_supply_register;
+	}
+
+	charger->psy_otg.name = "otg";
+	charger->psy_otg.type = POWER_SUPPLY_TYPE_OTG;
+	charger->psy_otg.get_property = sm5705_otg_get_property;
+	charger->psy_otg.set_property = sm5705_otg_set_property;
+	charger->psy_otg.properties	 = sm5705_otg_props;
+	charger->psy_otg.num_properties	= ARRAY_SIZE(sm5705_otg_props);
+	ret = power_supply_register(&pdev->dev, &charger->psy_otg);
+	if (ret) {
+		pr_err("fail to register otg_chg\n");
+		goto err_power_supply_register_chg;
+	}
+
+	/* Operation Mode Initialize */
+	sm5705_charger_oper_table_init(charger->i2c);
+
+	/* Request IRQ */
+#if defined(SM5705_USED_WIRELESS_CHARGER)
+	ret = request_threaded_irq(charger->irq_wpcin_pok, NULL,
+			sm5705_chg_wpcin_pok_isr, IRQF_TRIGGER_FALLING, "wpc-int", charger);
+	if (ret) {
+		pr_err("fail to request wpcin IRQ: %d: %d\n", charger->irq_wpcin_pok, ret);
+		goto err_power_supply_register_otg;
+	}
+#endif
+	ret = request_threaded_irq(charger->irq_vbus_pok, NULL,
+			sm5705_chg_vbus_in_isr, 0, "chgin-irq", charger);
+	if (ret < 0) {
+		pr_err("fail to request chgin IRQ: %d: %d\n", charger->irq_vbus_pok, ret);
+		goto err_power_supply_register_otg;
+	}
+#if EN_TOPOFF_IRQ
+	ret = request_threaded_irq(charger->irq_topoff, NULL,
+			sm5705_chg_topoff_isr, 0, "topoff-irq", charger);
+	if (ret < 0) {
+		pr_err("fail to request topoff IRQ: %d: %d\n", charger->irq_topoff, ret);
+		goto err_power_supply_register_otg;
+	}
+#endif /*EN_TOPOFF_IRQ*/
+#if EN_OTGFAIL_IRQ
+	ret = request_threaded_irq(charger->irq_otgfail, NULL,
+			sm5705_chg_otgfail_isr, 0, "otgfail-irq", charger);
+	if (ret < 0) {
+		pr_err("fail to request otgfail IRQ: %d: %d\n", charger->irq_otgfail, ret);
+		goto err_power_supply_register_otg;
+	}
+#endif
+	ret = request_threaded_irq(charger->irq_done, NULL,
+			sm5705_chg_done_isr, 0, "done-irq", charger);
+	if (ret < 0) {
+		pr_err("fail to request chgin IRQ: %d: %d\n", charger->irq_done, ret);
+		goto err_power_supply_register_otg;
+	}
+
+	ret = sm5705_chg_create_attrs(charger->psy_chg.dev);
+	if (ret){
+		pr_err("Failed to create_attrs\n");
+		goto err_power_supply_register_otg;
+	}
+
+	pr_info("SM5705 Charger Driver Loaded Done\n");
+
+	return 0;
+
+err_power_supply_register_otg:
+	power_supply_unregister(&charger->psy_otg);
+err_power_supply_register_chg:
+	power_supply_unregister(&charger->psy_chg);
+err_power_supply_register:
+	destroy_workqueue(charger->wqueue);
+#ifdef CONFIG_OF
+	kfree(pdata->charger_data);
+#endif
+	mutex_destroy(&charger->charger_mutex);
+err_free:
+	kfree(charger);
+
+	return ret;
+}
+
+static int sm5705_charger_remove(struct platform_device *pdev)
+{
+	struct sm5705_charger_data *charger = platform_get_drvdata(pdev);
+
+#if defined(SM5705_USED_WIRELESS_CHARGER)
+	cancel_delayed_work(&charger->wpc_work);
+	cancel_delayed_work(&charger->wc_afc_work);
+#endif
+	if (charger->pdata->support_slow_charging)
+		cancel_delayed_work(&charger->aicl_work);
+#if EN_TOPOFF_IRQ
+	cancel_delayed_work(&charger->topoff_work);
+#endif
+	cancel_delayed_work(&charger->op_mode_switch_work);
+	destroy_workqueue(charger->wqueue);
+#if defined(SM5705_USED_WIRELESS_CHARGER)
+	free_irq(charger->irq_wpcin_pok, NULL);
+#endif
+	free_irq(charger->irq_vbus_pok, NULL);
+#if EN_TOPOFF_IRQ
+	free_irq(charger->irq_topoff, NULL);
+#endif
+#if EN_OTGFAIL_IRQ
+	free_irq(charger->irq_otgfail, NULL);
+#endif
+
+	power_supply_unregister(&charger->psy_chg);
+	mutex_destroy(&charger->charger_mutex);
+	kfree(charger);
+	return 0;
+}
+
+static void sm5705_charger_shutdown(struct device *dev)
+{
+	struct sm5705_charger_data *charger = dev_get_drvdata(dev);
+
+#if defined(CONFIG_BATTERY_SWELLING_SELF_DISCHARGING)
+	sm5705_charger_en_discharing_force(charger, false);
+#endif
+	sm5705_update_reg(charger->i2c, SM5705_REG_CNTL,
+			SM5705_CHARGER_OP_MODE_CHG_ON, 0x07);
+
+	pr_info("call shutdown\n");
+}
+
+#if defined CONFIG_PM
+static int sm5705_charger_suspend(struct device *dev)
+{
+	pr_info("call suspend\n");
+	return 0;
+}
+
+static int sm5705_charger_resume(struct device *dev)
+{
+	pr_info("call resume\n");
+	return 0;
+}
+#else
+#define sm5705_charger_suspend NULL
+#define sm5705_charger_resume NULL
+#endif
+
+static SIMPLE_DEV_PM_OPS(sm5705_charger_pm_ops, sm5705_charger_suspend, sm5705_charger_resume);
+static struct platform_driver sm5705_charger_driver = {
+	.driver = {
+		.name = "sm5705-charger",
+		.owner = THIS_MODULE,
+		.pm = &sm5705_charger_pm_ops,
+		.shutdown = sm5705_charger_shutdown,
+	},
+	.probe = sm5705_charger_probe,
+	.remove = sm5705_charger_remove,
+};
+
+static int __init sm5705_charger_init(void)
+{
+	return platform_driver_register(&sm5705_charger_driver);
+}
+
+static void __exit sm5705_charger_exit(void)
+{
+	platform_driver_unregister(&sm5705_charger_driver);
+}
+
+
+module_init(sm5705_charger_init);
+module_exit(sm5705_charger_exit);
+
+MODULE_DESCRIPTION("SM5705 Charger Driver");
+MODULE_LICENSE("GPL v2");
+
diff -Naur linux-3.18.14/drivers/battery/sm5705_charger_oper.c samsung/drivers/battery/sm5705_charger_oper.c
--- linux-3.18.14/drivers/battery/sm5705_charger_oper.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery/sm5705_charger_oper.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,230 @@
+/*
+ * drivers/battery/sm5705_charger_oper.c
+ *
+ * SM5705 Charger Operation Mode controller
+ *
+ * Copyright (C) 2015 Siliconmitus Technology Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/battery/charger/sm5705_charger.h>
+#include <linux/battery/charger/sm5705_charger_oper.h>
+
+enum {
+	BST_OUT_4000mV              = 0x0,
+	BST_OUT_4100mV              = 0x1,
+	BST_OUT_4200mV              = 0x2,
+	BST_OUT_4300mV              = 0x3,
+	BST_OUT_4400mV              = 0x4,
+	BST_OUT_4500mV              = 0x5,
+	BST_OUT_4600mV              = 0x6,
+	BST_OUT_4700mV              = 0x7,
+	BST_OUT_4800mV              = 0x8,
+	BST_OUT_4900mV              = 0x9,
+	BST_OUT_5000mV              = 0xA,
+	BST_OUT_5100mV              = 0xB,
+};
+
+enum {
+	OTG_CURRENT_500mA           = 0x0,
+	OTG_CURRENT_700mA           = 0x1,
+	OTG_CURRENT_900mA           = 0x2,
+	OTG_CURRENT_1500mA          = 0x3,
+};
+
+#define SM5705_OPERATION_MODE_MASK  0x07
+#define SM5705_BSTOUT_MASK          0x0F
+#define SM5705_OTGCURRENT_MASK      0xC
+
+struct sm5705_charger_oper_table_info {
+	unsigned char status;
+	unsigned char oper_mode;
+	unsigned char BST_OUT;
+	unsigned char OTG_CURRENT;
+};
+
+struct sm5705_charger_oper_info {
+	struct i2c_client *i2c;
+
+	int max_table_num;
+	struct sm5705_charger_oper_table_info current_table;
+};
+static struct sm5705_charger_oper_info oper_info;
+
+/**
+ *  (VBUS in/out) (WPC in/out) (FLASH on/off) (TORCH on/off) (OTG cable in/out) (Power Sharing cable in/out)
+ **/
+static struct sm5705_charger_oper_table_info sm5705_charger_operation_mode_table[] = {
+	/* Charger mode : Charging ON */
+	{ make_OP_STATUS(0,0,0,0,0,0), SM5705_CHARGER_OP_MODE_CHG_ON, BST_OUT_4500mV, OTG_CURRENT_500mA},
+	{ make_OP_STATUS(1,0,0,0,0,0), SM5705_CHARGER_OP_MODE_CHG_ON, BST_OUT_4500mV, OTG_CURRENT_500mA},
+	{ make_OP_STATUS(1,1,0,0,0,0), SM5705_CHARGER_OP_MODE_CHG_ON, BST_OUT_4500mV, OTG_CURRENT_500mA},
+	{ make_OP_STATUS(1,0,0,1,0,0), SM5705_CHARGER_OP_MODE_CHG_ON, BST_OUT_4500mV, OTG_CURRENT_500mA},
+	{ make_OP_STATUS(1,1,0,1,0,0), SM5705_CHARGER_OP_MODE_CHG_ON, BST_OUT_4500mV, OTG_CURRENT_500mA},
+	{ make_OP_STATUS(0,1,0,0,0,0), SM5705_CHARGER_OP_MODE_CHG_ON, BST_OUT_4500mV, OTG_CURRENT_500mA},
+	/* Charger mode : Flash Boost */
+	{ make_OP_STATUS(0,0,1,0,0,0), SM5705_CHARGER_OP_MODE_FLASH_BOOST, BST_OUT_4500mV, OTG_CURRENT_500mA},
+	{ make_OP_STATUS(0,0,1,0,1,0), SM5705_CHARGER_OP_MODE_FLASH_BOOST, BST_OUT_4500mV, OTG_CURRENT_900mA},
+	{ make_OP_STATUS(0,0,1,0,0,1), SM5705_CHARGER_OP_MODE_FLASH_BOOST, BST_OUT_4500mV, OTG_CURRENT_900mA},
+	{ make_OP_STATUS(0,1,1,0,0,0), SM5705_CHARGER_OP_MODE_FLASH_BOOST, BST_OUT_4500mV, OTG_CURRENT_500mA},
+	{ make_OP_STATUS(0,1,1,0,1,0), SM5705_CHARGER_OP_MODE_FLASH_BOOST, BST_OUT_4500mV, OTG_CURRENT_900mA},
+	{ make_OP_STATUS(0,1,1,0,0,1), SM5705_CHARGER_OP_MODE_FLASH_BOOST, BST_OUT_4500mV, OTG_CURRENT_900mA},
+	{ make_OP_STATUS(1,0,1,0,0,0), SM5705_CHARGER_OP_MODE_FLASH_BOOST, BST_OUT_4500mV, OTG_CURRENT_500mA},
+	{ make_OP_STATUS(1,1,1,0,0,0), SM5705_CHARGER_OP_MODE_FLASH_BOOST, BST_OUT_4500mV, OTG_CURRENT_500mA},
+	{ make_OP_STATUS(0,0,0,1,0,0), SM5705_CHARGER_OP_MODE_FLASH_BOOST, BST_OUT_4500mV, OTG_CURRENT_500mA},
+	/* Charger mode : Wireless OTG & Charger ON */
+	{ make_OP_STATUS(0,1,0,1,1,0), SM5705_CHARGER_OP_MODE_WPC_OTG_CHG_ON, BST_OUT_5100mV, OTG_CURRENT_900mA},
+	{ make_OP_STATUS(0,1,0,1,0,1), SM5705_CHARGER_OP_MODE_WPC_OTG_CHG_ON, BST_OUT_5100mV, OTG_CURRENT_900mA},
+	{ make_OP_STATUS(0,1,0,1,0,0), SM5705_CHARGER_OP_MODE_WPC_OTG_CHG_ON, BST_OUT_4500mV, OTG_CURRENT_500mA},
+	{ make_OP_STATUS(0,1,0,0,1,0), SM5705_CHARGER_OP_MODE_WPC_OTG_CHG_ON, BST_OUT_5100mV, OTG_CURRENT_900mA},
+	{ make_OP_STATUS(0,1,0,0,0,1), SM5705_CHARGER_OP_MODE_WPC_OTG_CHG_ON, BST_OUT_5100mV, OTG_CURRENT_900mA},
+	/* Charger mode : USB OTG */
+	{ make_OP_STATUS(0,0,0,1,1,0), SM5705_CHARGER_OP_MODE_USB_OTG, BST_OUT_5100mV, OTG_CURRENT_900mA},
+	{ make_OP_STATUS(0,0,0,1,0,1), SM5705_CHARGER_OP_MODE_USB_OTG, BST_OUT_5100mV, OTG_CURRENT_900mA},
+	{ make_OP_STATUS(0,0,0,0,1,0), SM5705_CHARGER_OP_MODE_USB_OTG, BST_OUT_5100mV, OTG_CURRENT_900mA},
+	{ make_OP_STATUS(0,0,0,0,0,1), SM5705_CHARGER_OP_MODE_USB_OTG, BST_OUT_5100mV, OTG_CURRENT_900mA},
+};
+
+/**
+ * SM5705 Charger operation mode controller relative I2C setup
+ */
+
+static int sm5705_charger_oper_set_mode(struct i2c_client *i2c, unsigned char mode)
+{
+	return sm5705_update_reg(i2c, SM5705_REG_CNTL, mode, SM5705_OPERATION_MODE_MASK);
+}
+
+static int sm5705_charger_oper_set_BSTOUT(struct i2c_client *i2c, unsigned char BSTOUT)
+{
+	return sm5705_update_reg(i2c, SM5705_REG_FLEDCNTL6, BSTOUT, SM5705_BSTOUT_MASK);
+}
+
+static int sm5705_charger_oper_set_OTG_CURRENT(struct i2c_client *i2c, unsigned char OTG_CURRENT)
+{
+	return sm5705_update_reg(i2c, SM5705_REG_CHGCNTL6, OTG_CURRENT << 2, SM5705_OTGCURRENT_MASK);
+}
+
+/**
+ * SM5705 Charger operation mode controller API functions.
+ */
+
+static inline unsigned char _update_status(int event_type, bool enable)
+{
+	if (event_type > SM5705_CHARGER_OP_EVENT_VBUS) {
+		return oper_info.current_table.status;
+	}
+
+	if (enable) {
+		return (oper_info.current_table.status | (1 << event_type));
+	} else {
+		return (oper_info.current_table.status & ~(1 << event_type));
+	}
+}
+
+static inline void sm5705_charger_oper_change_state(unsigned char new_status)
+{
+	int i;
+
+	for (i=0; i < oper_info.max_table_num; ++i) {
+		if (new_status == sm5705_charger_operation_mode_table[i].status) {
+			break;
+		}
+	}
+	if (i == oper_info.max_table_num) {
+		pr_err("sm5705-charger: %s: can't find matched Charger Operation Mode Table (status = 0x%x)\n", __func__, new_status);
+		return;
+	}
+
+	if (sm5705_charger_operation_mode_table[i].BST_OUT != oper_info.current_table.BST_OUT) {
+		sm5705_charger_oper_set_BSTOUT(oper_info.i2c, sm5705_charger_operation_mode_table[i].BST_OUT);
+		oper_info.current_table.BST_OUT = sm5705_charger_operation_mode_table[i].BST_OUT;
+	}
+	if (sm5705_charger_operation_mode_table[i].OTG_CURRENT != oper_info.current_table.OTG_CURRENT) {
+		sm5705_charger_oper_set_OTG_CURRENT(oper_info.i2c, sm5705_charger_operation_mode_table[i].OTG_CURRENT);
+		oper_info.current_table.OTG_CURRENT = sm5705_charger_operation_mode_table[i].OTG_CURRENT;
+	}
+
+	/* USB_OTG to CHG_ON work-around for BAT_REG stabilize */
+	if (oper_info.current_table.oper_mode == SM5705_CHARGER_OP_MODE_USB_OTG && \
+		sm5705_charger_operation_mode_table[i].oper_mode == SM5705_CHARGER_OP_MODE_CHG_ON) {
+		pr_info("sm5705-charger: %s: trans op_mode:suspend for BAT_REG stabilize (time=100ms)\n", __func__);
+		sm5705_charger_oper_set_mode(oper_info.i2c, SM5705_CHARGER_OP_MODE_SUSPEND);
+		msleep(100);
+	}
+
+	if (sm5705_charger_operation_mode_table[i].oper_mode != oper_info.current_table.oper_mode) {
+		sm5705_charger_oper_set_mode(oper_info.i2c, sm5705_charger_operation_mode_table[i].oper_mode);
+		oper_info.current_table.oper_mode = sm5705_charger_operation_mode_table[i].oper_mode;
+	}
+	oper_info.current_table.status = new_status;
+
+	pr_info("sm5705-charger: %s: New table[%d] info (STATUS: 0x%x, MODE: %d, BST_OUT: 0x%x, OTG_CURRENT: 0x%x\n", \
+			__func__, i, oper_info.current_table.status, oper_info.current_table.oper_mode, oper_info.current_table.BST_OUT, oper_info.current_table.OTG_CURRENT);
+}
+
+int sm5705_charger_oper_push_event(int event_type, bool enable)
+{
+	unsigned char new_status;
+
+	if (oper_info.i2c == NULL) {
+		pr_err("sm5705-charger: %s: required sm5705 charger operation table initialize\n", __func__);
+		return -ENOENT;
+	}
+
+	pr_info("sm5705-charger: %s: event_type=%d, enable=%d\n", __func__, event_type, enable);
+
+	new_status = _update_status(event_type, enable);
+	if (new_status == oper_info.current_table.status) {
+		goto out;
+	}
+
+	sm5705_charger_oper_change_state(new_status);
+
+out:
+	return 0;
+}
+EXPORT_SYMBOL(sm5705_charger_oper_push_event);
+
+int sm5705_charger_oper_table_init(struct i2c_client *i2c)
+{
+	if (i2c == NULL) {
+		pr_err("sm5705-charger: %s: invalid i2c client handler=n", __func__);
+		return -EINVAL;
+	}
+	oper_info.i2c = i2c;
+
+	/* set default operation mode condition */
+	oper_info.max_table_num = ARRAY_SIZE(sm5705_charger_operation_mode_table);
+	oper_info.current_table.status = make_OP_STATUS(0, 0, 0, 0, 0, 0);
+	oper_info.current_table.oper_mode = SM5705_CHARGER_OP_MODE_CHG_ON;
+	oper_info.current_table.BST_OUT = BST_OUT_4500mV;
+	oper_info.current_table.OTG_CURRENT = OTG_CURRENT_500mA;
+
+	sm5705_charger_oper_set_mode(oper_info.i2c, oper_info.current_table.oper_mode);
+	sm5705_charger_oper_set_BSTOUT(oper_info.i2c, oper_info.current_table.BST_OUT);
+	sm5705_charger_oper_set_OTG_CURRENT(oper_info.i2c, oper_info.current_table.OTG_CURRENT);
+
+	pr_info("sm5705-charger: %s: current table info (STATUS: 0x%x, MODE: %d, BST_OUT: 0x%x, OTG_CURRENT: 0x%x\n", \
+			__func__, oper_info.current_table.status, oper_info.current_table.oper_mode, oper_info.current_table.BST_OUT, oper_info.current_table.OTG_CURRENT);
+
+	return 0;
+}
+EXPORT_SYMBOL(sm5705_charger_oper_table_init);
+
+int sm5705_charger_oper_get_current_status(void)
+{
+	return oper_info.current_table.status;
+}
+EXPORT_SYMBOL(sm5705_charger_oper_get_current_status);
+
+int sm5705_charger_oper_get_current_op_mode(void)
+{
+	return oper_info.current_table.oper_mode;
+}
+EXPORT_SYMBOL(sm5705_charger_oper_get_current_op_mode);
diff -Naur linux-3.18.14/drivers/battery/sm5705_fuelgauge.c samsung/drivers/battery/sm5705_fuelgauge.c
--- linux-3.18.14/drivers/battery/sm5705_fuelgauge.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery/sm5705_fuelgauge.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,2645 @@
+/* drivers/battery/sm5705_fuelgauge.c
+ * SM5705 Voltage Tracking Fuelgauge Driver
+ *
+ * Copyright (C) 2013
+ * Author: Dongik Sin <dongik.sin@samsung.com>
+ * Modified by SW Jung
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ */
+
+#define pr_fmt(fmt)	"sm5705-fuelgauge: %s: " fmt, __func__
+
+#include <linux/battery/fuelgauge/sm5705_fuelgauge.h>
+#include <linux/battery/fuelgauge/sm5705_fuelgauge_impl.h>
+#include <linux/uaccess.h>
+#include <linux/of.h>
+#include <linux/fs.h>
+#include <linux/math64.h>
+#include <linux/compiler.h>
+#include <linux/of_gpio.h>
+
+#define SM5705_FG_DEVICE_NAME "sm5705-fg"
+#define ALIAS_NAME "sm5705-fuelgauge"
+
+#define FG_DET_BAT_PRESENT 1
+#define MINVAL(a, b) ((a <= b) ? a : b)
+#define MAXVAL(a, b) ((a > b) ? a : b)
+
+#define LIMIT_N_CURR_MIXFACTOR -2000
+#define FG_ABNORMAL_RESET -1
+#define IGNORE_N_I_OFFSET 1
+#define ABSOLUTE_ERROR_OCV_MATCH 1 
+//#define SM5705_FG_FULL_DEBUG 1
+
+enum battery_table_type {
+	DISCHARGE_TABLE = 0,
+	Q_TABLE,
+	TABLE_MAX,
+};
+
+static int sm5705_device_id = -1;
+
+static struct device_attribute sm5705_fg_attrs[] = {
+	SM5705_FG_ATTR(reg),
+	SM5705_FG_ATTR(data),
+	SM5705_FG_ATTR(regs),
+};
+
+static enum power_supply_property sm5705_fuelgauge_props[] = {
+};
+
+bool sm5705_fg_fuelalert_init(struct i2c_client *client, int soc);
+
+static inline int sm5705_fg_read_device(struct i2c_client *client,
+				      int reg, int bytes, void *dest)
+{
+	int ret;
+
+	if (bytes > 1)
+		ret = i2c_smbus_read_i2c_block_data(client, reg, bytes, dest);
+	else {
+		ret = i2c_smbus_read_byte_data(client, reg);
+		if (ret < 0)
+			return ret;
+		*(unsigned char *)dest = (unsigned char)ret;
+	}
+	return ret;
+}
+
+static int32_t sm5705_fg_i2c_read_word(struct i2c_client *client,
+                        uint8_t reg_addr)
+{
+	uint16_t data = 0;
+	int ret;
+	ret = sm5705_fg_read_device(client, reg_addr, 2, &data);
+	//pr_info("ret = %d, addr = 0x%x, data = 0x%x\n", ret, reg_addr, data);
+
+	if (ret < 0)
+		return ret;
+	else
+		return data;
+
+	// not use big endian
+	//return (int32_t)be16_to_cpu(data);
+}
+
+
+static int32_t sm5705_fg_i2c_write_word(struct i2c_client *client,
+                            uint8_t reg_addr,uint16_t data)
+{
+	int ret;
+
+	// not use big endian
+	//data = cpu_to_be16(data);
+	ret = i2c_smbus_write_i2c_block_data(client, reg_addr, 2, (uint8_t *)&data);
+//	pr_info("ret = %d, addr = 0x%x, data = 0x%x\n", ret, reg_addr, data);
+
+	return ret;
+}
+
+static int32_t sm5705_fg_i2c_verified_write_word(struct i2c_client *client,
+		uint8_t reg_addr,uint16_t data)
+{
+	int ret;
+
+	// not use big endian
+	//data = cpu_to_be16(data);
+	ret = i2c_smbus_write_i2c_block_data(client, reg_addr, 2, (uint8_t *)&data);
+	if(ret<0)
+	{
+		msleep(50);
+		pr_info("1st fail i2c write : ret = %d, addr = 0x%x, data = 0x%x\n", ret, reg_addr, data);
+		ret = i2c_smbus_write_i2c_block_data(client, reg_addr, 2, (uint8_t *)&data);
+		if(ret<0)
+		{
+			msleep(50);
+			pr_info("2nd fail i2c write : ret = %d, addr = 0x%x, data = 0x%x\n", ret, reg_addr, data);
+			ret = i2c_smbus_write_i2c_block_data(client, reg_addr, 2, (uint8_t *)&data);
+			if(ret<0)
+			{
+				pr_info("3rd fail i2c write : ret = %d, addr = 0x%x, data = 0x%x\n", ret, reg_addr, data);
+			}
+		}
+	}
+	//	pr_info("ret = %d, addr = 0x%x, data = 0x%x\n", ret, reg_addr, data);
+
+	return ret;
+}
+
+static int sm5705_get_all_value(struct i2c_client *client);
+static unsigned int sm5705_get_vbat(struct i2c_client *client);
+static unsigned int sm5705_get_ocv(struct i2c_client *client);
+static int sm5705_get_curr(struct i2c_client *client);
+static int sm5705_get_temperature(struct i2c_client *client);
+static unsigned int sm5705_get_soc(struct i2c_client *client);
+static int sm5705_abnormal_reset_check(struct i2c_client *client);
+
+#if 0
+static void sm5705_pr_ver_info(struct i2c_client *client)
+{
+	pr_info("SM5705 Fuel-Gauge Ver %s\n", FG_DRIVER_VER);
+}
+#endif
+
+static unsigned int sm5705_get_ocv(struct i2c_client *client)
+{
+	int ret;
+	unsigned int ocv;// = 3500; /*3500 means 3500mV*/
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+
+	ret = sm5705_fg_i2c_read_word(client, SM5705_REG_OCV);
+	if (ret<0) {
+		pr_err("read ocv reg fail\n");
+		ocv = 4000;
+	} else {
+		ocv = ((ret&0x7800)>>11) * 1000; //integer;
+		ocv = ocv + (((ret&0x07ff)*1000)/2048); // integer + fractional
+	}
+
+	fuelgauge->info.batt_ocv = ocv;
+#ifdef SM5705_FG_FULL_DEBUG
+	pr_info(" read = 0x%x, ocv = %d\n", ret, ocv);
+#endif
+
+	return ocv;
+}
+
+void sm5705_cal_avg_vbat(struct sec_fuelgauge_info *fuelgauge)
+{
+	if (fuelgauge->info.batt_avgvoltage == 0)
+		fuelgauge->info.batt_avgvoltage = fuelgauge->info.batt_voltage;
+
+	else if (fuelgauge->info.batt_voltage == 0 && fuelgauge->info.p_batt_voltage == 0)
+		fuelgauge->info.batt_avgvoltage = 3400;
+
+	else if(fuelgauge->info.batt_voltage == 0)
+		fuelgauge->info.batt_avgvoltage =
+				((fuelgauge->info.batt_avgvoltage) + (fuelgauge->info.p_batt_voltage))/2;
+
+	else if(fuelgauge->info.p_batt_voltage == 0)
+		fuelgauge->info.batt_avgvoltage =
+				((fuelgauge->info.batt_avgvoltage) + (fuelgauge->info.batt_voltage))/2;
+
+	else
+		fuelgauge->info.batt_avgvoltage =
+				((fuelgauge->info.batt_avgvoltage*2) +
+				 (fuelgauge->info.p_batt_voltage+fuelgauge->info.batt_voltage))/4;
+
+#ifdef SM5705_FG_FULL_DEBUG
+	pr_info("batt_avgvoltage = %d\n", fuelgauge->info.batt_avgvoltage);
+#endif
+
+	return;
+}
+
+static unsigned int sm5705_get_vbat(struct i2c_client *client)
+{
+	int ret;
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+
+	unsigned int vbat;/* = 3500; 3500 means 3500mV*/
+
+	ret = sm5705_fg_i2c_read_word(client, SM5705_REG_VOLTAGE);
+	if (ret<0) {
+		pr_err("read vbat reg fail");
+		vbat = 4000;
+	} else {
+		vbat = ((ret&0x3800)>>11) * 1000; //integer;
+		vbat = vbat + (((ret&0x07ff)*1000)/2048); // integer + fractional
+	}
+	fuelgauge->info.batt_voltage = vbat;
+
+#ifdef SM5705_FG_FULL_DEBUG
+	pr_info("read = 0x%x, vbat = %d\n", ret, vbat);
+#endif
+	sm5705_cal_avg_vbat(fuelgauge);
+
+	if ((fuelgauge->volt_alert_flag == true) && vbat > 3400) {
+		fuelgauge->volt_alert_flag = false;
+		sm5705_fg_fuelalert_init(client,
+				fuelgauge->pdata->fuel_alert_soc);
+		pr_info("volt_alert_flag = %d \n", fuelgauge->volt_alert_flag);
+	}
+
+	return vbat;
+}
+
+void sm5705_cal_avg_current(struct sec_fuelgauge_info *fuelgauge)
+{
+	if (fuelgauge->info.batt_avgcurrent == 0)
+		fuelgauge->info.batt_avgcurrent = fuelgauge->info.batt_current;
+
+	else if (fuelgauge->info.batt_avgcurrent == 0 && fuelgauge->info.p_batt_current == 0)
+		fuelgauge->info.batt_avgcurrent = fuelgauge->info.batt_current;
+
+	else if(fuelgauge->info.batt_current == 0)
+		fuelgauge->info.batt_avgcurrent =
+				((fuelgauge->info.batt_avgcurrent) + (fuelgauge->info.p_batt_current))/2;
+
+	else if(fuelgauge->info.p_batt_current == 0)
+		fuelgauge->info.batt_avgcurrent =
+				((fuelgauge->info.batt_avgcurrent) + (fuelgauge->info.batt_current))/2;
+
+	else
+		fuelgauge->info.batt_avgcurrent =
+				((fuelgauge->info.batt_avgcurrent*2) +
+				 (fuelgauge->info.p_batt_current+fuelgauge->info.batt_current))/4;
+
+#ifdef SM5705_FG_FULL_DEBUG
+	pr_info("batt_avgcurrent = %d\n", fuelgauge->info.batt_avgcurrent);
+#endif
+
+	return;
+}
+
+
+static int sm5705_get_curr(struct i2c_client *client)
+{
+	int ret, volt_slope, mohm_volt_cal;
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+
+	int curr;/* = 1000; 1000 means 1000mA*/
+
+	ret = sm5705_fg_i2c_read_word(client, SM5705_REG_CURRENT);
+	if (ret<0) {
+		pr_err("read curr reg fail");
+		curr = 0;
+	} else {
+		curr = ((ret&0x1800)>>11) * 1000; //integer;
+		curr = curr + (((ret&0x07ff)*1000)/2048); // integer + fractional
+
+		if(ret&0x8000) {
+			curr *= -1;
+		}
+	}
+	fuelgauge->info.batt_current = curr;
+
+#ifdef SM5705_FG_FULL_DEBUG
+	pr_info("read = 0x%x, curr = %d\n", ret, curr);
+#endif
+
+	//set vbat offset cancel start
+	volt_slope = sm5705_fg_i2c_read_word(client, SM5705_REG_VOLT_CAL);
+	volt_slope = volt_slope & 0xFF00;
+	mohm_volt_cal = fuelgauge->info.volt_cal & 0x00FF;
+	if(fuelgauge->info.enable_v_offset_cancel_p)
+	{
+		if(fuelgauge->is_charging && (curr > fuelgauge->info.v_offset_cancel_level))
+		{
+			if(mohm_volt_cal & 0x0080)
+			{
+				mohm_volt_cal = -(mohm_volt_cal & 0x007F);
+			}
+			mohm_volt_cal = mohm_volt_cal - (curr/(fuelgauge->info.v_offset_cancel_mohm * 13)); // ((curr*0.001)*0.006)*2048 -> 6mohm
+			if(mohm_volt_cal < 0)
+			{
+				mohm_volt_cal = -mohm_volt_cal;
+				mohm_volt_cal = mohm_volt_cal|0x0080;
+			}
+		}
+	}
+	if(fuelgauge->info.enable_v_offset_cancel_n)
+	{
+		if(!(fuelgauge->is_charging) && (curr < -(fuelgauge->info.v_offset_cancel_level)))
+		{
+			if(fuelgauge->info.volt_cal & 0x0080)
+			{
+				mohm_volt_cal = -(mohm_volt_cal & 0x007F);
+			}
+			mohm_volt_cal = mohm_volt_cal - (curr/(fuelgauge->info.v_offset_cancel_mohm * 13)); // ((curr*0.001)*0.006)*2048 -> 6mohm
+			if(mohm_volt_cal < 0)
+			{
+				mohm_volt_cal = -mohm_volt_cal;
+				mohm_volt_cal = mohm_volt_cal|0x0080;
+			}
+		}
+	}
+	sm5705_fg_i2c_write_word(client, SM5705_REG_VOLT_CAL, (mohm_volt_cal | volt_slope));
+	pr_info("<%d %d %d %d> info.volt_cal = 0x%x, volt_slope = 0x%x, mohm_volt_cal = 0x%x\n",
+			fuelgauge->info.enable_v_offset_cancel_p, fuelgauge->info.enable_v_offset_cancel_n
+			, fuelgauge->info.v_offset_cancel_level, fuelgauge->info.v_offset_cancel_mohm
+			, fuelgauge->info.volt_cal, volt_slope, mohm_volt_cal);
+	//set vbat offset cancel end
+
+	sm5705_cal_avg_current(fuelgauge);
+
+	return curr;
+}
+
+static int sm5705_get_temperature(struct i2c_client *client)
+{
+	int ret;
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+
+	int temp;/* = 250; 250 means 25.0oC*/
+	//double temp_data;
+
+	ret = sm5705_fg_i2c_read_word(client, SM5705_REG_TEMPERATURE);
+	if (ret<0) {
+		pr_err("read temp reg fail");
+		temp = 0;
+	} else {
+		temp = ((ret&0x7F00)>>8) * 10; //integer bit
+		temp = temp + (((ret&0x00f0)*10)/256); // integer + fractional bit
+		if(ret&0x8000) {
+			temp *= -1;
+		}
+	}
+	fuelgauge->info.temp_fg = temp;
+
+#ifdef SM5705_FG_FULL_DEBUG
+	pr_info("read = 0x%x, temp_fg = %d\n", ret, temp);
+#endif
+
+	return temp;
+}
+
+static int sm5705_get_soc_cycle(struct i2c_client *client)
+{
+	int ret;
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+
+	int cycle;
+
+	ret = sm5705_fg_i2c_read_word(client, SM5705_REG_SOC_CYCLE);
+	if (ret<0) {
+		pr_err("read cycle reg fail");
+		cycle = 0;
+	} else {
+		cycle = ret&0x03FF;
+	}
+	fuelgauge->info.batt_soc_cycle = cycle;
+
+#ifdef SM5705_FG_FULL_DEBUG
+	pr_info("read = 0x%x, soc_cycle = %d\n", ret, cycle);
+#endif
+
+	return cycle;
+}
+
+static void sm5705_fg_test_read(struct i2c_client *client)
+{
+	int ret0, ret1, ret2, ret3, ret4, ret5, ret6, ret7;
+
+	ret0 = sm5705_fg_i2c_read_word(client, 0xA0);
+	ret1 = sm5705_fg_i2c_read_word(client, 0xAC);
+	ret2 = sm5705_fg_i2c_read_word(client, 0xAD);
+	ret3 = sm5705_fg_i2c_read_word(client, 0xAE);
+	ret4 = sm5705_fg_i2c_read_word(client, 0xAF);
+	ret5 = sm5705_fg_i2c_read_word(client, 0x28);
+	ret6 = sm5705_fg_i2c_read_word(client, 0x2F);
+	pr_info("%s: 0xA0=0x%04x, 0xAC=0x%04x, 0xAD=0x%04x, 0xAE=0x%04x, 0xAF=0x%04x, 0x28=0x%04x, 0x2F=0x%04x, SM5705_ID=0x%04x\n",
+		__func__, ret0, ret1, ret2, ret3, ret4, ret5, ret6, sm5705_device_id);
+
+	ret0 = sm5705_fg_i2c_read_word(client, 0xB0);
+	ret1 = sm5705_fg_i2c_read_word(client, 0xBC);
+	ret2 = sm5705_fg_i2c_read_word(client, 0xBD);
+	ret3 = sm5705_fg_i2c_read_word(client, 0xBE);
+	ret4 = sm5705_fg_i2c_read_word(client, 0xBF);
+	ret5 = sm5705_fg_i2c_read_word(client, 0x85);
+	ret6 = sm5705_fg_i2c_read_word(client, 0x86);
+	ret7 = sm5705_fg_i2c_read_word(client, 0x87);
+	pr_info("%s: 0xB0=0x%04x, 0xBC=0x%04x, 0xBD=0x%04x, 0xBE=0x%04x, 0xBF=0x%04x, 0x85=0x%04x, 0x86=0x%04x, 0x87=0x%04x \n",
+		__func__, ret0, ret1, ret2, ret3, ret4, ret5, ret6, ret7);
+
+	return;
+}
+
+static unsigned int sm5705_get_device_id(struct i2c_client *client)
+{
+	int ret;
+	ret = sm5705_fg_i2c_read_word(client, SM5705_REG_DEVICE_ID);
+	sm5705_device_id = ret;
+	pr_info("SM5705 device_id = 0x%x\n", ret);
+
+	return ret;
+}
+
+int sm5705_call_fg_device_id(void)
+{
+	pr_info("extern call SM5705 fg_device_id = 0x%x\n", sm5705_device_id);
+
+	return sm5705_device_id;
+}
+
+unsigned int sm5705_get_soc(struct i2c_client *client)
+{
+	int ret;
+	unsigned int soc;
+
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+
+	ret = sm5705_fg_i2c_read_word(client, SM5705_REG_SOC);
+	if (ret<0) {
+		pr_err("Warning!!!! read soc reg fail\n");
+		soc = 500;
+	} else {
+		soc = ((ret&0xff00)>>8) * 10; //integer bit;
+		soc = soc + (((ret&0x00ff)*10)/256); // integer + fractional bit
+	}
+	fuelgauge->info.batt_soc = soc;
+
+#ifdef SM5705_FG_FULL_DEBUG
+	pr_info("read = 0x%x, soc = %d\n", ret, soc);
+#endif
+
+	if (sm5705_abnormal_reset_check(client) < 0)
+		return fuelgauge->info.batt_soc;
+
+	// for low temp power off test
+	if(fuelgauge->info.volt_alert_flag && (fuelgauge->info.temperature < -100))
+	{
+		pr_info("volt_alert_flag is TRUE!!!! SOC make force ZERO!!!!\n");
+		fuelgauge->info.batt_soc = 0;
+		return 0;
+	}
+
+	return soc;
+}
+
+static bool sm5705_fg_check_reg_init_need(struct i2c_client *client)
+{
+	int ret;
+
+	ret = sm5705_fg_i2c_read_word(client, SM5705_REG_FG_OP_STATUS);
+
+	if((ret & INIT_CHECK_MASK) == DISABLE_RE_INIT)
+	{
+		pr_info("SM5705_REG_FG_OP_STATUS : 0x%x , return 0\n", ret);
+		return 0;
+	}
+	else
+	{
+		pr_info("SM5705_REG_FG_OP_STATUS : 0x%x , return 1\n", ret);
+		return 1;
+	}
+}
+
+static void sm5705_fg_buffer_read(struct i2c_client *client)
+{
+	int ret0, ret1, ret2, ret3, ret4, ret5;
+
+	ret0 = sm5705_fg_i2c_read_word(client, 0x30);
+	ret1 = sm5705_fg_i2c_read_word(client, 0x31);
+	ret2 = sm5705_fg_i2c_read_word(client, 0x32);
+	ret3 = sm5705_fg_i2c_read_word(client, 0x33);
+	ret4 = sm5705_fg_i2c_read_word(client, 0x34);
+	ret5 = sm5705_fg_i2c_read_word(client, 0x35);
+	pr_info("sm5705 FG buffer 0x30_0x35 lb_V = 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x \n",
+		ret0, ret1, ret2, ret3, ret4, ret5);
+
+	ret0 = sm5705_fg_i2c_read_word(client, 0x36);
+	ret1 = sm5705_fg_i2c_read_word(client, 0x37);
+	ret2 = sm5705_fg_i2c_read_word(client, 0x38);
+	ret3 = sm5705_fg_i2c_read_word(client, 0x39);
+	ret4 = sm5705_fg_i2c_read_word(client, 0x3A);
+	ret5 = sm5705_fg_i2c_read_word(client, 0x3B);
+	pr_info("sm5705 FG buffer 0x36_0x3B cb_V = 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x \n",
+		ret0, ret1, ret2, ret3, ret4, ret5);
+
+
+	ret0 = sm5705_fg_i2c_read_word(client, 0x40);
+	ret1 = sm5705_fg_i2c_read_word(client, 0x41);
+	ret2 = sm5705_fg_i2c_read_word(client, 0x42);
+	ret3 = sm5705_fg_i2c_read_word(client, 0x43);
+	ret4 = sm5705_fg_i2c_read_word(client, 0x44);
+	ret5 = sm5705_fg_i2c_read_word(client, 0x45);
+	pr_info("sm5705 FG buffer 0x40_0x45 lb_I = 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x \n",
+		ret0, ret1, ret2, ret3, ret4, ret5);
+
+
+	ret0 = sm5705_fg_i2c_read_word(client, 0x46);
+	ret1 = sm5705_fg_i2c_read_word(client, 0x47);
+	ret2 = sm5705_fg_i2c_read_word(client, 0x48);
+	ret3 = sm5705_fg_i2c_read_word(client, 0x49);
+	ret4 = sm5705_fg_i2c_read_word(client, 0x4A);
+	ret5 = sm5705_fg_i2c_read_word(client, 0x4B);
+	pr_info("sm5705 FG buffer 0x46_0x4B cb_I = 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x \n",
+		ret0, ret1, ret2, ret3, ret4, ret5);
+
+	return;
+}
+
+static bool sm5705_fg_get_batt_present(struct i2c_client *client)
+{
+	// SM5705 is not suport batt present
+	pr_debug("sm5705_fg_get_batt_present\n");
+
+	return true;
+}
+
+int sm5705_calculate_iocv(struct i2c_client *client)
+{
+	bool only_lb=false, valid_cb=false, sign_i_offset=0;
+	int roop_start=0, roop_max=0, i=0, cb_last_index = 0, cb_pre_last_index =0;
+	int lb_v_buffer[6] = {0, 0, 0, 0, 0, 0};
+	int lb_i_buffer[6] = {0, 0, 0, 0, 0, 0};
+	int cb_v_buffer[6] = {0, 0, 0, 0, 0, 0};
+	int cb_i_buffer[6] = {0, 0, 0, 0, 0, 0};
+	int i_offset_margin = 0x14, i_vset_margin = 0x67;
+	int v_max=0, v_min=0, v_sum=0, lb_v_avg=0, cb_v_avg=0, lb_v_minmax_offset=0, lb_v_set=0, lb_i_set=0, i_offset=0;
+	int i_max=0, i_min=0, i_sum=0, lb_i_avg=0, cb_i_avg=0, lb_i_minmax_offset=0, cb_v_set=0, cb_i_set=0;
+	int lb_i_p_v_min=0, lb_i_n_v_max=0, cb_i_p_v_min=0, cb_i_n_v_max=0;
+
+	int v_ret=0, i_ret=0, ret=0;
+
+	ret = sm5705_fg_i2c_read_word(client, SM5705_REG_END_V_IDX);
+	pr_info("iocv_status_read = addr : 0x%x , data : 0x%x\n", SM5705_REG_END_V_IDX, ret);
+
+	// init start
+	if((ret & 0x0010) == 0x0000)
+	{
+		only_lb = true;
+	}
+
+	if((ret & 0x0300) == 0x0300)
+	{
+		valid_cb = true;
+	}
+	// init end
+
+	// lb get start
+	roop_max = (ret & 0x000F);
+	if(roop_max > 6)
+		roop_max = 6;
+
+	roop_start = SM5705_REG_IOCV_B_L_MIN;
+	for (i = roop_start; i < roop_start + roop_max; i++)
+	{
+		v_ret = sm5705_fg_i2c_read_word(client, i);
+		i_ret = sm5705_fg_i2c_read_word(client, i+0x10);
+		if((i_ret&0x4000) == 0x4000)
+		{
+			i_ret = -(i_ret&0x3FFF);
+		}
+
+		lb_v_buffer[i-roop_start] = v_ret;
+		lb_i_buffer[i-roop_start] = i_ret;
+
+		if (i == roop_start)
+		{
+			v_max = v_ret;
+			v_min = v_ret;
+			v_sum = v_ret;
+			i_max = i_ret;
+			i_min = i_ret;
+			i_sum = i_ret;
+		}
+		else
+		{
+			if(v_ret > v_max)
+				v_max = v_ret;
+			else if(v_ret < v_min)
+				v_min = v_ret;
+			v_sum = v_sum + v_ret;
+
+			if(i_ret > i_max)
+				i_max = i_ret;
+			else if(i_ret < i_min)
+				i_min = i_ret;
+			i_sum = i_sum + i_ret;
+		}
+
+		if(abs(i_ret) > i_vset_margin)
+		{
+			if(i_ret > 0)
+			{
+				if(lb_i_p_v_min == 0)
+				{
+					lb_i_p_v_min = v_ret;
+				}
+				else
+				{
+					if(v_ret < lb_i_p_v_min)
+						lb_i_p_v_min = v_ret;
+				}
+			}
+			else
+			{
+				if(lb_i_n_v_max == 0)
+				{
+					lb_i_n_v_max = v_ret;
+				}
+				else
+				{
+					if(v_ret > lb_i_n_v_max)
+						lb_i_n_v_max = v_ret;
+				}
+			}
+		}
+	}
+	v_sum = v_sum - v_max - v_min;
+	i_sum = i_sum - i_max - i_min;
+
+	lb_v_minmax_offset = v_max - v_min;
+	lb_i_minmax_offset = i_max - i_min;
+
+	lb_v_avg = v_sum / (roop_max-2);
+	lb_i_avg = i_sum / (roop_max-2);
+	// lb get end
+
+	// lb_vset start
+	if(abs(lb_i_buffer[roop_max-1]) < i_vset_margin)
+	{
+		if(abs(lb_i_buffer[roop_max-2]) < i_vset_margin)
+		{
+			lb_v_set = MAXVAL(lb_v_buffer[roop_max-2], lb_v_buffer[roop_max-1]);
+			if(abs(lb_i_buffer[roop_max-3]) < i_vset_margin)
+			{
+				lb_v_set = MAXVAL(lb_v_buffer[roop_max-3], lb_v_set);
+			}
+		}
+		else
+		{
+			lb_v_set = lb_v_buffer[roop_max-1];
+		}
+	}
+	else
+	{
+		lb_v_set = lb_v_avg;
+	}
+
+	if(lb_i_n_v_max > 0)
+	{
+		lb_v_set = MAXVAL(lb_i_n_v_max, lb_v_set);
+	}
+	//else if(lb_i_p_v_min > 0)
+	//{
+	//	lb_v_set = MINVAL(lb_i_p_v_min, lb_v_set);
+	//}
+	// lb_vset end
+
+	// lb offset make start
+	if(roop_max > 3)
+	{
+		lb_i_set = (lb_i_buffer[2] + lb_i_buffer[3]) / 2;
+	}
+
+	if((abs(lb_i_buffer[roop_max-1]) < i_offset_margin) && (abs(lb_i_set) < i_offset_margin))
+	{
+		lb_i_set = MAXVAL(lb_i_buffer[roop_max-1], lb_i_set);
+	}
+	else if(abs(lb_i_buffer[roop_max-1]) < i_offset_margin)
+	{
+		lb_i_set = lb_i_buffer[roop_max-1];
+	}
+	else if(abs(lb_i_set) < i_offset_margin)
+	{
+		lb_i_set = lb_i_set;
+	}
+	else
+	{
+		lb_i_set = 0;
+	}
+
+	i_offset = lb_i_set;
+
+	i_offset = i_offset + 4;	// add extra offset
+
+	if(i_offset <= 0)
+	{
+		sign_i_offset = 1;
+#if IGNORE_N_I_OFFSET
+		i_offset = 0;
+#else
+		i_offset = -i_offset;
+#endif
+	}
+
+	i_offset = i_offset>>1;
+
+	if(sign_i_offset == 0)
+	{
+		i_offset = i_offset|0x0080;
+	}
+
+	//do not write in kernel point.
+	//sm5705_fg_i2c_write_word(client, SM5705_REG_CURR_OFF, i_offset);
+	// lb offset make end
+
+	pr_info("iocv_l_max=0x%x, iocv_l_min=0x%x, iocv_l_avg=0x%x, lb_v_set=0x%x, roop_max=%d \n",
+		v_max, v_min, lb_v_avg, lb_v_set, roop_max);
+	pr_info("ioci_l_max=0x%x, ioci_l_min=0x%x, ioci_l_avg=0x%x, lb_i_set=0x%x, i_offset=0x%x, sign_i_offset=%d\n",
+		i_max, i_min, lb_i_avg, lb_i_set, i_offset, sign_i_offset);
+
+	if(!only_lb)
+	{
+		// cb get start
+		roop_start = SM5705_REG_IOCV_B_C_MIN;
+		roop_max = 6;
+		for (i = roop_start; i < roop_start + roop_max; i++)
+		{
+			v_ret = sm5705_fg_i2c_read_word(client, i);
+			i_ret = sm5705_fg_i2c_read_word(client, i+0x10);
+			if((i_ret&0x4000) == 0x4000)
+			{
+				i_ret = -(i_ret&0x3FFF);
+			}
+
+			cb_v_buffer[i-roop_start] = v_ret;
+			cb_i_buffer[i-roop_start] = i_ret;
+
+			if (i == roop_start)
+			{
+				v_max = v_ret;
+				v_min = v_ret;
+				v_sum = v_ret;
+				i_max = i_ret;
+				i_min = i_ret;
+				i_sum = i_ret;
+			}
+			else
+			{
+				if(v_ret > v_max)
+					v_max = v_ret;
+				else if(v_ret < v_min)
+					v_min = v_ret;
+				v_sum = v_sum + v_ret;
+
+				if(i_ret > i_max)
+					i_max = i_ret;
+				else if(i_ret < i_min)
+					i_min = i_ret;
+				i_sum = i_sum + i_ret;
+			}
+
+			if(abs(i_ret) > i_vset_margin)
+			{
+				if(i_ret > 0)
+				{
+					if(cb_i_p_v_min == 0)
+					{
+						cb_i_p_v_min = v_ret;
+					}
+					else
+					{
+						if(v_ret < cb_i_p_v_min)
+							cb_i_p_v_min = v_ret;
+					}
+				}
+				else
+				{
+					if(cb_i_n_v_max == 0)
+					{
+						cb_i_n_v_max = v_ret;
+					}
+					else
+					{
+						if(v_ret > cb_i_n_v_max)
+							cb_i_n_v_max = v_ret;
+					}
+				}
+			}
+		}
+		v_sum = v_sum - v_max - v_min;
+		i_sum = i_sum - i_max - i_min;
+
+		cb_v_avg = v_sum / (roop_max-2);
+		cb_i_avg = i_sum / (roop_max-2);
+		// cb get end
+
+		// cb_vset start
+		cb_last_index = (ret & 0x000F)-7; //-6-1
+		if(cb_last_index < 0)
+		{
+			cb_last_index = 5;
+		}
+
+		for (i = roop_max; i > 0; i--)
+		{
+			if(abs(cb_i_buffer[cb_last_index]) < i_vset_margin)
+			{
+				cb_v_set = cb_v_buffer[cb_last_index];
+				if(abs(cb_i_buffer[cb_last_index]) < i_offset_margin)
+				{
+					cb_i_set = cb_i_buffer[cb_last_index];
+				}
+
+				cb_pre_last_index = cb_last_index - 1;
+				if(cb_pre_last_index < 0)
+				{
+					cb_pre_last_index = 5;
+				}
+
+				if(abs(cb_i_buffer[cb_pre_last_index]) < i_vset_margin)
+				{
+					cb_v_set = MAXVAL(cb_v_buffer[cb_pre_last_index], cb_v_set);
+					if(abs(cb_i_buffer[cb_pre_last_index]) < i_offset_margin)
+					{
+						cb_i_set = MAXVAL(cb_i_buffer[cb_pre_last_index], cb_i_set);
+					}
+				}
+			}
+			else
+			{
+				cb_last_index--;
+				if(cb_last_index < 0)
+				{
+					cb_last_index = 5;
+				}
+			}
+		}
+
+		if(cb_v_set == 0)
+		{
+			cb_v_set = cb_v_avg;
+			if(cb_i_set == 0)
+			{
+				cb_i_set = cb_i_avg;
+			}
+		}
+
+		if(cb_i_n_v_max > 0)
+		{
+			cb_v_set = MAXVAL(cb_i_n_v_max, cb_v_set);
+		}
+		//else if(cb_i_p_v_min > 0)
+		//{
+		//	cb_v_set = MINVAL(cb_i_p_v_min, cb_v_set);
+		//}
+		// cb_vset end
+
+		// cb offset make start
+		if(abs(cb_i_set) < i_offset_margin)
+		{
+			if(cb_i_set > lb_i_set)
+			{
+				i_offset = cb_i_set;
+				i_offset = i_offset + 4;	// add extra offset
+				if(i_offset <= 0)
+				{
+					sign_i_offset = 1;
+#if IGNORE_N_I_OFFSET
+					i_offset = 0;
+#else
+					i_offset = -i_offset;
+#endif
+				}
+
+				i_offset = i_offset>>1;
+				if(sign_i_offset == 0)
+				{
+					i_offset = i_offset|0x0080;
+				}
+
+				//do not write in kernel point.
+				//sm5705_fg_i2c_write_word(client, SM5705_REG_CURR_OFF, i_offset);
+			}
+		}
+		// cb offset make end
+
+		pr_info("iocv_c_max=0x%x, iocv_c_min=0x%x, iocv_c_avg=0x%x, cb_v_set=0x%x, cb_last_index=%d \n",
+			v_max, v_min, cb_v_avg, cb_v_set, cb_last_index);
+		pr_info("ioci_c_max=0x%x, ioci_c_min=0x%x, ioci_c_avg=0x%x, cb_i_set=0x%x, i_offset=0x%x, sign_i_offset=%d\n",
+			i_max, i_min, cb_i_avg, cb_i_set, i_offset, sign_i_offset);
+
+	}
+
+	// final set
+	if((abs(cb_i_set) > i_vset_margin) || only_lb)
+	{
+		ret = MAXVAL(lb_v_set, cb_i_n_v_max);
+	}
+	else
+	{
+		ret = cb_v_set;
+	}
+
+	return ret;
+
+}
+
+static void sm5705_set_soc_cycle_cfg(struct i2c_client *client)
+{
+	int value;
+
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+
+	value = fuelgauge->info.cycle_limit_cntl|(fuelgauge->info.cycle_high_limit<<12)|(fuelgauge->info.cycle_low_limit<<8);
+
+	pr_info("cycle cfg value = 0x%x\n", value);
+
+	sm5705_fg_i2c_write_word(client, SM5705_REG_SOC_CYCLE_CFG, value);
+}
+
+static bool sm5705_fg_reg_init(struct i2c_client *client, int is_surge)
+{
+	int i, j, value, ret;
+	uint8_t table_reg;
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+
+	pr_info("sm5705_fg_reg_init START!!\n");
+
+	// init mark
+	sm5705_fg_i2c_write_word(client, SM5705_REG_RESET, SM5705_FG_INIT_MARK);
+
+	// start first param_ctrl unlock
+	sm5705_fg_i2c_write_word(client, SM5705_REG_PARAM_CTRL, SM5705_FG_PARAM_UNLOCK_CODE);
+
+	// RCE write
+	for (i = 0; i < 3; i++)
+	{
+		sm5705_fg_i2c_write_word(client, SM5705_REG_RCE0+i, fuelgauge->info.rce_value[i]);
+		pr_info("RCE write RCE%d = 0x%x : 0x%x\n",  i, SM5705_REG_RCE0+i, fuelgauge->info.rce_value[i]);
+	}
+
+	// DTCD write
+	sm5705_fg_i2c_write_word(client, SM5705_REG_DTCD, fuelgauge->info.dtcd_value);
+	pr_info("DTCD write DTCD = 0x%x : 0x%x\n", SM5705_REG_DTCD, fuelgauge->info.dtcd_value);
+
+	// RS write
+	sm5705_fg_i2c_write_word(client, SM5705_REG_AUTO_RS_MAN, fuelgauge->info.rs_value[0]);
+	pr_info("RS write RS = 0x%x : 0x%x\n", SM5705_REG_AUTO_RS_MAN, fuelgauge->info.rs_value[0]);
+
+	// VIT_PERIOD write
+	sm5705_fg_i2c_write_word(client, SM5705_REG_VIT_PERIOD, fuelgauge->info.vit_period);
+	pr_info("VIT_PERIOD write VIT_PERIOD = 0x%x : 0x%x\n", SM5705_REG_VIT_PERIOD, fuelgauge->info.vit_period);
+
+	// TABLE_LEN write & pram unlock
+	sm5705_fg_i2c_write_word(client, SM5705_REG_PARAM_CTRL, SM5705_FG_PARAM_UNLOCK_CODE | SM5705_FG_TABLE_LEN);
+
+	for (i=0; i < TABLE_MAX; i++)
+	{
+		table_reg = SM5705_REG_TABLE_START + (i<<4);
+		for(j=0; j <= SM5705_FG_TABLE_LEN; j++)
+		{
+			sm5705_fg_i2c_write_word(client, (table_reg + j), fuelgauge->info.battery_table[i][j]);
+			msleep(10);
+			if(fuelgauge->info.battery_table[i][j] != sm5705_fg_i2c_read_word(client, (table_reg + j)))
+			{
+				pr_info("TABLE write FAIL retry[%d][%d] = 0x%x : 0x%x\n",
+					i, j, (table_reg + j), fuelgauge->info.battery_table[i][j]);
+				sm5705_fg_i2c_write_word(client, (table_reg + j), fuelgauge->info.battery_table[i][j]);
+			}
+			pr_info("TABLE write OK [%d][%d] = 0x%x : 0x%x\n",
+				i, j, (table_reg + j), fuelgauge->info.battery_table[i][j]);
+		}
+	}
+
+	// MIX_MODE write
+	sm5705_fg_i2c_write_word(client, SM5705_REG_RS_MIX_FACTOR, fuelgauge->info.rs_value[2]);
+	sm5705_fg_i2c_write_word(client, SM5705_REG_RS_MAX, fuelgauge->info.rs_value[3]);
+	sm5705_fg_i2c_write_word(client, SM5705_REG_RS_MIN, fuelgauge->info.rs_value[4]);
+	sm5705_fg_i2c_write_word(client, SM5705_REG_MIX_RATE, fuelgauge->info.mix_value[0]);
+	sm5705_fg_i2c_write_word(client, SM5705_REG_MIX_INIT_BLANK, fuelgauge->info.mix_value[1]);
+
+	pr_info("RS_MIX_FACTOR = 0x%x, RS_MAX = 0x%x, RS_MIN = 0x%x, MIX_RATE = 0x%x, MIX_INIT_BLANK = 0x%x\n",
+		fuelgauge->info.rs_value[2], fuelgauge->info.rs_value[3], fuelgauge->info.rs_value[4],
+		fuelgauge->info.mix_value[0], fuelgauge->info.mix_value[1]);
+
+	// CAL write
+	sm5705_fg_i2c_write_word(client, SM5705_REG_VOLT_CAL, fuelgauge->info.volt_cal);
+	sm5705_fg_i2c_write_word(client, SM5705_REG_CURR_OFF, fuelgauge->info.curr_offset);
+	sm5705_fg_i2c_write_word(client, SM5705_REG_CURR_P_SLOPE, fuelgauge->info.p_curr_cal);
+	sm5705_fg_i2c_write_word(client, SM5705_REG_CURR_N_SLOPE, fuelgauge->info.n_curr_cal);
+	pr_info("VOLT_CAL = 0x%x, curr_offset = 0x%x, p_curr_cal = 0x%x, n_curr_cal = 0x%x\n",
+		fuelgauge->info.volt_cal, fuelgauge->info.curr_offset,
+		fuelgauge->info.p_curr_cal, fuelgauge->info.n_curr_cal);
+
+	// MISC write
+	sm5705_fg_i2c_write_word(client, SM5705_REG_MISC, fuelgauge->info.misc);
+	pr_info("SM5705_REG_MISC 0x%x : 0x%x\n", SM5705_REG_MISC, fuelgauge->info.misc);
+
+	// TOPOFF SOC
+	sm5705_fg_i2c_write_word(client, SM5705_REG_TOPOFFSOC, fuelgauge->info.topoff_soc);
+	pr_info("SM5705_REG_TOPOFFSOC 0x%x : 0x%x\n", SM5705_REG_TOPOFFSOC, fuelgauge->info.topoff_soc);
+
+	// INIT_last -  control register set
+	value = sm5705_fg_i2c_read_word(client, SM5705_REG_CNTL);
+	if(value == CNTL_REG_DEFAULT_VALUE)
+	{
+		value = fuelgauge->info.cntl_value;
+	}
+	value = ENABLE_MIX_MODE | ENABLE_TEMP_MEASURE | ENABLE_MANUAL_OCV | (fuelgauge->info.enable_topoff_soc << 13);
+	pr_info("SM5705_REG_CNTL reg : 0x%x\n", value);
+
+	ret = sm5705_fg_i2c_write_word(client, SM5705_REG_CNTL, value);
+	if (ret < 0)
+		pr_info("fail control register set(%d)\n",  ret);
+
+	pr_info("LAST SM5705_REG_CNTL = 0x%x : 0x%x\n", SM5705_REG_CNTL, value);
+
+	// LOCK
+	value = SM5705_FG_PARAM_LOCK_CODE | SM5705_FG_TABLE_LEN;
+	sm5705_fg_i2c_write_word(client, SM5705_REG_PARAM_CTRL, value);
+	pr_info("LAST PARAM CTRL VALUE = 0x%x : 0x%x\n", SM5705_REG_PARAM_CTRL, value);
+
+	// surge reset defence
+	if(is_surge)
+	{
+		value = ((fuelgauge->info.batt_ocv<<8)/125);
+	}
+	else
+	{
+		value = sm5705_calculate_iocv(client);
+
+		if((fuelgauge->info.volt_cal & 0x0080) == 0x0080)
+		{
+			value = value - (fuelgauge->info.volt_cal & 0x007F);
+		}
+		else
+		{
+			value = value + (fuelgauge->info.volt_cal & 0x007F);
+		}
+	}
+
+	sm5705_fg_i2c_write_word(client, SM5705_REG_IOCV_MAN, value);
+	pr_info("IOCV_MAN_WRITE = %d : 0x%x\n", fuelgauge->info.batt_ocv, value);
+
+	// init delay
+	msleep(20);
+
+	return 1;
+}
+
+static bool sm5705_fg_init(struct i2c_client *client, bool is_surge)
+{
+	int ret;
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+
+	fuelgauge->info.is_FG_initialised = 0;
+	fuelgauge->info.iocv_error_count = 0;
+
+	//board_fuelgauge_init(fuelgauge);
+
+	//SM5705 i2c read check
+	ret = sm5705_get_device_id(client);
+	if (ret < 0)
+	{
+		pr_info("fail to do i2c read(%d)\n", ret);
+	}
+
+	if(fuelgauge->info.batt_ocv == 0)
+	{
+		sm5705_get_ocv(client);
+	}
+
+	ret = sm5705_fg_i2c_read_word(client, SM5705_REG_CNTL);
+	if(ret != CNTL_REG_DEFAULT_VALUE)
+	{
+		fuelgauge->info.cntl_value = ret;
+	}
+
+	sm5705_set_soc_cycle_cfg(client);
+
+	if(sm5705_fg_check_reg_init_need(client))
+	{
+		sm5705_fg_reg_init(client, is_surge);
+	}
+
+	// curr_off save and restore
+	if(fuelgauge->info.en_auto_curr_offset)
+	{
+		ret = sm5705_fg_i2c_read_word(client, SM5705_REG_CURR_OFF);
+		fuelgauge->info.curr_offset = ret;
+	}
+	else
+	{
+		sm5705_fg_i2c_write_word(client, SM5705_REG_CURR_OFF, fuelgauge->info.curr_offset);
+	}
+
+	// set lcal
+	if(fuelgauge->info.curr_lcal_en)
+	{
+		sm5705_fg_i2c_write_word(client, SM5705_REG_CURRLCAL_0, fuelgauge->info.curr_lcal_0);
+		sm5705_fg_i2c_write_word(client, SM5705_REG_CURRLCAL_1, fuelgauge->info.curr_lcal_1);
+		sm5705_fg_i2c_write_word(client, SM5705_REG_CURRLCAL_2, fuelgauge->info.curr_lcal_2);
+	}
+
+	fuelgauge->info.is_FG_initialised = 1;
+
+	// get first measure all value
+	//soc
+	sm5705_get_soc(client);
+	//vbat
+	sm5705_get_vbat(client);
+	//current
+	sm5705_get_curr(client);
+	//ocv
+	sm5705_get_ocv(client);
+	//temperature
+	sm5705_get_temperature(client);
+
+	//cycle
+	sm5705_get_soc_cycle(client);
+
+	pr_info("vbat=%d, vbat_avg=%d, curr=%d, curr_avg=%d, ocv=%d, temp=%d, "
+		"cycle=%d, soc=%d, state=0x%x, Q=0x%x\n",
+		fuelgauge->info.batt_voltage, fuelgauge->info.batt_avgvoltage,
+		fuelgauge->info.batt_current, fuelgauge->info.batt_avgcurrent, fuelgauge->info.batt_ocv,
+		fuelgauge->info.temp_fg, fuelgauge->info.batt_soc_cycle, fuelgauge->info.batt_soc,
+		sm5705_fg_i2c_read_word(client, SM5705_REG_OCV_STATE),
+		sm5705_fg_i2c_read_word(client, SM5705_REG_Q_EST));
+
+	// for debug
+	sm5705_fg_buffer_read(client);
+	sm5705_fg_test_read(client);
+
+	return true;
+}
+
+static int sm5705_abnormal_reset_check(struct i2c_client *client)
+{
+	int cntl_read, reset_read;
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+
+	reset_read = sm5705_fg_i2c_read_word(client, SM5705_REG_RESET) & 0xF000;
+	// abnormal case.... SW reset
+	if((sm5705_fg_check_reg_init_need(client) && (fuelgauge->info.is_FG_initialised == 1)) || (reset_read == 0))
+	{
+		cntl_read = sm5705_fg_i2c_read_word(client, SM5705_REG_CNTL);
+		pr_info("SM5705 FG abnormal case!!!! SM5705_REG_CNTL : 0x%x, reset_read : 0x%x\n", cntl_read, reset_read);
+		// SW reset code
+		if(sm5705_fg_i2c_verified_write_word(client, SM5705_REG_RESET, SW_RESET_OTP_CODE) < 0)
+		{
+			pr_info("Warning!!!! SM5705 FG abnormal case.... SW reset FAIL \n");
+		}
+		else
+		{
+			pr_info("SM5705 FG abnormal case.... SW reset OK\n");
+		}
+		// delay 100ms
+		msleep(100);
+		// init code
+		sm5705_fg_init(client, true);
+		return FG_ABNORMAL_RESET;
+	}
+	return 0;
+}
+
+void sm5705_vbatocv_check(struct i2c_client *client)
+{
+	int ret;
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+
+	// iocv error case cover start
+#ifdef ABSOLUTE_ERROR_OCV_MATCH
+	if((abs(fuelgauge->info.batt_current)<40) ||
+		((fuelgauge->is_charging) && (fuelgauge->info.batt_current<(fuelgauge->info.top_off)) &&
+		(fuelgauge->info.batt_current>(fuelgauge->info.top_off/3))))
+#else
+	if(((!fuelgauge->ta_exist) && (fuelgauge->info.batt_current<0) && (fuelgauge->info.batt_current>-40)) ||
+		((fuelgauge->ta_exist) && (fuelgauge->info.batt_current>0) && (fuelgauge->info.batt_current<40)) ||
+		((fuelgauge->is_charging) && (fuelgauge->info.batt_current<(fuelgauge->info.top_off)) &&
+		(fuelgauge->info.batt_current>(fuelgauge->info.top_off/3))))
+#endif
+	{
+		if(abs(fuelgauge->info.batt_ocv-fuelgauge->info.batt_voltage)>30) // 30mV over
+		{
+			fuelgauge->info.iocv_error_count ++;
+		}
+
+		pr_info("sm5705 FG iocv_error_count (%d)\n", fuelgauge->info.iocv_error_count);
+
+		if(fuelgauge->info.iocv_error_count > 5) // prevent to overflow
+			fuelgauge->info.iocv_error_count = 6;
+	}
+	else
+	{
+		fuelgauge->info.iocv_error_count = 0;
+	}
+
+	if(fuelgauge->info.iocv_error_count > 5)
+	{
+		pr_info("p_v - v = (%d)\n", fuelgauge->info.p_batt_voltage - fuelgauge->info.batt_voltage);
+		if(abs(fuelgauge->info.p_batt_voltage - fuelgauge->info.batt_voltage)>15) // 15mV over
+		{
+			fuelgauge->info.iocv_error_count = 0;
+		}
+		else
+		{
+			// mode change to mix RS manual mode
+			pr_info("mode change to mix RS manual mode\n");
+			// run update set
+			sm5705_fg_i2c_write_word(client, SM5705_REG_PARAM_RUN_UPDATE, 1);
+			// RS manual value write
+			sm5705_fg_i2c_write_word(client, SM5705_REG_RS_MAN, fuelgauge->info.rs_value[0]);
+			// run update set
+			sm5705_fg_i2c_write_word(client, SM5705_REG_PARAM_RUN_UPDATE, 0);
+			// mode change
+			ret = sm5705_fg_i2c_read_word(client, SM5705_REG_CNTL);
+			ret = (ret | ENABLE_MIX_MODE) | ENABLE_RS_MAN_MODE; // +RS_MAN_MODE
+			sm5705_fg_i2c_write_word(client, SM5705_REG_CNTL, ret);
+		}
+	}
+	else
+	{
+		if((fuelgauge->info.temperature/10) > 15)
+		{
+			if((fuelgauge->info.p_batt_voltage < fuelgauge->info.n_tem_poff) &&
+				(fuelgauge->info.batt_voltage < fuelgauge->info.n_tem_poff) && (!fuelgauge->is_charging))
+			{
+				pr_info("mode change to normal tem mix RS manual mode\n");
+				// mode change to mix RS manual mode
+				// run update init
+				sm5705_fg_i2c_write_word(client, SM5705_REG_PARAM_RUN_UPDATE, 1);
+				// RS manual value write
+				if((fuelgauge->info.p_batt_voltage <
+					(fuelgauge->info.n_tem_poff - fuelgauge->info.n_tem_poff_offset)) &&
+					(fuelgauge->info.batt_voltage <
+					(fuelgauge->info.n_tem_poff - fuelgauge->info.n_tem_poff_offset)))
+				{
+					sm5705_fg_i2c_write_word(client, SM5705_REG_RS_MAN, fuelgauge->info.rs_value[0]>>1);
+				}
+				else
+				{
+					sm5705_fg_i2c_write_word(client, SM5705_REG_RS_MAN, fuelgauge->info.rs_value[0]);
+				}
+				// run update set
+				sm5705_fg_i2c_write_word(client, SM5705_REG_PARAM_RUN_UPDATE, 0);
+
+				// mode change
+				ret = sm5705_fg_i2c_read_word(client, SM5705_REG_CNTL);
+				ret = (ret | ENABLE_MIX_MODE) | ENABLE_RS_MAN_MODE; // +RS_MAN_MODE
+				sm5705_fg_i2c_write_word(client, SM5705_REG_CNTL, ret);
+			}
+			else
+			{
+				pr_info("mode change to mix RS auto mode\n");
+
+				// mode change to mix RS auto mode
+				ret = sm5705_fg_i2c_read_word(client, SM5705_REG_CNTL);
+				ret = (ret | ENABLE_MIX_MODE) & ~ENABLE_RS_MAN_MODE; // -RS_MAN_MODE
+				sm5705_fg_i2c_write_word(client, SM5705_REG_CNTL, ret);
+			}
+		}
+		else
+		{
+			if((fuelgauge->info.p_batt_voltage < fuelgauge->info.l_tem_poff) &&
+				(fuelgauge->info.batt_voltage < fuelgauge->info.l_tem_poff) && (!fuelgauge->is_charging))
+			{
+				pr_info("mode change to normal tem mix RS manual mode\n");
+				// mode change to mix RS manual mode
+				// run update init
+				sm5705_fg_i2c_write_word(client, SM5705_REG_PARAM_RUN_UPDATE, 1);
+				// RS manual value write
+				if((fuelgauge->info.p_batt_voltage <
+					(fuelgauge->info.l_tem_poff - fuelgauge->info.l_tem_poff_offset)) &&
+					(fuelgauge->info.batt_voltage <
+					(fuelgauge->info.l_tem_poff - fuelgauge->info.l_tem_poff_offset)))
+				{
+					sm5705_fg_i2c_write_word(client, SM5705_REG_RS_MAN, fuelgauge->info.rs_value[0]>>1);
+				}
+				else
+				{
+					sm5705_fg_i2c_write_word(client, SM5705_REG_RS_MAN, fuelgauge->info.rs_value[0]);
+				}
+				// run update set
+				sm5705_fg_i2c_write_word(client, SM5705_REG_PARAM_RUN_UPDATE, 0);
+
+				// mode change
+				ret = sm5705_fg_i2c_read_word(client, SM5705_REG_CNTL);
+				ret = (ret | ENABLE_MIX_MODE) | ENABLE_RS_MAN_MODE; // +RS_MAN_MODE
+				sm5705_fg_i2c_write_word(client, SM5705_REG_CNTL, ret);
+			}
+			else
+			{
+				pr_info("mode change to mix RS auto mode\n");
+
+				// mode change to mix RS auto mode
+				ret = sm5705_fg_i2c_read_word(client, SM5705_REG_CNTL);
+				ret = (ret | ENABLE_MIX_MODE) & ~ENABLE_RS_MAN_MODE; // -RS_MAN_MODE
+				sm5705_fg_i2c_write_word(client, SM5705_REG_CNTL, ret);
+			}
+		}
+	}
+	fuelgauge->info.p_batt_voltage = fuelgauge->info.batt_voltage;
+	fuelgauge->info.p_batt_current = fuelgauge->info.batt_current;
+	// iocv error case cover end
+}
+
+static int sm5705_cal_carc (struct i2c_client *client)
+{
+	int p_curr_cal=0, n_curr_cal=0, p_delta_cal=0, n_delta_cal=0, p_fg_delta_cal=0, n_fg_delta_cal=0, temp_curr_offset=0;
+	int volt_cal=0, fg_delta_volcal=0, pn_volt_slope=0, volt_offset=0;
+	int temp_gap, fg_temp_gap, mix_factor=0;
+
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+
+	sm5705_vbatocv_check(client);
+
+	if(fuelgauge->is_charging || (fuelgauge->info.batt_current < LIMIT_N_CURR_MIXFACTOR))
+	{
+		mix_factor = fuelgauge->info.rs_value[1];
+	}
+	else
+	{
+		mix_factor = fuelgauge->info.rs_value[2];
+	}
+	sm5705_fg_i2c_write_word(client, SM5705_REG_RS_MIX_FACTOR, mix_factor);
+
+	fg_temp_gap = (fuelgauge->info.temp_fg/10) - fuelgauge->info.temp_std;
+
+	volt_cal = sm5705_fg_i2c_read_word(client, SM5705_REG_VOLT_CAL);
+	volt_offset = volt_cal & 0x00FF;
+	pn_volt_slope = fuelgauge->info.volt_cal & 0xFF00;
+
+	if (fuelgauge->info.en_fg_temp_volcal)
+	{
+		fg_delta_volcal = (fg_temp_gap / fuelgauge->info.fg_temp_volcal_denom)*fuelgauge->info.fg_temp_volcal_fact;
+		pn_volt_slope = pn_volt_slope + (fg_delta_volcal<<8);
+		volt_cal = pn_volt_slope | volt_offset;
+		sm5705_fg_i2c_write_word(client, SM5705_REG_VOLT_CAL, volt_cal);
+	}
+
+	temp_curr_offset = fuelgauge->info.curr_offset;
+	if(fuelgauge->info.en_high_fg_temp_offset && (fg_temp_gap > 0))
+	{
+		if(temp_curr_offset & 0x0080)
+		{
+			temp_curr_offset = -(temp_curr_offset & 0x007F);
+		}
+		temp_curr_offset = temp_curr_offset + (fg_temp_gap / fuelgauge->info.high_fg_temp_offset_denom)*fuelgauge->info.high_fg_temp_offset_fact;
+		if(temp_curr_offset < 0)
+		{
+			temp_curr_offset = -temp_curr_offset;
+			temp_curr_offset = temp_curr_offset|0x0080;
+		}
+	}
+	else if (fuelgauge->info.en_low_fg_temp_offset && (fg_temp_gap < 0))
+	{
+		if(temp_curr_offset & 0x0080)
+		{
+			temp_curr_offset = -(temp_curr_offset & 0x007F);
+		}
+		temp_curr_offset = temp_curr_offset + ((-fg_temp_gap) / fuelgauge->info.low_fg_temp_offset_denom)*fuelgauge->info.low_fg_temp_offset_fact;
+		if(temp_curr_offset < 0)
+		{
+			temp_curr_offset = -temp_curr_offset;
+			temp_curr_offset = temp_curr_offset|0x0080;
+		}
+	}
+	sm5705_fg_i2c_write_word(client, SM5705_REG_CURR_OFF, temp_curr_offset);
+
+
+	n_curr_cal = fuelgauge->info.n_curr_cal;
+	p_curr_cal = fuelgauge->info.p_curr_cal;
+
+	if (fuelgauge->info.en_high_fg_temp_cal && (fg_temp_gap > 0))
+	{
+		p_fg_delta_cal = (fg_temp_gap / fuelgauge->info.high_fg_temp_p_cal_denom)*fuelgauge->info.high_fg_temp_p_cal_fact;
+		n_fg_delta_cal = (fg_temp_gap / fuelgauge->info.high_fg_temp_n_cal_denom)*fuelgauge->info.high_fg_temp_n_cal_fact;
+	}
+	else if (fuelgauge->info.en_low_fg_temp_cal && (fg_temp_gap < 0))
+	{
+		fg_temp_gap = -fg_temp_gap;
+		p_fg_delta_cal = (fg_temp_gap / fuelgauge->info.low_fg_temp_p_cal_denom)*fuelgauge->info.low_fg_temp_p_cal_fact;
+		n_fg_delta_cal = (fg_temp_gap / fuelgauge->info.low_fg_temp_n_cal_denom)*fuelgauge->info.low_fg_temp_n_cal_fact;
+	}
+	p_curr_cal = p_curr_cal + (p_fg_delta_cal);
+	n_curr_cal = n_curr_cal + (n_fg_delta_cal);
+
+	pr_info("<%d %d %d %d %d %d %d %d %d %d>, temp_fg = %d ,p_curr_cal = 0x%x, n_curr_cal = 0x%x, "
+		"curr_offset = 0x%x, volt_cal = 0x%x ,fg_delta_volcal = 0x%x\n",
+		fuelgauge->info.en_high_fg_temp_cal,
+		fuelgauge->info.high_fg_temp_p_cal_denom, fuelgauge->info.high_fg_temp_p_cal_fact, 
+		fuelgauge->info.high_fg_temp_n_cal_denom, fuelgauge->info.high_fg_temp_n_cal_fact,
+		fuelgauge->info.en_low_fg_temp_cal, 
+		fuelgauge->info.low_fg_temp_p_cal_denom, fuelgauge->info.low_fg_temp_p_cal_fact, 
+		fuelgauge->info.low_fg_temp_n_cal_denom, fuelgauge->info.low_fg_temp_n_cal_fact,
+		fuelgauge->info.temp_fg, p_curr_cal, n_curr_cal, temp_curr_offset,
+		volt_cal, fg_delta_volcal);
+
+	temp_gap = (fuelgauge->info.temperature/10) - fuelgauge->info.temp_std;
+	if (fuelgauge->info.en_high_temp_cal && (temp_gap > 0))
+	{
+		p_delta_cal = (temp_gap / fuelgauge->info.high_temp_p_cal_denom)*fuelgauge->info.high_temp_p_cal_fact;
+		n_delta_cal = (temp_gap / fuelgauge->info.high_temp_n_cal_denom)*fuelgauge->info.high_temp_n_cal_fact;
+	}
+	else if (fuelgauge->info.en_low_temp_cal && (temp_gap < 0))
+	{
+		temp_gap = -temp_gap;
+		p_delta_cal = (temp_gap / fuelgauge->info.low_temp_p_cal_denom)*fuelgauge->info.low_temp_p_cal_fact;
+		n_delta_cal = (temp_gap / fuelgauge->info.low_temp_n_cal_denom)*fuelgauge->info.low_temp_n_cal_fact;
+	}
+	p_curr_cal = p_curr_cal + (p_delta_cal);
+	n_curr_cal = n_curr_cal + (n_delta_cal);
+
+	sm5705_fg_i2c_write_word(client, SM5705_REG_CURR_P_SLOPE, p_curr_cal);
+	sm5705_fg_i2c_write_word(client, SM5705_REG_CURR_N_SLOPE, n_curr_cal);
+
+	pr_info("<%d %d %d %d %d %d %d %d %d %d>, "
+		"p_curr_cal = 0x%x, n_curr_cal = 0x%x, mix_factor=0x%x ,batt_temp = %d\n",
+		fuelgauge->info.en_high_temp_cal,
+		fuelgauge->info.high_temp_p_cal_denom, fuelgauge->info.high_temp_p_cal_fact,
+		fuelgauge->info.high_temp_n_cal_denom, fuelgauge->info.high_temp_n_cal_fact,
+		fuelgauge->info.en_low_temp_cal,
+		fuelgauge->info.low_temp_p_cal_denom, fuelgauge->info.low_temp_p_cal_fact,
+		fuelgauge->info.low_temp_n_cal_denom, fuelgauge->info.low_temp_n_cal_fact,
+		p_curr_cal, n_curr_cal, mix_factor, fuelgauge->info.temperature);
+
+	return 0;
+}
+
+static int sm5705_get_all_value(struct i2c_client *client)
+{
+	union power_supply_propval value;
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+
+	// check charging.
+	value.intval = POWER_SUPPLY_HEALTH_UNKNOWN;
+	psy_do_property("sm5705-charger", get,
+			POWER_SUPPLY_PROP_HEALTH, value);
+#ifdef SM5705_FG_FULL_DEBUG
+	pr_info("get POWER_SUPPLY_PROP_HEALTH = 0x%x\n", value.intval);
+#endif
+	fuelgauge->is_charging = ((value.intval == POWER_SUPPLY_HEALTH_GOOD) |
+		fuelgauge->ta_exist) && (fuelgauge->info.batt_current>=30);
+
+	// check charger status
+	psy_do_property("sm5705-charger", get,
+			POWER_SUPPLY_PROP_STATUS, value);
+	fuelgauge->info.flag_full_charge =
+		(value.intval == POWER_SUPPLY_STATUS_FULL) ? 1 : 0;
+	fuelgauge->info.flag_chg_status =
+		(value.intval == POWER_SUPPLY_STATUS_CHARGING) ? 1 : 0;
+
+	//vbat
+	sm5705_get_vbat(client);
+	//current
+	sm5705_get_curr(client);
+	//ocv
+	sm5705_get_ocv(client);
+	//temperature
+	sm5705_get_temperature(client);
+	//cycle
+	sm5705_get_soc_cycle(client);
+
+	//carc
+	sm5705_cal_carc(client);
+	//soc
+	sm5705_get_soc(client);
+
+	sm5705_fg_test_read(client);
+
+	pr_info("is_chg=%d, ta_exist=%d, v=%d, v_avg=%d, i=%d, i_avg=%d, ocv=%d, "
+		"fg_t=%d, b_t=%d, cycle=%d, soc=%d, state=0x%x, I_EST=0x%x, Q_EST=0x%x\n",
+		fuelgauge->is_charging, fuelgauge->ta_exist, fuelgauge->info.batt_voltage,
+		fuelgauge->info.batt_avgvoltage, fuelgauge->info.batt_current, fuelgauge->info.batt_avgcurrent,
+		fuelgauge->info.batt_ocv, fuelgauge->info.temp_fg, fuelgauge->info.temperature, fuelgauge->info.batt_soc_cycle,
+		fuelgauge->info.batt_soc, sm5705_fg_i2c_read_word(client, SM5705_REG_OCV_STATE),
+		sm5705_fg_i2c_read_word(client, SM5705_REG_CURRENT_EST), sm5705_fg_i2c_read_word(client, SM5705_REG_Q_EST));
+
+    return 0;
+}
+
+static int sm5705_fg_get_jig_mode_real_vbat(struct i2c_client *client)
+{
+	int cntl, ret;
+
+	cntl = sm5705_fg_i2c_read_word(client, SM5705_REG_CNTL);
+	pr_info("%s: start, CNTL=0x%x\n", __func__, cntl);
+
+	if(sm5705_fg_check_reg_init_need(client))
+	{
+		return -1;
+	}
+
+	cntl = cntl | ENABLE_MODE_nENQ4;
+	sm5705_fg_i2c_write_word(client, SM5705_REG_CNTL, cntl);
+
+	msleep(300);
+
+	ret = sm5705_get_vbat(client);
+	pr_info("%s: jig mode real batt V = %d, CNTL=0x%x\n", __func__, ret, cntl);
+
+	cntl = sm5705_fg_i2c_read_word(client, SM5705_REG_CNTL);
+	cntl = cntl & (~ENABLE_MODE_nENQ4);
+	sm5705_fg_i2c_write_word(client, SM5705_REG_CNTL, cntl);
+
+	pr_info("%s: end_1, CNTL=0x%x\n", __func__, cntl);
+	msleep(300);
+
+	cntl = sm5705_fg_i2c_read_word(client, SM5705_REG_CNTL);
+	cntl = cntl & (~ENABLE_MODE_nENQ4);
+	sm5705_fg_i2c_write_word(client, SM5705_REG_CNTL, cntl);
+
+	pr_info("%s: end_2, CNTL=0x%x\n", __func__, cntl);
+
+	return ret;
+}
+
+#ifdef CONFIG_OF
+static int get_battery_id(struct sec_fuelgauge_info *fuelgauge)
+{
+	// sm5705fg does not support this function
+	return 0;
+}
+#define PROPERTY_NAME_SIZE 128
+
+#define PINFO(format, args...) \
+	printk(KERN_INFO "%s() line-%d: " format, \
+		__func__, __LINE__, ## args)
+
+#define DECL_PARAM_PROP(_id, _name) {.id = _id, .name = _name,}
+
+static int sm5705_fg_parse_dt(struct sec_fuelgauge_info *fuelgauge)
+{
+	char prop_name[PROPERTY_NAME_SIZE];
+	int battery_id = -1;
+	int table[16];
+	int rce_value[3];
+	int rs_value[5];
+	int mix_value[2];
+	int topoff_soc[3];
+	int cycle_cfg[3];
+	int v_offset_cancel[4];
+	int temp_volcal[3];
+	int temp_offset[6];
+	int temp_cal[10];
+	int ext_temp_cal[10];
+	int set_temp_poff[4];
+	int curr_offset[2];
+	int curr_lcal[4];
+
+	int ret;
+	int i, j;
+
+	struct device_node *np = of_find_node_by_name(NULL, "sm5705-fuelgauge");
+
+	/* reset, irq gpio info */
+	if (np == NULL) {
+		pr_err("np NULL\n");
+	} else {
+		ret = of_get_named_gpio(np, "fuelgauge,fuel_int", 0);
+		if (ret > 0) {
+			fuelgauge->pdata->fg_irq = ret;
+			pr_info("reading fg_irq = %d\n", ret);
+		}
+
+		ret = of_get_named_gpio(np, "fuelgauge,bat_int", 0);
+		if (ret > 0) {
+			fuelgauge->pdata->bat_irq_gpio = ret;
+			fuelgauge->pdata->bat_irq = gpio_to_irq(ret);
+			pr_info("reading bat_int_gpio = %d\n", ret);
+		}
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_max",
+				&fuelgauge->pdata->capacity_max);
+		if (ret < 0)
+			pr_err("error reading capacity_max %d\n", ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_max_margin",
+				&fuelgauge->pdata->capacity_max_margin);
+		if (ret < 0)
+			pr_err("error reading capacity_max_margin %d\n", ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_min",
+				&fuelgauge->pdata->capacity_min);
+		if (ret < 0)
+			pr_err("error reading capacity_min %d\n", ret);
+
+		pr_info("capacity_max: %d, "
+				"capacity_max_margin: 0x%x, "
+				"capacity_min: %d\n", fuelgauge->pdata->capacity_max,
+				fuelgauge->pdata->capacity_max_margin,
+				fuelgauge->pdata->capacity_min);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_calculation_type",
+				&fuelgauge->pdata->capacity_calculation_type);
+		if (ret < 0)
+			pr_err("error reading capacity_calculation_type %d\n", ret);
+		ret = of_property_read_u32(np, "fuelgauge,fuel_alert_soc",
+				&fuelgauge->pdata->fuel_alert_soc);
+		if (ret < 0)
+			pr_err("error reading pdata->fuel_alert_soc %d\n", ret);
+		fuelgauge->pdata->repeated_fuelalert = of_property_read_bool(np,
+				"fuelgaguge,repeated_fuelalert");
+
+		pr_info("fg_irq: %d, "
+				"calculation_type: 0x%x, fuel_alert_soc: %d,\n"
+				"repeated_fuelalert: %d\n", fuelgauge->pdata->fg_irq,
+				fuelgauge->pdata->capacity_calculation_type,
+				fuelgauge->pdata->fuel_alert_soc, fuelgauge->pdata->repeated_fuelalert);
+	}
+
+	// get battery_params node
+	np = of_find_node_by_name(of_node_get(np), "battery_params");
+	if (np == NULL) {
+		PINFO("Cannot find child node \"battery_params\"\n");
+		return -EINVAL;
+	}
+
+	// get battery_id
+	if (of_property_read_u32(np, "battery,id", &battery_id) < 0)
+		PINFO("not battery,id property\n");
+	if (battery_id == -1)
+		battery_id = get_battery_id(fuelgauge);
+	PINFO("battery id = %d\n", battery_id);
+
+	// get battery_table
+	for (i = DISCHARGE_TABLE; i < TABLE_MAX; i++) {
+		snprintf(prop_name, PROPERTY_NAME_SIZE,
+			 "battery%d,%s%d", battery_id, "battery_table", i);
+
+		ret = of_property_read_u32_array(np, prop_name, table, 16);
+		if (ret < 0) {
+			PINFO("Can get prop %s (%d)\n", prop_name, ret);
+		}
+		for (j = 0; j <= SM5705_FG_TABLE_LEN; j++)
+		{
+			fuelgauge->info.battery_table[i][j] = table[j];
+			PINFO("%s = <table[%d][%d] 0x%x>\n", prop_name, i, j, table[j]);
+		}
+	}
+
+	// get rce
+	for (i = 0; i < 3; i++) {
+		snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "rce_value");
+		ret = of_property_read_u32_array(np, prop_name, rce_value, 3);
+		if (ret < 0) {
+			PINFO("Can get prop %s (%d)\n", prop_name, ret);
+		}
+        fuelgauge->info.rce_value[i] = rce_value[i];
+	}
+	PINFO("%s = <0x%x 0x%x 0x%x>\n", prop_name, rce_value[0], rce_value[1], rce_value[2]);
+
+	// get dtcd_value
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "dtcd_value");
+	ret = of_property_read_u32_array(np, prop_name, &fuelgauge->info.dtcd_value, 1);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	PINFO("%s = <0x%x>\n",prop_name, fuelgauge->info.dtcd_value);
+
+	// get rs_value
+	for (i = 0; i < 5; i++) {
+		snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "rs_value");
+		ret = of_property_read_u32_array(np, prop_name, rs_value, 5);
+		if (ret < 0) {
+			PINFO("Can get prop %s (%d)\n", prop_name, ret);
+		}
+        fuelgauge->info.rs_value[i] = rs_value[i];
+	}
+	PINFO("%s = <0x%x 0x%x 0x%x 0x%x 0x%x>\n", prop_name, rs_value[0], rs_value[1], rs_value[2], rs_value[3], rs_value[4]);
+
+	// get vit_period
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "vit_period");
+	ret = of_property_read_u32_array(np, prop_name, &fuelgauge->info.vit_period, 1);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	PINFO("%s = <0x%x>\n",prop_name, fuelgauge->info.vit_period);
+
+	// get mix_value
+	for (i = 0; i < 2; i++) {
+		snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "mix_value");
+		ret = of_property_read_u32_array(np, prop_name, mix_value, 2);
+		if (ret < 0) {
+			PINFO("Can get prop %s (%d)\n", prop_name, ret);
+		}
+        fuelgauge->info.mix_value[i] = mix_value[i];
+	}
+	PINFO("%s = <0x%x 0x%x>\n", prop_name, mix_value[0], mix_value[1]);
+
+	// battery_type
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "battery_type");
+	ret = of_property_read_u32_array(np, prop_name, &fuelgauge->info.battery_type, 1);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	PINFO("%s = <%d>\n", prop_name, fuelgauge->info.battery_type);
+
+	// MISC
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "misc");
+	ret = of_property_read_u32_array(np, prop_name, &fuelgauge->info.misc, 1);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	PINFO("%s = <0x%x>\n", prop_name, fuelgauge->info.misc);
+
+	// V_ALARM
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "v_alarm");
+	ret = of_property_read_u32_array(np, prop_name, &fuelgauge->info.value_v_alarm, 1);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	PINFO("%s = <%d>\n", prop_name, fuelgauge->info.value_v_alarm);
+
+	// TOP OFF SOC
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "topoff_soc");
+	ret = of_property_read_u32_array(np, prop_name, topoff_soc, 3);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	fuelgauge->info.enable_topoff_soc = topoff_soc[0];
+	fuelgauge->info.topoff_soc = topoff_soc[1];
+	fuelgauge->info.top_off = topoff_soc[2];
+
+	PINFO("%s = <%d %d %d>\n", prop_name,
+		fuelgauge->info.enable_topoff_soc, fuelgauge->info.topoff_soc, fuelgauge->info.top_off);
+
+	// SOC cycle cfg
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "cycle_cfg");
+	ret = of_property_read_u32_array(np, prop_name, cycle_cfg, 3);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	fuelgauge->info.cycle_high_limit = cycle_cfg[0];
+	fuelgauge->info.cycle_low_limit = cycle_cfg[1];
+	fuelgauge->info.cycle_limit_cntl = cycle_cfg[2];
+
+	PINFO("%s = <%d %d %d>\n", prop_name,
+		fuelgauge->info.cycle_high_limit, fuelgauge->info.cycle_low_limit, fuelgauge->info.cycle_limit_cntl);
+
+	// v_offset_cancel
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "v_offset_cancel");
+	ret = of_property_read_u32_array(np, prop_name, v_offset_cancel, 4);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	fuelgauge->info.enable_v_offset_cancel_p = v_offset_cancel[0];
+	fuelgauge->info.enable_v_offset_cancel_n = v_offset_cancel[1];
+	fuelgauge->info.v_offset_cancel_level = v_offset_cancel[2];
+	fuelgauge->info.v_offset_cancel_mohm = v_offset_cancel[3];
+
+	PINFO("%s = <%d %d %d %d>\n", prop_name,
+		fuelgauge->info.enable_v_offset_cancel_p, fuelgauge->info.enable_v_offset_cancel_n,
+		fuelgauge->info.v_offset_cancel_level, fuelgauge->info.v_offset_cancel_mohm);
+
+	// VOL & CURR CAL
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "volt_cal");
+	ret = of_property_read_u32_array(np, prop_name, &fuelgauge->info.volt_cal, 1);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	PINFO("%s = <0x%x>\n", prop_name, fuelgauge->info.volt_cal);
+
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "curr_offset");
+	ret = of_property_read_u32_array(np, prop_name, curr_offset, 2);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	fuelgauge->info.en_auto_curr_offset = curr_offset[0];
+	fuelgauge->info.curr_offset = curr_offset[1];
+
+	PINFO("%s = <%d 0x%x>\n", prop_name, fuelgauge->info.en_auto_curr_offset, fuelgauge->info.curr_offset);
+
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "p_curr_cal");
+	ret = of_property_read_u32_array(np, prop_name, &fuelgauge->info.p_curr_cal, 1);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	PINFO("%s = <0x%x>\n", prop_name, fuelgauge->info.p_curr_cal);
+
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "n_curr_cal");
+	ret = of_property_read_u32_array(np, prop_name, &fuelgauge->info.n_curr_cal, 1);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	PINFO("%s = <0x%x>\n", prop_name, fuelgauge->info.n_curr_cal);
+
+	// curr_lcal
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "curr_lcal");
+	ret = of_property_read_u32_array(np, prop_name, curr_lcal, 4);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	fuelgauge->info.curr_lcal_en = curr_lcal[0];
+	fuelgauge->info.curr_lcal_0 = curr_lcal[1];
+	fuelgauge->info.curr_lcal_1 = curr_lcal[2];
+	fuelgauge->info.curr_lcal_2 = curr_lcal[3];
+	PINFO("%s = <%d, 0x%x, 0x%x, 0x%x>\n", prop_name,
+		fuelgauge->info.curr_lcal_en, fuelgauge->info.curr_lcal_0, fuelgauge->info.curr_lcal_1, fuelgauge->info.curr_lcal_2);
+
+	// temp_std
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "temp_std");
+	ret = of_property_read_u32_array(np, prop_name, &fuelgauge->info.temp_std, 1);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	PINFO("%s = <%d>\n", prop_name, fuelgauge->info.temp_std);
+
+	// temp_volcal
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "temp_volcal");
+	ret = of_property_read_u32_array(np, prop_name, temp_volcal, 3);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	fuelgauge->info.en_fg_temp_volcal = temp_volcal[0];
+	fuelgauge->info.fg_temp_volcal_denom = temp_volcal[1];
+	fuelgauge->info.fg_temp_volcal_fact = temp_volcal[2];
+	PINFO("%s = <%d, %d, %d>\n", prop_name,
+		fuelgauge->info.en_fg_temp_volcal, fuelgauge->info.fg_temp_volcal_denom, fuelgauge->info.fg_temp_volcal_fact);
+
+	// temp_offset
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "temp_offset");
+	ret = of_property_read_u32_array(np, prop_name, temp_offset, 6);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	fuelgauge->info.en_high_fg_temp_offset = temp_offset[0];
+	fuelgauge->info.high_fg_temp_offset_denom = temp_offset[1];
+	fuelgauge->info.high_fg_temp_offset_fact = temp_offset[2];
+	fuelgauge->info.en_low_fg_temp_offset = temp_offset[3];
+	fuelgauge->info.low_fg_temp_offset_denom = temp_offset[4];
+	fuelgauge->info.low_fg_temp_offset_fact = temp_offset[5];
+	PINFO("%s = <%d, %d, %d, %d, %d, %d>\n", prop_name,
+		fuelgauge->info.en_high_fg_temp_offset,
+		fuelgauge->info.high_fg_temp_offset_denom, fuelgauge->info.high_fg_temp_offset_fact,
+		fuelgauge->info.en_low_fg_temp_offset,
+		fuelgauge->info.low_fg_temp_offset_denom, fuelgauge->info.low_fg_temp_offset_fact);
+
+	// temp_calc
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "temp_cal");
+	ret = of_property_read_u32_array(np, prop_name, temp_cal, 10);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	fuelgauge->info.en_high_fg_temp_cal = temp_cal[0];
+	fuelgauge->info.high_fg_temp_p_cal_denom = temp_cal[1];
+	fuelgauge->info.high_fg_temp_p_cal_fact = temp_cal[2];
+	fuelgauge->info.high_fg_temp_n_cal_denom = temp_cal[3];
+	fuelgauge->info.high_fg_temp_n_cal_fact = temp_cal[4];
+	fuelgauge->info.en_low_fg_temp_cal = temp_cal[5];
+	fuelgauge->info.low_fg_temp_p_cal_denom = temp_cal[6];
+	fuelgauge->info.low_fg_temp_p_cal_fact = temp_cal[7];
+	fuelgauge->info.low_fg_temp_n_cal_denom = temp_cal[8];
+	fuelgauge->info.low_fg_temp_n_cal_fact = temp_cal[9];
+	PINFO("%s = <%d, %d, %d, %d, %d, %d, %d, %d, %d, %d>\n", prop_name,
+		fuelgauge->info.en_high_fg_temp_cal,
+		fuelgauge->info.high_fg_temp_p_cal_denom, fuelgauge->info.high_fg_temp_p_cal_fact,
+		fuelgauge->info.high_fg_temp_n_cal_denom, fuelgauge->info.high_fg_temp_n_cal_fact,
+		fuelgauge->info.en_low_fg_temp_cal,
+		fuelgauge->info.low_fg_temp_p_cal_denom, fuelgauge->info.low_fg_temp_p_cal_fact,
+		fuelgauge->info.low_fg_temp_n_cal_denom, fuelgauge->info.low_fg_temp_n_cal_fact);
+
+	// ext_temp_calc
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "ext_temp_cal");
+	ret = of_property_read_u32_array(np, prop_name, ext_temp_cal, 10);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	fuelgauge->info.en_high_temp_cal = ext_temp_cal[0];
+	fuelgauge->info.high_temp_p_cal_denom = ext_temp_cal[1];
+	fuelgauge->info.high_temp_p_cal_fact = ext_temp_cal[2];
+	fuelgauge->info.high_temp_n_cal_denom = ext_temp_cal[3];
+	fuelgauge->info.high_temp_n_cal_fact = ext_temp_cal[4];
+	fuelgauge->info.en_low_temp_cal = ext_temp_cal[5];
+	fuelgauge->info.low_temp_p_cal_denom = ext_temp_cal[6];
+	fuelgauge->info.low_temp_p_cal_fact = ext_temp_cal[7];
+	fuelgauge->info.low_temp_n_cal_denom = ext_temp_cal[8];
+	fuelgauge->info.low_temp_n_cal_fact = ext_temp_cal[9];
+	PINFO("%s = <%d, %d, %d, %d, %d, %d, %d, %d, %d, %d>\n", prop_name,
+		fuelgauge->info.en_high_temp_cal,
+		fuelgauge->info.high_temp_p_cal_denom, fuelgauge->info.high_temp_p_cal_fact,
+		fuelgauge->info.high_temp_n_cal_denom, fuelgauge->info.high_temp_n_cal_fact,
+		fuelgauge->info.en_low_temp_cal,
+		fuelgauge->info.low_temp_p_cal_denom, fuelgauge->info.low_temp_p_cal_fact,
+		fuelgauge->info.low_temp_n_cal_denom, fuelgauge->info.low_temp_n_cal_fact);
+
+	// tem poff level
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "tem_poff");
+	ret = of_property_read_u32_array(np, prop_name, set_temp_poff, 4);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	fuelgauge->info.n_tem_poff = set_temp_poff[0];
+	fuelgauge->info.n_tem_poff_offset = set_temp_poff[1];
+	fuelgauge->info.l_tem_poff = set_temp_poff[2];
+	fuelgauge->info.l_tem_poff_offset = set_temp_poff[3];
+
+	PINFO("%s = <%d, %d, %d, %d>\n",
+		prop_name,
+		fuelgauge->info.n_tem_poff, fuelgauge->info.n_tem_poff_offset,
+		fuelgauge->info.l_tem_poff, fuelgauge->info.l_tem_poff_offset);
+
+	return 0;
+}
+#else
+static int sm5705_fg_parse_dt(struct sec_fuelgauge_info *fuelgauge)
+{
+	return 0;
+}
+#endif
+
+bool sm5705_fg_fuelalert_init(struct i2c_client *client, int soc)
+{
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+	int ret;
+	int value_v_alarm, value_soc_alarm;
+
+	if (soc >= 0)
+	{
+		// remove interrupt
+		ret = sm5705_fg_i2c_read_word(client, SM5705_REG_INTFG);
+
+		// check status
+		ret = sm5705_fg_i2c_read_word(client, SM5705_REG_STATUS);
+
+		// remove all mask
+		sm5705_fg_i2c_write_word(client,SM5705_REG_INTFG_MASK, 0x0000);
+
+		/* enable volt alert only, other alert mask*/
+		ret = MASK_L_SOC_INT|MASK_H_TEM_INT|MASK_L_TEM_INT;
+		sm5705_fg_i2c_write_word(client,SM5705_REG_INTFG_MASK,ret);
+		fuelgauge->info.irq_ctrl = ~(ret);
+
+		/* set volt and soc alert threshold */
+		value_v_alarm = (((fuelgauge->info.value_v_alarm)<<8)/1000);
+		sm5705_fg_i2c_write_word(client, SM5705_REG_V_ALARM, value_v_alarm);
+		value_soc_alarm = 0x0100; // 1.00%
+		sm5705_fg_i2c_write_word(client, SM5705_REG_SOC_ALARM, value_soc_alarm);
+
+		// enabel volt alert control, other alert disable
+		ret = sm5705_fg_i2c_read_word(client, SM5705_REG_CNTL);
+		ret = ret | ENABLE_V_ALARM;
+		ret = ret & (~ENABLE_SOC_ALARM & ~ENABLE_T_H_ALARM & ~ENABLE_T_L_ALARM);
+		sm5705_fg_i2c_write_word(client, SM5705_REG_CNTL, ret);
+
+		pr_info("irq_ctrl=0x%x, REG_CNTL=0x%x, V_ALARM=%d, SOC_ALARM=0x%x \n",
+			fuelgauge->info.irq_ctrl, ret, value_v_alarm, value_soc_alarm);
+	}
+
+	/* alert flag init*/
+	fuelgauge->info.soc_alert_flag = false;
+	fuelgauge->is_fuel_alerted = false;
+
+	return true;
+}
+
+bool sm5705_fg_is_fuelalerted(struct i2c_client *client)
+{
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+	int ret;
+
+	/* alert process */
+	ret = sm5705_fg_i2c_read_word(client, SM5705_REG_INTFG);
+	pr_info("SM5705_REG_INTFG(0x%x)\n", ret);
+
+	if(ret & fuelgauge->info.irq_ctrl)
+	{
+		// check status
+		ret = sm5705_fg_i2c_read_word(client, SM5705_REG_STATUS);
+		pr_info("SM5705_REG_STATUS(0x%x)\n", ret);
+
+		if(ret & fuelgauge->info.irq_ctrl)
+		{
+			return true;
+		}
+	}
+
+	return false;
+}
+
+bool sm5705_fg_fuelalert_process(void *irq_data, bool is_fuel_alerted)
+{
+	struct sec_fuelgauge_info *fuelgauge = irq_data;
+	struct i2c_client *client = fuelgauge->client;
+	int ret;
+
+	pr_info("is_fuel_alerted=%d \n", is_fuel_alerted);
+
+	if(is_fuel_alerted)
+	{
+		ret = sm5705_fg_i2c_read_word(client, SM5705_REG_STATUS);
+		pr_info("SM5705_REG_STATUS(0x%x)\n", ret);
+
+		/* not use SOC alarm
+		if(ret & fuelgauge->info.irq_ctrl & ENABLE_SOC_ALARM) {
+			fuelgauge->info.soc_alert_flag = true;
+			// todo more action
+		}
+		*/
+
+		if(ret & fuelgauge->info.irq_ctrl & ENABLE_V_ALARM) {
+			fuelgauge->info.volt_alert_flag = true;
+			// todo more action
+		}
+	}
+
+	return true;
+}
+
+/* capacity is  0.1% unit */
+static void sm5705_fg_get_scaled_capacity(
+				struct sec_fuelgauge_info *fuelgauge,
+				union power_supply_propval *val)
+{
+	val->intval = (val->intval < fuelgauge->pdata->capacity_min) ?
+		0 : ((val->intval - fuelgauge->pdata->capacity_min) * 1000 /
+		(fuelgauge->capacity_max - fuelgauge->pdata->capacity_min));
+
+	pr_info("scaled capacity (%d.%d)\n", val->intval/10, val->intval%10);
+}
+
+/* capacity is integer */
+static void sm5705_fg_get_atomic_capacity(
+				struct sec_fuelgauge_info *fuelgauge,
+				union power_supply_propval *val)
+{
+	pr_info("NOW(%d), OLD(%d)\n", val->intval, fuelgauge->capacity_old);
+
+	if (fuelgauge->pdata->capacity_calculation_type &
+		SEC_FUELGAUGE_CAPACITY_TYPE_ATOMIC) {
+		if (fuelgauge->capacity_old < val->intval)
+			val->intval = fuelgauge->capacity_old + 1;
+		else if (fuelgauge->capacity_old > val->intval)
+			val->intval = fuelgauge->capacity_old - 1;
+	}
+
+	/* keep SOC stable in abnormal status */
+	if (fuelgauge->pdata->capacity_calculation_type &
+		SEC_FUELGAUGE_CAPACITY_TYPE_SKIP_ABNORMAL) {
+		if (!fuelgauge->ta_exist &&
+			fuelgauge->capacity_old < val->intval) {
+			pr_info("capacity (old %d : new %d)\n",	fuelgauge->capacity_old, val->intval);
+			val->intval = fuelgauge->capacity_old;
+		}
+	}
+
+	/* updated old capacity */
+	fuelgauge->capacity_old = val->intval;
+}
+
+static int sm5705_fg_check_capacity_max(
+				struct sec_fuelgauge_info *fuelgauge, int capacity_max)
+{
+	int new_capacity_max = capacity_max;
+
+	if (new_capacity_max < (fuelgauge->pdata->capacity_max -
+			fuelgauge->pdata->capacity_max_margin - 10)) {
+		new_capacity_max =
+			(fuelgauge->pdata->capacity_max -
+			fuelgauge->pdata->capacity_max_margin);
+
+		pr_info("set capacity max(%d --> %d)\n", capacity_max, new_capacity_max);
+	} else if (new_capacity_max > (fuelgauge->pdata->capacity_max +
+			fuelgauge->pdata->capacity_max_margin)) {
+		new_capacity_max =
+			(fuelgauge->pdata->capacity_max +
+			fuelgauge->pdata->capacity_max_margin);
+
+		pr_info("set capacity max(%d --> %d)\n", capacity_max, new_capacity_max);
+	}
+
+	return new_capacity_max;
+}
+
+static int sm5705_fg_calculate_dynamic_scale(
+				struct sec_fuelgauge_info *fuelgauge, int capacity)
+{
+	union power_supply_propval raw_soc_val;
+
+	raw_soc_val.intval = sm5705_get_soc(fuelgauge->client);
+
+	if (raw_soc_val.intval <
+		fuelgauge->pdata->capacity_max -
+		fuelgauge->pdata->capacity_max_margin) {
+		fuelgauge->capacity_max =
+			fuelgauge->pdata->capacity_max -
+			fuelgauge->pdata->capacity_max_margin;
+		pr_debug("capacity_max (%d)", fuelgauge->capacity_max);
+	} else {
+		fuelgauge->capacity_max =
+			(raw_soc_val.intval >
+			fuelgauge->pdata->capacity_max +
+			fuelgauge->pdata->capacity_max_margin) ?
+			(fuelgauge->pdata->capacity_max +
+			fuelgauge->pdata->capacity_max_margin) :
+			raw_soc_val.intval;
+		pr_debug("raw soc (%d)", fuelgauge->capacity_max);
+	}
+
+	if (capacity != 100) {
+		fuelgauge->capacity_max = sm5705_fg_check_capacity_max(
+			fuelgauge, (fuelgauge->capacity_max * 100 / (capacity + 1)));
+	} else {
+		fuelgauge->capacity_max =
+			(fuelgauge->capacity_max * 99 / 100);
+	}
+	/* update capacity_old for sec_fg_get_atomic_capacity algorithm */
+	fuelgauge->capacity_old = capacity;
+
+	pr_info("%d is used for capacity_max\n", fuelgauge->capacity_max);
+
+	return fuelgauge->capacity_max;
+}
+
+bool sm5705_fg_reset(struct i2c_client *client)
+{
+	pr_info("Start quick-start\n");
+	// SW reset code
+	sm5705_fg_i2c_verified_write_word(client, SM5705_REG_RESET, SW_RESET_CODE);
+	// delay 800ms
+	msleep(800);
+	// init code
+	sm5705_fg_init(client, false);
+
+	pr_info("End quick-start\n");
+	return true;
+}
+
+static void sm5705_fg_reset_capacity_by_jig_connection(struct sec_fuelgauge_info *fuelgauge)
+{
+	union power_supply_propval value;
+	int ret;
+
+	pr_info("(Jig Connection)\n");
+
+	ret = sm5705_fg_i2c_read_word(fuelgauge->client, SM5705_REG_RESERVED);
+	ret |= 0x0001;
+	sm5705_fg_i2c_write_word(fuelgauge->client, SM5705_REG_RESERVED, ret);
+	/* If JIG is attached, the voltage is set as 1079 */
+	value.intval = 1079;
+	psy_do_property("battery", set,
+			POWER_SUPPLY_PROP_VOLTAGE_NOW, value);
+}
+
+static int sm5705_fg_get_property(struct power_supply *psy,
+			    enum power_supply_property psp,
+			    union power_supply_propval *val)
+{
+	struct sec_fuelgauge_info *fuelgauge =
+		container_of(psy, struct sec_fuelgauge_info, psy_fg);
+
+	switch (psp) {
+	/* Additional Voltage Information (mV) */
+	case POWER_SUPPLY_PROP_PRESENT:
+		// SM5705 is not suport this prop
+		sm5705_fg_get_batt_present(fuelgauge->client);
+		break;
+	/* Cell voltage (VCELL, mV) */
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		sm5705_get_vbat(fuelgauge->client);
+		val->intval = fuelgauge->info.batt_voltage;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_AVG:
+		switch (val->intval) {
+		case SEC_BATTERY_VOLTAGE_AVERAGE:
+			sm5705_get_vbat(fuelgauge->client);
+			val->intval = fuelgauge->info.batt_avgvoltage;
+			break;
+		case SEC_BATTERY_VOLTAGE_OCV:
+			sm5705_get_ocv(fuelgauge->client);
+			val->intval = fuelgauge->info.batt_ocv;
+			break;
+		}
+		break;
+	case POWER_SUPPLY_PROP_INBAT_VOLTAGE_FGSRC_SWITCHING:
+		val->intval = sm5705_fg_get_jig_mode_real_vbat(fuelgauge->client) / 10;
+		break;
+	/* Current (mA) */
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		sm5705_get_curr(fuelgauge->client);
+		if (val->intval == SEC_BATTERY_CURRENT_UA)
+			val->intval = fuelgauge->info.batt_current * 1000;
+		else
+			val->intval = fuelgauge->info.batt_current;
+		break;
+	/* Average Current (mA) */
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+		sm5705_get_curr(fuelgauge->client);
+		if (val->intval == SEC_BATTERY_CURRENT_UA)
+			val->intval = fuelgauge->info.batt_avgcurrent * 1000;
+		else
+			val->intval = fuelgauge->info.batt_avgcurrent;
+		break;
+	/* Battery Temperature */
+	case POWER_SUPPLY_PROP_TEMP:
+	/* Target Temperature */
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		sm5705_get_temperature(fuelgauge->client);
+		val->intval = fuelgauge->info.temp_fg;
+		break;
+	/* SOC (%) */
+	case POWER_SUPPLY_PROP_CAPACITY:
+		sm5705_get_all_value(fuelgauge->client);
+		/* SM5705 F/G unit is 0.1%, raw ==> convert the unit to 0.01% */
+		if (val->intval == SEC_FUELGAUGE_CAPACITY_TYPE_RAW) {
+			val->intval = fuelgauge->info.batt_soc * 10;
+			break;
+		} else
+			val->intval = fuelgauge->info.batt_soc;
+
+		if (fuelgauge->pdata->capacity_calculation_type &
+			(SEC_FUELGAUGE_CAPACITY_TYPE_SCALE |
+			 SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE))
+			sm5705_fg_get_scaled_capacity(fuelgauge, val);
+
+		/* capacity should be between 0% and 100%
+		 * (0.1% degree)
+		 */
+		if (val->intval > 1000)
+			val->intval = 1000;
+		if (val->intval < 0)
+			val->intval = 0;
+
+		/* get only integer part */
+		val->intval /= 10;
+
+		/* check whether doing the wake_unlock */
+		if ((val->intval > fuelgauge->pdata->fuel_alert_soc) &&
+			fuelgauge->is_fuel_alerted) {
+			wake_unlock(&fuelgauge->fuel_alert_wake_lock);
+			sm5705_fg_fuelalert_init(fuelgauge->client,
+				fuelgauge->pdata->fuel_alert_soc);
+		}
+
+		/* (Only for atomic capacity)
+		 * In initial time, capacity_old is 0.
+		 * and in resume from sleep,
+		 * capacity_old is too different from actual soc.
+		 * should update capacity_old
+		 * by val->intval in booting or resume.
+		 */
+		if (fuelgauge->initial_update_of_soc) {
+			/* updated old capacity */
+			fuelgauge->capacity_old = val->intval;
+			fuelgauge->initial_update_of_soc = false;
+			break;
+		}
+
+		if (fuelgauge->pdata->capacity_calculation_type &
+			(SEC_FUELGAUGE_CAPACITY_TYPE_ATOMIC |
+			 SEC_FUELGAUGE_CAPACITY_TYPE_SKIP_ABNORMAL))
+			sm5705_fg_get_atomic_capacity(fuelgauge, val);
+		break;
+	case POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:
+		val->intval = fuelgauge->capacity_max;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int sm5705_fg_set_property(struct power_supply *psy,
+			    enum power_supply_property psp,
+			    const union power_supply_propval *val)
+{
+	struct sec_fuelgauge_info *fuelgauge =
+		container_of(psy, struct sec_fuelgauge_info, psy_fg);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		if (val->intval == POWER_SUPPLY_STATUS_FULL)
+			fuelgauge->info.flag_full_charge = 1;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+		if (fuelgauge->pdata->capacity_calculation_type &
+				SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE) {
+#if defined(CONFIG_PREVENT_SOC_JUMP)
+				sm5705_fg_calculate_dynamic_scale(fuelgauge, val->intval);
+#else
+				sm5705_fg_calculate_dynamic_scale(fuelgauge, 100);
+#endif
+			}
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		fuelgauge->cable_type = val->intval;
+		if (val->intval == POWER_SUPPLY_TYPE_BATTERY) {
+			fuelgauge->ta_exist = false;
+			fuelgauge->is_charging = false;
+		} else {
+			fuelgauge->ta_exist = true;
+			fuelgauge->is_charging = true;
+		}
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		if (val->intval == SEC_FUELGAUGE_CAPACITY_TYPE_RESET) {
+			fuelgauge->initial_update_of_soc = true;
+			if (!sm5705_fg_reset(fuelgauge->client))
+				return -EINVAL;
+			else
+				break;
+		}
+	case POWER_SUPPLY_PROP_TEMP:
+		fuelgauge->info.temperature = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		break;
+	case POWER_SUPPLY_PROP_INBAT_VOLTAGE_FGSRC_SWITCHING:
+		break;
+	case POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:
+		pr_info("capacity_max changed, %d -> %d\n", fuelgauge->capacity_max, val->intval);
+		fuelgauge->capacity_max = sm5705_fg_check_capacity_max(fuelgauge, val->intval);
+		fuelgauge->initial_update_of_soc = true;
+		break;
+	case POWER_SUPPLY_PROP_ENERGY_NOW:
+		sm5705_fg_reset_capacity_by_jig_connection(fuelgauge);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static void sm5705_fg_isr_work(struct work_struct *work)
+{
+	struct sec_fuelgauge_info *fuelgauge =
+		container_of(work, struct sec_fuelgauge_info, isr_work.work);
+
+	/* process for fuel gauge chip */
+	sm5705_fg_fuelalert_process(fuelgauge, fuelgauge->is_fuel_alerted);
+
+	/* process for others */
+	if (fuelgauge->pdata->fuelalert_process != NULL)
+		fuelgauge->pdata->fuelalert_process(fuelgauge->is_fuel_alerted);
+}
+
+static irqreturn_t sm5705_fg_irq_thread(int irq, void *irq_data)
+{
+	struct sec_fuelgauge_info *fuelgauge = irq_data;
+	bool fuel_alerted;
+
+	if (fuelgauge->pdata->fuel_alert_soc >= 0) {
+		fuel_alerted =
+			sm5705_fg_is_fuelalerted(fuelgauge->client);
+
+		pr_info("Fuel-alert %salerted!\n", fuel_alerted ? "" : "NOT ");
+
+		if (fuel_alerted == fuelgauge->is_fuel_alerted) {
+			if (!fuelgauge->pdata->repeated_fuelalert) {
+				pr_debug("Fuel-alert Repeated (%d)\n", fuelgauge->is_fuel_alerted);
+				return IRQ_HANDLED;
+			}
+		}
+
+		if (fuel_alerted)
+			wake_lock(&fuelgauge->fuel_alert_wake_lock);
+		else
+			wake_unlock(&fuelgauge->fuel_alert_wake_lock);
+
+		fuelgauge->is_fuel_alerted = fuel_alerted;
+
+		schedule_delayed_work(&fuelgauge->isr_work, 0);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int sm5705_create_attrs(struct device *dev)
+{
+	int i, rc;
+
+	for (i = 0; i < ARRAY_SIZE(sm5705_fg_attrs); i++) {
+		rc = device_create_file(dev, &sm5705_fg_attrs[i]);
+		if (rc)
+			goto create_attrs_failed;
+	}
+	goto create_attrs_succeed;
+
+create_attrs_failed:
+	pr_err("failed (%d)\n", rc);
+	while (i--)
+		device_remove_file(dev, &sm5705_fg_attrs[i]);
+create_attrs_succeed:
+	return rc;
+}
+
+ssize_t sm5705_fg_show_attrs(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	const ptrdiff_t offset = attr - sm5705_fg_attrs;
+	int i = 0;
+
+	switch (offset) {
+	case FG_REG:
+	case FG_DATA:
+	case FG_REGS:
+		break;
+	default:
+		i = -EINVAL;
+		break;
+	}
+
+	return i;
+}
+
+ssize_t sm5705_fg_store_attrs(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	const ptrdiff_t offset = attr - sm5705_fg_attrs;
+	int ret = 0;
+
+	switch (offset) {
+	case FG_REG:
+	case FG_DATA:
+		ret = count;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static int sm5705_fuelgauge_probe(struct i2c_client *client,
+						const struct i2c_device_id *id)
+{
+	struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
+	struct sec_fuelgauge_info *fuelgauge;
+	sec_battery_platform_data_t *pdata = NULL;
+//	struct battery_data_t *battery_data = NULL;
+	int ret = 0;
+	union power_supply_propval raw_soc_val;
+
+	pr_info("SM5705 Fuelgauge Driver Loading\n");
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE))
+		return -EIO;
+
+	fuelgauge = kzalloc(sizeof(*fuelgauge), GFP_KERNEL);
+	if (!fuelgauge)
+		return -ENOMEM;
+
+	mutex_init(&fuelgauge->fg_lock);
+
+	fuelgauge->client = client;
+
+	if (client->dev.of_node) {
+		int error;
+		pdata = devm_kzalloc(&client->dev, sizeof(sec_battery_platform_data_t), GFP_KERNEL);
+		if (!pdata) {
+			dev_err(&client->dev, "Failed to allocate memory\n");
+			ret = -ENOMEM;
+			goto err_free;
+		}
+
+		fuelgauge->pdata = pdata;
+
+		mutex_init(&fuelgauge->info.param_lock);
+		mutex_lock(&fuelgauge->info.param_lock);
+		error = sm5705_fg_parse_dt(fuelgauge);
+		mutex_unlock(&fuelgauge->info.param_lock);
+		if (error < 0) {
+			pr_err("Failed to get fuel_int\n");
+			goto err_parse_dt;
+		}
+	} else	{
+		pr_err("Failed to get of_node\n");
+		fuelgauge->pdata = client->dev.platform_data;
+	}
+	i2c_set_clientdata(client, fuelgauge);
+
+	if (fuelgauge->pdata->fg_gpio_init != NULL) {
+		pr_err("@@@\n");
+		if (!fuelgauge->pdata->fg_gpio_init()) {
+			pr_err("Failed to Initialize GPIO\n");
+			goto err_devm_free;
+		}
+	}
+
+	if (!sm5705_fg_init(fuelgauge->client, false)) {
+		pr_err("Failed to Initialize Fuelgauge\n");
+		goto err_devm_free;
+	}
+
+	fuelgauge->psy_fg.name		= "sm5705-fuelgauge";
+	fuelgauge->psy_fg.type		= POWER_SUPPLY_TYPE_UNKNOWN;
+	fuelgauge->psy_fg.get_property	= sm5705_fg_get_property;
+	fuelgauge->psy_fg.set_property	= sm5705_fg_set_property;
+	fuelgauge->psy_fg.properties	= sm5705_fuelgauge_props;
+	fuelgauge->psy_fg.num_properties =
+		ARRAY_SIZE(sm5705_fuelgauge_props);
+
+        fuelgauge->capacity_max = fuelgauge->pdata->capacity_max;
+	raw_soc_val.intval = sm5705_get_soc(fuelgauge->client);
+
+        if(raw_soc_val.intval > fuelgauge->pdata->capacity_max)
+                sm5705_fg_calculate_dynamic_scale(fuelgauge, 100);
+
+	ret = power_supply_register(&client->dev, &fuelgauge->psy_fg);
+	if (ret) {
+		pr_err("Failed to Register psy_fg\n");
+		goto err_free;
+	}
+
+	fuelgauge->is_fuel_alerted = false;
+	if (fuelgauge->pdata->fuel_alert_soc >= 0) {
+		if (sm5705_fg_fuelalert_init(fuelgauge->client,
+			fuelgauge->pdata->fuel_alert_soc))
+			wake_lock_init(&fuelgauge->fuel_alert_wake_lock,
+				WAKE_LOCK_SUSPEND, "fuel_alerted");
+		else {
+			pr_err("Failed to Initialize Fuel-alert\n");
+			goto err_irq;
+		}
+	}
+
+	if (fuelgauge->pdata->fg_irq > 0) {
+		INIT_DELAYED_WORK(
+			&fuelgauge->isr_work, sm5705_fg_isr_work);
+
+		fuelgauge->fg_irq = gpio_to_irq(fuelgauge->pdata->fg_irq);
+		pr_info("fg_irq = %d\n", fuelgauge->fg_irq);
+		if (fuelgauge->fg_irq > 0) {
+			ret = request_threaded_irq(fuelgauge->fg_irq,
+					NULL, sm5705_fg_irq_thread,
+					IRQF_TRIGGER_FALLING
+					 | IRQF_ONESHOT,
+					"fuelgauge-irq", fuelgauge);
+			if (ret) {
+				pr_err("Failed to Reqeust IRQ\n");
+				goto err_supply_unreg;
+			}
+
+			ret = enable_irq_wake(fuelgauge->fg_irq);
+			if (ret < 0)
+				pr_err("Failed to Enable Wakeup Source(%d)\n", ret);
+		} else {
+			pr_err("Failed gpio_to_irq(%d)\n", fuelgauge->fg_irq);
+			goto err_supply_unreg;
+		}
+	}
+
+	fuelgauge->initial_update_of_soc = true;
+	fuelgauge->info.temperature = 250;
+
+	//if (sec_bat_check_jig_status())
+	//	sm5705_fg_reset_capacity_by_jig_connection(fuelgauge);
+
+	ret = sm5705_create_attrs(fuelgauge->psy_fg.dev);
+	if (ret) {
+		pr_err("Failed to create_attrs\n");
+		goto err_irq;
+	}
+
+	pr_info("SEC Fuelgauge Driver Loaded\n");
+	return 0;
+
+err_irq:
+	if (fuelgauge->fg_irq > 0)
+		free_irq(fuelgauge->fg_irq, fuelgauge);
+	wake_lock_destroy(&fuelgauge->fuel_alert_wake_lock);
+err_supply_unreg:
+	power_supply_unregister(&fuelgauge->psy_fg);
+err_devm_free:
+err_parse_dt:
+	if(pdata)
+		devm_kfree(&client->dev, pdata);
+//	if(battery_data)
+//		devm_kfree(&client->dev, battery_data);
+err_free:
+	mutex_destroy(&fuelgauge->fg_lock);
+	kfree(fuelgauge);
+
+	pr_info("Fuel gauge probe failed\n");
+	return ret;
+}
+
+static int sm5705_fuelgauge_remove(
+						struct i2c_client *client)
+{
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+
+	if (fuelgauge->pdata->fuel_alert_soc >= 0)
+		wake_lock_destroy(&fuelgauge->fuel_alert_wake_lock);
+
+	return 0;
+}
+
+static int sm5705_fuelgauge_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int sm5705_fuelgauge_resume(struct device *dev)
+{
+	struct sec_fuelgauge_info *fuelgauge = dev_get_drvdata(dev);
+
+	fuelgauge->initial_update_of_soc = true;
+
+	return 0;
+}
+
+static void sm5705_fuelgauge_shutdown(struct i2c_client *client)
+{
+}
+
+static const struct i2c_device_id sm5705_fuelgauge_id[] = {
+	{"sm5705-fuelgauge", 0},
+	{}
+};
+
+static const struct dev_pm_ops sm5705_fuelgauge_pm_ops = {
+	.suspend = sm5705_fuelgauge_suspend,
+	.resume  = sm5705_fuelgauge_resume,
+};
+
+MODULE_DEVICE_TABLE(i2c, sm5705_fuelgauge_id);
+static struct of_device_id fuelgague_i2c_match_table[] = {
+	{ .compatible = "sm,sm5705-fuelgauge", },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, fuelgague_i2c_match_table);
+
+static struct i2c_driver sm5705_fuelgauge_driver = {
+	.driver = {
+		   .name = "sm5705-fuelgauge",
+		   .owner = THIS_MODULE,
+		   .of_match_table = fuelgague_i2c_match_table,
+#ifdef CONFIG_PM
+		   .pm = &sm5705_fuelgauge_pm_ops,
+#endif
+	},
+	.probe	= sm5705_fuelgauge_probe,
+	.remove	= sm5705_fuelgauge_remove,
+	.shutdown   = sm5705_fuelgauge_shutdown,
+	.id_table   = sm5705_fuelgauge_id,
+};
+
+static int __init sm5705_fuelgauge_init(void)
+{
+	pr_info("called\n");
+	return i2c_add_driver(&sm5705_fuelgauge_driver);
+}
+
+static void __exit sm5705_fuelgauge_exit(void)
+{
+	i2c_del_driver(&sm5705_fuelgauge_driver);
+}
+
+module_init(sm5705_fuelgauge_init);
+module_exit(sm5705_fuelgauge_exit);
+
+MODULE_DESCRIPTION("Samsung SM5705 Fuel Gauge Driver");
+MODULE_AUTHOR("Samsung Electronics");
+MODULE_LICENSE("GPL");
diff -Naur linux-3.18.14/drivers/battery/smb347_charger.c samsung/drivers/battery/smb347_charger.c
--- linux-3.18.14/drivers/battery/smb347_charger.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery/smb347_charger.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,740 @@
+/*
+ *  smb347_charger.c
+ *  Samsung SMB347 Charger Driver
+ *
+ *  Copyright (C) 2012 Samsung Electronics
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#define DEBUG
+
+#include <linux/battery/sec_charger.h>
+static int smb347_i2c_write(struct i2c_client *client,
+				int reg, u8 *buf)
+{
+	int ret;
+	ret = i2c_smbus_write_i2c_block_data(client, reg, 1, buf);
+	if (ret < 0)
+		dev_err(&client->dev, "%s: Error(%d)\n", __func__, ret);
+	return ret;
+}
+
+static int smb347_i2c_read(struct i2c_client *client,
+				int reg, u8 *buf)
+{
+	int ret;
+	ret = i2c_smbus_read_i2c_block_data(client, reg, 1, buf);
+	if (ret < 0)
+		dev_err(&client->dev, "%s: Error(%d)\n", __func__, ret);
+	return ret;
+}
+
+static void smb347_i2c_write_array(struct i2c_client *client,
+				u8 *buf, int size)
+{
+	int i;
+	for (i = 0; i < size; i += 3)
+		smb347_i2c_write(client, (u8) (*(buf + i)), (buf + i) + 1);
+}
+
+static void smb347_set_command(struct i2c_client *client,
+				int reg, int datum)
+{
+	int val;
+	u8 data = 0;
+	val = smb347_i2c_read(client, reg, &data);
+	if (val >= 0) {
+		dev_dbg(&client->dev, "%s : reg(0x%02x): 0x%02x",
+			__func__, reg, data);
+		if (data != datum) {
+			data = datum;
+			if (smb347_i2c_write(client, reg, &data) < 0)
+				dev_err(&client->dev,
+					"%s : error!\n", __func__);
+			val = smb347_i2c_read(client, reg, &data);
+			if (val >= 0)
+				dev_dbg(&client->dev, " => 0x%02x\n", data);
+		}
+	}
+}
+
+static void smb347_test_read(struct i2c_client *client)
+{
+	u8 data = 0;
+	u32 addr = 0;
+	for (addr = 0; addr <= 0x0f; addr++) {
+		smb347_i2c_read(client, addr, &data);
+		dev_dbg(&client->dev,
+			"smb347 addr : 0x%02x data : 0x%02x\n", addr, data);
+	}
+	for (addr = 0x30; addr <= 0x3f; addr++) {
+		smb347_i2c_read(client, addr, &data);
+		dev_dbg(&client->dev,
+			"smb347 addr : 0x%02x data : 0x%02x\n", addr, data);
+	}
+}
+
+static void smb347_read_regs(struct i2c_client *client, char *str)
+{
+	u8 data = 0;
+	u32 addr = 0;
+
+	for (addr = 0; addr <= 0x0f; addr++) {
+		smb347_i2c_read(client, addr, &data);
+		sprintf(str+strlen(str), "0x%x, ", data);
+	}
+
+	/* "#" considered as new line in application */
+	sprintf(str+strlen(str), "#");
+
+	for (addr = 0x30; addr <= 0x3f; addr++) {
+		smb347_i2c_read(client, addr, &data);
+		sprintf(str+strlen(str), "0x%x, ", data);
+	}
+}
+
+static int smb347_read_reg(struct i2c_client *client, int reg)
+{
+	int ret;
+
+	ret = i2c_smbus_read_byte_data(client, reg);
+
+	if (ret < 0) {
+		pr_err("%s: err %d, try again!\n", __func__, ret);
+		ret = i2c_smbus_read_byte_data(client, reg);
+		if (ret < 0)
+			pr_err("%s: err %d\n", __func__, ret);
+	}
+
+	return ret;
+}
+
+static int smb347_get_charging_status(struct i2c_client *client)
+{
+	int status = POWER_SUPPLY_STATUS_UNKNOWN;
+	u8 data_a = 0;
+	u8 data_b = 0;
+	u8 data_c = 0;
+	u8 data_d = 0;
+	u8 data_e = 0;
+
+	smb347_i2c_read(client, SMB347_STATUS_A, &data_a);
+	dev_info(&client->dev,
+		"%s : charger status A(0x%02x)\n", __func__, data_a);
+	smb347_i2c_read(client, SMB347_STATUS_B, &data_b);
+	dev_info(&client->dev,
+		"%s : charger status B(0x%02x)\n", __func__, data_b);
+	smb347_i2c_read(client, SMB347_STATUS_C, &data_c);
+	dev_info(&client->dev,
+		"%s : charger status C(0x%02x)\n", __func__, data_c);
+	smb347_i2c_read(client, SMB347_STATUS_D, &data_d);
+	dev_info(&client->dev,
+		"%s : charger status D(0x%02x)\n", __func__, data_d);
+	smb347_i2c_read(client, SMB347_STATUS_E, &data_e);
+	dev_info(&client->dev,
+		"%s : charger status E(0x%02x)\n", __func__, data_e);
+
+	/* At least one charge cycle terminated,
+	 * Charge current < Termination Current
+	 */
+	if ((data_c & 0x20) == 0x20) {
+		/* top-off by full charging */
+		status = POWER_SUPPLY_STATUS_FULL;
+		goto charging_status_end;
+	}
+
+	/* Is enabled ? */
+	if (data_c & 0x01) {
+		/* check for 0x06 : no charging (0b00) */
+		/* not charging */
+		if (!(data_c & 0x06)) {
+			status = POWER_SUPPLY_STATUS_NOT_CHARGING;
+			goto charging_status_end;
+		} else {
+			status = POWER_SUPPLY_STATUS_CHARGING;
+			goto charging_status_end;
+		}
+	} else
+		status = POWER_SUPPLY_STATUS_DISCHARGING;
+charging_status_end:
+	return (int)status;
+}
+
+static int smb347_get_charging_health(struct i2c_client *client)
+{
+	int health = POWER_SUPPLY_HEALTH_GOOD;
+	u8 data_a = 0;
+	u8 data_b = 0;
+	u8 data_c = 0;
+	u8 data_d = 0;
+	u8 data_e = 0;
+
+	smb347_i2c_read(client, SMB347_STATUS_A, &data_a);
+	dev_info(&client->dev,
+		"%s : charger status A(0x%02x)\n", __func__, data_a);
+	smb347_i2c_read(client, SMB347_STATUS_B, &data_b);
+	dev_info(&client->dev,
+		"%s : charger status B(0x%02x)\n", __func__, data_b);
+	smb347_i2c_read(client, SMB347_STATUS_C, &data_c);
+	dev_info(&client->dev,
+		"%s : charger status C(0x%02x)\n", __func__, data_c);
+	smb347_i2c_read(client, SMB347_STATUS_D, &data_d);
+	dev_info(&client->dev,
+		"%s : charger status D(0x%02x)\n", __func__, data_d);
+	smb347_i2c_read(client, SMB347_STATUS_E, &data_e);
+	dev_info(&client->dev,
+		"%s : charger status E(0x%02x)\n", __func__, data_e);
+
+	/* Is enabled ? */
+	if (data_c & 0x01) {
+		if (!(data_a & 0x02))	/* Input current is NOT OK */
+			health = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+	}
+	return (int)health;
+}
+
+static void smb347_allow_volatile_writes(struct i2c_client *client)
+{
+	int val, reg;
+	u8 data;
+	reg = SMB347_COMMAND_A;
+	val = smb347_i2c_read(client, reg, &data);
+	if ((val >= 0) && !(data & 0x80)) {
+		dev_dbg(&client->dev,
+			"%s : reg(0x%02x): 0x%02x", __func__, reg, data);
+		data |= (0x1 << 7);
+		if (smb347_i2c_write(client, reg, &data) < 0)
+			dev_err(&client->dev, "%s : error!\n", __func__);
+		val = smb347_i2c_read(client, reg, &data);
+		if (val >= 0) {
+			data = (u8) data;
+			dev_dbg(&client->dev, " => 0x%02x\n", data);
+		}
+	}
+}
+
+static u8 smb347_get_float_voltage_data(
+			int float_voltage)
+{
+	u8 data;
+
+	if (float_voltage < 3500)
+		float_voltage = 3500;
+
+	data = (float_voltage - 3500) / 20;
+
+	return data;
+}
+
+static u8 smb347_get_input_current_limit_data(
+			struct sec_charger_info *charger, int input_current)
+{
+	u8 data;
+
+	if (input_current <= 300)
+		data = 0x0;
+	else if (input_current <= 500)
+		data = 0x1;
+	else if (input_current <= 700)
+		data = 0x2;
+	else if (input_current <= 900)
+		data = 0x3;
+	else if (input_current <= 1200)
+		data = 0x4;
+	else if (input_current <= 1500)
+		data = 0x5;
+	else if (input_current <= 1800)
+		data = 0x6;
+	else if (input_current <= 2000)
+		data = 0x7;
+	else if (input_current <= 2200)
+		data = 0x8;
+	else if (input_current <= 2500)
+		data = 0x9;
+	else
+		data = 0;
+
+	return data;
+}
+
+static u8 smb347_get_termination_current_limit_data(
+			int termination_current)
+{
+	u8 data;
+
+	if (termination_current <= 37)
+		data = 0x0;
+	else if (termination_current <= 50)
+		data = 0x1;
+	else if (termination_current <= 100)
+		data = 0x2;
+	else if (termination_current <= 150)
+		data = 0x3;
+	else if (termination_current <= 200)
+		data = 0x4;
+	else if (termination_current <= 250)
+		data = 0x5;
+	else if (termination_current <= 500)
+		data = 0x6;
+	else if (termination_current <= 600)
+		data = 0x7;
+	else
+		data = 0;
+
+	return data;
+}
+
+static u8 smb347_get_fast_charging_current_data(
+			int fast_charging_current)
+{
+	u8 data;
+
+	if (fast_charging_current <= 700)
+		data = 0x0;
+	else if (fast_charging_current <= 900)
+		data = 0x1;
+	else if (fast_charging_current <= 1200)
+		data = 0x2;
+	else if (fast_charging_current <= 1500)
+		data = 0x3;
+	else if (fast_charging_current <= 1800)
+		data = 0x4;
+	else if (fast_charging_current <= 2000)
+		data = 0x5;
+	else if (fast_charging_current <= 2200)
+		data = 0x6;
+	else if (fast_charging_current <= 2500)
+		data = 0x7;
+	else
+		data = 0;
+
+	return data << 5;
+}
+
+static void smb347_charger_function_conrol(
+				struct i2c_client *client)
+{
+	struct sec_charger_info *charger = i2c_get_clientdata(client);
+	u8 data;
+
+	if (charger->charging_current < 0) {
+		dev_dbg(&client->dev,
+			"%s : OTG is activated. Ignore command!\n", __func__);
+		return;
+	}
+	smb347_allow_volatile_writes(client);
+
+	if (charger->cable_type ==
+		POWER_SUPPLY_TYPE_BATTERY) {
+		/* turn off charger */
+		smb347_set_command(client,
+			SMB347_COMMAND_A, 0x80);
+
+		/* high current mode for system current */
+		smb347_set_command(client,
+			SMB347_COMMAND_B, 0x01);
+	} else {
+		/* Pre-charge curr 250mA */
+		dev_dbg(&client->dev,
+			"%s : fast charging current (%dmA)\n",
+			__func__, charger->charging_current);
+		dev_dbg(&client->dev,
+			"%s : termination current (%dmA)\n",
+			__func__, charger->pdata->charging_current[
+			charger->cable_type].full_check_current_1st);
+		data = 0x1c;
+		data |= smb347_get_fast_charging_current_data(
+			charger->charging_current);
+		data |= smb347_get_termination_current_limit_data(
+			charger->pdata->charging_current[
+			charger->cable_type].full_check_current_1st);
+		smb347_set_command(client,
+			SMB347_CHARGE_CURRENT, data);
+
+		/* Pin enable control */
+		/* DCIN Input Pre-bias Enable */
+		data = 0x01;
+		if (charger->pdata->chg_gpio_en)
+			data |= 0x40;
+		if (charger->pdata->chg_polarity_en)
+			data |= 0x20;
+		smb347_set_command(client,
+			SMB347_PIN_ENABLE_CONTROL, data);
+
+		/* Input current limit */
+		dev_dbg(&client->dev, "%s : input current (%dmA)\n",
+			__func__, charger->pdata->charging_current
+			[charger->cable_type].input_current_limit);
+		data = 0;
+		data = smb347_get_input_current_limit_data(
+			charger,
+			charger->pdata->charging_current
+			[charger->cable_type].input_current_limit);
+		smb347_set_command(client,
+			SMB347_INPUT_CURRENTLIMIT, data);
+
+		/*
+		 * Input to System FET by Register
+		 * Enable AICL, VCHG
+		 * Max System voltage =Vflt + 0.1v
+		 * Input Source Priority : USBIN
+		 */
+		if (charger->pdata->chg_functions_setting &
+			SEC_CHARGER_NO_GRADUAL_CHARGING_CURRENT)
+			/* disable AICL */
+			smb347_set_command(client,
+				SMB347_VARIOUS_FUNCTIONS, 0x85);
+		else
+			/* enable AICL */
+			smb347_set_command(client,
+				SMB347_VARIOUS_FUNCTIONS, 0x95);
+
+		/* Float voltage, Vprechg : 2.4V */
+		dev_dbg(&client->dev, "%s : float voltage (%dmV)\n",
+				__func__, charger->pdata->chg_float_voltage);
+		data = 0;
+		data |= smb347_get_float_voltage_data(
+			charger->pdata->chg_float_voltage);
+		smb347_set_command(client,
+			SMB347_FLOAT_VOLTAGE, data);
+
+		/* Charge control
+		 * Automatic Recharge disable,
+		 * Current Termination disable,
+		 * BMD disable, Recharge Threshold =50mV,
+		 * APSD disable */
+		data = 0xC0;
+		switch (charger->pdata->full_check_type) {
+		case SEC_BATTERY_FULLCHARGED_CHGGPIO:
+		case SEC_BATTERY_FULLCHARGED_CHGINT:
+		case SEC_BATTERY_FULLCHARGED_CHGPSY:
+			/* Enable Current Termination */
+			data &= 0xBF;
+			break;
+		default:
+			break;
+		}
+		smb347_set_command(client,
+			SMB347_CHARGE_CONTROL, data);
+
+		/* STAT, Timer control : STAT active low,
+		 * Complete time out 1527min.
+		 */
+		smb347_set_command(client,
+			SMB347_STAT_TIMERS_CONTROL, 0x1A);
+
+		/* Pin/Enable
+		 * USB 5/1/HC Dual state
+		 * DCIN pre-bias Enable
+		 */
+		smb347_set_command(client,
+			SMB347_PIN_ENABLE_CONTROL, 0x09);
+
+		/* Therm control :
+		 * Therm monitor disable,
+		 * Minimum System Voltage 3.60V
+		 */
+		smb347_set_command(client,
+			SMB347_THERM_CONTROL_A, 0x7F);
+
+		/* USB selection : USB2.0(100mA/500mA),
+		 * INOK polarity Active low
+		 */
+		smb347_set_command(client,
+			SMB347_SYSOK_USB30_SELECTION, 0x08);
+
+		/* Other control
+		 * Low batt detection disable
+		 * Minimum System Voltage 3.60V
+		 */
+		smb347_set_command(client,
+			SMB347_OTHER_CONTROL_A, 0x00);
+
+		/* OTG tlim therm control */
+		smb347_set_command(client,
+			SMB347_OTG_TLIM_THERM_CONTROL, 0x3F);
+
+		/* Limit cell temperature */
+		smb347_set_command(client,
+			SMB347_LIMIT_CELL_TEMPERATURE_MONITOR, 0x01);
+
+		/* Fault interrupt : Clear */
+		smb347_set_command(client,
+			SMB347_FAULT_INTERRUPT, 0x00);
+
+		/* STATUS ingerrupt : Clear */
+		smb347_set_command(client,
+			SMB347_STATUS_INTERRUPT, 0x00);
+
+		/* turn on charger */
+		smb347_set_command(client,
+			SMB347_COMMAND_A, 0xC2);
+
+		/* HC or USB5 mode */
+		switch (charger->cable_type) {
+		case POWER_SUPPLY_TYPE_MAINS:
+		case POWER_SUPPLY_TYPE_MISC:
+			/* High-current mode */
+			data = 0x01;
+			break;
+		case POWER_SUPPLY_TYPE_USB:
+		case POWER_SUPPLY_TYPE_USB_DCP:
+		case POWER_SUPPLY_TYPE_USB_CDP:
+		case POWER_SUPPLY_TYPE_USB_ACA:
+			/* USB5 */
+			data = 0x02;
+			break;
+		default:
+			/* USB1 */
+			data = 0x00;
+			break;
+		}
+		smb347_set_command(client,
+			SMB347_COMMAND_B, data);
+	}
+}
+
+static void smb347_charger_otg_conrol(
+				struct i2c_client *client)
+{
+	struct sec_charger_info *charger = i2c_get_clientdata(client);
+	smb347_allow_volatile_writes(client);
+	if (charger->cable_type ==
+		POWER_SUPPLY_TYPE_BATTERY) {
+		/* turn off charger */
+		smb347_set_command(client,
+			SMB347_COMMAND_A, 0x80);
+	} else {
+		/* turn on OTG */
+		smb347_set_command(client,
+			SMB347_COMMAND_A, (0x1 << 4));
+	}
+}
+
+static int smb347_check_charging_status(struct i2c_client *client)
+{
+	int val, reg;
+	u8 data = 0;
+	int ret = -1;
+
+	reg = SMB347_STATUS_C;	/* SMB328A_BATTERY_CHARGING_STATUS_C */
+	val = smb347_read_reg(client, reg);
+	if (val >= 0) {
+		data = (u8) val;
+		pr_debug("%s : reg (0x%x) = 0x%x\n", __func__, reg, data);
+
+		ret = (data & (0x3 << 1)) >> 1;
+		pr_debug("%s : status = 0x%x\n", __func__, data);
+	}
+
+	return ret;
+}
+
+bool sec_hal_chg_init(struct i2c_client *client)
+{
+	smb347_test_read(client);
+	return true;
+}
+
+bool sec_hal_chg_suspend(struct i2c_client *client)
+{
+	return true;
+}
+
+bool sec_hal_chg_resume(struct i2c_client *client)
+{
+	return true;
+}
+
+bool sec_hal_chg_get_property(struct i2c_client *client,
+			      enum power_supply_property psp,
+			      union power_supply_propval *val)
+{
+	struct sec_charger_info *charger = i2c_get_clientdata(client);
+	u8 data;
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = smb347_get_charging_status(client);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+		switch (smb347_check_charging_status(client)) {
+		case 0:
+			val->intval = POWER_SUPPLY_CHARGE_TYPE_NONE;
+			break;
+		case 1:
+			val->intval = POWER_SUPPLY_CHARGE_TYPE_UNKNOWN;
+			break;
+		case 2:
+			val->intval = POWER_SUPPLY_CHARGE_TYPE_FAST;
+			break;
+		case 3:
+			val->intval = POWER_SUPPLY_CHARGE_TYPE_TRICKLE;
+			break;
+		default:
+			pr_err("%s : get charge type error!\n", __func__);
+			return -EINVAL;
+		}
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = smb347_get_charging_health(client);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		if (charger->charging_current) {
+			smb347_i2c_read(client, SMB347_STATUS_B, &data);
+			if (data & 0x20)
+				switch (data & 0x18) {
+				case 0:
+					val->intval = 100;
+					break;
+				case 1:
+					val->intval = 150;
+					break;
+				case 2:
+					val->intval = 200;
+					break;
+				case 3:
+					val->intval = 250;
+					break;
+				}
+			else
+				switch (data & 0x07) {
+				case 0:
+					val->intval = 700;
+					break;
+				case 1:
+					val->intval = 900;
+					break;
+				case 2:
+					val->intval = 1200;
+					break;
+				case 3:
+					val->intval = 1500;
+					break;
+				case 4:
+					val->intval = 1800;
+					break;
+				case 5:
+					val->intval = 2000;
+					break;
+				case 6:
+					val->intval = 2200;
+					break;
+				case 7:
+					val->intval = 2500;
+					break;
+				}
+		} else
+			val->intval = 0;
+		dev_dbg(&client->dev,
+			"%s : set-current(%dmA), current now(%dmA)\n",
+			__func__, charger->charging_current, val->intval);
+		break;
+	default:
+		return false;
+	}
+	return true;
+}
+
+bool sec_hal_chg_set_property(struct i2c_client *client,
+			      enum power_supply_property psp,
+			      const union power_supply_propval *val)
+{
+	struct sec_charger_info *charger = i2c_get_clientdata(client);
+
+	switch (psp) {
+	/* val->intval : type */
+	case POWER_SUPPLY_PROP_ONLINE:
+	/* val->intval : charging current */
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		if (charger->charging_current < 0)
+			smb347_charger_otg_conrol(client);
+		else if (charger->charging_current > 0)
+			smb347_charger_function_conrol(client);
+		else {
+			smb347_charger_function_conrol(client);
+			smb347_charger_otg_conrol(client);
+		}
+		smb347_test_read(client);
+		break;
+	default:
+		return false;
+	}
+	return true;
+}
+
+ssize_t sec_hal_chg_show_attrs(struct device *dev,
+				const ptrdiff_t offset, char *buf)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct sec_charger_info *chg =
+		container_of(psy, struct sec_charger_info, psy_chg);
+	int i = 0;
+	char *str = NULL;
+
+	switch (offset) {
+	case CHG_DATA:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%x\n",
+			chg->reg_data);
+		break;
+	case CHG_REGS:
+		str = kzalloc(sizeof(char)*1024, GFP_KERNEL);
+		if (!str)
+			return -ENOMEM;
+
+		smb347_read_regs(chg->client, str);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%s\n",
+			str);
+
+		kfree(str);
+		break;
+	default:
+		i = -EINVAL;
+		break;
+	}
+
+	return i;
+}
+
+ssize_t sec_hal_chg_store_attrs(struct device *dev,
+				const ptrdiff_t offset,
+				const char *buf, size_t count)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct sec_charger_info *chg =
+		container_of(psy, struct sec_charger_info, psy_chg);
+	int ret = 0;
+	int x = 0;
+	u8 data = 0;
+
+	switch (offset) {
+	case CHG_REG:
+		if (sscanf(buf, "%x\n", &x) == 1) {
+			chg->reg_addr = x;
+			smb347_i2c_read(chg->client,
+				chg->reg_addr, &data);
+			chg->reg_data = data;
+			dev_dbg(dev, "%s: (read) addr = 0x%x, data = 0x%x\n",
+				__func__, chg->reg_addr, chg->reg_data);
+			ret = count;
+		}
+		break;
+	case CHG_DATA:
+		if (sscanf(buf, "%x\n", &x) == 1) {
+			data = (u8)x;
+			dev_dbg(dev, "%s: (write) addr = 0x%x, data = 0x%x\n",
+				__func__, chg->reg_addr, data);
+			smb347_i2c_write(chg->client,
+				chg->reg_addr, &data);
+			ret = count;
+		}
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
diff -Naur linux-3.18.14/drivers/battery_v2/battery_notifier.c samsung/drivers/battery_v2/battery_notifier.c
--- linux-3.18.14/drivers/battery_v2/battery_notifier.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/battery_notifier.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,204 @@
+#include <linux/device.h>
+
+#include <linux/notifier.h>
+#include <linux/battery/battery_notifier.h>
+#include <linux/sec_sysfs.h>
+
+#define DEBUG
+#define SET_BATTERY_NOTIFIER_BLOCK(nb, fn, dev) do {	\
+		(nb)->notifier_call = (fn);		\
+		(nb)->priority = (dev);			\
+	} while (0)
+
+#define DESTROY_BATTERY_NOTIFIER_BLOCK(nb)			\
+		SET_BATTERY_NOTIFIER_BLOCK(nb, NULL, -1)
+
+static struct charger_notifier_struct charger_notifier;
+static struct pdic_notifier_struct pdic_notifier;
+
+struct device *charger_device;
+struct device *pdic_device;
+
+int charger_notifier_register(struct notifier_block *nb, notifier_fn_t notifier,
+			charger_notifier_device_t listener)
+{
+	int ret = 0;
+
+	pr_info("%s: listener=%d register\n", __func__, listener);
+
+	/* Check if CHARGER Notifier is ready. */
+	if (!charger_device) {
+		pr_err("%s: Not Initialized...\n", __func__);
+		return -1;
+	}
+
+	SET_BATTERY_NOTIFIER_BLOCK(nb, notifier, listener);
+	ret = blocking_notifier_chain_register(&(charger_notifier.notifier_call_chain), nb);
+	if (ret < 0)
+		pr_err("%s: blocking_notifier_chain_register error(%d)\n",
+				__func__, ret);
+
+	/* current charger's attached_device status notify */
+	nb->notifier_call(nb, charger_notifier.event,
+			&(charger_notifier));
+
+	return ret;
+}
+
+int charger_notifier_unregister(struct notifier_block *nb)
+{
+	int ret = 0;
+
+	pr_info("%s: listener=%d unregister\n", __func__, nb->priority);
+
+	ret = blocking_notifier_chain_unregister(&(charger_notifier.notifier_call_chain), nb);
+	if (ret < 0)
+		pr_err("%s: blocking_notifier_chain_unregister error(%d)\n",
+				__func__, ret);
+	DESTROY_BATTERY_NOTIFIER_BLOCK(nb);
+
+	return ret;
+}
+#if 0
+int pdic_notifier_register(struct notifier_block *nb, notifier_fn_t notifier,
+			pdic_notifier_device_t listener)
+{
+	int ret = 0;
+
+	pr_info("%s: listener=%d register\n", __func__, listener);
+
+	/* Check if CHARGER Notifier is ready. */
+	if (!pdic_device) {
+		pr_err("%s: Not Initialized...\n", __func__);
+		return -1;
+	}
+
+	SET_BATTERY_NOTIFIER_BLOCK(nb, notifier, listener);
+	ret = blocking_notifier_chain_register(&(pdic_notifier.notifier_call_chain), nb);
+	if (ret < 0)
+		pr_err("%s: blocking_notifier_chain_register error(%d)\n",
+				__func__, ret);
+
+	/* current pdic's attached_device status notify */
+	nb->notifier_call(nb, pdic_notifier.event,
+			&(pdic_notifier));
+
+	return ret;
+}
+
+int pdic_notifier_unregister(struct notifier_block *nb)
+{
+	int ret = 0;
+
+	pr_info("%s: listener=%d unregister\n", __func__, nb->priority);
+
+	ret = blocking_notifier_chain_unregister(&(pdic_notifier.notifier_call_chain), nb);
+	if (ret < 0)
+		pr_err("%s: blocking_notifier_chain_unregister error(%d)\n",
+				__func__, ret);
+	DESTROY_BATTERY_NOTIFIER_BLOCK(nb);
+
+	return ret;
+}
+#endif
+static int battery_notifier_notify(int type)
+{
+	int ret = 0;
+
+	switch (type) {
+	case CHARGER_NOTIFY:
+		ret = blocking_notifier_call_chain(&(charger_notifier.notifier_call_chain),
+				charger_notifier.event, &(charger_notifier));
+		break;
+	case PDIC_NOTIFY:
+		ret = blocking_notifier_call_chain(&(pdic_notifier.notifier_call_chain),
+				pdic_notifier.event, &(pdic_notifier));
+		break;
+	default:
+		pr_info("%s: notify status unknown(0x%x)\n", __func__, ret);
+		break;
+	}
+
+	switch (ret) {
+	case NOTIFY_STOP_MASK:
+	case NOTIFY_BAD:
+		pr_err("%s: notify error occur(0x%x)\n", __func__, ret);
+		break;
+	case NOTIFY_DONE:
+	case NOTIFY_OK:
+		pr_info("%s: notify done(0x%x)\n", __func__, ret);
+		break;
+	default:
+		pr_info("%s: notify status unknown(0x%x)\n", __func__, ret);
+		break;
+	}
+
+	return ret;
+}
+
+static void charger_notifier_set_property(struct charger_notifier_struct * value)
+{
+	charger_notifier.event = value->event;
+	switch(value->event) {
+		case CHARGER_NOTIFY_EVENT_AICL:
+			charger_notifier.aicl_status.input_current = value->aicl_status.input_current;
+			break;
+		default:
+			break;
+	}
+}
+
+void charger_notifier_call(struct charger_notifier_struct *value)
+{
+	/* charger's event broadcast */
+	pr_info("%s: CHARGER_NOTIFY_EVENT :%d\n", __func__, value->event);
+	charger_notifier_set_property(value);
+	battery_notifier_notify(CHARGER_NOTIFY);
+}
+
+static void pdic_notifier_set_property(struct pdic_notifier_struct *value)
+{
+	pdic_notifier.event = value->event;
+	switch(value->event) {
+		case PDIC_NOTIFY_EVENT_PD_SINK:
+			pdic_notifier.sink_status = value->sink_status;
+			break;
+		default:
+			break;
+	}
+}
+
+void pdic_notifier_call(struct pdic_notifier_struct *value)
+{
+	/* pdic's event broadcast */
+	pdic_notifier_set_property(value);
+	battery_notifier_notify(PDIC_NOTIFY);
+}
+
+int battery_notifier_init(void)
+{
+	int ret = 0;
+
+	pr_info("%s\n", __func__);
+
+	charger_device = sec_device_create(NULL, "charger_notifier");
+	pdic_device = sec_device_create(NULL, "pdic_notifier");
+	if (IS_ERR(charger_device)) {
+		pr_err("%s Failed to create device(charger_notifier)!\n", __func__);
+		ret = -ENODEV;
+		goto out;
+	}
+	if (IS_ERR(pdic_device)) {
+		pr_err("%s Failed to create device(pdic_notifier)!\n", __func__);
+		ret = -ENODEV;
+		goto out;
+	}
+
+	BLOCKING_INIT_NOTIFIER_HEAD(&(charger_notifier.notifier_call_chain));
+	BLOCKING_INIT_NOTIFIER_HEAD(&(pdic_notifier.notifier_call_chain));
+
+out:
+	return ret;
+}
+device_initcall(battery_notifier_init);
+
diff -Naur linux-3.18.14/drivers/battery_v2/da9155_charger.c samsung/drivers/battery_v2/da9155_charger.c
--- linux-3.18.14/drivers/battery_v2/da9155_charger.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/da9155_charger.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,636 @@
+/*
+ *  da9155_charger.c
+ *  Samsung da9155 Charger Driver
+ *
+ *  Copyright (C) 2015 Samsung Electronics
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include "include/charger/da9155_charger.h"
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+
+#define DEBUG
+
+#define ENABLE 1
+#define DISABLE 0
+static void da9155_set_charge_current(struct da9155_charger_data *charger,
+	int charge_current);
+
+static enum power_supply_property da9155_charger_props[] = {
+};
+
+static int da9155_read_reg(struct i2c_client *client, u8 reg, u8 *dest)
+{
+	struct da9155_charger_data *charger = i2c_get_clientdata(client);
+	int ret = 0;
+
+	mutex_lock(&charger->io_lock);
+	ret = i2c_smbus_read_byte_data(client, reg);
+	mutex_unlock(&charger->io_lock);
+
+	if (ret < 0) {
+		pr_err("%s: can't read reg(0x%x), ret(%d)\n", __func__, reg, ret);
+		return ret;
+	}
+
+	reg &= 0xFF;
+	*dest = ret;
+
+	return 0;
+}
+
+static int da9155_write_reg(struct i2c_client *client, u8 reg, u8 data)
+{
+	struct da9155_charger_data *charger = i2c_get_clientdata(client);
+	int ret = 0;
+
+	mutex_lock(&charger->io_lock);
+	ret = i2c_smbus_write_byte_data(client, reg, data);
+	mutex_unlock(&charger->io_lock);
+
+	if (ret < 0)
+		pr_err("%s: can't write reg(0x%x), ret(%d)\n", __func__, reg, ret);
+
+	return ret;
+}
+
+static int da9155_update_reg(struct i2c_client *client, u8 reg, u8 val, u8 mask)
+{
+	struct da9155_charger_data *charger = i2c_get_clientdata(client);
+	int ret = 0;
+
+	mutex_lock(&charger->io_lock);
+	ret = i2c_smbus_read_byte_data(client, reg);
+
+	if (ret < 0)
+		pr_err("%s: can't update reg(0x%x), ret(%d)\n", __func__, reg, ret);
+	else {
+		u8 old_val = ret & 0xFF;
+		u8 new_val = (val & mask) | (old_val & (~mask));
+		ret = i2c_smbus_write_byte_data(client, reg, new_val);
+	}
+	mutex_unlock(&charger->io_lock);
+
+	return ret;
+}
+
+static void da9155_charger_test_read(struct da9155_charger_data *charger)
+{
+	u8 data = 0;
+	u32 addr = 0;
+	char str[1024]={0,};
+	for (addr = 0x01; addr <= 0x13; addr++) {
+		da9155_read_reg(charger->i2c, addr, &data);
+		sprintf(str + strlen(str), "[0x%02x]0x%02x, ", addr, data);
+	}
+	pr_info("DA9155 : %s\n", str);
+}
+
+static int da9155_get_charger_state(struct da9155_charger_data *charger)
+{
+	u8 reg_data;
+
+	da9155_read_reg(charger->i2c, DA9155_STATUS_B, &reg_data);
+	if (reg_data & DA9155_MODE_MASK)
+		return POWER_SUPPLY_STATUS_CHARGING;
+	return POWER_SUPPLY_STATUS_NOT_CHARGING;
+}
+
+static int da9155_get_charger_health(struct da9155_charger_data *charger)
+{
+	u8 reg_data;
+
+	// 80s same with maxim IC
+	if (da9155_write_reg(charger->i2c, DA9155_TIMER_B, 0x50) < 0)
+	{
+		dev_info(charger->dev,
+				"%s: addr: 0x%x write fail\n", __func__, DA9155_TIMER_B);
+	}
+
+	da9155_read_reg(charger->i2c, DA9155_STATUS_A, &reg_data);
+	if (reg_data & DA9155_S_VIN_UV_MASK) {
+		pr_info("%s: VIN undervoltage\n", __func__);
+		return POWER_SUPPLY_HEALTH_UNDERVOLTAGE;
+	} else if (reg_data & DA9155_S_VIN_DROP_MASK) {
+		pr_info("%s: VIN DROP\n", __func__);
+		return POWER_SUPPLY_HEALTH_UNDERVOLTAGE;
+	} else if (reg_data & DA9155_S_VIN_OV_MASK) {
+		pr_info("%s: VIN overvoltage\n", __func__);
+		return POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+	} else
+		return POWER_SUPPLY_HEALTH_GOOD;
+}
+
+static int da9155_get_charge_current(struct da9155_charger_data *charger)
+{
+	u8 reg_data;
+	int charge_current;
+
+	da9155_read_reg(charger->i2c, DA9155_BUCK_IOUT, &reg_data);
+	charge_current = reg_data * 10 + 250;
+
+	return charge_current;
+}
+
+static void da9155_charger_initialize(struct da9155_charger_data *charger)
+{
+	pr_info("%s\n", __func__);
+
+	/* clear event reg */
+	da9155_update_reg(charger->i2c, DA9155_EVENT_A, 0xFF, 0xFF);
+	da9155_update_reg(charger->i2c, DA9155_EVENT_B, 0xFF, 0xFF);
+
+	/* Safety timer enable */
+	da9155_update_reg(charger->i2c, DA9155_CONTROL_E, 0, DA9155_TIMER_DIS_MASK);
+
+	/* VBAT_OV: MAX(5V) */
+	da9155_update_reg(charger->i2c, DA9155_CONTROL_C, 0x38, DA9155_VBAT_OV_MASK);
+}
+
+static void da9155_set_charger_state(struct da9155_charger_data *charger,
+	int enable)
+{
+	u8 status = 0;
+	int current_setting = 0;
+
+	pr_info("%s: BUCK_EN(%s)\n", enable > 0 ? "ENABLE" : "DISABLE", __func__);
+
+	if (enable){
+		da9155_charger_initialize(charger);
+		da9155_read_reg(charger->i2c, DA9155_STATUS_A, &status);
+		if (status & 0x7E ){
+			pr_info("%s: STATUS_A(0x%X)\n", __func__, status);
+			return;
+		}
+
+		current_setting = da9155_get_charge_current(charger);
+		da9155_set_charge_current(charger, 500);
+		da9155_update_reg(charger->i2c, DA9155_BUCK_CONT, DA9155_BUCK_EN_MASK, DA9155_BUCK_EN_MASK);
+		msleep(10);
+		if (current_setting > 500)
+			da9155_set_charge_current(charger, current_setting);
+	}
+	else {
+		current_setting = da9155_get_charge_current(charger);
+		if (current_setting > 700) {
+			da9155_set_charge_current(charger, 700);
+			msleep(100);
+		}
+		da9155_set_charge_current(charger, 500);
+		msleep(100);
+		da9155_update_reg(charger->i2c, DA9155_BUCK_CONT, 0, DA9155_BUCK_EN_MASK);
+	}
+}
+
+#if 0
+static void da9155_set_input_current(struct da9155_charger_data *charger,
+	int input_current)
+{
+	u8 reg_data;
+
+	reg_data = (input_current - 3000) / 100;
+
+	da9155_update_reg(charger->i2c, DA9155_BUCK_ILIM, reg_data, DA9155_BUCK_ILIM_MASK);
+	pr_info("%s: input_current(%d)\n", __func__, input_current);
+}
+#endif
+
+static void da9155_set_charge_current(struct da9155_charger_data *charger,
+	int charge_current)
+{
+	u8 reg_data;
+
+	if (!charge_current) {
+		reg_data = 0x00;
+	} else {
+		charge_current = (charge_current > 2500) ? 2500 : charge_current;
+		reg_data = (charge_current - 250) / 10;
+	}
+
+	da9155_update_reg(charger->i2c, DA9155_BUCK_IOUT, reg_data, DA9155_BUCK_IOUT_MASK);
+	pr_info("%s: charge_current(%d)\n", __func__, charge_current);
+}
+
+/* return : 0 (AFC type or High Voltage( > 6V), 1 : 5V ) */
+static int da9155_check_cable_type(unsigned int type)
+{
+	if (type == POWER_SUPPLY_TYPE_BATTERY)
+		return -1;
+
+	// AFC or High Voltage charger (6V > )
+	if (type == POWER_SUPPLY_TYPE_HV_MAINS
+			|| type == POWER_SUPPLY_TYPE_HV_MAINS_12V) {
+		return 0;
+	}
+	else {
+		return 1;
+	}
+
+	return -1;
+}
+
+static void da9155_set_vindrop_vbatov(struct da9155_charger_data *charger)
+{
+	/* VBAT OV Enable */
+	da9155_write_reg(charger->i2c, DA9155_PAGE_CTRL_0, 0x06);
+	da9155_write_reg(charger->i2c, 0x39, 0x05);
+	da9155_write_reg(charger->i2c, 0x19, 0x0);
+	da9155_write_reg(charger->i2c, 0x39, 0x0);
+	da9155_write_reg(charger->i2c, DA9155_PAGE_CTRL_0, 0x0);
+
+	/* set VIN_DROP to 4.5V */
+	da9155_write_reg(charger->i2c, DA9155_CONTROL_A, 0x4);
+}
+
+static void da9155_mode_change(struct da9155_charger_data *charger, u8 enable)
+{
+	if(charger->i2c) {
+		pr_info("%s: mode(%d), prev_cable_type(%d), cable_type(%d)\n",
+			__func__, enable,charger->prev_cable_type, charger->cable_type);
+		if (enable == ENABLE) {
+			da9155_write_reg(charger->i2c, DA9155_PAGE_CTRL_0, 0x06);
+			da9155_write_reg(charger->i2c, 0x39, 0x05);
+			da9155_write_reg(charger->i2c, 0x11, 0x04);
+			da9155_write_reg(charger->i2c, 0x39, 0x0);
+			da9155_write_reg(charger->i2c, DA9155_PAGE_CTRL_0, 0x0);
+		} else if (enable == DISABLE) {
+			if((charger->prev_cable_type == POWER_SUPPLY_TYPE_HV_MAINS ||
+				charger->prev_cable_type == POWER_SUPPLY_TYPE_HV_MAINS_12V) &&
+				charger->cable_type == POWER_SUPPLY_TYPE_BATTERY)
+					return;
+
+			da9155_write_reg(charger->i2c, DA9155_PAGE_CTRL_0, 0x06);
+			da9155_write_reg(charger->i2c, 0x39, 0x05);
+			da9155_write_reg(charger->i2c, 0x11, 0x0);
+			if(charger->prev_cable_type != POWER_SUPPLY_TYPE_HV_MAINS &&
+				charger->prev_cable_type != POWER_SUPPLY_TYPE_HV_MAINS_12V &&
+				charger->prev_cable_type != POWER_SUPPLY_TYPE_BATTERY &&
+				charger->cable_type == POWER_SUPPLY_TYPE_BATTERY)
+					return;
+
+			da9155_write_reg(charger->i2c, 0x39, 0x0);
+			da9155_write_reg(charger->i2c, DA9155_PAGE_CTRL_0, 0x0);
+		}
+	}
+}
+
+static irqreturn_t da9155_irq_handler(int irq, void *data)
+{
+	struct da9155_charger_data *charger = data;
+	u8 event_a, event_b;
+
+	dev_info(charger->dev,
+			"%s: \n", __func__);
+
+	if (!da9155_read_reg(charger->i2c, DA9155_EVENT_A, &event_a) &&
+			!da9155_read_reg(charger->i2c, DA9155_EVENT_B, &event_b)) {
+
+		if ((event_b & 0x1) && (charger->cable_type != POWER_SUPPLY_TYPE_BATTERY)) {
+			dev_info(charger->dev, "%s: E_RDY Event occured", __func__);
+			da9155_mode_change(charger, da9155_check_cable_type(charger->cable_type));
+			da9155_charger_initialize(charger);
+			da9155_set_vindrop_vbatov(charger);
+		}
+
+		/* clear event reg */
+		da9155_write_reg(charger->i2c, DA9155_EVENT_A, event_a);
+		da9155_write_reg(charger->i2c, DA9155_EVENT_B, event_b);
+
+		dev_info(charger->dev,
+				"%s: EVENT_A(0x%x), EVENT_B(0x%x)\n",
+				__func__, event_a, event_b);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int da9155_chg_get_property(struct power_supply *psy,
+	enum power_supply_property psp, union power_supply_propval *val)
+{
+	struct da9155_charger_data *charger =
+		container_of(psy, struct da9155_charger_data, psy_chg);
+	enum power_supply_ext_property ext_psp = psp;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_HEALTH:
+		if (charger->cable_type == POWER_SUPPLY_TYPE_HV_MAINS ||
+			charger->cable_type == POWER_SUPPLY_TYPE_HV_MAINS_12V) {
+			da9155_charger_test_read(charger);
+			val->intval = da9155_get_charger_health(charger);
+		} else
+			val->intval = POWER_SUPPLY_HEALTH_GOOD;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = da9155_get_charger_state(charger);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = da9155_get_charge_current(charger);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		return -ENODATA;
+	case POWER_SUPPLY_PROP_MAX ... POWER_SUPPLY_EXT_PROP_MAX:
+		switch (ext_psp) {
+		case POWER_SUPPLY_EXT_PROP_CHECK_SLAVE_I2C:
+			{
+				u8 reg_data;
+				val->intval = (da9155_read_reg(charger->i2c, DA9155_EVENT_B, &reg_data) == 0);
+			}
+			break;
+		case POWER_SUPPLY_EXT_PROP_CHECK_MULTI_CHARGE:
+			val->intval = (da9155_get_charger_health(charger) == POWER_SUPPLY_HEALTH_GOOD) ?
+				da9155_get_charger_state(charger) : POWER_SUPPLY_STATUS_NOT_CHARGING;
+			break;
+		default:
+			return -EINVAL;
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int da9155_chg_set_property(struct power_supply *psy,
+	enum power_supply_property psp, const union power_supply_propval *val)
+{
+	struct da9155_charger_data *charger =
+		container_of(psy, struct da9155_charger_data, psy_chg);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_CHARGING_ENABLED:
+		charger->is_charging =
+			(val->intval == SEC_BAT_CHG_MODE_CHARGING) ? ENABLE : DISABLE;
+		da9155_set_charger_state(charger, charger->is_charging);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		charger->charging_current = val->intval;
+		da9155_set_charge_current(charger, charger->charging_current);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+		charger->siop_level = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		charger->cable_type = val->intval;
+		if (val->intval != POWER_SUPPLY_TYPE_BATTERY) {
+			da9155_mode_change(charger, da9155_check_cable_type(charger->cable_type));
+			charger->prev_cable_type = charger->cable_type;
+			da9155_charger_initialize(charger);
+			da9155_set_vindrop_vbatov(charger);
+		} else {
+			da9155_mode_change(charger, DISABLE);
+			charger->prev_cable_type = POWER_SUPPLY_TYPE_BATTERY;
+		}
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+	case POWER_SUPPLY_PROP_STATUS:
+	case POWER_SUPPLY_PROP_CURRENT_FULL:
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+	case POWER_SUPPLY_PROP_HEALTH:
+		return -ENODATA;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int da9155_charger_parse_dt(struct da9155_charger_data *charger,
+	struct da9155_charger_platform_data *pdata)
+{
+	struct device_node *np = of_find_node_by_name(NULL, "da9155-charger");
+	int ret = 0;
+
+	if (!np) {
+		pr_err("%s: np is NULL\n", __func__);
+		return -1;
+	} else {
+		ret = of_get_named_gpio_flags(np, "da9155-charger,irq-gpio",
+			0, NULL);
+		if (ret < 0) {
+			pr_err("%s: da9155-charger,irq-gpio is empty\n", __func__);
+			pdata->irq_gpio = 0;
+		} else {
+			pdata->irq_gpio = ret;
+			pr_info("%s: irq-gpio = %d\n", __func__, pdata->irq_gpio);
+		}
+	}
+	np = of_find_node_by_name(NULL, "battery");
+	if (!np) {
+		pr_err("%s np NULL\n", __func__);
+	} else {
+		ret = of_property_read_u32(np, "battery,chg_float_voltage",
+					   &charger->float_voltage);
+		if (ret) {
+			pr_info("%s: battery,chg_float_voltage is Empty\n", __func__);
+			charger->float_voltage = 42000;
+		}
+	}
+
+	return ret;
+}
+
+static int da9155_charger_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	struct device_node *of_node = client->dev.of_node;
+	struct da9155_charger_data *charger;
+	struct da9155_charger_platform_data *pdata = client->dev.platform_data;
+	int ret = 0;
+
+	pr_info("%s: DA9155 Charger Driver Loading\n", __func__);
+
+	charger = kzalloc(sizeof(*charger), GFP_KERNEL);
+	if (!charger) {
+		pr_err("%s: Failed to allocate memory\n", __func__);
+		return -ENOMEM;
+	}
+
+	mutex_init(&charger->io_lock);
+	charger->dev = &client->dev;
+	charger->i2c = client;
+	if (of_node) {
+		pdata = devm_kzalloc(&client->dev, sizeof(*pdata), GFP_KERNEL);
+		if (!pdata) {
+			pr_err("%s: Failed to allocate memory\n", __func__);
+			ret = -ENOMEM;
+			goto err_nomem;
+		}
+		ret = da9155_charger_parse_dt(charger, pdata);
+		if (ret < 0)
+			goto err_parse_dt;
+	}
+	charger->pdata = pdata;
+	i2c_set_clientdata(client, charger);
+
+	charger->psy_chg.name			= "da9155-charger";
+	charger->psy_chg.type			= POWER_SUPPLY_TYPE_UNKNOWN;
+	charger->psy_chg.get_property	= da9155_chg_get_property;
+	charger->psy_chg.set_property	= da9155_chg_set_property;
+	charger->psy_chg.properties		= da9155_charger_props;
+	charger->psy_chg.num_properties	= ARRAY_SIZE(da9155_charger_props);
+
+	/* da9155_charger_initialize(charger); */
+	charger->cable_type = POWER_SUPPLY_TYPE_BATTERY;
+	charger->prev_cable_type = POWER_SUPPLY_TYPE_BATTERY;
+
+	ret = power_supply_register(charger->dev, &charger->psy_chg);
+	if (ret) {
+		pr_err("%s: Failed to Register psy_chg\n", __func__);
+		ret = -1;
+		goto err_power_supply_register;
+	}
+
+	if (pdata->irq_gpio) {
+		charger->chg_irq = gpio_to_irq(pdata->irq_gpio);
+
+		ret = request_threaded_irq(charger->chg_irq, NULL,
+			da9155_irq_handler,
+			IRQF_TRIGGER_LOW | IRQF_ONESHOT,
+			"da9155-irq", charger);
+		if (ret < 0) {
+			pr_err("%s: Failed to Request IRQ(%d)\n", __func__, ret);
+			goto err_req_irq;
+		}
+	}
+	device_init_wakeup(charger->dev, 1);
+
+	pr_info("%s: DA9155 Charger Driver Loaded\n", __func__);
+
+	return 0;
+
+err_req_irq:
+	power_supply_unregister(&charger->psy_chg);
+err_power_supply_register:
+err_parse_dt:
+	kfree(pdata);
+err_nomem:
+	mutex_destroy(&charger->io_lock);
+	kfree(charger);
+
+	return ret;
+}
+
+static int da9155_charger_remove(struct i2c_client *client)
+{
+	struct da9155_charger_data *charger = i2c_get_clientdata(client);
+
+	if (charger->chg_irq)
+		free_irq(charger->chg_irq, charger);
+	power_supply_unregister(&charger->psy_chg);
+	mutex_destroy(&charger->io_lock);
+	kfree(charger->pdata);
+	kfree(charger);
+
+	return 0;
+}
+
+static void da9155_charger_shutdown(struct i2c_client *client)
+{
+	struct da9155_charger_data *charger = i2c_get_clientdata(client);
+
+	if (charger->chg_irq)
+		free_irq(charger->chg_irq, charger);
+	da9155_update_reg(client, DA9155_BUCK_CONT, 0, DA9155_BUCK_EN_MASK);
+	da9155_update_reg(client, DA9155_BUCK_IOUT, 0x7D, DA9155_BUCK_ILIM_MASK);
+	if (charger->cable_type != POWER_SUPPLY_TYPE_BATTERY)
+		da9155_mode_change(charger, DISABLE);
+}
+
+static const struct i2c_device_id da9155_charger_id_table[] = {
+	{"da9155-charger", 0},
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, da9155_id_table);
+
+#ifdef CONFIG_OF
+static struct of_device_id da9155_charger_match_table[] = {
+	{.compatible = "dlg,da9155-charger"},
+	{},
+};
+#else
+#define da9155_charger_match_table NULL
+#endif
+
+#if defined(CONFIG_PM)
+static int da9155_charger_suspend(struct device *dev)
+{
+	struct i2c_client *i2c = container_of(dev, struct i2c_client, dev);
+	struct da9155_charger_data *charger = i2c_get_clientdata(i2c);
+
+	if (charger->chg_irq) {
+		if (device_may_wakeup(dev))
+			enable_irq_wake(charger->chg_irq);
+		disable_irq(charger->chg_irq);
+	}
+
+	return 0;
+}
+
+static int da9155_charger_resume(struct device *dev)
+{
+	struct i2c_client *i2c = container_of(dev, struct i2c_client, dev);
+	struct da9155_charger_data *charger = i2c_get_clientdata(i2c);
+
+	if (charger->chg_irq) {
+		if (device_may_wakeup(dev))
+			disable_irq_wake(charger->chg_irq);
+		enable_irq(charger->chg_irq);
+	}
+
+	return 0;
+}
+#else
+#define da9155_charger_suspend		NULL
+#define da9155_charger_resume		NULL
+#endif /* CONFIG_PM */
+
+const struct dev_pm_ops da9155_pm = {
+	.suspend = da9155_charger_suspend,
+	.resume = da9155_charger_resume,
+};
+
+static struct i2c_driver da9155_charger_driver = {
+	.driver = {
+		.name	= "da9155-charger",
+		.owner	= THIS_MODULE,
+#if defined(CONFIG_PM)
+		.pm	= &da9155_pm,
+#endif /* CONFIG_PM */
+		.of_match_table = da9155_charger_match_table,
+	},
+	.probe		= da9155_charger_probe,
+	.remove		= da9155_charger_remove,
+	.shutdown	= da9155_charger_shutdown,
+	.id_table	= da9155_charger_id_table,
+};
+
+static int __init da9155_charger_init(void)
+{
+	pr_info("%s: \n", __func__);
+	return i2c_add_driver(&da9155_charger_driver);
+}
+
+static void __exit da9155_charger_exit(void)
+{
+	pr_info("%s: \n", __func__);
+	i2c_del_driver(&da9155_charger_driver);
+}
+
+module_init(da9155_charger_init);
+module_exit(da9155_charger_exit);
+
+MODULE_DESCRIPTION("Samsung DA9155 Charger Driver");
+MODULE_AUTHOR("Samsung Electronics");
+MODULE_LICENSE("GPL");
diff -Naur linux-3.18.14/drivers/battery_v2/include/charger/da9155_charger.h samsung/drivers/battery_v2/include/charger/da9155_charger.h
--- linux-3.18.14/drivers/battery_v2/include/charger/da9155_charger.h	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/include/charger/da9155_charger.h	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,245 @@
+/*
+ * da9155-charger.h - Header for DA9155
+ * Copyright (C) 2015 Samsung Electronics
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __DA9155_CHARGER_H__
+#define __DA9155_CHARGER_H__
+
+#include "../sec_charging_common.h"
+
+#define DA9155_REGS_BASE                    0
+#define DA9155_REGS_SIZE                    1024
+
+/*---------------------------------------- */
+/* Registers */
+/*---------------------------------------- */
+#define DA9155_PAGE_CTRL_0                   0x0
+#define DA9155_STATUS_A                      0x1
+#define DA9155_STATUS_B                      0x2
+#define DA9155_EVENT_A                       0x3
+#define DA9155_EVENT_B                       0x4
+#define DA9155_MASK_A                        0x5
+#define DA9155_MASK_B                        0x6
+#define DA9155_CONTROL_A                     0x7
+#define DA9155_CONTROL_B                     0x8
+#define DA9155_CONTROL_C                     0x9
+#define DA9155_CONTROL_D                     0xA
+#define DA9155_CONTROL_E                     0xB
+#define DA9155_TIMER_A                       0xC
+#define DA9155_TIMER_B                       0xD
+#define DA9155_BUCK_CONT                     0xE
+#define DA9155_BUCK_ILIM                     0xF
+#define DA9155_BUCK_IOUT                     0x10
+#define DA9155_INTERFACE                     0x11
+#define DA9155_CONFIG_A                      0x12
+#define DA9155_CONFIG_B                      0x13
+
+/*---------------------------------------- */
+/* Bit Fields */
+/*---------------------------------------- */
+
+/* DA9155_PAGE_CTRL_0     = 0x0 */
+#define DA9155_REG_PAGE_SHIFT                0
+#define DA9155_REG_PAGE_MASK                 0x7
+#define DA9155_WRITE_MODE_SHIFT              6
+#define DA9155_WRITE_MODE_MASK               BIT(6)
+#define DA9155_REVERT_SHIFT                  7
+#define DA9155_REVERT_MASK                   BIT(7)
+
+/* DA9155_STATUS_A     = 0x1 */
+#define DA9155_S_TJUNC_WARN_SHIFT            0
+#define DA9155_S_TJUNC_WARN_MASK             0x1
+#define DA9155_S_TJUNC_CRIT_SHIFT            1
+#define DA9155_S_TJUNC_CRIT_MASK             BIT(1)
+#define DA9155_S_VBAT_UV_SHIFT               2
+#define DA9155_S_VBAT_UV_MASK                BIT(2)
+#define DA9155_S_VBAT_OV_SHIFT               3
+#define DA9155_S_VBAT_OV_MASK                BIT(3)
+#define DA9155_S_VIN_UV_SHIFT                4
+#define DA9155_S_VIN_UV_MASK                 BIT(4)
+#define DA9155_S_VIN_DROP_SHIFT              5
+#define DA9155_S_VIN_DROP_MASK               BIT(5)
+#define DA9155_S_VIN_OV_SHIFT                6
+#define DA9155_S_VIN_OV_MASK                 BIT(6)
+#define DA9155_S_EN_BLOCK_SHIFT              7
+#define DA9155_S_EN_BLOCK_MASK               BIT(7)
+#define DA9155_S_FAULT_COND_SHIFT            0
+#define DA9155_S_FAULT_COND_MASK             0xFE
+
+/* DA9155_STATUS_B     = 0x2 */
+#define DA9155_MODE_SHIFT                    0
+#define DA9155_MODE_MASK                     0x1
+#define DA9155_S_EN_PIN_SHIFT                1
+#define DA9155_S_EN_PIN_MASK                 BIT(1)
+
+/* DA9155_EVENT_A     = 0x3 */
+#define DA9155_E_TJUNC_WARN_SHIFT            0
+#define DA9155_E_TJUNC_WARN_MASK             0x1
+#define DA9155_E_TJUNC_CRIT_SHIFT            1
+#define DA9155_E_TJUNC_CRIT_MASK             BIT(1)
+#define DA9155_E_VBAT_UV_SHIFT               2
+#define DA9155_E_VBAT_UV_MASK                BIT(2)
+#define DA9155_E_VBAT_OV_SHIFT               3
+#define DA9155_E_VBAT_OV_MASK                BIT(3)
+#define DA9155_E_VIN_UV_SHIFT                4
+#define DA9155_E_VIN_UV_MASK                 BIT(4)
+#define DA9155_E_VIN_DROP_SHIFT              5
+#define DA9155_E_VIN_DROP_MASK               BIT(5)
+#define DA9155_E_VIN_OV_SHIFT                6
+#define DA9155_E_VIN_OV_MASK                 BIT(6)
+#define DA9155_E_EN_BLOCK_SHIFT              7
+#define DA9155_E_EN_BLOCK_MASK               BIT(7)
+#define DA9155_E_FAULT_SHIFT                 0
+#define DA9155_E_FAULT_MASK                  0x7E
+
+/* DA9155_EVENT_B     = 0x4 */
+#define DA9155_E_RDY_SHIFT                   0
+#define DA9155_E_RDY_MASK                    0x1
+#define DA9155_E_BUCK_ILIM_SHIFT             1
+#define DA9155_E_BUCK_ILIM_MASK              BIT(1)
+#define DA9155_E_TIMER_SHIFT                 2
+#define DA9155_E_TIMER_MASK                  BIT(2)
+#define DA9155_E_VDDIO_UV_SHIFT              3
+#define DA9155_E_VDDIO_UV_MASK               BIT(3)
+#define DA9155_E_TJUNC_POR_SHIFT             4
+#define DA9155_E_TJUNC_POR_MASK              BIT(4)
+
+/* DA9155_MASK_A     = 0x5 */
+#define DA9155_M_TJUNC_WARN_SHIFT            0
+#define DA9155_M_TJUNC_WARN_MASK             0x1
+#define DA9155_M_TJUNC_CRIT_SHIFT            1
+#define DA9155_M_TJUNC_CRIT_MASK             BIT(1)
+#define DA9155_M_VBAT_UV_SHIFT               2
+#define DA9155_M_VBAT_UV_MASK                BIT(2)
+#define DA9155_M_VBAT_OV_SHIFT               3
+#define DA9155_M_VBAT_OV_MASK                BIT(3)
+#define DA9155_M_VIN_UV_SHIFT                4
+#define DA9155_M_VIN_UV_MASK                 BIT(4)
+#define DA9155_M_VIN_DROP_SHIFT              5
+#define DA9155_M_VIN_DROP_MASK               BIT(5)
+#define DA9155_M_VIN_OV_SHIFT                6
+#define DA9155_M_VIN_OV_MASK                 BIT(6)
+#define DA9155_M_EN_BLOCK_SHIFT              7
+#define DA9155_M_EN_BLOCK_MASK               BIT(7)
+
+/* DA9155_MASK_B     = 0x6 */
+#define DA9155_M_RDY_SHIFT                   0
+#define DA9155_M_RDY_MASK                    0x1
+#define DA9155_M_BUCK_ILIM_SHIFT             1
+#define DA9155_M_BUCK_ILIM_MASK              BIT(1)
+#define DA9155_M_TIMER_SHIFT                 2
+#define DA9155_M_TIMER_MASK                  BIT(2)
+#define DA9155_M_VDDIO_UV_SHIFT              3
+#define DA9155_M_VDDIO_UV_MASK               BIT(3)
+#define DA9155_M_TJUNC_POR_SHIFT             4
+#define DA9155_M_TJUNC_POR_MASK              BIT(4)
+
+/* DA9155_CONTROL_A     = 0x7 */
+#define DA9155_VIN_DROP_SHIFT                0
+#define DA9155_VIN_DROP_MASK                 0xFF
+
+/* DA9155_CONTROL_B     = 0x8 */
+#define DA9155_VBAT_UV_SHIFT                 0
+#define DA9155_VBAT_UV_MASK                  0x3F
+
+/* DA9155_CONTROL_C     = 0x9 */
+#define DA9155_VBAT_OV_SHIFT                 0
+#define DA9155_VBAT_OV_MASK                  0x3F
+
+/* DA9155_CONTROL_D     = 0xa */
+#define DA9155_DEF_SLEW_RATE_SHIFT           0
+#define DA9155_DEF_SLEW_RATE_MASK            0x7
+#define DA9155_START_SLEW_SHIFT              4
+#define DA9155_START_SLEW_MASK               (0x7 << 4)
+
+/* DA9155_CONTROL_E     = 0xb */
+#define DA9155_TIMER_DIS_SHIFT               4
+#define DA9155_TIMER_DIS_MASK                0x10
+#define DA9155_TJUNC_WARN_SHIFT              0
+#define DA9155_TJUNC_WARN_MASK               0xF
+
+/* DA9155_TIMER_A     = 0xc */
+#define DA9155_TIMER_COUNT_SHIFT             0
+#define DA9155_TIMER_COUNT_MASK              0xFF
+
+/* DA9155_TIMER_B     = 0xd */
+#define DA9155_TIMER_LOAD_SHIFT              0
+#define DA9155_TIMER_LOAD_MASK               0xFF
+#define DA9155_TIMER_LOAD_DEFAULT            0xFF
+
+/* DA9155_BUCK_CONT     = 0xe */
+#define DA9155_BUCK_EN_SHIFT                 0
+#define DA9155_BUCK_EN_MASK                  0x1
+
+/* DA9155_BUCK_ILIM     = 0xf */
+#define DA9155_BUCK_ILIM_SHIFT               0
+#define DA9155_BUCK_ILIM_MASK                0x1F
+
+/* DA9155_BUCK_IOUT     = 0x10 */
+#define DA9155_BUCK_IOUT_SHIFT               0
+#define DA9155_BUCK_IOUT_MASK                0xFF
+
+/* DA9155_INTERFACE     = 0x11 */
+#define DA9155_IF_BASE_ADDR_SHIFT            1
+#define DA9155_IF_BASE_ADDR_MASK             (0x7F << 1)
+
+/* DA9155_CONFIG_A     = 0x12 */
+#define DA9155_IRQ_TYPE_SHIFT                0
+#define DA9155_IRQ_TYPE_MASK                 0x1
+#define DA9155_IRQ_LEVEL_SHIFT               1
+#define DA9155_IRQ_LEVEL_MASK                BIT(1)
+#define DA9155_PM_IF_HSM_SHIFT               3
+#define DA9155_PM_IF_HSM_MASK                BIT(3)
+#define DA9155_I2C_TO_EN_SHIFT               4
+#define DA9155_I2C_TO_EN_MASK                BIT(4)
+#define DA9155_I2C_EXTEND_EN_SHIFT           5
+#define DA9155_I2C_EXTEND_EN_MASK            BIT(5)
+#define DA9155_VDDIO_CONF_SHIFT              6
+#define DA9155_VDDIO_CONF_MASK               (0x3 << 6)
+
+/* DA9155_CONFIG_B     = 0x13 */
+#define DA9155_BUCK_FSW_SHIFT                0
+#define DA9155_BUCK_FSW_MASK                 0x3
+#define DA9155_OSC_FRQ_SHIFT                 4
+#define DA9155_OSC_FRQ_MASK                  (0xF << 4)
+
+struct da9155_charger_platform_data {
+	int irq_gpio;
+};
+
+struct da9155_charger_data {
+	struct device           *dev;
+	struct i2c_client       *i2c;
+	struct mutex            io_lock;
+
+	struct da9155_charger_platform_data *pdata;
+
+	struct power_supply	psy_chg;
+
+	unsigned int siop_level;
+	unsigned int chg_irq;
+	unsigned int is_charging;
+	unsigned int charging_type;
+	unsigned int cable_type;
+	unsigned int prev_cable_type;
+	unsigned int charging_current_max;
+	unsigned int charging_current;
+	unsigned int float_voltage;
+
+	u8 addr;
+	int size;
+};
+
+
+#endif	/* __DA9155_CHARGER_H__ */
diff -Naur linux-3.18.14/drivers/battery_v2/include/charger/max77854_charger.h samsung/drivers/battery_v2/include/charger/max77854_charger.h
--- linux-3.18.14/drivers/battery_v2/include/charger/max77854_charger.h	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/include/charger/max77854_charger.h	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,294 @@
+/*
+ * max77854_charger.h
+ * Samsung MAX77854 Charger Header
+ *
+ * Copyright (C) 2015 Samsung Electronics, Inc.
+ *
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __MAX77854_CHARGER_H
+#define __MAX77854_CHARGER_H __FILE__
+
+#include <linux/mfd/core.h>
+#include <linux/mfd/max77854.h>
+#include <linux/mfd/max77854-private.h>
+#include <linux/regulator/machine.h>
+#include "../sec_charging_common.h"
+
+enum {
+	CHIP_ID = 0,
+	DATA,
+};
+
+ssize_t max77854_chg_show_attrs(struct device *dev,
+				struct device_attribute *attr, char *buf);
+
+ssize_t max77854_chg_store_attrs(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count);
+
+#define MAX77854_CHARGER_ATTR(_name)				\
+{							\
+	.attr = {.name = #_name, .mode = 0664},	\
+	.show = max77854_chg_show_attrs,			\
+	.store = max77854_chg_store_attrs,			\
+}
+
+#define MAX77854_CHG_SAFEOUT2                0x80
+
+/* MAX77854_CHG_REG_CHG_INT */
+#define MAX77854_BYP_I                  (1 << 0)
+#define MAX77854_INP_LIMIT_I		(1 << 1)
+#define MAX77854_BATP_I                 (1 << 2)
+#define MAX77854_BAT_I                  (1 << 3)
+#define MAX77854_CHG_I                  (1 << 4)
+#define MAX77854_WCIN_I                 (1 << 5)
+#define MAX77854_CHGIN_I                (1 << 6)
+#define MAX77854_AICL_I                 (1 << 7)
+
+/* MAX77854_CHG_REG_CHG_INT_MASK */
+#define MAX77854_BYP_IM                 (1 << 0)
+#define MAX77854_INP_LIMIT_IM		(1 << 1)
+#define MAX77854_BATP_IM                (1 << 2)
+#define MAX77854_BAT_IM                 (1 << 3)
+#define MAX77854_CHG_IM                 (1 << 4)
+#define MAX77854_WCIN_IM                (1 << 5)
+#define MAX77854_CHGIN_IM               (1 << 6)
+#define MAX77854_AICL_IM                (1 << 7)
+
+/* MAX77854_CHG_REG_CHG_INT_OK */
+#define MAX77854_BYP_OK                 0x01
+#define MAX77854_BYP_OK_SHIFT           0
+#define MAX77854_INP_LIMIT_OK		0x02
+#define MAX77854_INP_LIMIT_OK_SHIFT	1
+#define MAX77854_BATP_OK		0x04
+#define MAX77854_BATP_OK_SHIFT		2
+#define MAX77854_BAT_OK                 0x08
+#define MAX77854_BAT_OK_SHIFT           3
+#define MAX77854_CHG_OK                 0x10
+#define MAX77854_CHG_OK_SHIFT           4
+#define MAX77854_WCIN_OK		0x20
+#define MAX77854_WCIN_OK_SHIFT		5
+#define MAX77854_CHGIN_OK               0x40
+#define MAX77854_CHGIN_OK_SHIFT         6
+#define MAX77854_AICL_OK                0x80
+#define MAX77854_AICL_OK_SHIFT          7
+#define MAX77854_DETBAT                 0x04
+#define MAX77854_DETBAT_SHIFT           2
+
+/* MAX77854_CHG_REG_CHG_DTLS_00 */
+#define MAX77854_BATP_DTLS		0x01
+#define MAX77854_BATP_DTLS_SHIFT	0
+#define MAX77854_WCIN_DTLS		0x18
+#define MAX77854_WCIN_DTLS_SHIFT	3
+#define MAX77854_CHGIN_DTLS             0x60
+#define MAX77854_CHGIN_DTLS_SHIFT       5
+
+/* MAX77854_CHG_REG_CHG_DTLS_01 */
+#define MAX77854_CHG_DTLS               0x0F
+#define MAX77854_CHG_DTLS_SHIFT         0
+#define MAX77854_BAT_DTLS               0x70
+#define MAX77854_BAT_DTLS_SHIFT         4
+
+/* MAX77854_CHG_REG_CHG_DTLS_02 */
+#define MAX77854_BYP_DTLS               0x0F
+#define MAX77854_BYP_DTLS_SHIFT         0
+#define MAX77854_BYP_DTLS0      0x1
+#define MAX77854_BYP_DTLS1      0x2
+#define MAX77854_BYP_DTLS2      0x4
+#define MAX77854_BYP_DTLS3      0x8
+
+/* MAX77854_CHG_REG_CHG_CNFG_00 */
+#define CHG_CNFG_00_MODE_SHIFT		        0
+#define CHG_CNFG_00_CHG_SHIFT		        0
+#define CHG_CNFG_00_UNO_SHIFT		        1
+#define CHG_CNFG_00_OTG_SHIFT		        1
+#define CHG_CNFG_00_BUCK_SHIFT		        2
+#define CHG_CNFG_00_BOOST_SHIFT		        3
+#define CHG_CNFG_00_MODE_MASK		        (0x0F << CHG_CNFG_00_MODE_SHIFT)
+#define CHG_CNFG_00_CHG_MASK		        (1 << CHG_CNFG_00_CHG_SHIFT)
+#define CHG_CNFG_00_UNO_MASK		        (1 << CHG_CNFG_00_UNO_SHIFT)
+#define CHG_CNFG_00_OTG_MASK		        (1 << CHG_CNFG_00_OTG_SHIFT)
+#define CHG_CNFG_00_BUCK_MASK		        (1 << CHG_CNFG_00_BUCK_SHIFT)
+#define CHG_CNFG_00_BOOST_MASK		        (1 << CHG_CNFG_00_BOOST_SHIFT)
+#define CHG_CNFG_00_UNO_CTRL			(CHG_CNFG_00_UNO_MASK | CHG_CNFG_00_BOOST_MASK)
+#define CHG_CNFG_00_OTG_CTRL			(CHG_CNFG_00_OTG_MASK | CHG_CNFG_00_BOOST_MASK)
+#define MAX77854_MODE_DEFAULT                   0x04
+#define MAX77854_MODE_CHGR                      0x01
+#define MAX77854_MODE_UNO			0x01
+#define MAX77854_MODE_OTG                       0x02
+#define MAX77854_MODE_BUCK                      0x04
+#define MAX77854_MODE_BOOST		        0x08
+#define MAX77854_WDTEN							0x10
+
+/* MAX&7843_CHG_REG_CHG_CNFG_01 */
+#define MAX77854_CHG_FQ_2MHz                    (1 << 3)
+/* MAX77854_CHG_REG_CHG_CNFG_02 */
+#define MAX77854_CHG_CC                         0x3F
+
+/* MAX77854_CHG_REG_CHG_CNFG_03 */
+#define MAX77854_CHG_TO_ITH		        0x07
+
+/* MAX77854_CHG_REG_CHG_CNFG_04 */
+#define MAX77854_CHG_MINVSYS_MASK               0xC0
+#define MAX77854_CHG_MINVSYS_SHIFT		6 
+#define MAX77854_CHG_PRM_MASK                   0x1F
+#define MAX77854_CHG_PRM_SHIFT                  0
+
+#define CHG_CNFG_04_CHG_CV_PRM_SHIFT            0
+#define CHG_CNFG_04_CHG_CV_PRM_MASK             (0x3F << CHG_CNFG_04_CHG_CV_PRM_SHIFT)
+
+/* MAX77854_CHG_CNFG_06 */
+#define MAX77854_WDTCLR							0x1
+
+/* MAX77854_CHG_REG_CHG_CNFG_07 */
+#define MAX77854_CHG_FMBST			0x04
+#define CHG_CNFG_07_REG_FMBST_SHIFT		2
+#define CHG_CNFG_07_REG_FMBST_MASK		(0x1 << CHG_CNFG_07_REG_FMBST_SHIFT)
+#define CHG_CNFG_07_REG_FGSRC_SHIFT		1
+#define CHG_CNFG_07_REG_FGSRC_MASK		(0x1 << CHG_CNFG_07_REG_FGSRC_SHIFT)
+
+/* MAX77854_CHG_REG_CHG_CNFG_09 */
+#define MAX77854_CHG_CHGIN_LIM                  0x7F
+
+/* MAX77854_CHG_REG_CHG_CNFG_10 */
+#define MAX77854_CHG_WCIN_LIM                   0x3F
+
+/* MAX77854_CHG_REG_CHG_CNFG_12 */
+#define MAX77854_CHG_WCINSEL			0x40
+#define CHG_CNFG_12_CHGINSEL_SHIFT		5
+#define CHG_CNFG_12_CHGINSEL_MASK		(0x1 << CHG_CNFG_12_CHGINSEL_SHIFT)
+#define CHG_CNFG_12_WCINSEL_SHIFT		6
+#define CHG_CNFG_12_WCINSEL_MASK		(0x1 << CHG_CNFG_12_WCINSEL_SHIFT)
+#define CHG_CNFG_12_VCHGIN_REG_MASK		(0x3 << 3)
+#define CHG_CNFG_12_WCIN_REG_MASK		(0x3 << 1)
+#define CHG_CNFG_12_DISSKIP				(0x1 << 0)
+
+/* MAX77854_CHG_REG_CHG_SWI_INT */
+#define MAX77854_SLAVE_TREG_I			(1 << 0)
+#define MAX77854_CV_I				(1 << 1)
+#define MAX77854_SLAVE_FAULT_I			(1 << 2)
+
+/* MAX77854_CHG_REG_CHG_SWI_INT_MASK */
+#define MAX77854_SLAVE_TREG_IM			(1 << 0)
+#define MAX77854_CV_IM				(1 << 1)
+#define MAX77854_SLAVE_FAULT_IM			(1 << 2)
+
+/* MAX77854_CHG_REG_CHG_SWI_STATUS */
+#define MAX77854_SLAVE_TREG_S			0x00
+#define MAX77854_CV_S				0x01
+
+/* MAX77854_CHG_REG_CHG_SWI_STATUS */
+#define MAX77854_DIS_MIN_SELECTOR		0x80
+
+/* MAX77854_CHG_REG_CHG_SLAVE_READBACK */
+#define MAX77854_SWI_READBACK			0x3F
+
+/* MAX77854_CHG_REG_CHG_SLAVE_CNTL */
+#define MAX77854_BOVE				0x03
+
+#define REDUCE_CURRENT_STEP						100
+#define MINIMUM_INPUT_CURRENT					300
+#define SLOW_CHARGING_CURRENT_STANDARD          400
+
+#define WC_CURRENT_STEP		100
+#define WC_CURRENT_START	480
+
+struct max77854_charger_data {
+	struct device           *dev;
+	struct i2c_client       *i2c;
+	struct i2c_client       *pmic_i2c;
+	struct mutex            charger_mutex;
+
+	struct max77854_platform_data *max77854_pdata;
+
+	struct power_supply	psy_chg;
+	struct power_supply	psy_otg;
+
+	struct workqueue_struct *wqueue;
+	struct work_struct	chgin_work;
+	struct delayed_work	aicl_work;
+	struct delayed_work	isr_work;
+	struct delayed_work	recovery_work;	/*  softreg recovery work */
+	struct delayed_work	wpc_work;	/*  wpc detect work */
+	struct delayed_work	chgin_init_work;	/*  chgin init work */
+	struct delayed_work wc_current_work;
+
+/* mutex */
+	struct mutex irq_lock;
+	struct mutex ops_lock;
+
+	/* wakelock */
+	struct wake_lock recovery_wake_lock;
+	struct wake_lock wpc_wake_lock;
+	struct wake_lock chgin_wake_lock;
+	struct wake_lock wc_current_wake_lock;
+	struct wake_lock aicl_wake_lock;
+
+	unsigned int	is_charging;
+	unsigned int	charging_type;
+	unsigned int	battery_state;
+	unsigned int	battery_present;
+	unsigned int	cable_type;
+	unsigned int	input_current;
+	unsigned int	charging_current;
+	unsigned int	vbus_state;
+	int		aicl_on;
+	bool	slow_charging;
+	int		status;
+	int		charge_mode;
+	int uvlo_attach_flag;
+	int uvlo_attach_cable_type;
+
+	int		irq_bypass;
+	int		irq_batp;
+
+	int		irq_battery;
+	int		irq_chg;
+	int		irq_wcin;
+	int		irq_chgin;
+	int		irq_aicl;
+	/* software regulation */
+	bool		soft_reg_state;
+	int		soft_reg_current;
+
+	/* unsufficient power */
+	bool		reg_loop_deted;
+
+	/* wireless charge, w(wpc), v(vbus) */
+	int		wc_w_gpio;
+	int		wc_w_irq;
+	int		wc_w_state;
+	int		wc_v_gpio;
+	int		wc_v_irq;
+	int		wc_v_state;
+	bool		wc_pwr_det;
+	int		soft_reg_recovery_cnt;
+	int		wc_current;
+	int		wc_pre_current;
+
+	int		jig_gpio;
+
+	bool is_mdock;
+	bool otg_on;
+
+	int pmic_ver;
+	int input_curr_limit_step;
+	int wpc_input_curr_limit_step;
+	int charging_curr_step;
+	int float_voltage;
+
+	sec_charger_platform_data_t *pdata;
+};
+
+#endif /* __MAX77854_CHARGER_H */
diff -Naur linux-3.18.14/drivers/battery_v2/include/charger/p9220_charger.h samsung/drivers/battery_v2/include/charger/p9220_charger.h
--- linux-3.18.14/drivers/battery_v2/include/charger/p9220_charger.h	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/include/charger/p9220_charger.h	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,494 @@
+/*
+ * p9220_charger.h
+ * Samsung p9220 Charger Header
+ *
+ * Copyright (C) 2015 Samsung Electronics, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __p9220_CHARGER_H
+#define __p9220_CHARGER_H __FILE__
+
+#include <linux/mfd/core.h>
+#include <linux/regulator/machine.h>
+#include <linux/i2c.h>
+#include "../sec_charging_common.h"
+
+/* REGISTER MAPS */
+#define P9220_CHIP_ID_L_REG					0x00
+#define P9220_CHIP_ID_H_REG					0x01
+#define P9220_CHIP_REVISION_REG				0x02
+#define P9220_CUSTOMER_ID_REG				0x03
+#define P9220_OTP_FW_MAJOR_REV_L_REG		0x04
+#define P9220_OTP_FW_MAJOR_REV_H_REG		0x05
+#define P9220_OTP_FW_MINOR_REV_L_REG		0x06
+#define P9220_OTP_FW_MINOR_REV_H_REG		0x07
+#define P9220_SRAM_FW_MAJOR_REV_L_REG		0x1C
+#define P9220_SRAM_FW_MAJOR_REV_H_REG		0x1D
+#define P9220_SRAM_FW_MINOR_REV_L_REG		0x1E
+#define P9220_SRAM_FW_MINOR_REV_H_REG		0x1F
+#define P9220_EPT_REG						0x06
+#define P9220_ADC_VRECT_REG					0x07
+#define P9220_ADC_IOUT_REG					0x08
+#define P9220_ADC_VOUT_REG					0x09
+#define P9220_ADC_DIE_TEMP_REG				0x0A
+#define P9220_ADC_ALLGN_X_REG				0x0B
+#define P9220_ADC_ALIGN_Y_REG				0x0C
+#define P9220_INT_STATUS_L_REG				0x34
+#define P9220_INT_STATUS_H_REG				0x35
+#define P9220_INT_L_REG						0x36
+#define P9220_INT_H_REG						0x37
+#define P9220_INT_ENABLE_L_REG				0x38
+#define P9220_INT_ENABLE_H_REG				0x39
+#define P9220_CHG_STATUS_REG				0x3A
+#define P9220_END_POWER_TRANSFER_REG		0x3B
+#define P9220_ADC_VOUT_L_REG				0x3C
+#define P9220_ADC_VOUT_H_REG				0x3D
+#define P9220_VOUT_SET_REG					0x3E
+#define P9220_VRECT_SET_REG					0x3F
+#define P9220_ADC_VRECT_L_REG				0x40
+#define P9220_ADC_VRECT_H_REG				0x41
+#define P9220_ADC_TX_ISENSE_L_REG			0x42
+#define P9220_ADC_TX_ISENSE_H_REG			0x43
+#define P9220_ADC_RX_IOUT_L_REG				0x44
+#define P9220_ADC_RX_IOUT_H_REG				0x45
+#define P9220_ADC_DIE_TEMP_L_REG			0x46
+#define P9220_ADC_DIE_TEMP_H_REG			0x47
+#define P9220_OP_FREQ_L_REG					0x48
+#define P9220_OP_FREQ_H_REG					0x49
+#define P9220_ILIM_SET_REG					0x4A
+#define P9220_ADC_ALLIGN_X_REG				0x4B
+#define P9220_ADC_ALLIGN_Y_REG				0x4C
+#define P9220_SYS_OP_MODE_REG				0x4D
+#define P9220_COMMAND_REG					0x4E
+#define P9220_PACKET_HEADER					0x50
+#define P9220_RX_DATA_COMMAND				0x51
+#define P9220_RX_DATA_VALUE0				0x52
+#define P9220_RX_DATA_VALUE1				0x53
+#define P9220_RX_DATA_VALUE2				0x54
+#define P9220_RX_DATA_VALUE3				0x55
+#define P9220_INT_CLEAR_L_REG				0x56
+#define P9220_INT_CLEAR_H_REG				0x57
+#define P9220_TX_DATA_COMMAND				0x58
+#define P9220_TX_DATA_VALUE0				0x59
+#define P9220_TX_DATA_VALUE1				0x5a
+#define P9220_RXID_0_REG					0x5C
+#define P9220_RXID_1_REG					0x5D
+#define P9220_RXID_2_REG					0x5E
+#define P9220_RXID_3_REG					0x5F
+#define P9220_RXID_4_REG					0x60
+#define P9220_RXID_5_REG					0x61
+#define P9220_MOD_DEPTH_REG                 0x63
+#define P9220_WPC_FOD_0A_REG				0x68
+#define P9220_TX_PING_FREQ_REG				0xFC
+
+#define P9220_NUM_FOD_REG					12
+
+#define P9220_CHIP_ID_MAJOR_1_REG			0x0070
+#define P9220_CHIP_ID_MAJOR_0_REG			0x0074
+#define P9220_CHIP_ID_MINOR_REG				0x0078
+#define P9220_LDO_EN_REG					0x301c
+
+/* Chip Revision and Font Register, Chip_Rev (0x02) */
+#define P9220_CHIP_GRADE_MASK				0x0f
+#define P9220_CHIP_REVISION_MASK			0xf0
+
+/* Status Registers, Status_L (0x34), Status_H (0x35) */
+#define P9220_STAT_VOUT_SHIFT				7
+#define P9220_STAT_STAT_VRECT_SHIFT			6
+#define P9220_STAT_MODE_CHANGE_SHIFT		5
+#define P9220_STAT_TX_DATA_RECEIVED_SHIFT	4
+#define P9220_STAT_OVER_VOL_SHIFT			1
+#define P9220_STAT_OVER_CURR_SHIFT			0
+#define P9220_STAT_VOUT_MASK				(1 << P9220_STAT_VOUT_SHIFT)
+#define P9220_STAT_STAT_VRECT_MASK			(1 << P9220_STAT_STAT_VRECT_SHIFT)
+#define P9220_STAT_MODE_CHANGE_MASK			(1 << P9220_STAT_MODE_CHANGE_SHIFT)
+#define P9220_STAT_TX_DATA_RECEIVED_MASK	(1 << P9220_STAT_TX_DATA_RECEIVED_SHIFT)
+#define P9220_STAT_OVER_VOL_MASK			(1 << P9220_STAT_OVER_VOL_SHIFT)
+#define P9220_STAT_OVER_CURR_MASK			(1 << P9220_STAT_OVER_CURR_SHIFT)
+
+#define P9220_STAT_OVER_TEMP_SHIFT			7
+#define P9220_STAT_TX_OVER_CURR_SHIFT		6
+#define P9220_STAT_TX_OVER_TEMP_SHIFT		5
+#define P9220_STAT_TX_FOD_SHIFT				4
+#define P9220_STAT_TX_CONNECT_SHIFT			3
+#define P9220_STAT_OVER_TEMP_MASK			(1 << P9220_STAT_OVER_TEMP_SHIFT)
+#define P9220_STAT_TX_OVER_CURR_MASK		(1 << P9220_STAT_TX_OVER_CURR_SHIFT)
+#define P9220_STAT_TX_OVER_TEMP_MASK		(1 << P9220_STAT_TX_OVER_TEMP_SHIFT)
+#define P9220_STAT_TX_FOD_MASK				(1 << P9220_STAT_TX_FOD_SHIFT)
+#define P9220_STAT_TX_CONNECT_MASK			(1 << P9220_STAT_TX_CONNECT_SHIFT)
+
+/* Interrupt Registers, INT_L (0x36), INT_H (0x37) */
+#define P9220_INT_STAT_VOUT					P9220_STAT_VOUT_MASK
+#define P9220_INT_STAT_VRECT				P9220_STAT_STAT_VRECT_MASK
+#define P9220_INT_MODE_CHANGE				P9220_STAT_MODE_CHANGE_MASK
+#define P9220_INT_TX_DATA_RECEIVED			P9220_STAT_TX_DATA_RECEIVED_MASK
+#define P9220_INT_OVER_VOLT					P9220_STAT_OVER_VOL_MASK
+#define P9220_INT_OVER_CURR					P9220_STAT_OVER_CURR_MASK
+
+#define P9220_INT_OVER_TEMP					P9220_STAT_OVER_TEMP_MASK
+#define P9220_INT_TX_OVER_CURR				P9220_STAT_TX_OVER_CURR_MASK
+#define P9220_INT_TX_OVER_TEMP				P9220_STAT_TX_OVER_TEMP_MASK
+#define P9220_INT_TX_FOD					P9220_STAT_TX_FOD_MASK
+#define P9220_INT_TX_CONNECT				P9220_STAT_TX_CONNECT_MASK
+
+/* End of Power Transfer Register, EPT (0x3B) (RX only) */
+#define P9220_EPT_UNKNOWN					0
+#define P9220_EPT_END_OF_CHG				1
+#define P9220_EPT_INT_FAULT					2
+#define P9220_EPT_OVER_TEMP					3
+#define P9220_EPT_OVER_VOL					4
+#define P9220_EPT_OVER_CURR					5
+#define P9220_EPT_BATT_FAIL					6
+#define P9220_EPT_RECONFIG					7
+
+/* System Operating Mode Register,Sys_Op_Mode (0x4D) */
+#define P9220_SYS_MODE_INIT					0
+#define P9220_SYS_MODE_WPC					1
+#define P9220_SYS_MODE_PMA					2
+#define P9220_SYS_MODE_MISSING_BACK			3
+#define P9220_SYS_MODE_TX					4
+#define P9220_SYS_MODE_WPC_RX				5
+#define P9220_SYS_MODE_PMA_RX				6
+#define P9220_SYS_MODE_MISSING				7
+
+
+/* Command Register, COM(0x4E) */
+#define P9220_CMD_CLEAR_INT_SHIFT			5
+#define P9220_CMD_SEND_CHG_STS_SHIFT		4
+#define P9220_CMD_SEND_EOP_SHIFT			3
+#define P9220_CMD_SET_TX_MODE_SHIFT			2
+#define P9220_CMD_TOGGLE_LDO_SHIFT			1
+#define P9220_CMD_SEND_RX_DATA_SHIFT		0
+#define P9220_CMD_CLEAR_INT_MASK			(1 << P9220_CMD_CLEAR_INT_SHIFT)
+#define P9220_CMD_SEND_CHG_STS_MASK			(1 << P9220_CMD_SEND_CHG_STS_SHIFT)
+#define P9220_CMD_SEND_EOP_MASK				(1 << P9220_CMD_SEND_EOP_SHIFT)
+#define P9220_CMD_SET_TX_MODE_MASK			(1 << P9220_CMD_SET_TX_MODE_SHIFT)
+#define P9220_CMD_TOGGLE_LDO_MASK			(1 << P9220_CMD_TOGGLE_LDO_SHIFT)
+#define P9220_CMD_SEND_RX_DATA_MASK			(1 << P9220_CMD_SEND_RX_DATA_SHIFT)
+
+/* Pro-prietary Packet Header Register, PPP_Header(0x50) */
+#define P9220_HEADER_END_SIG_STRENGTH		0x01
+#define P9220_HEADER_END_POWER_TRANSFER		0x02
+#define P9220_HEADER_END_CTR_ERROR			0x03
+#define P9220_HEADER_END_RECEIVED_POWER		0x04
+#define P9220_HEADER_END_CHARGE_STATUS		0x05
+#define P9220_HEADER_POWER_CTR_HOLD_OFF		0x06
+#define P9220_HEADER_AFC_CONF				0x28
+#define P9220_HEADER_CONFIGURATION			0x51
+#define P9220_HEADER_IDENTIFICATION			0x71
+#define P9220_HEADER_EXTENDED_IDENT			0x81
+
+/* RX Data Command Register, RX Data_COM (0x51) */
+#define P9220_RX_DATA_COM_UNKNOWN			0x00
+#define P9220_RX_DATA_COM_TX_ID				0x01
+#define P9220_RX_DATA_COM_CHG_STATUS		0x05
+#define P9220_RX_DATA_COM_AFC_SET			0x06
+#define P9220_RX_DATA_COM_AFC_DEBOUCE		0x07
+#define P9220_RX_DATA_COM_SID_TAG			0x08
+#define P9220_RX_DATA_COM_SID_TOKEN			0x09
+#define P9220_RX_DATA_COM_TX_STANBY			0x0a
+#define P9220_RX_DATA_COM_LED_CTRL			0x0b
+#define P9220_RX_DATA_COM_REQ_AFC			0x0c
+#define P9220_RX_DATA_COM_FAN_CTRL			0x0d
+
+/* TX Data Command Register, TX Data_COM (0x58) */
+#define P9220_TX_DATA_COM_UNKNOWN			0x00
+#define P9220_TX_DATA_COM_TX_ID				0x01
+#define P9220_TX_DATA_COM_AFC_TX			0x02
+#define P9220_TX_DATA_COM_ACK				0x03
+#define P9220_TX_DATA_COM_NAK				0x04
+
+/* END POWER TRANSFER CODES IN WPC */
+#define P9220_EPT_CODE_UNKOWN				0x00
+#define P9220_EPT_CODE_CHARGE_COMPLETE		0x01
+#define P9220_EPT_CODE_INTERNAL_FAULT		0x02
+#define P9220_EPT_CODE_OVER_TEMPERATURE		0x03
+#define P9220_EPT_CODE_OVER_VOLTAGE			0x04
+#define P9220_EPT_CODE_OVER_CURRENT			0x05
+#define P9220_EPT_CODE_BATTERY_FAILURE		0x06
+#define P9220_EPT_CODE_RECONFIGURE			0x07
+#define P9220_EPT_CODE_NO_RESPONSE			0x08
+
+#define P9220_POWER_MODE_MASK				(0x1 << 0)
+#define P9220_SEND_USER_PKT_DONE_MASK		(0x1 << 7)
+#define P9220_SEND_USER_PKT_ERR_MASK		(0x3 << 5)
+#define P9220_SEND_ALIGN_MASK				(0x1 << 3)
+#define P9220_SEND_EPT_CC_MASK				(0x1 << 0)
+#define P9220_SEND_EOC_MASK					(0x1 << 0)
+
+#define P9220_PTK_ERR_NO_ERR				0x00
+#define P9220_PTK_ERR_ERR					0x01
+#define P9220_PTK_ERR_ILLEGAL_HD			0x02
+#define P9220_PTK_ERR_NO_DEF				0x03
+
+#define P9220_VOUT_5V_VAL					0x0f
+#define P9220_VOUT_6V_VAL					0x19
+#define P9220_VOUT_7V_VAL					0x23
+#define P9220_VOUT_8V_VAL					0x2d
+/* We set VOUT to 10V actually for HERO for RE/CE standard authentication */
+#define P9220_VOUT_9V_VAL					0x37
+#define P9220_VOUT_10V_VAL					0x41
+
+#define P9220_FW_RESULT_DOWNLOADING			2
+#define P9220_FW_RESULT_PASS				1
+#define P9220_FW_RESULT_FAIL				0
+
+enum {
+	P9220_EVENT_IRQ = 0,
+	P9220_IRQS_NR,
+};
+
+enum {
+	P9220_PAD_MODE_NONE = 0,
+	P9220_PAD_MODE_WPC,
+	P9220_PAD_MODE_WPC_AFC,
+	P9220_PAD_MODE_WPC_PACK,
+	P9220_PAD_MODE_WPC_PACK_TA,
+	P9220_PAD_MODE_WPC_STAND,
+	P9220_PAD_MODE_WPC_STAND_HV,
+	P9220_PAD_MODE_PMA,
+	P9220_PAD_MODE_TX,
+	P9220_PAD_MODE_WPC_VEHICLE,
+};
+
+/* PAD Vout */
+enum {
+	PAD_VOUT_5V = 0,
+	PAD_VOUT_9V,
+	PAD_VOUT_10V,
+	PAD_VOUT_12V,
+	PAD_VOUT_18V,
+	PAD_VOUT_19V,
+	PAD_VOUT_20V,
+	PAD_VOUT_24V,
+};
+
+/* vout settings */
+enum {
+	P9220_VOUT_0V = 0,
+	P9220_VOUT_5V,
+	P9220_VOUT_6V,
+	P9220_VOUT_9V,
+	P9220_VOUT_CC_CV,
+	P9220_VOUT_CV_CALL,
+	P9220_VOUT_CC_CALL,
+	P9220_VOUT_9V_STEP,
+};
+
+enum {
+    P9220_ADC_VOUT = 0,
+    P9220_ADC_VRECT,
+    P9220_ADC_TX_ISENSE,
+    P9220_ADC_RX_IOUT,
+    P9220_ADC_DIE_TEMP,
+    P9220_ADC_ALLIGN_X,
+    P9220_ADC_ALLIGN_Y,
+    P9220_ADC_OP_FRQ,
+    P9220_ADC_TX_PING,
+};
+
+enum {
+	P9220_END_SIG_STRENGTH = 0,
+	P9220_END_POWER_TRANSFER,
+	P9220_END_CTR_ERROR,
+	P9220_END_RECEIVED_POWER,
+	P9220_END_CHARGE_STATUS,
+	P9220_POWER_CTR_HOLD_OFF,
+	P9220_AFC_CONF_5V,
+	P9220_AFC_CONF_9V,
+	P9220_CONFIGURATION,
+	P9220_IDENTIFICATION,
+	P9220_EXTENDED_IDENT,
+	P9220_LED_CONTROL_ON,
+	P9220_LED_CONTROL_OFF,
+	P9220_FAN_CONTROL_ON,
+	P9220_FAN_CONTROL_OFF,
+	P9220_REQUEST_AFC_TX,
+	P9220_REQUEST_TX_ID,
+};
+
+enum p9220_irq_source {
+	TOP_INT = 0,
+};
+
+enum p9220_chip_rev {
+	P9220_A_GRADE_IC = 0,
+	P9220_B_GRADE_IC,
+	P9220_C_GRADE_IC,
+	P9220_D_GRADE_IC,
+};
+
+enum p9220_irq {
+	P9220_IRQ_STAT_VOUT = 0,
+	P9220_IRQ_STAT_VRECT,
+	P9220_IRQ_MODE_CHANGE,
+	P9220_IRQ_TX_DATA_RECEIVED,
+	P9220_IRQ_OVER_VOLT,
+	P9220_IRQ_OVER_CURR,
+	P9220_IRQ_OVER_TEMP,
+	P9220_IRQ_TX_OVER_CURR,
+	P9220_IRQ_TX_OVER_TEMP,
+	P9220_IRQ_TX_FOD,
+	P9220_IRQ_TX_CONNECT,
+	P9220_IRQ_NR,
+};
+
+struct p9220_irq_data {
+	int mask;
+	enum p9220_irq_source group;
+};
+
+enum p9220_firmware_mode {
+	P9220_RX_FIRMWARE = 0,
+	P9220_TX_FIRMWARE,
+};
+
+enum p9220_read_mode {
+	P9220_IC_GRADE = 0,
+	P9220_IC_VERSION,
+	P9220_IC_VENDOR,
+};
+
+enum p9220_headroom {
+	P9220_HEADROOM_0 = 0,
+	P9220_HEADROOM_1, /* 0.277V */
+	P9220_HEADROOM_2, /* 0.497V */
+	P9220_HEADROOM_3, /* 0.650V */
+	P9220_HEADROOM_4, /* 0.030V */
+	P9220_HEADROOM_5, /* 0.082V */
+};
+
+struct p9220_ppp_info {
+	u8 header;
+	u8 rx_data_com;
+	u8 data_val[4];
+	int data_size;
+};
+
+#define DECLARE_IRQ(idx, _group, _mask)		\
+	[(idx)] = { .group = (_group), .mask = (_mask) }
+static const struct p9220_irq_data p9220_irqs[] = {
+	DECLARE_IRQ(P9220_IRQ_STAT_VOUT,	TOP_INT, 1 << 0),
+};
+
+static const u8 OTPBootloader[] = {
+0x00, 0x04, 0x00, 0x20, 0x57, 0x01, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0xFE, 0xE7, 0x00, 0x00, 0x80, 0x00, 0x00, 0xE0, 0x00, 0xBF, 0x40, 0x1E, 0xFC, 0xD2, 0x70, 0x47,
+0x00, 0xB5, 0x6F, 0x4A, 0x6F, 0x4B, 0x01, 0x70, 0x01, 0x20, 0xFF, 0xF7, 0xF3, 0xFF, 0x52, 0x1E,
+0x02, 0xD0, 0x18, 0x8B, 0x00, 0x06, 0xF7, 0xD4, 0x00, 0xBD, 0xF7, 0xB5, 0x05, 0x46, 0x6A, 0x48,
+0x81, 0xB0, 0x00, 0x21, 0x94, 0x46, 0x81, 0x81, 0x66, 0x48, 0x31, 0x21, 0x01, 0x80, 0x04, 0x21,
+0x81, 0x80, 0x06, 0x21, 0x01, 0x82, 0x28, 0x20, 0xFF, 0xF7, 0xDC, 0xFF, 0x00, 0x24, 0x15, 0xE0,
+0x02, 0x99, 0x28, 0x5D, 0x09, 0x5D, 0x02, 0x46, 0x8A, 0x43, 0x01, 0xD0, 0x10, 0x20, 0x50, 0xE0,
+0x81, 0x43, 0x0A, 0xD0, 0x5D, 0x4E, 0xB0, 0x89, 0x08, 0x27, 0x38, 0x43, 0xB0, 0x81, 0x28, 0x19,
+0xFF, 0xF7, 0xCE, 0xFF, 0xB0, 0x89, 0xB8, 0x43, 0xB0, 0x81, 0x64, 0x1C, 0x64, 0x45, 0xE7, 0xD3,
+0x54, 0x48, 0x36, 0x21, 0x01, 0x82, 0x00, 0x24, 0x38, 0xE0, 0x02, 0x98, 0x00, 0x27, 0x06, 0x5D,
+0x52, 0x48, 0x82, 0x89, 0x08, 0x21, 0x0A, 0x43, 0x82, 0x81, 0x28, 0x19, 0x00, 0x90, 0x4D, 0x4A,
+0x08, 0x20, 0x90, 0x80, 0x02, 0x20, 0xFF, 0xF7, 0xAD, 0xFF, 0x28, 0x5D, 0x33, 0x46, 0x83, 0x43,
+0x15, 0xD0, 0x48, 0x49, 0x04, 0x20, 0x88, 0x80, 0x02, 0x20, 0xFF, 0xF7, 0xA3, 0xFF, 0x19, 0x46,
+0x00, 0x98, 0xFF, 0xF7, 0xA5, 0xFF, 0x43, 0x49, 0x0F, 0x20, 0x88, 0x80, 0x02, 0x20, 0xFF, 0xF7,
+0x99, 0xFF, 0x28, 0x5D, 0xB0, 0x42, 0x02, 0xD0, 0x7F, 0x1C, 0x0A, 0x2F, 0xDF, 0xD3, 0x3F, 0x48,
+0x82, 0x89, 0x08, 0x21, 0x8A, 0x43, 0x82, 0x81, 0x0A, 0x2F, 0x06, 0xD3, 0x3C, 0x48, 0x29, 0x19,
+0x41, 0x80, 0x29, 0x5D, 0xC1, 0x80, 0x04, 0x20, 0x03, 0xE0, 0x64, 0x1C, 0x64, 0x45, 0xC4, 0xD3,
+0x02, 0x20, 0x34, 0x49, 0x11, 0x22, 0x0A, 0x80, 0x04, 0x22, 0x8A, 0x80, 0x32, 0x49, 0xFF, 0x22,
+0x8A, 0x81, 0x04, 0xB0, 0xF0, 0xBD, 0x34, 0x49, 0x32, 0x48, 0x08, 0x60, 0x2F, 0x4D, 0x00, 0x22,
+0xAA, 0x81, 0x2E, 0x4E, 0x20, 0x3E, 0xB2, 0x83, 0x2A, 0x80, 0x2B, 0x48, 0x5A, 0x21, 0x40, 0x38,
+0x01, 0x80, 0x81, 0x15, 0x81, 0x80, 0x0B, 0x21, 0x01, 0x81, 0x2C, 0x49, 0x81, 0x81, 0x14, 0x20,
+0xFF, 0xF7, 0x60, 0xFF, 0x2A, 0x4B, 0x01, 0x20, 0x18, 0x80, 0x02, 0x20, 0xFF, 0xF7, 0x5A, 0xFF,
+0x8D, 0x20, 0x18, 0x80, 0x9A, 0x80, 0xFF, 0x20, 0x98, 0x82, 0x03, 0x20, 0x00, 0x02, 0x18, 0x82,
+0xFC, 0x20, 0x98, 0x83, 0x22, 0x49, 0x95, 0x20, 0x20, 0x31, 0x08, 0x80, 0x1C, 0x4C, 0x0C, 0x20,
+0x22, 0x80, 0xA8, 0x81, 0x20, 0x20, 0xB0, 0x83, 0x28, 0x80, 0xAA, 0x81, 0x04, 0x26, 0xA8, 0x89,
+0x30, 0x43, 0xA8, 0x81, 0x20, 0x88, 0x01, 0x28, 0x1B, 0xD1, 0x61, 0x88, 0x80, 0x03, 0xA2, 0x88,
+0x08, 0x18, 0x51, 0x18, 0x8B, 0xB2, 0x00, 0x21, 0x04, 0xE0, 0x0F, 0x19, 0x3F, 0x7A, 0xFB, 0x18,
+0x9B, 0xB2, 0x49, 0x1C, 0x8A, 0x42, 0xF8, 0xD8, 0xE1, 0x88, 0x27, 0x46, 0x99, 0x42, 0x01, 0xD0,
+0x08, 0x20, 0x0B, 0xE0, 0x00, 0x2A, 0x08, 0xD0, 0x09, 0x49, 0x08, 0x31, 0xFF, 0xF7, 0x35, 0xFF,
+0x38, 0x80, 0xA8, 0x89, 0xB0, 0x43, 0xA8, 0x81, 0xD9, 0xE7, 0x02, 0x20, 0x20, 0x80, 0xD6, 0xE7,
+0x10, 0x27, 0x00, 0x00, 0x00, 0x5C, 0x00, 0x40, 0x40, 0x30, 0x00, 0x40, 0x20, 0x6C, 0x00, 0x40,
+0x00, 0x04, 0x00, 0x20, 0xFF, 0x0F, 0x00, 0x00, 0x80, 0xE1, 0x00, 0xE0, 0x04, 0x1D, 0x00, 0x00,
+0x00, 0x64, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+};
+
+#define P9220_OTP_FIRM_VERSION						0x4012
+#define P9220_SRAM_FIRM_VERSION						0x04 /* 2015-6-9 */
+
+#define FREQ_OFFSET	384000 /* 64*6000 */
+
+struct p9220_charger_platform_data {
+	int wpc_det;
+	int irq_wpc_det;
+	int wpc_int;
+	int irq_wpc_int;
+	int cs100_status;
+	int vout_status;
+	int wireless_cc_cv;
+	int siop_level;
+	int cable_type;
+	bool default_voreg;
+	int is_charging;
+	u32 *fod_data_cv;
+	u32 *fod_data;
+	int fod_data_check;
+	bool ic_on_mode;
+	int hw_rev_changed; /* this is only for noble/zero2 */
+	int otp_firmware_result;
+	int tx_firmware_result;
+	int wc_ic_grade;
+	int wc_ic_rev;
+	int otp_firmware_ver;
+	int tx_firmware_ver;
+	int vout;
+	int vrect;
+	char *wireless_charger_name;
+	char *wired_charger_name;
+	int tx_status;
+	int wpc_cc_cv_vout;
+	int wpc_cv_call_vout;
+	int wpc_cc_call_vout;
+	int opfq_cnt;
+	u8 tx_data_cmd;
+	u8 tx_data_val;
+	u32 hv_vout_wa; /* this is only for Hero/Poseidon */
+};
+
+#define p9220_charger_platform_data_t \
+	struct p9220_charger_platform_data
+
+struct p9220_charger_data {
+	struct i2c_client				*client;
+	struct device					*dev;
+	p9220_charger_platform_data_t 	*pdata;
+	struct mutex io_lock;
+	const struct firmware *firm_data_bin;
+
+	int wc_w_state;
+
+	struct power_supply psy_chg;
+	struct wake_lock wpc_wake_lock;
+	struct wake_lock wpc_update_lock;
+	struct wake_lock wpc_opfq_lock;
+	struct workqueue_struct *wqueue;
+	struct work_struct	wcin_work;
+	struct delayed_work	wpc_det_work;
+	struct delayed_work	wpc_opfq_work;
+	struct delayed_work	wpc_isr_work;
+	struct delayed_work	wpc_tx_id_work;
+
+	u16 addr;
+	int size;
+	int is_afc;
+	int pad_vout;
+};
+
+#endif /* __p9220_CHARGER_H */
\ No newline at end of file
diff -Naur linux-3.18.14/drivers/battery_v2/include/charger/s2mu004_charger.h samsung/drivers/battery_v2/include/charger/s2mu004_charger.h
--- linux-3.18.14/drivers/battery_v2/include/charger/s2mu004_charger.h	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/include/charger/s2mu004_charger.h	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,405 @@
+/*
+ * s2mu004_charger.h - Header of S2MU004 Charger Driver
+ *
+ * Copyright (C) 2016 Samsung Electronics Co.Ltd
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#ifndef S2MU004_CHARGER_H
+#define S2MU004_CHARGER_H
+#include <linux/mfd/samsung/s2mu004.h>
+#include <linux/mfd/samsung/s2mu004-private.h>
+#include "../sec_charging_common.h"
+
+#define MASK(width, shift)	(((0x1 << (width)) - 1) << shift)
+
+#define S2MU004_CHG_STATUS0		0x0A
+#define S2MU004_CHG_STATUS1		0x0B
+#define S2MU004_CHG_STATUS2		0x0C
+#define S2MU004_CHG_STATUS3		0x0D
+#define S2MU004_CHG_STATUS4		0x0E
+#define S2MU004_CHG_STATUS5		0x0F
+#define S2MU004_CHG_CTRL0		0x10
+#define S2MU004_CHG_CTRL1		0x11
+#define S2MU004_CHG_CTRL2		0x12
+#define S2MU004_CHG_CTRL3		0x13
+#define S2MU004_CHG_CTRL4		0x14
+#define S2MU004_CHG_CTRL5		0x15
+#define S2MU004_CHG_CTRL6		0x16
+#define S2MU004_CHG_CTRL7		0x17
+#define S2MU004_CHG_CTRL8		0x18
+#define S2MU004_CHG_CTRL9		0x19
+#define S2MU004_CHG_CTRL10		0x1A
+#define S2MU004_CHG_CTRL11		0x1B
+#define S2MU004_CHG_CTRL12		0x1C
+#define S2MU004_CHG_CTRL13		0x1D
+#define S2MU004_CHG_CTRL14		0x1E
+#define S2MU004_CHG_CTRL15		0x1F
+#define S2MU004_CHG_CTRL16		0x20
+#define S2MU004_CHG_CTRL17		0x21
+#define S2MU004_CHG_CTRL18		0x22
+#define S2MU004_CHG_CTRL19		0x23
+#define S2MU004_CHG_CTRL20		0x24
+
+#define S2MU004_PWRSEL_CTRL0	0x72
+#define PWRSEL_CTRL0_SHIFT		7
+#define PWRSEL_CTRL0_WIDTH		1
+#define PWRSEL_CTRL0_MASK	MASK(PWRSEL_CTRL0_WIDTH, PWRSEL_CTRL0_SHIFT)
+
+#define EN_JIG_REG_AP_SHIFT		7
+#define EN_JIG_REG_AP_WIDTH		1
+#define EN_JIG_REG_AP_MASK	MASK(EN_JIG_REG_AP_WIDTH, EN_JIG_REG_AP_SHIFT)
+
+/* S2MU004_SC_INT_MASK */
+#define Poor_CHG_INT_SHIFT	1
+#define Poor_CHG_INT_MASK	BIT(Poor_CHG_INT_SHIFT)
+
+/* S2MU004_CHG_STATUS0 */
+#define FG_SOC_STATUS_SHIFT	0
+#define FG_SOC_STATUS_WIDTH	2
+#define FG_SOC_STATUS_MASK	MASK(FG_SOC_STATUS_WIDTH, FG_SOC_STATUS_SHIFT)
+
+#define WCIN_STATUS_SHIFT	2
+#define WCIN_STATUS_WIDTH	3
+#define WCIN_STATUS_MASK	MASK(WCIN_STATUS_WIDTH, WCIN_STATUS_SHIFT)
+
+#define WCIN_M_SHIFT	6
+#define WCIN_M_MASK		BIT(WCIN_M_SHIFT)
+
+#define CHGIN_STATUS_SHIFT	5
+#define CHGIN_STATUS_WIDTH	3
+#define CHGIN_STATUS_MASK	MASK(CHGIN_STATUS_WIDTH, CHGIN_STATUS_SHIFT)
+
+#define VBUS_OVP_MASK		0xE0
+#define VBUS_OVP_SHIFT		5
+
+/* S2MU004_CHG_STATUS1 */
+#define SELF_DISCHG_STATUS_SHIFT	7
+#define SELF_DISCHG_STATUS_MASK 	BIT(SELF_DISCHG_STATUS_SHIFT)
+
+#define CHG_FAULT_STATUS_SHIFT		3
+#define CHG_FAULT_STATUS_WIDTH		4
+#define CHG_FAULT_STATUS_MASK		MASK(CHG_FAULT_STATUS_WIDTH,\
+					 CHG_FAULT_STATUS_SHIFT)
+
+#define CHG_STATUS_PRE_CHARGE	1
+#define CHG_STATUS_FAST_CHARGE	2
+#define CHG_STATUS_WD_SUSPEND	3
+#define CHG_STATUS_WD_RST	4
+#define CHG_STATUS_TSD		5
+#define CHG_STATUS_TFB		6
+
+#define CHG_Restart_STATUS_SHIFT	2
+#define CHG_Restart_STATUS_MASK		BIT(CHG_Restart_STATUS_SHIFT)
+
+#define TOP_OFF_STATUS_SHIFT		1
+#define TOP_OFF_STATUS_MASK		BIT(TOP_OFF_STATUS_SHIFT)
+
+#define DONE_STATUS_SHIFT	0
+#define DONE_STATUS_MASK	BIT(DONE_STATUS_SHIFT)
+
+/* S2MU004_CHG_STATUS2 */
+#define OTG_STATUS_SHIFT	5
+#define OTG_STATUS_WIDTH	3
+#define OTG_STATUS_MASK		MASK(OTG_STATUS_WIDTH, OTG_STATUS_SHIFT)
+
+#define TX_STATUS_SHIFT		2
+#define TX_STATUS_WIDTH		3
+#define TX_STATUS_MASK		MASK(TX_STATUS_WIDTH, TX_STATUS_SHIFT)
+
+#define SYS_STATUS_SHIFT	2
+#define SYS_STATUS_WIDTH	3
+#define SYS_STATUS_MASK		MASK(SYS_STATUS_WIDTH, SYS_STATUS_SHIFT)
+
+/* S2MU004_CHG_STATUS3 */
+#define DET_BAT_STATUS_SHIFT	0
+#define DET_BAT_STATUS_MASK	BIT(DET_BAT_STATUS_SHIFT)
+
+#define BAT_STATUS_SHIFT	1
+#define BAT_STATUS_WIDTH	2
+#define BAT_STATUS_MASK		MASK(BAT_STATUS_WIDTH, BAT_STATUS_SHIFT)
+
+#define AICL_STATUS_SHIFT	4
+#define AICL_STATUS_WIDTH	2
+#define AICL_STATUS_MASK	MASK(AICL_STATUS_WIDTH, AICL_STATUS_SHIFT)
+
+#define ICR_STATUS_SHIFT	6
+#define ICR_STATUS_MASK		BIT(ICR_STATUS_SHIFT)
+
+#define IVR_STATUS_SHIFT	7
+#define IVR_STATUS_MASK		BIT(IVR_STATUS_SHIFT)
+
+/* S2MU004_CHG_CTRL0 */
+#define EN_CHG_SHIFT		7
+#define EN_CHG_MASK		BIT(EN_CHG_SHIFT)
+
+#define REG_MODE_SHIFT		0
+#define REG_MODE_WIDTH		4
+#define REG_MODE_MASK		MASK(REG_MODE_WIDTH, REG_MODE_SHIFT)
+
+#define CHARGER_OFF_MODE	0
+#define CHG_MODE		3
+#define BUCK_MODE		1
+#define OTG_BST_MODE		6
+
+/* S2MU004_CHG_CTRL1 */
+
+/* S2MU004_CHG_CTRL2 */
+#define INPUT_CURRENT_LIMIT_SHIFT	0
+#define INPUT_CURRENT_LIMIT_WIDTH	7
+#define INPUT_CURRENT_LIMIT_MASK	MASK(INPUT_CURRENT_LIMIT_WIDTH,\
+					INPUT_CURRENT_LIMIT_SHIFT)
+
+/* S2MU004_CHG_CTRL4 */
+#define OTG_OCP_SW_ON_SHIFT		5
+#define OTG_OCP_SW_ON_MASK		BIT(OTG_OCP_SW_ON_SHIFT)
+
+#define OTG_OCP_SW_OFF_SHIFT	4
+#define OTG_OCP_SW_OFF_MASK		BIT(OTG_OCP_SW_OFF_SHIFT)
+
+#define SET_OTG_OCP_SHIFT	2
+#define SET_OTG_OCP_WIDTH	2
+#define SET_OTG_OCP_MASK	MASK(SET_OTG_OCP_WIDTH, SET_OTG_OCP_SHIFT)
+
+/* S2MU004_CHG_CTRL5 */
+#define SET_CHG_2L_DROP_SHIFT	4
+#define SET_CHG_2L_DROP_WIDTH	2
+#define SET_CHG_2L_DROP_MASK	MASK(SET_CHG_2L_DROP_WIDTH,\
+				SET_CHG_2L_DROP_SHIFT)
+
+#define SET_CHG_3L_DROP_SHIFT	6
+#define SET_CHG_3L_DROP_WIDTH	2
+#define SET_CHG_3L_DROP_MASK	MASK(SET_CHG_3L_DROP_WIDTH,\
+					SET_CHG_3L_DROP_SHIFT)
+
+/* S2MU004_CHG_CTRL6 */
+#define SET_VF_VBAT_SHIFT	0
+#define SET_VF_VBAT_WIDTH	6
+#define SET_VF_VBAT_MASK	MASK(SET_VF_VBAT_WIDTH, SET_VF_VBAT_SHIFT)
+
+/* S2MU004_CHG_CTRL7 */
+#define SET_VF_VBYP_SHIFT	5
+#define SET_VF_VBYP_WIDTH	2
+#define SET_VF_VBYP_MASK	MASK(SET_VF_VBYP_WIDTH, SET_VF_VBYP_SHIFT)
+#define SET_VSYS_SHIFT	0
+#define SET_VSYS_WIDTH	3
+#define SET_VSYS_MASK	MASK(SET_VSYS_WIDTH, SET_VSYS_SHIFT)
+
+/* S2MU004_CHG_CTRL8 */
+#define COOL_CHARGING_CURRENT_SHIFT	0
+#define COOL_CHARGING_CURRENT_WIDTH	7
+#define COOL_CHARGING_CURRENT_MASK	MASK(COOL_CHARGING_CURRENT_WIDTH,\
+					COOL_CHARGING_CURRENT_SHIFT)
+
+/* S2MU004_CHG_CTRL9 */
+#define FAST_CHARGING_CURRENT_SHIFT	0
+#define FAST_CHARGING_CURRENT_WIDTH	7
+#define FAST_CHARGING_CURRENT_MASK	MASK(FAST_CHARGING_CURRENT_WIDTH,\
+					FAST_CHARGING_CURRENT_SHIFT)
+
+/* S2MU004_CHG_CTRL11 */
+#define FIRST_TOPOFF_CURRENT_SHIFT	0
+#define FIRST_TOPOFF_CURRENT_WIDTH	4
+#define FIRST_TOPOFF_CURRENT_MASK	MASK(FIRST_TOPOFF_CURRENT_WIDTH,\
+					FIRST_TOPOFF_CURRENT_SHIFT)
+
+#define SECOND_TOPOFF_CURRENT_SHIFT	4
+#define SECOND_TOPOFF_CURRENT_WIDTH	4
+#define SECOND_TOPOFF_CURRENT_MASK	MASK(SECOND_TOPOFF_CURRENT_WIDTH,\
+					SECOND_TOPOFF_CURRENT_SHIFT)
+
+/* S2MU004_CHG_CTRL12 */
+#define SET_OSC_BUCK_SHIFT		0
+#define SET_OSC_BUCK_WIDTH		3
+#define SET_OSC_BUCK_MASK		MASK(SET_OSC_BUCK_WIDTH,\
+					SET_OSC_BUCK_SHIFT)
+
+#define SET_OSC_BUCK_3L_SHIFT		3
+#define SET_OSC_BUCK_3L_WIDTH		3
+#define SET_OSC_BUCK_3L_MASK		MASK(SET_OSC_BUCK_3L_WIDTH,\
+					SET_OSC_BUCK_3L_SHIFT)
+
+enum {
+	S2MU004_OSC_BUCK_FRQ_500kHz	= 0x0,
+	S2MU004_OSC_BUCK_FRQ_750kHz	= 0x1,
+	S2MU004_OSC_BUCK_FRQ_1MHz	= 0x2,
+	S2MU004_OSC_BUCK_FRQ_1P25MHz	= 0x3,
+	S2MU004_OSC_BUCK_FRQ_1P5MHz	= 0x4,
+	S2MU004_OSC_BUCK_FRQ_1P75MHz	= 0x5,
+	S2MU004_OSC_BUCK_FRQ_2MHz	= 0x6,
+	S2MU004_OSC_BUCK_FRQ_2P25MHz	= 0x7,
+};
+
+/* S2MU004_CHG_CTRL13 */
+#define SET_IVR_Recovery_SHIFT	5
+#define SET_IVR_Recovery_MASK	BIT(SET_IVR_Recovery_SHIFT)
+
+#define SET_EN_WDT_SHIFT 1
+#define SET_EN_WDT_MASK BIT(SET_EN_WDT_SHIFT)
+
+#define SET_EN_WDT_AP_RESET_SHIFT 0
+#define SET_EN_WDT_AP_RESET_MASK BIT(SET_EN_WDT_AP_RESET_SHIFT)
+
+/* S2MU004_CHG_CTRL14 */
+#define WDT_CLR_SHIFT 0
+#define WDT_CLR_MASK BIT(WDT_CLR_SHIFT)
+
+/* S2MU004_CHG_CTRL15 */
+#define SET_OSC_BST_SHIFT	5
+#define SET_OSC_BST_WIDTH	3
+#define SET_OSC_BST_MASK	MASK(SET_OSC_BST_WIDTH, SET_OSC_BST_SHIFT)
+
+/* S2MU004_CHG_CTRL16 */
+#define SET_TIME_CHG_SHIFT	3
+#define SET_TIME_CHG_WIDTH	3
+#define SET_TIME_CHG_MASK	MASK(SET_TIME_CHG_WIDTH, SET_TIME_CHG_SHIFT)
+
+/* S2MU004_CHG_CTRL17 */
+#define TOP_OFF_TIME_SHIFT    3
+#define TOP_OFF_TIME_WIDTH    3
+#define TOP_OFF_TIME_MASK    MASK(TOP_OFF_TIME_WIDTH, TOP_OFF_TIME_SHIFT)
+
+#define WDT_TIME_SHIFT        0
+#define WDT_TIME_WIDTH        3
+#define WDT_TIME_MASK        MASK(WDT_TIME_WIDTH, WDT_TIME_SHIFT)
+
+/* S2MU004_CHG_CTRL18 */
+#define CHGIN_ON_SHIFT		2
+#define CHGIN_ON_WIDTH		2
+#define CHGIN_ON_MASK		MASK(CHGIN_ON_WIDTH, CHGIN_ON_SHIFT)
+
+/* S2MU005_REG_SELFDIS_CFG1 */
+#define FC_SELF_DISCHG_SHIFT	3
+#define FC_SELF_DISCHG_MASK		BIT(FC_SELF_DISCHG_SHIFT)
+
+/* S2MU004_REG_SELFDIS_CFG3 */
+#define SELF_DISCHG_MODE_SHIFT	7
+#define SELF_DISCHG_MODE_MASK	BIT(SELF_DISCHG_MODE_SHIFT)
+
+enum {
+	CHIP_ID = 0,
+};
+
+ssize_t s2mu004_chg_show_attrs(struct device *dev,
+				struct device_attribute *attr, char *buf);
+
+ssize_t s2mu004_chg_store_attrs(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count);
+
+#define S2MU004_CHARGER_ATTR(_name)				\
+{							                    \
+	.attr = {.name = #_name, .mode = 0664},	    \
+	.show = s2mu004_chg_show_attrs,			    \
+	.store = s2mu004_chg_store_attrs,			\
+}
+
+enum {
+	CHG_REG = 0,
+	CHG_DATA,
+	CHG_REGS,
+};
+
+enum {
+	S2MU004_TOPOFF_TIMER_500us	= 0x0,
+	S2MU004_TOPOFF_TIMER_5m		= 0x1,
+	S2MU004_TOPOFF_TIMER_10m	= 0x2,
+	S2MU004_TOPOFF_TIMER_30m	= 0x3,
+	S2MU004_TOPOFF_TIMER_50m	= 0x4,
+	S2MU004_TOPOFF_TIMER_70m	= 0x5,
+	S2MU004_TOPOFF_TIMER_90m	= 0x6,
+	S2MU004_TOPOFF_TIMER_DIS	= 0x7,
+};
+
+enum {
+	S2MU004_WDT_TIMER_40s	= 0x1,
+	S2MU004_WDT_TIMER_50s	= 0x2,
+	S2MU004_WDT_TIMER_60s	= 0x3,
+	S2MU004_WDT_TIMER_70s	= 0x4,
+	S2MU004_WDT_TIMER_80s	= 0x5,
+	S2MU004_WDT_TIMER_90s	= 0x6,
+	S2MU004_WDT_TIMER_100s	= 0x7,
+};
+
+enum {
+	S2MU004_FC_CHG_TIMER_4hr	= 0x1,
+	S2MU004_FC_CHG_TIMER_6hr	= 0x2,
+	S2MU004_FC_CHG_TIMER_8hr	= 0x3,
+	S2MU004_FC_CHG_TIMER_10hr	= 0x4,
+	S2MU004_FC_CHG_TIMER_12hr	= 0x5,
+	S2MU004_FC_CHG_TIMER_14hr	= 0x6,
+	S2MU004_FC_CHG_TIMER_16hr	= 0x7,
+};
+
+typedef struct s2mu004_charger_platform_data {
+	sec_charging_current_t *charging_current;
+	int chg_float_voltage;
+	char *charger_name;
+	char *fuelgauge_name;
+	bool chg_eoc_dualpath;
+	uint32_t is_1MHz_switching:1;
+	int chg_switching_freq;
+	/* 2nd full check */
+	sec_battery_full_charged_t full_check_type_2nd;
+} s2mu004_charger_platform_data_t;
+
+struct s2mu004_charger_data {
+	struct i2c_client       *i2c;
+	struct device *dev;
+	struct s2mu004_platform_data *s2mu004_pdata;
+	struct delayed_work	charger_work;
+	struct delayed_work	wpc_work;
+#ifndef CONFIG_SEC_FACTORY
+	struct delayed_work	otg_vbus_work;
+#endif
+	struct workqueue_struct *charger_wqueue;
+	struct power_supply	psy_chg;
+	struct power_supply	psy_otg;
+	s2mu004_charger_platform_data_t *pdata;
+	int dev_id;
+	int input_current;
+	int charging_current;
+	int topoff_current;
+	int cable_type;
+	bool is_charging;
+	int charge_mode;
+	struct mutex charger_mutex;
+
+	/* register programming */
+	int reg_addr;
+	int reg_data;
+
+	bool ovp;
+	bool otg_on;
+
+	int unhealth_cnt;
+	int status;
+
+	/* s2mu004 */
+	int irq_det_bat;
+	int irq_chgin;
+	int irq_chg_fault;
+	int irq_vbus;
+	int irq_rst;
+	int irq_done;
+	int irq_sys;
+
+	/* wireless charge, w(wpc), v(vbus) */
+	int 	wc_w_irq;
+	int 	wc_w_state;
+};
+
+
+#endif /*S2MU004_CHARGER_H*/
diff -Naur linux-3.18.14/drivers/battery_v2/include/charger/s2mu005_charger.h samsung/drivers/battery_v2/include/charger/s2mu005_charger.h
--- linux-3.18.14/drivers/battery_v2/include/charger/s2mu005_charger.h	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/include/charger/s2mu005_charger.h	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,204 @@
+/*
+ * drivers/battery/s2mu005_charger.h
+ *
+ * Header of S2MU005 Charger Driver
+ *
+ * Copyright (C) 2015 Samsung Electronics
+ * Develope by Nguyen Tien Dat <tiendat.nt@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef S2MU005_CHARGER_H
+#define S2MU005_CHARGER_H
+#include <linux/mfd/samsung/s2mu005.h>
+#include <linux/mfd/samsung/s2mu005-private.h>
+#include "../sec_charging_common.h"
+
+#define MASK(width, shift)      (((0x1 << (width)) - 1) << shift)
+
+#define S2MU005_CHG_STATUS0		0x08
+#define S2MU005_CHG_STATUS1		0x09
+#define S2MU005_CHG_STATUS2		0x0A
+#define S2MU005_CHG_STATUS3		0x0B
+#define S2MU005_CHG_STATUS4		0x0C
+#define S2MU005_CHG_STATUS5		0x0D
+#define S2MU005_CHG_CTRL0       0x0E
+#define S2MU005_CHG_CTRL1       0x0F
+#define S2MU005_CHG_CTRL2       0x10
+#define S2MU005_CHG_CTRL3       0x11
+#define S2MU005_CHG_CTRL4       0x12
+#define S2MU005_CHG_CTRL5       0x13
+#define S2MU005_CHG_CTRL6       0x14
+#define S2MU005_CHG_CTRL7       0x15
+#define S2MU005_CHG_CTRL8       0x16
+#define S2MU005_CHG_CTRL9		0x17
+#define S2MU005_CHG_CTRL10		0x18
+#define S2MU005_CHG_CTRL11		0x19
+#define S2MU005_CHG_CTRL12		0x1A
+#define S2MU005_CHG_CTRL13		0x1B
+#define S2MU005_CHG_CTRL14		0x1C
+#define S2MU005_CHG_CTRL15		0x1D
+#define S2MU005_CHG_CTRL16		0x1E
+#define S2MU005_CHG_CTRL17		0x1F
+#define S2MU005_CHG_CTRL18		0x20
+
+/* S2MU005_SC_INT_MASK */
+#define VMID_M_SHIFT	5
+#define VMID_M_MASK		BIT(VMID_M_SHIFT)
+
+/* S2MU005_CHG_STATUS0 */
+#define VBUS_OK_SHIFT	7
+#define VBUS_OK_MASK	BIT(VBUS_OK_SHIFT)
+
+#define WCIN_OK_SHIFT	6
+#define S2MU005_WCIN_OK_MASK	BIT(WCIN_OK_SHIFT)
+
+#define VMID_OK_SHIFT	5
+#define VMID_OK_MASK	BIT(VMID_OK_SHIFT)
+
+#define CHG_OK_SHIFT	4
+#define CHG_OK_MASK	BIT(CHG_OK_SHIFT)
+
+#define CHG_STATUS_SHIFT	0
+#define CHG_STATUS_WIDTH	4
+#define CHG_STATUS_MASK		MASK(CHG_STATUS_WIDTH, CHG_STATUS_SHIFT)
+
+#define CHG_STATUS_PRE_CHARGE	2
+#define	CHG_STATUS_COOL_CHARGE	3
+#define CHG_STATUS_CC		4
+#define CHG_STATUS_CV		5
+#define CHG_STATUS_DONE_FLAG	6
+#define CHG_STATUS_TOP_OFF	7
+#define CHG_STATUS_DONE		8
+
+/* S2MU005_CHG_STATUS1 */
+#define DET_BAT_STATUS_SHIFT	7
+#define DET_BAT_STATUS_MASK	BIT(DET_BAT_STATUS_SHIFT)
+
+
+/* S2MU005_CHG_STATUS2 */
+#define BAT_STATUS_SHIFT	4
+#define BAT_STATUS_WIDTH	3
+#define BAT_STATUS_MASK		MASK(BAT_STATUS_WIDTH, BAT_STATUS_SHIFT)
+
+#define BAT_OVP_DET		0
+#define BAT_SELF_DISCHARGING	1
+#define LOW_BATTERY_DETECTION_IN_CHARGING	2
+#define	COOL_CHARGE_DET		5
+#define FAST_CHARGE_DET		6
+#define	BAT_VOL_DET		7
+
+/* S2MU005_CHG_STATUS3 */
+#define CHG_EVENT_STATUS_SHIFT	0
+#define CHG_EVENT_STATUS_WIDTH	4
+#define CHG_EVENT_STATUS_MASK	MASK(CHG_EVENT_STATUS_WIDTH, CHG_EVENT_STATUS_SHIFT)
+
+#define THREMAL_SHUT_DOWN	1
+#define THERMAL_FOLDBACK	2
+#define VSYS_OVER_VOVP		3
+#define VSYS_OVER_VUVLO		4
+#define WATCHDOG_SUSPENSION	5
+#define WATCHDOG_AP_RESET	6
+
+#define VBUS_OVP_MASK		0x70
+#define VBUS_OVP_SHIFT		4
+
+/* S2MU005_CHG_CTRL0 */
+#define EN_CHG_SHIFT		4
+#define EN_CHG_MASK		BIT(EN_CHG_SHIFT)
+
+#define REG_MODE_SHIFT		0
+#define REG_MODE_WIDTH		3
+#define REG_MODE_MASK		MASK(REG_MODE_WIDTH, REG_MODE_SHIFT)
+
+/* S2MU005_CHG_CTRL1 */
+#define SET_VIN_DROP_SHIFT	4
+#define SET_VIN_DROP_WIDTH	3
+#define SET_VIN_DROP_MASK	MASK(SET_VIN_DROP_WIDTH, SET_VIN_DROP_SHIFT)
+
+/* S2MU005_CHG_CTRL2 */
+#define INPUT_CURRENT_LIMIT_SHIFT	0
+#define INPUT_CURRENT_LIMIT_WIDTH	6
+#define INPUT_CURRENT_LIMIT_MASK	MASK(INPUT_CURRENT_LIMIT_WIDTH,\
+					INPUT_CURRENT_LIMIT_SHIFT)
+
+/* S2MU005_CHG_CTRL4 */
+#define OTG_OCP_SW_ON_SHIFT		5
+#define OTG_OCP_SW_ON_MASK		BIT(OTG_OCP_SW_ON_SHIFT)
+
+#define OTG_OCP_SW_OFF_SHIFT	4
+#define OTG_OCP_SW_OFF_MASK		BIT(OTG_OCP_SW_OFF_SHIFT)
+
+#define SET_OTG_OCP_SHIFT	2
+#define SET_OTG_OCP_WIDTH	2
+#define SET_OTG_OCP_MASK	MASK(SET_OTG_OCP_WIDTH, SET_OTG_OCP_SHIFT)
+
+/* S2MU005_CHG_CTRL5 */
+#define SET_VF_VMID_BST_SHIFT	0
+#define SET_VF_VMID_BST_WIDTH	5
+#define SET_VF_VMID_BST_MASK	MASK(SET_VF_VMID_BST_WIDTH, SET_VF_VMID_BST_SHIFT)
+
+/* S2MU005_CHG_CTRL6 */
+#define COOL_CHARGING_CURRENT_SHIFT 0
+#define COOL_CHARGING_CURRENT_WIDTH 6
+#define COOL_CHARGING_CURRENT_MASK MASK(COOL_CHARGING_CURRENT_WIDTH,\
+					COOL_CHARGING_CURRENT_SHIFT)
+
+/* S2MU005_CHG_CTRL7 */
+#define FAST_CHARGING_CURRENT_SHIFT	0
+#define FAST_CHARGING_CURRENT_WIDTH	6
+#define FAST_CHARGING_CURRENT_MASK	MASK(FAST_CHARGING_CURRENT_WIDTH,\
+					FAST_CHARGING_CURRENT_SHIFT)
+
+/* S2MU005_CHG_CTRL8 */
+#define SET_VF_VBAT_SHIFT	1
+#define SET_VF_VBAT_WIDTH	6
+#define SET_VF_VBAT_MASK	MASK(SET_VF_VBAT_WIDTH, SET_VF_VBAT_SHIFT)
+
+/* S2MU005_CHG_CTRL10 */
+#define SECOND_TOPOFF_CURRENT_SHIFT	4
+#define SECOND_TOPOFF_CURRENT_WIDTH	4
+#define SECOND_TOPOFF_CURRENT_MASK	MASK(SECOND_TOPOFF_CURRENT_WIDTH,\
+					SECOND_TOPOFF_CURRENT_SHIFT)
+
+#define FIRST_TOPOFF_CURRENT_SHIFT	0
+#define FIRST_TOPOFF_CURRENT_WIDTH	4
+#define FIRST_TOPOFF_CURRENT_MASK	MASK(FIRST_TOPOFF_CURRENT_WIDTH,\
+					FIRST_TOPOFF_CURRENT_SHIFT)
+
+/* S2MU005_CHG_CTRL11 */
+#define SET_OSC_BST_SHIFT	5
+#define SET_OSC_BST_WIDTH	2
+#define SET_OSC_BST_MASK	MASK(SET_OSC_BST_WIDTH, SET_OSC_BST_SHIFT)
+
+#define SET_OSC_BUCK_SHIFT	3
+#define SET_OSC_BUCK_WIDTH	2
+#define SET_OSC_BUCK_MASK	MASK(SET_OSC_BUCK_WIDTH, SET_OSC_BUCK_SHIFT)
+
+/* S2MU005_CHG_CTRL15 */
+#define T_EN_OTG_SHIFT		2
+#define T_EN_OTG_WIDTH		2
+#define T_EN_OTG_MASK		MASK(T_EN_OTG_WIDTH, T_EN_OTG_SHIFT)
+
+/* S2MU005_REG_SELFDIS_CFG2 */
+#define FC_SELF_DISCHG_SHIFT	4
+#define FC_SELF_DISCHG_MASK		BIT(FC_SELF_DISCHG_SHIFT)
+
+/* S2MU005_REG_SELFDIS_CFG3 */
+#define SELF_DISCHG_MODE_SHIFT	7
+#define SELF_DISCHG_MODE_MASK	BIT(SELF_DISCHG_MODE_SHIFT)
+
+enum {
+	CHG_REG = 0,
+	CHG_DATA,
+	CHG_REGS,
+};
+
+struct charger_info {
+	int dummy;
+};
+
+#endif /*S2MU005_CHARGER_H*/
diff -Naur linux-3.18.14/drivers/battery_v2/include/charger/sm5703_charger.h samsung/drivers/battery_v2/include/charger/sm5703_charger.h
--- linux-3.18.14/drivers/battery_v2/include/charger/sm5703_charger.h	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/include/charger/sm5703_charger.h	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,131 @@
+/*
+ * drivers/battery/sm5703_charger.h
+ *
+ * Header of Siliconmitus SM5703 Fuelgauge Driver
+ *
+ * Copyright (C) 2013 Siliconmitus Technology Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef SM5703_CHARGER_H
+#define SM5703_CHARGER_H
+#include <linux/mfd/sm5703.h>
+#include <linux/mfd/sm5703_irq.h>
+#include "../sec_charging_common.h"
+
+enum {
+    SM5703_TOPOFF_TIMER_10m         = 0x0,
+    SM5703_TOPOFF_TIMER_20m         = 0x1,
+    SM5703_TOPOFF_TIMER_30m         = 0x2,
+    SM5703_TOPOFF_TIMER_45m         = 0x3,
+};
+
+enum {
+	CHG_REG = 0,
+	CHG_DATA,
+	CHG_REGS,
+};
+
+#define SM5703_CNTL				0x0C
+#define SM5703_VBUSCNTL				0x0D
+#define SM5703_CHGCNTL1				0x0E
+#define SM5703_CHGCNTL2				0x0F
+#define SM5703_CHGCNTL3				0x10
+#define SM5703_CHGCNTL4				0x11
+#define SM5703_CHGCNTL5				0x12
+#define SM5703_CHGCNTL6				0x13
+#define SM5703_OTGCURRENTCNTL			0x60
+#define SM5703_Q3LIMITCNTL			0x66
+
+#define SM5703_USBLDO1CNTL			0x0C
+#define SM5703_USBLDO2CNTL			0x0C
+#define SM5703_LDOOUT1CNTL			0x1A
+#define SM5703_LDOOUT2CNTL			0x1B
+#define SM5703_LDOOUT3CNTL			0x1C
+#define SM5703_BUCKCNTL				0x1D
+#define SM5703_DEVICE_ID			0x1E
+
+#define SM5703_AUTOSET             0x1
+#define SM5703_AUTOSET_MASK        (1 << 4)
+
+#define SM5703_OPERATION_MODE				        0x07
+#define SM5703_OPERATION_MODE_MASK                  0x07
+#define SM5703_OPERATION_MODE_SHIFT			        0
+
+#define SM5703_OPERATION_MODE_SUSPEND               0x00
+#define SM5703_OPERATION_MODE_CHARGING_OFF          0x04//100
+#define SM5703_OPERATION_MODE_CHARGING_ON           0x05//101
+#define SM5703_OPERATION_MODE_FLASH_BOOST_MODE      0x06//110
+#define SM5703_OPERATION_MODE_USB_OTG_MODE          0x07//111
+
+#define SM5703_BSTOUT				0x0F
+#define SM5703_BSTOUT_MASK			0x0F
+#define SM5703_BSTOUT_SHIFT			0
+
+#define SM5703_BSTOUT_4P5           0x05
+#define SM5703_BSTOUT_5P0           0x0A
+#define SM5703_BSTOUT_5P1           0x0B
+
+#define SM5703_AUTOSTOP             0x1
+#define SM5703_AUTOSTOP_MASK        (1 << 7)
+
+#define SM5703_TOPOFF_TIMER			0x3
+#define SM5703_TOPOFF_TIMER_MASK	0x60
+#define SM5703_TOPOFF_TIMER_SHIFT	0x5
+
+#define SM5703_AICLEN               0x1
+#define SM5703_AICLEN_MASK          (1 << 7)
+
+#define SM5703_VBUSLIMIT            0x3F
+#define SM5703_VBUSLIMIT_MASK       0x3F
+
+#define SM5703_BATREG               0x1F
+#define SM5703_BATREG_MASK          0x1F
+
+#define SM5703_FASTCHG               0x3F
+#define SM5703_FASTCHG_MASK          0x3F
+
+#define SM5703_TOPOFF               0x0F
+#define SM5703_TOPOFF_MASK          0x78
+#define SM5703_TOPOFF_SHIFT         0x03
+
+#define SM5703_CHGON                0x01
+#define SM5703_CHGON_MASK           (1 << 0)
+#define SM5703_CHGON_SHIFT          0x00
+
+#define SM5703_AICLTH                 0x07
+#define SM5703_AICLTH_MASK            0x07
+
+#define SM5703_FREQSEL                 0x03
+#define SM5703_FREQSEL_MASK            0x0C
+#define SM5703_FREQSEL_SHIFT           0x02
+
+#define SM5703_OTGCURRENT               0x03
+#define SM5703_OTGCURRENT_MASK          0x03
+
+#define SM5703_FREQSEL_3MHZ             0x0
+#define SM5703_FREQSEL_2P4MHZ           0x1
+#define SM5703_FREQSEL_1P5MHZ           0x2
+#define SM5703_FREQSEL_1P8MHZ           0x3
+
+#define SM5703_BST_IQ3LIMIT_0P7X        0x0
+#define SM5703_BST_IQ3LIMIT_1X          0x1
+#define SM5703_BST_IQ3LIMIT_MASK        0x80
+#define SM5703_BST_IQ3LIMIT_SHIFT       0x7
+
+#define REDUCE_CURRENT_STEP				100
+#define MINIMUM_INPUT_CURRENT			300
+#define SLOW_CHARGING_CURRENT_STANDARD	999
+
+#define ENABLE 1
+#define DISABLE 0
+
+extern bool sec_bat_get_slate_mode(void);
+
+extern sec_battery_platform_data_t sec_battery_pdata;
+
+
+#endif /*SM5703_CHARGER_H*/
diff -Naur linux-3.18.14/drivers/battery_v2/include/charger/sm5705_charger.h samsung/drivers/battery_v2/include/charger/sm5705_charger.h
--- linux-3.18.14/drivers/battery_v2/include/charger/sm5705_charger.h	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/include/charger/sm5705_charger.h	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,183 @@
+/*
+ * sm5705_charger.h
+ * Samsung SM5705 Charger Header
+ *
+ * Copyright (C) 2012 Samsung Electronics, Inc.
+ *
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __SM5705_CHARGER_H
+#define __SM5705_CHARGER_H __FILE__
+
+#include <linux/mfd/core.h>
+#include <linux/mfd/sm5705.h>
+#include <linux/regulator/machine.h>
+#include "../sec_charging_common.h"
+
+/* CONFIG: Kernel Feature & Target System configuration */
+//#define SM5705_SUPPORT_AICL_CONTROL       - New A series dosen't support, It's MUST be disabled
+#define SM5705_SUPPORT_OTG_CONTROL        - New A series dosen't support, It's MUST be disabled
+
+/* SM5705 Charger - RESET condition configuaration */
+//#define SM5705_I2C_RESET_ACTIVATE
+//#define SM5705_MANUAL_RESET_ACTIVATE
+//#define SM5705_MANUAL_RESET_TIMER                   SM5705_MANUAL_RESET_TIME_7s
+//#define SM5705_WATCHDOG_RESET_ACTIVATE
+//#define SM5705_WATCHDOG_RESET_TIMER                   SM5705_WATCHDOG_RESET_TIME_120s
+//#define SM5705_SW_SOFT_START      /* default used HW soft-start */
+
+#define EN_NOBAT_IRQ		1
+#define EN_TOPOFF_IRQ		1
+#define EN_OTGFAIL_IRQ		1
+
+#define SM5705_STATUS3_OTGFAIL		(1 << 2)
+#if defined(CONFIG_USE_POGO)
+#define SM5705_STATUS1_WPCINPOK		(1 << 4)
+#endif
+
+enum {
+	CHIP_ID = 0,
+	CHARGER_OP_MODE=1,
+};
+ssize_t sm5705_chg_show_attrs(struct device *dev,
+				struct device_attribute *attr, char *buf);
+ssize_t sm5705_chg_store_attrs(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count);
+
+#define SM5705_CHARGER_ATTR(_name)				\
+{							                    \
+	.attr = {.name = #_name, .mode = 0664},	    \
+	.show = sm5705_chg_show_attrs,			    \
+	.store = sm5705_chg_store_attrs,			\
+}
+
+enum {
+    SM5705_MANUAL_RESET_TIME_7s = 0x1,
+    SM5705_MANUAL_RESET_TIME_8s = 0x2,
+    SM5705_MANUAL_RESET_TIME_9s = 0x3,
+};
+
+enum {
+    SM5705_WATCHDOG_RESET_TIME_30s  = 0x0,
+    SM5705_WATCHDOG_RESET_TIME_60s  = 0x1,
+    SM5705_WATCHDOG_RESET_TIME_90s  = 0x2,
+    SM5705_WATCHDOG_RESET_TIME_120s = 0x3,
+};
+
+enum {
+    SM5705_TOPOFF_TIMER_10m         = 0x0,
+    SM5705_TOPOFF_TIMER_20m         = 0x1,
+    SM5705_TOPOFF_TIMER_30m         = 0x2,
+    SM5705_TOPOFF_TIMER_45m         = 0x3,
+};
+
+enum {
+    SM5705_BUCK_BOOST_FREQ_3MHz     = 0x0,
+    SM5705_BUCK_BOOST_FREQ_2_4MHz   = 0x1,
+    SM5705_BUCK_BOOST_FREQ_1_5MHz   = 0x2,
+    SM5705_BUCK_BOOST_FREQ_1_8MHz   = 0x3,
+};
+
+/* for VZW support */
+#define SLOW_CHARGING_CURRENT_STANDARD		400
+
+/* SM5705 Charger - AICL reduce current configuration */
+#define REDUCE_CURRENT_STEP			100
+#define MINIMUM_INPUT_CURRENT			300
+#define AICL_VALID_CHECK_DELAY_TIME             10
+
+#define SM5705_OTGCURRENT_MASK                  0xC
+#define SM5705_EN_DISCHG_FORCE_MASK             0x02
+
+#define INPUT_CURRENT_TA		                1000
+#define INPUT_CURRENT_WPC		                500
+
+struct sm5705_charger_data {
+	struct device *dev;
+	struct i2c_client *i2c;
+	struct sec_charger_platform_data *pdata;
+
+	struct power_supply	psy_chg;
+	struct power_supply	psy_otg;
+	int status;
+
+	/* for IRQ-service handling */
+	int irq_aicl;
+	int irq_vbus_pok;
+	int irq_wpcin_pok;
+#if defined(CONFIG_USE_POGO)
+	int irq_wpcin_pok_pogo;
+	int irq_wpcin_uvlo_pogo;
+#endif
+#if EN_NOBAT_IRQ
+	int irq_nobat;
+#endif
+#if EN_TOPOFF_IRQ
+	int irq_topoff;
+#endif
+#if EN_OTGFAIL_IRQ
+	int irq_otgfail;
+#endif
+	int irq_done;
+
+	/* for Workqueue & wake-lock, mutex process */
+	struct mutex charger_mutex;
+
+	struct workqueue_struct *wqueue;
+	struct delayed_work wpc_work;
+	struct delayed_work wc_afc_work;
+	struct delayed_work aicl_work;
+#if defined(CONFIG_USE_POGO)
+	struct delayed_work pogo_work;
+#endif
+#if EN_NOBAT_IRQ
+	struct delayed_work nobat_work;
+#endif
+#if EN_TOPOFF_IRQ
+	struct delayed_work topoff_work;
+#endif
+	// temp for rev2 SW WA
+	struct delayed_work op_mode_switch_work;        /* for WA obnormal switch case in JIG cable */
+
+	struct wake_lock wpc_wake_lock;
+#if defined(SM5705_SW_SOFT_START)
+	struct wake_lock softstart_wake_lock;
+#endif
+	struct wake_lock check_slow_wake_lock;
+	struct wake_lock aicl_wake_lock;
+
+	/* for charging operation handling */
+	int charge_mode;
+	unsigned int is_charging;
+	unsigned int cable_type;
+	unsigned int input_current;
+	unsigned int charging_current;
+	unsigned int topoff_current;
+        bool is_jig_on;
+	int	irq_wpcin_state;
+	bool topoff_pending;
+	// temp for rev2 SW WA
+	bool is_rev2_wa_done;
+
+	bool wc_afc_detect;
+	bool is_mdock;
+};
+
+extern int sm5705_call_fg_device_id(void);
+
+#if defined(SM5705_WATCHDOG_RESET_ACTIVATE)
+extern void sm5705_charger_watchdog_timer_keepalive(void);
+#endif
+
+#endif /* __SM5705_CHARGER_H */
+
diff -Naur linux-3.18.14/drivers/battery_v2/include/charger/sm5705_charger_oper.h samsung/drivers/battery_v2/include/charger/sm5705_charger_oper.h
--- linux-3.18.14/drivers/battery_v2/include/charger/sm5705_charger_oper.h	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/include/charger/sm5705_charger_oper.h	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,50 @@
+/*
+ * drivers/battery/sm5705_charger_oper.h
+ *
+ * SM5705 Charger Operation Mode controller
+ *
+ * Copyright (C) 2015 Siliconmitus Technology Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/mfd/sm5705.h>
+
+enum {
+	SM5705_CHARGER_OP_MODE_SUSPEND             = 0x0,
+	SM5705_CHARGER_OP_MODE_FACTORY             = 0x1,
+	SM5705_CHARGER_OP_MODE_WPC_OTG_CHG_OFF     = 0x2,
+	SM5705_CHARGER_OP_MODE_WPC_OTG_CHG_ON      = 0x3,
+	SM5705_CHARGER_OP_MODE_CHG_OFF             = 0x4,
+	SM5705_CHARGER_OP_MODE_CHG_ON              = 0x5,
+	SM5705_CHARGER_OP_MODE_FLASH_BOOST         = 0x6,
+	SM5705_CHARGER_OP_MODE_USB_OTG             = 0x7,
+};
+
+enum SM5705_CHARGER_OP_EVENT_TYPE {
+	SM5705_CHARGER_OP_EVENT_VBUS                = 0x5,
+	SM5705_CHARGER_OP_EVENT_WPC                 = 0x4,
+	SM5705_CHARGER_OP_EVENT_FLASH               = 0x3,
+	SM5705_CHARGER_OP_EVENT_TORCH               = 0x2,
+	SM5705_CHARGER_OP_EVENT_OTG                 = 0x1,
+	SM5705_CHARGER_OP_EVENT_PWR_SHAR            = 0x0,
+};
+
+#define make_OP_STATUS(vbus,wpc,flash,torch,otg,pwr_shar)   (((vbus & 0x1) << SM5705_CHARGER_OP_EVENT_VBUS)         | \
+                                                             ((wpc & 0x1) << SM5705_CHARGER_OP_EVENT_WPC)           | \
+                                                             ((flash & 0x1) << SM5705_CHARGER_OP_EVENT_FLASH)       | \
+                                                             ((torch & 0x1) << SM5705_CHARGER_OP_EVENT_TORCH)       | \
+                                                             ((otg & 0x1) << SM5705_CHARGER_OP_EVENT_OTG)           | \
+                                                             ((pwr_shar & 0x1) << SM5705_CHARGER_OP_EVENT_PWR_SHAR))
+
+int sm5705_charger_oper_push_event(int event_type, bool enable);
+int sm5705_charger_oper_table_init(struct i2c_client *i2c);
+
+int sm5705_charger_oper_get_current_status(void);
+int sm5705_charger_oper_get_current_op_mode(void);
+
diff -Naur linux-3.18.14/drivers/battery_v2/include/charger/sma7p10_charger.h samsung/drivers/battery_v2/include/charger/sma7p10_charger.h
--- linux-3.18.14/drivers/battery_v2/include/charger/sma7p10_charger.h	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/include/charger/sma7p10_charger.h	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,119 @@
+/*
+ * sma7p10-charger.h - Header of SMA7P10 sub charger IC
+ *
+ * Copyright (C) 2016 Samsung Electronics Co.Ltd
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#ifndef __SMA7P10_CHARGER_H__
+#define __SMA7P10_CHARGER_H__
+
+#include "../sec_charging_common.h"
+
+#define SMA7P10_REGS_BASE	0
+#define SMA7P10_REGS_SIZE	1024
+
+#define MASK(width, shift)      (((0x1 << (width)) - 1) << shift) 
+
+/*---------------------------------------- */
+/* Registers */
+/*---------------------------------------- */
+#define SMA7P10_CHG_INT1			0x1
+#define SMA7P10_CHG_INT2			0x2
+#define SMA7P10_CHG_INT1_MASK		0x3
+#define SMA7P10_CHG_INT2_MASK		0x4
+#define SMA7P10_CHG_STATUS1			0x5
+#define SMA7P10_CHG_STATUS2			0x6
+#define SMA7P10_SC_CTRL0			0x4D
+#define SMA7P10_SC_CTRL1			0x4E
+#define SMA7P10_SC_CTRL5			0x50
+#define SMA7P10_SC_CTRL6			0x51
+#define SMA7P10_PMIC_ID				0x56
+
+/* SMA7P10_CHG_STATUS1			0x5 */
+#define VIN_OK_SHIFT 7
+#define VIN_OK_STATUS_MASK		BIT(VIN_OK_SHIFT)
+#define VINOV_OK_SHIFT 6
+#define VINOV_OK_STATUS_MASK	BIT(VINOV_OK_SHIFT)
+#define VINUV_OK_SHIFT 5
+#define VINUV_OK_STATUS_MASK	BIT(VINUV_OK_SHIFT)
+#define BATOV_OK_SHIFT 4
+#define BATOV_OK_STATUS_MASK	BIT(BATOV_OK_SHIFT)
+#define BATUV_OK_SHIFT 3
+#define BATUV_OK_STATUS_MASK	BIT(BATUV_OK_SHIFT)
+
+/* SMA7P10_CHG_STATUS2			0x6 */
+#define MODE_STATUS_SHIFT			6
+#define MODE_STATUS_MASK			BIT(MODE_STATUS_SHIFT)
+
+/* SMA7P10_SC_CTRL0			0x4D */
+#define CHG_CURRENT_SHIFT			7
+#define CHG_CURRENT_MASK			BIT(CHG_CURRENT_SHIFT)
+
+/* SMA7P10_SC_CTRL1			0x4E */
+#define ENI2C_SHIFT				3
+#define ENI2C_MASK				BIT(ENI2C_SHIFT)
+
+/* SMA7P10_SC_CTRL5			0x50 */
+#define CPQ_SHIFT				4
+#define CPQ_WIDTH				2
+#define CPQ_MASK				MASK(CPQ_WIDTH, CPQ_SHIFT)
+
+#define V3P14					0
+#define V3P04					1
+#define V2P94					2
+#define V2P84					3
+
+#define CV_FLG_SHIFT				0
+#define CV_FLG_WIDTH				4
+#define CV_FLG_MASK				MASK(CV_FLG_WIDTH, CV_FLG_SHIFT)
+
+/* SMA7P10_SC_CTRL6			0x51 */
+#define SOFT_DOWN_SHIFT				1
+#define SOFT_DOWN_WIDTH				3
+#define	SOFT_DOWN_MASK				MASK(SOFT_DOWN_WIDTH, SOFT_DOWN_SHIFT)
+
+/*---------------------------------------- */
+/* Bit Fields */
+/*---------------------------------------- */
+
+struct sma7p10_charger_data {
+	struct device           *dev;
+	struct i2c_client       *i2c;
+	struct mutex            io_lock;
+
+	sec_charger_platform_data_t *pdata;
+
+	struct power_supply	psy_chg;
+	struct workqueue_struct *wqueue;
+	struct delayed_work	isr_work;
+
+	struct pinctrl *i2c_pinctrl;
+	struct pinctrl_state *i2c_gpio_state_active;
+	struct pinctrl_state *i2c_gpio_state_suspend;
+
+	unsigned int siop_level;
+	unsigned int chg_irq;
+	unsigned int is_charging;
+	unsigned int charging_type;
+	unsigned int cable_type;
+	unsigned int charging_current_max;
+	unsigned int charging_current;
+
+	u8 addr;
+	int size;
+};
+#endif	/* __SMA7P10_CHARGER_H__ */
diff -Naur linux-3.18.14/drivers/battery_v2/include/fuelgauge/max77854_fuelgauge.h samsung/drivers/battery_v2/include/fuelgauge/max77854_fuelgauge.h
--- linux-3.18.14/drivers/battery_v2/include/fuelgauge/max77854_fuelgauge.h	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/include/fuelgauge/max77854_fuelgauge.h	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,192 @@
+/*
+ * max77854_fuelgauge.h
+ * Samsung MAX77854 Fuel Gauge Header
+ *
+ * Copyright (C) 2015 Samsung Electronics, Inc.
+ *
+ * This software is 77854 under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __MAX77854_FUELGAUGE_H
+#define __MAX77854_FUELGAUGE_H __FILE__
+
+#include <linux/mfd/core.h>
+#include <linux/mfd/max77854.h>
+#include <linux/mfd/max77854-private.h>
+#include <linux/regulator/machine.h>
+#include "../sec_charging_common.h"
+
+#include <linux/sec_batt.h>
+
+/* Slave address should be shifted to the right 1bit.
+ * R/W bit should NOT be included.
+ */
+
+#define PRINT_COUNT	10
+
+#define ALERT_EN 0x04
+#define CAPACITY_SCALE_DEFAULT_CURRENT 1000
+#define CAPACITY_SCALE_HV_CURRENT 600
+
+enum max77854_vempty_mode {
+	VEMPTY_MODE_HW = 0,
+	VEMPTY_MODE_SW,
+	VEMPTY_MODE_SW_VALERT,
+	VEMPTY_MODE_SW_RECOVERY,
+};
+
+struct sec_fg_info {
+	/* test print count */
+	int pr_cnt;
+	/* full charge comp */
+	struct delayed_work	full_comp_work;
+	u32 previous_fullcap;
+	u32 previous_vffullcap;
+
+	/* battery info */
+	u32 soc;
+
+	/* miscellaneous */
+	unsigned long fullcap_check_interval;
+	int full_check_flag;
+	bool is_first_check;
+};
+
+enum {
+	FG_LEVEL = 0,
+	FG_TEMPERATURE,
+	FG_VOLTAGE,
+	FG_CURRENT,
+	FG_CURRENT_AVG,
+	FG_CHECK_STATUS,
+	FG_RAW_SOC,
+	FG_VF_SOC,
+	FG_AV_SOC,
+	FG_FULLCAP,
+	FG_FULLCAPNOM,
+	FG_FULLCAPREP,
+	FG_MIXCAP,
+	FG_AVCAP,
+	FG_REPCAP,
+	FG_CYCLE,
+};
+
+enum {
+	POSITIVE = 0,
+	NEGATIVE,
+};
+
+enum {
+	RANGE = 0,
+	SLOPE,
+	OFFSET,
+	TABLE_MAX
+};
+
+#define CURRENT_RANGE_MAX_NUM	5
+
+struct battery_data_t {
+	u32 V_empty;
+	u32 V_empty_origin;
+	u32 sw_v_empty_vol;
+	u32 sw_v_empty_recover_vol;	
+	u32 QResidual20;
+	u32 QResidual30;
+	u32 TempCo;
+	u32 Capacity;
+	u8	*type_str;
+	u32 ichgterm;
+	u32 misccfg;
+	u32 fullsocthr;
+	u32 ichgterm_2nd;
+	u32 misccfg_2nd;
+	u32 fullsocthr_2nd;
+};
+
+/* FullCap learning setting */
+#define VFFULLCAP_CHECK_INTERVAL	300 /* sec */
+/* soc should be 0.1% unit */
+#define VFSOC_FOR_FULLCAP_LEARNING	950
+#define LOW_CURRENT_FOR_FULLCAP_LEARNING	20
+#define HIGH_CURRENT_FOR_FULLCAP_LEARNING	120
+#define LOW_AVGCURRENT_FOR_FULLCAP_LEARNING	20
+#define HIGH_AVGCURRENT_FOR_FULLCAP_LEARNING	100
+
+/* power off margin */
+/* soc should be 0.1% unit */
+#define POWER_OFF_SOC_HIGH_MARGIN	20
+#define POWER_OFF_VOLTAGE_HIGH_MARGIN	3500
+#define POWER_OFF_VOLTAGE_LOW_MARGIN	3400
+
+struct cv_slope{
+	int fg_current;
+	int soc;
+	int time;
+};
+
+struct max77854_fuelgauge_data {
+	struct device           *dev;
+	struct i2c_client       *i2c;
+	struct i2c_client       *pmic;
+	struct mutex            fuelgauge_mutex;
+	struct max77854_platform_data *max77854_pdata;
+	sec_fuelgauge_platform_data_t *pdata;
+	struct power_supply		psy_fg;
+	struct delayed_work isr_work;
+
+	int cable_type;
+	bool is_charging;
+
+	/* HW-dedicated fuel guage info structure
+	 * used in individual fuel gauge file only
+	 * (ex. dummy_fuelgauge.c)
+	 */
+	struct sec_fg_info	info;
+	struct battery_data_t        *battery_data;
+
+	bool is_fuel_alerted;
+	struct wake_lock fuel_alert_wake_lock;
+
+	unsigned int capacity_old;	/* only for atomic calculation */
+	unsigned int capacity_max;	/* only for dynamic calculation */
+	unsigned int standard_capacity;
+
+	bool initial_update_of_soc;
+	struct mutex fg_lock;
+
+	/* register programming */
+	int reg_addr;
+	u8 reg_data[2];
+
+	unsigned int pre_soc;
+	int fg_irq;
+
+	int raw_capacity;
+	int current_now;
+	int current_avg;
+	struct cv_slope *cv_data;
+	int cv_data_lenth;
+
+	bool using_temp_compensation;
+	bool using_hw_vempty;
+	unsigned int vempty_mode;
+	int temperature;
+
+	int low_temp_limit;
+
+	bool auto_discharge_en;
+	u32 discharge_temp_threshold;
+	u32 discharge_volt_threshold;
+
+	u32 fg_resistor;
+};
+
+#endif /* __MAX77854_FUELGAUGE_H */
diff -Naur linux-3.18.14/drivers/battery_v2/include/fuelgauge/s2mu004_fuelgauge.h samsung/drivers/battery_v2/include/fuelgauge/s2mu004_fuelgauge.h
--- linux-3.18.14/drivers/battery_v2/include/fuelgauge/s2mu004_fuelgauge.h	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/include/fuelgauge/s2mu004_fuelgauge.h	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,194 @@
+/*
+ * s2mu004_fuelgauge.h - Header of S2MU004 Fuel Gauge
+ *
+ * Copyright (C) 2016 Samsung Electronics Co.Ltd
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __S2MU004_FUELGAUGE_H
+#define __S2MU004_FUELGAUGE_H __FILE__
+
+#if defined(ANDROID_ALARM_ACTIVATED)
+#include <linux/android_alarm.h>
+#endif
+
+#include "../sec_charging_common.h"
+
+extern unsigned int lpcharge;
+
+/* Slave address should be shifted to the right 1bit.
+ * R/W bit should NOT be included.
+ */
+
+#define S2MU004_REG_STATUS              0x00
+#define S2MU004_REG_IRQ                 0x02
+#define S2MU004_REG_RVBAT               0x04
+#define S2MU004_REG_RCUR_CC             0x06
+#define S2MU004_REG_RSOC                0x08
+#define S2MU004_REG_MONOUT              0x0A
+#define S2MU004_REG_MONOUT_SEL          0x0C
+#define S2MU004_REG_RBATCAP             0x0E
+#define S2MU004_REG_RZADJ               0x12
+#define S2MU004_REG_RBATZ0              0x16
+#define S2MU004_REG_RBATZ1              0x18
+#define S2MU004_REG_IRQ_LVL             0x1A
+#define S2MU004_REG_START               0x1E
+#define S2MU004_REG_CTRL0		0x25
+#define S2MU004_REG_FG_ID		0x48
+#define S2MU004_REG_COFFSET             0x5A
+
+enum {
+        CURRENT_MODE = 0,
+        LOW_SOC_VOLTAGE_MODE,
+        HIGH_SOC_VOLTAGE_MODE,
+        END_MODE,
+};
+
+struct sec_fg_info {
+        /* test print count */
+        int pr_cnt;
+        /* full charge comp */
+        /* struct delayed_work     full_comp_work; */
+        u32 previous_fullcap;
+        u32 previous_vffullcap;
+        /* low battery comp */
+        int low_batt_comp_flag;
+        /* low battery boot */
+        int low_batt_boot_flag;
+        bool is_low_batt_alarm;
+
+        /* battery info */
+        int soc;
+
+#if !defined(CONFIG_BATTERY_AGE_FORECAST)
+        /* copy from platform data /
+         * DTS or update by shell script */
+        int battery_table1[88]; // evt1
+        int battery_table2[22]; // evt1
+        int battery_table3[88]; // evt2
+        int battery_table4[22]; // evt2
+        int soc_arr_val[22];
+        int ocv_arr_val[22];
+        int batcap[4];
+        int accum[2];
+#endif
+        /* miscellaneous */
+        unsigned long fullcap_check_interval;
+        int full_check_flag;
+        bool is_first_check;
+};
+
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+struct fg_age_data_info {
+        int battery_table3[88]; // evt2
+        int battery_table4[22]; // evt2
+        int batcap[4];
+        int accum[2];
+	int soc_arr_val[22];
+        int ocv_arr_val[22];
+};
+
+#define	fg_age_data_info_t \
+	struct fg_age_data_info
+#endif
+
+#if defined(CONFIG_FUELGAUGE_ASOC_FROM_CYCLES)
+struct sec_cycles_to_asoc {
+	unsigned int cycle;
+	unsigned int asoc;
+};
+
+#define sec_cycles_to_asoc_t \
+	struct sec_cycles_to_asoc
+#endif
+
+typedef struct s2mu004_fuelgauge_platform_data {
+	int capacity_max;
+	int capacity_max_margin;
+	int capacity_min;
+	int capacity_calculation_type;
+	int fuel_alert_soc;
+	int fuel_alert_vol;
+	int fullsocthr;
+	int fg_irq;
+	unsigned int capacity_full;
+	int fg_log_enable;
+
+	char *fuelgauge_name;
+
+	bool repeated_fuelalert;
+
+#if defined(CONFIG_FUELGAUGE_ASOC_FROM_CYCLES)
+	int fixed_asoc_levels;
+	sec_cycles_to_asoc_t *cycles_to_asoc;
+#endif
+} s2mu004_fuelgauge_platform_data_t;
+
+struct s2mu004_fuelgauge_data {
+        struct device           *dev;
+        struct i2c_client       *i2c;
+        struct i2c_client       *pmic;
+        struct mutex            fuelgauge_mutex;
+        s2mu004_fuelgauge_platform_data_t *pdata;
+        struct power_supply     psy_fg;
+        /* struct delayed_work isr_work; */
+
+        int cable_type;
+        bool is_charging;
+        int mode;
+        int revision;
+
+        /* HW-dedicated fuel guage info structure
+         * used in individual fuel gauge file only
+         * (ex. dummy_fuelgauge.c)
+         */
+        struct sec_fg_info      info;
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	fg_age_data_info_t*	age_data_info;
+	int fg_num_age_step;
+	int fg_age_step;
+	int age_reset_status;
+        struct mutex fg_reset_lock;
+#endif
+        bool is_fuel_alerted;
+        struct wake_lock fuel_alert_wake_lock;
+
+        unsigned int capacity_old;      /* only for atomic calculation */
+        unsigned int capacity_max;      /* only for dynamic calculation */
+        unsigned int standard_capacity;
+
+        bool initial_update_of_soc;
+	bool sleep_initial_update_of_soc;
+        struct mutex fg_lock;
+        struct delayed_work isr_work;
+
+        /* register programming */
+        int reg_addr;
+        u8 reg_data[2];
+		u8 reg_OTP_4F;
+		u8 reg_OTP_4E;
+
+        unsigned int pre_soc;
+        int fg_irq;
+        int diff_soc;
+        int target_ocv;
+        int vm_soc;
+        bool cc_on;
+        u16 coffset_old;
+        bool coffset_flag;
+        bool probe_done;
+};
+
+#endif /* __S2MU004_FUELGAUGE_H */
diff -Naur linux-3.18.14/drivers/battery_v2/include/fuelgauge/s2mu005_fuelgauge.h samsung/drivers/battery_v2/include/fuelgauge/s2mu005_fuelgauge.h
--- linux-3.18.14/drivers/battery_v2/include/fuelgauge/s2mu005_fuelgauge.h	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/include/fuelgauge/s2mu005_fuelgauge.h	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,182 @@
+/*
+ * s2mu005_fuelgauge.h
+ * Samsung S2MU005 Fuel Gauge Header
+ *
+ * Copyright (C) 2015 Samsung Electronics, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __S2MU005_FUELGAUGE_H
+#define __S2MU005_FUELGAUGE_H __FILE__
+
+#if defined(ANDROID_ALARM_ACTIVATED)
+#include <linux/android_alarm.h>
+#endif
+
+#include "../sec_charging_common.h"
+
+/* Slave address should be shifted to the right 1bit.
+ * R/W bit should NOT be included.
+ */
+
+#define S2MU005_REG_STATUS		0x00
+#define S2MU005_REG_IRQ			0x02
+#define S2MU005_REG_RVBAT		0x04
+#define S2MU005_REG_RCUR_CC		0x06
+#define S2MU005_REG_RSOC		0x08
+#define S2MU005_REG_MONOUT		0x0A
+#define S2MU005_REG_MONOUT_SEL		0x0C
+#define S2MU005_REG_RBATCAP		0x0E
+#define S2MU005_REG_RZADJ		0x12
+#define S2MU005_REG_RBATZ0		0x16
+#define S2MU005_REG_RBATZ1		0x18
+#define S2MU005_REG_IRQ_LVL		0x1A
+#define S2MU005_REG_START		0x1E
+#define S2MU005_REG_COFFSET		0x5A
+
+enum {
+	CURRENT_MODE = 0,
+	LOW_SOC_VOLTAGE_MODE,
+	HIGH_SOC_VOLTAGE_MODE,
+	END_MODE,
+};
+
+enum s2mu004_vbatl_mode {
+	VBATL_MODE_NORMAL = 0,
+	VBATL_MODE_SW_VALERT,
+	VBATL_MODE_SW_RECOVERY,
+};
+
+struct sec_fg_info {
+	/* test print count */
+	int pr_cnt;
+	/* full charge comp */
+	/* struct delayed_work     full_comp_work; */
+	u32 previous_fullcap;
+	u32 previous_vffullcap;
+	/* low battery comp */
+	int low_batt_comp_flag;
+	/* low battery boot */
+	int low_batt_boot_flag;
+	bool is_low_batt_alarm;
+
+	/* battery info */
+	int soc;
+#if !defined(CONFIG_BATTERY_AGE_FORECAST)
+	/* copy from platform data /
+	 * DTS or update by shell script */
+	int battery_table1[88]; // evt1
+	int battery_table2[22]; // evt1
+	int battery_table3[88]; // evt2
+	int battery_table4[22]; // evt2
+	int soc_arr_evt1[22];
+	int ocv_arr_evt1[22];
+	int soc_arr_evt2[22];
+	int ocv_arr_evt2[22];
+	int batcap[4];
+	int fg_accumulative_rate_evt2[4];
+#endif
+	/* miscellaneous */
+	unsigned long fullcap_check_interval;
+	int full_check_flag;
+	bool is_first_check;
+};
+
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+struct fg_age_data_info {
+	int battery_table3[88]; /* evt2 */
+	int battery_table4[22]; /* evt2 */
+	int batcap[4];
+	int accum[2];
+	int soc_arr_val[22];
+	int ocv_arr_val[22];
+};
+
+#define	fg_age_data_info_t \
+	struct fg_age_data_info
+#endif
+struct s2mu005_platform_data {
+	int capacity_max;
+	int capacity_max_margin;
+	int capacity_min;
+	int capacity_calculation_type;
+	int evt2_val;
+	int fuel_alert_soc;
+	int fullsocthr;
+	int fg_irq;
+	int fg_log_enable;
+
+	char *fuelgauge_name;
+
+	bool repeated_fuelalert;
+
+	struct sec_charging_current *charging_current;
+};
+
+struct s2mu005_fuelgauge_data {
+	struct device           *dev;
+	struct i2c_client       *i2c;
+	struct i2c_client       *pmic;
+	struct mutex            fuelgauge_mutex;
+	struct s2mu005_platform_data *pdata;
+	struct power_supply	psy_fg;
+	/* struct delayed_work isr_work; */
+
+	int cable_type;
+	bool is_charging;
+	int mode;
+	int revision;
+	int change_step;
+
+	/* HW-dedicated fuel guage info structure
+	 * used in individual fuel gauge file only
+	 * (ex. dummy_fuelgauge.c)
+	 */
+	struct sec_fg_info      info;
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	fg_age_data_info_t	*age_data_info;
+	int fg_num_age_step;
+	int fg_age_step;
+	int age_reset_status;
+#endif
+	bool is_fuel_alerted;
+	struct wake_lock fuel_alert_wake_lock;
+
+	unsigned int capacity_old;      /* only for atomic calculation */
+	unsigned int capacity_max;      /* only for dynamic calculation */
+	unsigned int standard_capacity;
+
+	bool initial_update_of_soc;
+	bool sleep_initial_update_of_soc;
+	struct mutex fg_lock;
+	bool wa_flag;	/*Prevent WA_0_issue_at_init1 overlap*/
+	struct delayed_work isr_work;
+
+	/* register programming */
+	int reg_addr;
+	u8 reg_data[2];
+
+	unsigned int vbatl_mode;
+	int sw_vbat_l_recovery_vol;
+	int low_temp_limit;
+	int temperature;
+
+	unsigned int pre_soc;
+	int fg_irq;
+	int diff_soc;
+	int target_ocv;
+	int vm_soc;
+	bool cc_on;
+	u16 coffset_old;
+	bool coffset_flag;
+};
+#endif /* __S2MU005_FUELGAUGE_H */
diff -Naur linux-3.18.14/drivers/battery_v2/include/fuelgauge/sm5703_fuelgauge.h samsung/drivers/battery_v2/include/fuelgauge/sm5703_fuelgauge.h
--- linux-3.18.14/drivers/battery_v2/include/fuelgauge/sm5703_fuelgauge.h	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/include/fuelgauge/sm5703_fuelgauge.h	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,209 @@
+/*
+ * drivers/battery/sm5703_fuelgauge.h
+ *
+ * Header of SiliconMitus SM5703 Fuelgauge Driver
+ *
+ * Copyright (C) 2015 SiliconMitus
+ * Author: SW Jung
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ */
+
+#ifndef SM5703_FUELGAUGE_H
+#define SM5703_FUELGAUGE_H
+
+#include <linux/i2c.h>
+#include <linux/mfd/sm5703.h>
+#include "../sec_charging_common.h"
+
+#ifdef CONFIG_DEBUG_FS
+#include <linux/debugfs.h>
+#endif /* #ifdef CONFIG_DEBUG_FS */
+
+#define FG_DRIVER_VER "0.0.0.1"
+#define USE_SUSPEND_LATE
+
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+#define ENABLE_BATT_LONG_LIFE 1
+#endif
+
+enum sm5703_valrt_mode {
+	SM5703_NORMAL_MODE = 0,
+	SM5703_RECOVERY_MODE,
+	SM5703_COLD_MODE,
+};
+
+enum sm5703_variants {
+	NOVEL = 0,
+	J2LTE,
+	O5LTE,
+	J3XATT,
+	J7LTE,
+};
+
+struct battery_data_t {
+	const int battery_type; /* 4200 or 4350 or 4400*/
+	const int battery_table[3][16];
+	const int rce_value[3];
+	const int dtcd_value;
+	const int rs_value[4];
+	const int vit_period;
+	const int mix_value[2];
+	const int topoff_soc[2];
+	const int volt_cal;
+	const int curr_cal;
+	const int temp_std;
+	const int temp_offset;
+	const int temp_offset_cal;
+	const int charge_offset_cal;
+};
+
+struct sm5703_fg_info {
+	bool is_low_batt_alarm;
+	/* State Of Connect */
+	int online;
+	/* battery SOC (capacity) */
+	int batt_soc;
+	/* battery voltage */
+	int batt_voltage;
+	/* battery AvgVoltage */
+	int batt_avgvoltage;
+	/* battery OCV */
+	int batt_ocv;
+	/* Current */
+	int batt_current;
+	/* battery Avg Current */
+	int batt_avgcurrent;
+
+	struct battery_data_t *comp_pdata;
+
+	struct mutex param_lock;
+	/* copy from platform data /
+	 * DTS or update by shell script */
+
+	struct mutex io_lock;
+	struct device *dev;
+	int32_t temperature; /* 0.1 deg C*/
+	int32_t temp_fg; /* 0.1 deg C*/
+	/* register programming */
+	int reg_addr;
+	u8 reg_data[2];
+
+	int battery_table[3][16];
+#ifdef ENABLE_BATT_LONG_LIFE
+#ifdef CONFIG_BATTERY_AGE_FORECAST_DETACHABLE
+	int v_max_table[3];
+	int q_max_table[3];
+#else
+	int v_max_table[5];
+	int q_max_table[5];
+#endif
+	int v_max_now;
+	int q_max_now;
+#endif
+	int rce_value[3];
+	int dtcd_value;
+	int rs_value[4]; /*rs mix_factor max min*/
+	int vit_period;
+	int mix_value[2]; /*mix_rate init_blank*/
+
+	int enable_topoff_soc;
+	int topoff_soc;
+
+	int volt_cal;
+	int curr_cal;
+
+	int temp_std;
+	int temp_offset;
+	int temp_offset_cal;
+	int charge_offset_cal;
+
+	int battery_type; /* 4200 or 4350 or 4400*/
+	uint32_t soc_alert_flag : 1;  /* 0 : nu-occur, 1: occur */
+	uint32_t volt_alert_flag : 1; /* 0 : nu-occur, 1: occur */
+	uint32_t flag_full_charge : 1; /* 0 : no , 1 : yes*/
+	uint32_t flag_chg_status : 1; /* 0 : discharging, 1: charging*/
+
+	int32_t irq_ctrl;
+
+	uint32_t is_FG_initialised;
+	int iocv_error_count;
+
+	int n_tem_poff;
+	int n_tem_poff_offset;
+	int l_tem_poff;
+	int l_tem_poff_offset;
+
+	/* previous battery voltage current*/
+	int p_batt_voltage;
+	int p_batt_current;
+};
+
+struct sm5703_platform_data {
+	int capacity_max;
+	int capacity_max_margin;
+	int capacity_min;
+	int capacity_calculation_type;
+	int fuel_alert_soc;
+	int fullsocthr;
+	int fg_irq;
+	int model_type;
+	unsigned long fg_irq_attr;
+
+	char *fuelgauge_name;
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	int num_age_step;
+	int age_step;
+	int age_data_length;
+	sec_age_data_t* age_data;
+#endif
+};
+
+struct sm5703_fuelgauge_data {
+	struct device           *dev;
+	struct i2c_client       *i2c;
+	struct mutex            fuelgauge_mutex;
+	struct sm5703_platform_data *pdata;
+	struct power_supply             psy_fg;
+	struct delayed_work isr_work;
+
+	int cable_type;
+	bool is_charging;
+
+	/* HW-dedicated fuel guage info structure
+	 * used in individual fuel gauge file only
+	 * (ex. dummy_fuelgauge.c)
+	 */
+	struct sm5703_fg_info	info;
+	struct battery_data_t	*battery_data;
+
+	bool is_fuel_alerted;
+	struct wake_lock fuel_alert_wake_lock;
+
+	unsigned int capacity_old;      /* only for atomic calculation */
+	unsigned int capacity_max;      /* only for dynamic calculation */
+	unsigned int standard_capacity;
+	
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	unsigned int chg_float_voltage; /* BATTERY_AGE_FORECAST */
+#endif
+
+	bool initial_update_of_soc;
+	struct mutex fg_lock;
+
+	/* register programming */
+	int reg_addr;
+	u8 reg_data[2];
+
+	unsigned int pre_soc;
+	int fg_irq;
+	int force_dec_mode;
+#ifdef USE_SUSPEND_LATE
+	bool	is_sleep_state;
+#endif
+};
+
+#endif // SM5703_FUELGAUGE_H
diff -Naur linux-3.18.14/drivers/battery_v2/include/fuelgauge/sm5703_fuelgauge_impl.h samsung/drivers/battery_v2/include/fuelgauge/sm5703_fuelgauge_impl.h
--- linux-3.18.14/drivers/battery_v2/include/fuelgauge/sm5703_fuelgauge_impl.h	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/include/fuelgauge/sm5703_fuelgauge_impl.h	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,134 @@
+/*
+ * drivers/battery/sm5703_fuelgauge-impl.h
+ *
+ * Header of SiliconMitus SM5703 Fuelgauge Driver Implementation
+ *
+ * Copyright (C) 2015 SiliconMitus
+ * Author: SW Jung
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ */
+
+#ifndef SM5703_FUELGAUGE_IMPL_H
+#define SM5703_FUELGAUGE_IMPL_H
+
+/* Definitions of SM5703 Fuelgauge Registers */
+// I2C Register
+#define SM5703_REG_DEVICE_ID                 0x00
+#define SM5703_REG_CNTL                      0x01
+#define SM5703_REG_INTFG                     0x02
+#define SM5703_REG_INTFG_MASK                0x03
+#define SM5703_REG_STATUS                    0x04
+#define SM5703_REG_SOC                       0x05
+#define SM5703_REG_OCV                       0x06
+#define SM5703_REG_VOLTAGE                   0x07
+#define SM5703_REG_CURRENT                   0x08
+#define SM5703_REG_TEMPERATURE               0x09
+#define SM5703_REG_FG_OP_STATUS              0x10
+#define SM5703_REG_PARAM_RUN_UPDATE          0x14
+#define SM5703_REG_IOCV_MAN                  0x2E
+#define SM5703_REG_END_V_IDX                 0x2F
+
+#define SM5703_REG_V_ALARM                   0x0C
+#define SM5703_REG_T_ALARM                   0x0D
+#define SM5703_REG_SOC_ALARM                 0x0E
+
+#define SM5703_REG_TOPOFFSOC                 0x12
+#define SM5703_REG_PARAM_CTRL                0x13
+#define SM5703_REG_PARAM_RUN_UPDATE          0x14
+#define SM5703_REG_VIT_PERIOD                0x1A
+#define SM5703_REG_MIX_RATE                  0x1B
+#define SM5703_REG_MIX_INIT_BLANK            0x1C
+
+//for cal
+#define SM5703_REG_VOLT_CAL         0x2B
+#define SM5703_REG_CURR_CAL         0x2C
+
+
+#define SM5703_REG_RCE0             0x20
+#define SM5703_REG_RCE1             0x21
+#define SM5703_REG_RCE2             0x22
+#define SM5703_REG_DTCD             0x23
+#define SM5703_REG_RS               0x24
+
+#define SM5703_REG_RS_MIX_FACTOR    0x25
+#define SM5703_REG_RS_MAX           0x26
+#define SM5703_REG_RS_MIN           0x27
+#define SM5703_REG_RS_MAN           0x29
+
+
+#define SM5703_REG_RS_TUNE          0x28
+#define SM5703_REG_CURRENT_EST      0x85
+#define SM5703_REG_CURRENT_ERR      0x86
+#define SM5703_REG_Q_EST            0x87
+
+
+#define SM5703_REG_IOCV_MAN         0x2E
+#define ENABLE_MANUAL_OCV           0x0400
+
+
+#define SM5703_FG_PARAM_UNLOCK_CODE     0x3700
+#define SM5703_FG_PARAM_LOCK_CODE     0x0000
+
+#define SM5703_FG_TABLE_LEN    0xF//real table length -1
+
+//start reg addr for table
+#define SM5703_REG_TABLE_START     0xA0
+
+#define SM5703_REG_IOCV_B_L_MIN		0x30
+#define SM5703_REG_IOCV_B_L_MAX		0x37
+#define SM5703_REG_IOCV_B_S_MIN		0x40
+#define SM5703_REG_IOCV_B_S_MAX		0x43
+
+#define SM5703_REG_MISC				0x90
+
+#define SM5703_FG_PARAM_UNLOCK_CODE     0x3700
+#define SM5703_FG_PARAM_LOCK_CODE     0x0000
+#define SM5703_FG_TABLE_LEN    0xF//real table length -1
+
+
+#define SW_RESET_CODE       0x0008
+#define RS_MAN_CNTL         0x0800
+
+// control register value
+#define ENABLE_MIX_MODE         0x8000
+#define ENABLE_TEMP_MEASURE     0x4000
+#define ENABLE_TOPOFF_SOC       0x2000
+#define ENABLE_MANUAL_OCV       0x0400
+#define ENABLE_RS_MAN_MODE      0x0800
+
+#define ENABLE_SOC_ALARM        0x0008
+#define ENABLE_T_H_ALARM        0x0004
+#define ENABLE_T_L_ALARM        0x0002
+#define ENABLE_V_ALARM          0x0001
+
+#define CNTL_REG_DEFAULT_VALUE  0x2008
+#define INIT_CHECK_MASK         0x00FF
+#define DISABLE_RE_INIT         0x0007
+
+
+#define TOPOFF_SOC_100   0x111
+#define TOPOFF_SOC_99   0x110
+#define TOPOFF_SOC_98   0x101
+#define TOPOFF_SOC_97   0x100
+#define TOPOFF_SOC_96   0x011
+#define TOPOFF_SOC_95   0x010
+#define TOPOFF_SOC_94   0x001
+#define TOPOFF_SOC_93   0x000
+
+#define ENABLE_L_SOC_INT  0x0008
+#define ENABLE_H_TEM_INT  0x0004
+#define ENABLE_L_TEM_INT  0x0002
+#define ENABLE_L_VOL_INT  0x0001
+
+
+
+
+#define FULL_SOC						100
+
+
+
+#endif // SM5703_FUELGAUGE_IMPL_H
diff -Naur linux-3.18.14/drivers/battery_v2/include/fuelgauge/sm5705_fuelgauge.h samsung/drivers/battery_v2/include/fuelgauge/sm5705_fuelgauge.h
--- linux-3.18.14/drivers/battery_v2/include/fuelgauge/sm5705_fuelgauge.h	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/include/fuelgauge/sm5705_fuelgauge.h	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,247 @@
+/*
+ * drivers/battery/sm5705_fuelgauge.h
+ *
+ * Header of SiliconMitus SM5705 Fuelgauge Driver
+ *
+ * Copyright (C) 2015 SiliconMitus
+ * Author: SW Jung
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ */
+
+#ifndef SM5705_FUELGAUGE_H
+#define SM5705_FUELGAUGE_H
+
+#include <linux/i2c.h>
+#include "../sec_charging_common.h"
+
+#ifdef CONFIG_DEBUG_FS
+#include <linux/debugfs.h>
+#endif /* #ifdef CONFIG_DEBUG_FS */
+
+#define FG_DRIVER_VER "0.0.0.1"
+
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+#define ENABLE_BATT_LONG_LIFE 1
+#endif
+
+struct battery_data_t {
+	const int battery_type; /* 4200 or 4350 or 4400*/
+	const int battery_table[3][16];
+	const int rce_value[3];
+	const int dtcd_value;
+	const int rs_value[4];
+	const int vit_period;
+	const int mix_value[2];
+	const int topoff_soc[2];
+	const int volt_cal;
+	const int curr_cal;
+	const int temp_std;
+	const int temp_offset;
+	const int temp_offset_cal;
+};
+
+struct sec_fg_info {
+	/* Device_id */
+	int device_id;
+	/* State Of Connect */
+	int online;
+	/* battery SOC (capacity) */
+	int batt_soc;
+	/* battery voltage */
+	int batt_voltage;
+	/* battery AvgVoltage */
+	int batt_avgvoltage;
+	/* battery OCV */
+	int batt_ocv;
+	/* Current */
+	int batt_current;
+	/* battery Avg Current */
+	int batt_avgcurrent;
+	/* battery SOC cycle */
+	int batt_soc_cycle;
+
+	struct battery_data_t *comp_pdata;
+
+	struct mutex param_lock;
+	/* copy from platform data /
+	 * DTS or update by shell script */
+
+	struct mutex io_lock;
+	struct device *dev;
+	int32_t temperature;; /* 0.1 deg C*/
+	int32_t temp_fg;; /* 0.1 deg C*/
+	/* register programming */
+	int reg_addr;
+	u8 reg_data[2];
+
+	int battery_table[3][16];
+#ifdef ENABLE_BATT_LONG_LIFE
+#ifdef CONFIG_BATTERY_AGE_FORECAST_DETACHABLE
+	int v_max_table[3];
+	int q_max_table[3];
+#else
+	int v_max_table[5];
+	int q_max_table[5];
+#endif
+	int v_max_now;
+	int q_max_now;
+#endif
+	int rce_value[3];
+	int dtcd_value;
+	int rs_value[5]; /*rs p_mix_factor n_mix_factor max min*/
+	int vit_period;
+	int mix_value[2]; /*mix_rate init_blank*/
+	int misc;
+
+	int enable_topoff_soc;
+	int topoff_soc;
+	int top_off;
+
+	int cycle_high_limit;
+	int cycle_low_limit;
+	int cycle_limit_cntl;
+
+	int enable_v_offset_cancel_p;
+	int enable_v_offset_cancel_n;
+	int v_offset_cancel_level;
+	int v_offset_cancel_mohm;
+
+	int volt_cal;
+	int curr_offset;
+	int p_curr_cal;
+	int n_curr_cal;
+	int curr_lcal_en;
+	int curr_lcal_0;
+	int curr_lcal_1;
+	int curr_lcal_2;
+	int en_auto_curr_offset;
+	int cntl_value;
+#ifdef ENABLE_FULL_OFFSET
+	int full_offset_margin;
+	int full_extra_offset;
+#endif
+
+	int temp_std;
+	int en_fg_temp_volcal;
+	int fg_temp_volcal_denom;
+	int fg_temp_volcal_fact;
+	int en_high_fg_temp_offset;
+	int high_fg_temp_offset_denom;
+	int high_fg_temp_offset_fact;
+	int en_low_fg_temp_offset;
+	int low_fg_temp_offset_denom;
+	int low_fg_temp_offset_fact;
+	int en_high_fg_temp_cal;
+	int high_fg_temp_p_cal_denom;
+	int high_fg_temp_p_cal_fact;
+	int high_fg_temp_n_cal_denom;
+	int high_fg_temp_n_cal_fact;
+	int en_low_fg_temp_cal;
+	int low_fg_temp_p_cal_denom;
+	int low_fg_temp_p_cal_fact;
+	int low_fg_temp_n_cal_denom;
+	int low_fg_temp_n_cal_fact;
+	int en_high_temp_cal;
+	int high_temp_p_cal_denom;
+	int high_temp_p_cal_fact;
+	int high_temp_n_cal_denom;
+	int high_temp_n_cal_fact;
+	int en_low_temp_cal;
+	int low_temp_p_cal_denom;
+	int low_temp_p_cal_fact;
+	int low_temp_n_cal_denom;
+	int low_temp_n_cal_fact;
+
+
+	int battery_type; /* 4200 or 4350 or 4400*/
+	int data_ver;
+	uint32_t soc_alert_flag : 1;  /* 0 : nu-occur, 1: occur */
+	uint32_t volt_alert_flag : 1; /* 0 : nu-occur, 1: occur */
+	uint32_t flag_full_charge : 1; /* 0 : no , 1 : yes*/
+	uint32_t flag_chg_status : 1; /* 0 : discharging, 1: charging*/
+	uint32_t flag_charge_health : 1; /* 0 : no , 1 : good*/
+
+	int32_t irq_ctrl;
+	int value_v_alarm;
+
+	uint32_t is_FG_initialised;
+	int iocv_error_count;
+
+	int n_tem_poff;
+	int n_tem_poff_offset;
+	int l_tem_poff;
+	int l_tem_poff_offset;
+
+	/* previous battery voltage current*/
+	int p_batt_voltage;
+	int p_batt_current;
+
+};
+
+struct sec_fuelgauge_info {
+	struct i2c_client		*client;
+	sec_battery_platform_data_t *pdata;
+	struct power_supply		psy_fg;
+	struct delayed_work isr_work;
+
+	int cable_type;
+	bool is_charging;
+	bool ta_exist;
+
+	/* HW-dedicated fuel guage info structure
+	 * used in individual fuel gauge file only
+	 * (ex. dummy_fuelgauge.c)
+	 */
+	struct sec_fg_info	info;
+
+	bool is_fuel_alerted;
+	bool volt_alert_flag;
+	struct wake_lock fuel_alert_wake_lock;
+
+	unsigned int capacity_old;	/* only for atomic calculation */
+	unsigned int capacity_max;	/* only for dynamic calculation */
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	unsigned int chg_full_soc; /* BATTERY_AGE_FORECAST */
+#endif
+
+	bool initial_update_of_soc;
+	struct mutex fg_lock;
+
+	/* register programming */
+	int reg_addr;
+	u8 reg_data[2];
+
+	int fg_irq;
+};
+
+ssize_t sm5705_fg_show_attrs(struct device *dev,
+				struct device_attribute *attr, char *buf);
+
+ssize_t sm5705_fg_store_attrs(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count);
+
+
+#ifdef CONFIG_OF
+extern void board_fuelgauge_init(struct sec_fuelgauge_info *fuelgauge);
+extern bool sec_bat_check_jig_status(void);
+#endif
+
+#define SM5705_FG_ATTR(_name)				\
+{							\
+	.attr = {.name = #_name, .mode = 0664},	\
+	.show = sm5705_fg_show_attrs,			\
+	.store = sm5705_fg_store_attrs,			\
+}
+
+enum {
+	FG_REG = 0,
+	FG_DATA,
+	FG_REGS,
+};
+
+#endif // SM5705_FUELGAUGE_H
diff -Naur linux-3.18.14/drivers/battery_v2/include/fuelgauge/sm5705_fuelgauge_impl.h samsung/drivers/battery_v2/include/fuelgauge/sm5705_fuelgauge_impl.h
--- linux-3.18.14/drivers/battery_v2/include/fuelgauge/sm5705_fuelgauge_impl.h	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/include/fuelgauge/sm5705_fuelgauge_impl.h	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,136 @@
+/*
+ * drivers/battery/sm5705_fuelgauge-impl.h
+ *
+ * Header of SiliconMitus SM5705 Fuelgauge Driver Implementation
+ *
+ * Copyright (C) 2015 SiliconMitus
+ * Author: SW Jung
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ */
+
+#ifndef SM5705_FUELGAUGE_IMPL_H
+#define SM5705_FUELGAUGE_IMPL_H
+
+/* Definitions of SM5705 Fuelgauge Registers */
+// I2C Register
+#define SM5705_REG_DEVICE_ID                 0x00
+#define SM5705_REG_CNTL                      0x01
+#define SM5705_REG_INTFG                     0x02
+#define SM5705_REG_INTFG_MASK                0x03
+#define SM5705_REG_STATUS                    0x04
+#define SM5705_REG_SOC                       0x05
+#define SM5705_REG_OCV                       0x06
+#define SM5705_REG_VOLTAGE                   0x07
+#define SM5705_REG_CURRENT                   0x08
+#define SM5705_REG_TEMPERATURE               0x09
+#define SM5705_REG_SOC_CYCLE                 0x0A
+
+#define SM5705_REG_V_ALARM                   0x0C
+#define SM5705_REG_T_ALARM                   0x0D
+#define SM5705_REG_SOC_ALARM                 0x0E
+#define SM5705_REG_FG_OP_STATUS              0x10
+#define SM5705_REG_TOPOFFSOC                 0x12
+#define SM5705_REG_PARAM_CTRL                0x13
+#define SM5705_REG_PARAM_RUN_UPDATE          0x14
+#define SM5705_REG_SOC_CYCLE_CFG             0x15
+#define SM5705_REG_VIT_PERIOD                0x1A
+#define SM5705_REG_MIX_RATE                  0x1B
+#define SM5705_REG_MIX_INIT_BLANK            0x1C
+#define SM5705_REG_RESERVED                  0x1F
+
+#define SM5705_REG_RCE0             0x20
+#define SM5705_REG_RCE1             0x21
+#define SM5705_REG_RCE2             0x22
+#define SM5705_REG_DTCD             0x23
+#define SM5705_REG_AUTO_RS_MAN               0x24
+#define SM5705_REG_RS_MIX_FACTOR    0x25
+#define SM5705_REG_RS_MAX           0x26
+#define SM5705_REG_RS_MIN           0x27
+#define SM5705_REG_RS_TUNE          0x28
+#define SM5705_REG_RS_MAN           0x29
+
+//for cal
+#define SM5705_REG_CURR_CAL         0x2C
+#define SM5705_REG_IOCV_MAN                  0x2E
+#define SM5705_REG_END_V_IDX                 0x2F
+
+#define SM5705_REG_VOLT_CAL         0x50
+#define SM5705_REG_CURR_OFF         0x51
+#define SM5705_REG_CURR_P_SLOPE         0x52
+#define SM5705_REG_CURR_N_SLOPE         0x53
+#define SM5705_REG_CURRLCAL_0		0x54
+#define SM5705_REG_CURRLCAL_1		0x55
+#define SM5705_REG_CURRLCAL_2		0x56
+
+//for debug
+#define SM5705_REG_OCV_STATE        0x80
+#define SM5705_REG_CURRENT_EST      0x85
+#define SM5705_REG_CURRENT_ERR      0x86
+#define SM5705_REG_Q_EST            0x87
+#define SM5705_AUX_STAT             0x94
+
+#define SM5705_REG_MISC			0x90
+#define SM5705_REG_RESET		0x91
+
+
+#define SM5705_FG_INIT_MARK	        0xA000
+#define SM5705_FG_PARAM_UNLOCK_CODE	0x3700
+#define SM5705_FG_PARAM_LOCK_CODE	0x0000
+#define SM5705_FG_TABLE_LEN			0xF//real table length -1
+
+//start reg addr for table
+#define SM5705_REG_TABLE_START		0xA0
+
+#define SM5705_REG_IOCV_B_L_MIN		0x30
+#define SM5705_REG_IOCV_B_L_MAX		0x35
+#define SM5705_REG_IOCV_B_C_MIN		0x36
+#define SM5705_REG_IOCV_B_C_MAX		0x3B
+#define SM5705_REG_IOCI_B_L_MIN		0x40
+#define SM5705_REG_IOCI_B_L_MAX		0x45
+#define SM5705_REG_IOCI_B_C_MIN		0x46
+#define SM5705_REG_IOCI_B_C_MAX		0x4B
+
+#define SW_RESET_CODE			0x00A6
+#define SW_RESET_OTP_CODE		0x01A6
+#define RS_MAN_CNTL				0x0800
+
+// control register value
+#define ENABLE_MIX_MODE         0x8000
+#define ENABLE_TEMP_MEASURE     0x4000
+#define ENABLE_TOPOFF_SOC       0x2000
+#define ENABLE_RS_MAN_MODE      0x0800
+#define ENABLE_MANUAL_OCV       0x0400
+#define ENABLE_MODE_nENQ4       0x0200
+
+#define ENABLE_SOC_ALARM        0x0008
+#define ENABLE_T_H_ALARM        0x0004
+#define ENABLE_T_L_ALARM        0x0002
+#define ENABLE_V_ALARM          0x0001
+
+#define CNTL_REG_DEFAULT_VALUE  0x2008
+#define INIT_CHECK_MASK         0x0010
+#define DISABLE_RE_INIT         0x0010
+#define SM5705_JIG_CONNECTED	0x0001
+#define SM5705_BATTERY_VERSION	0x00F0
+
+#define TOPOFF_SOC_97    0x111
+#define TOPOFF_SOC_96    0x110
+#define TOPOFF_SOC_95    0x101
+#define TOPOFF_SOC_94    0x100
+#define TOPOFF_SOC_93    0x011
+#define TOPOFF_SOC_92    0x010
+#define TOPOFF_SOC_91    0x001
+#define TOPOFF_SOC_90    0x000
+
+#define MASK_L_SOC_INT  0x0008
+#define MASK_H_TEM_INT  0x0004
+#define MASK_L_TEM_INT  0x0002
+#define MASK_L_VOL_INT  0x0001
+
+#define FULL_SOC						100
+
+#endif // SM5705_FUELGAUGE_IMPL_H
diff -Naur linux-3.18.14/drivers/battery_v2/include/sec_adc.h samsung/drivers/battery_v2/include/sec_adc.h
--- linux-3.18.14/drivers/battery_v2/include/sec_adc.h	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/include/sec_adc.h	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,32 @@
+/*
+ * sec_adc.h
+ * Samsung Mobile Charger Header
+ *
+ * Copyright (C) 2012 Samsung Electronics, Inc.
+ *
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __SEC_ADC_H
+#define __SEC_ADC_H __FILE__
+
+#include <linux/iio/consumer.h>
+#include "sec_battery.h"
+#include "sec_charging_common.h"
+
+#define VENDOR_UNKNOWN 0
+#define VENDOR_LSI 1
+#define VENDOR_QCOM 2
+#define RETRY_CNT 3
+
+#endif /* __SEC_ADC_H */
+
diff -Naur linux-3.18.14/drivers/battery_v2/include/sec_battery.h samsung/drivers/battery_v2/include/sec_battery.h
--- linux-3.18.14/drivers/battery_v2/include/sec_battery.h	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/include/sec_battery.h	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,630 @@
+/*
+ * sec_battery.h
+ * Samsung Mobile Battery Header
+ *
+ *
+ * Copyright (C) 2012 Samsung Electronics, Inc.
+ *
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __SEC_BATTERY_H
+#define __SEC_BATTERY_H __FILE__
+
+#include "sec_charging_common.h"
+#include <linux/of_gpio.h>
+#include <linux/alarmtimer.h>
+#include <linux/wakelock.h>
+#include <linux/workqueue.h>
+#include <linux/proc_fs.h>
+#include <linux/jiffies.h>
+
+#if defined(CONFIG_USB_TYPEC_MANAGER_NOTIFIER)
+#include <linux/usb/manager/usb_typec_manager_notifier.h>
+#else
+#if defined(CONFIG_CCIC_NOTIFIER)
+#include <linux/ccic/ccic_notifier.h>
+#endif /* CONFIG_CCIC_NOTIFIER */
+#if defined(CONFIG_MUIC_NOTIFIER)
+#include <linux/muic/muic.h>
+#include <linux/muic/muic_notifier.h>
+#endif
+#endif
+
+#if defined(CONFIG_BATTERY_NOTIFIER)
+#include <linux/battery/battery_notifier.h>
+#endif
+#if defined(CONFIG_VBUS_NOTIFIER)
+#include <linux/vbus_notifier.h>
+#endif
+#if defined(CONFIG_BATTERY_CISD)
+#include "sec_cisd.h"
+#endif
+#include <linux/sec_batt.h>
+
+#define SEC_BAT_CURRENT_EVENT_NONE			0x0000
+#define SEC_BAT_CURRENT_EVENT_AFC			0x0001
+#define SEC_BAT_CURRENT_EVENT_CHARGE_DISABLE		0x0002
+#define SEC_BAT_CURRENT_EVENT_SKIP_HEATING_CONTROL	0x0004
+#define SEC_BAT_CURRENT_EVENT_LOW_TEMP_SWELLING		0x0010
+#define SEC_BAT_CURRENT_EVENT_HIGH_TEMP_SWELLING	0x0020
+#define SEC_BAT_CURRENT_EVENT_BLOCK_CHG_IN_SWELLLING	0x0040
+#define SEC_BAT_CURRENT_EVENT_LOW_TEMP		0x0080
+#define SEC_BAT_CURRENT_EVENT_USB_SUPER			0x0100
+#define SEC_BAT_CURRENT_EVENT_CHG_LIMIT			0x0200
+#define SEC_BAT_CURRENT_EVENT_VBAT_OVP			0x1000
+#define SEC_BAT_CURRENT_EVENT_VSYS_OVP			0x2000
+#if defined(CONFIG_ENABLE_100MA_CHARGING_BEFORE_USB_CONFIGURED)
+#define SEC_BAT_CURRENT_EVENT_USB_100MA			0x0400
+#else
+#define SEC_BAT_CURRENT_EVENT_USB_100MA			0x0000
+#endif
+#define SEC_BAT_CURRENT_EVENT_HV_DISABLE		0x10000
+
+#define SIOP_EVENT_NONE 	0x0000
+#define SIOP_EVENT_WPC_CALL 	0x0001
+
+#if defined(CONFIG_CHARGING_VZWCONCEPT)
+#define STORE_MODE_CHARGING_MAX 35
+#define STORE_MODE_CHARGING_MIN 30
+#else
+#if defined(CONFIG_SEC_FACTORY)
+#define STORE_MODE_CHARGING_MAX 80
+#else
+#define STORE_MODE_CHARGING_MAX 70
+#endif
+#define STORE_MODE_CHARGING_MIN 60
+#endif
+
+#define ADC_CH_COUNT		10
+#define ADC_SAMPLE_COUNT	10
+
+#define DEFAULT_HEALTH_CHECK_COUNT	5
+#define TEMP_HIGHLIMIT_DEFAULT	2000
+
+#define SIOP_INPUT_LIMIT_CURRENT                1200
+#define SIOP_CHARGING_LIMIT_CURRENT             1000
+#define SIOP_WIRELESS_INPUT_LIMIT_CURRENT       530
+#define SIOP_WIRELESS_CHARGING_LIMIT_CURRENT    780
+#define SIOP_HV_WIRELESS_INPUT_LIMIT_CURRENT	700
+#define SIOP_HV_WIRELESS_CHARGING_LIMIT_CURRENT	600
+#define SIOP_HV_INPUT_LIMIT_CURRENT				1200
+#define SIOP_HV_CHARGING_LIMIT_CURRENT			1000
+#define SIOP_HV_12V_INPUT_LIMIT_CURRENT			535
+#define SIOP_HV_12V_CHARGING_LIMIT_CURRENT		1000
+
+#define BATT_MISC_EVENT_UNDEFINED_RANGE_TYPE	0x00000001
+#define BATT_MISC_EVENT_WIRELESS_BACKPACK_TYPE	0x00000002
+#define BATT_MISC_EVENT_TIMEOUT_OPEN_TYPE	0x00000004
+#define BATT_MISC_EVENT_BATT_RESET_SOC		0x00000008
+#define BATT_MISC_EVENT_UNDEFINED_RANGE_POGO    0x00000010
+
+#define SEC_INPUT_VOLTAGE_5V	5
+#define SEC_INPUT_VOLTAGE_9V	9
+#define SEC_INPUT_VOLTAGE_10V	10
+#define SEC_INPUT_VOLTAGE_12V	12
+
+#if defined(CONFIG_CCIC_NOTIFIER)
+struct sec_bat_pdic_info {
+	unsigned int input_voltage;
+	unsigned int input_current;
+	unsigned int pdo_index;
+};
+
+struct sec_bat_pdic_list {
+	struct sec_bat_pdic_info pd_info[8]; /* 5V ~ 12V */
+	unsigned int now_pd_index;
+	unsigned int max_pd_count;
+};
+#endif
+
+#if defined(CONFIG_BATTERY_SWELLING)
+enum swelling_mode_state {
+	SWELLING_MODE_NONE = 0,
+	SWELLING_MODE_CHARGING,
+	SWELLING_MODE_FULL,
+};
+#endif
+
+struct adc_sample_info {
+	unsigned int cnt;
+	int total_adc;
+	int average_adc;
+	int adc_arr[ADC_SAMPLE_COUNT];
+	int index;
+};
+
+struct sec_battery_info {
+	struct device *dev;
+	sec_battery_platform_data_t *pdata;
+
+	/* power supply used in Android */
+	struct power_supply psy_bat;
+	struct power_supply psy_usb;
+	struct power_supply psy_ac;
+	struct power_supply psy_wireless;
+	struct power_supply psy_ps;
+#if defined(CONFIG_USE_POGO)
+	struct power_supply psy_pogo;
+#endif
+	unsigned int irq;
+
+	int pd_usb_attached;
+#if defined(CONFIG_USB_TYPEC_MANAGER_NOTIFIER)
+	struct notifier_block usb_typec_nb;
+#else
+#if defined(CONFIG_CCIC_NOTIFIER)
+	struct notifier_block pdic_nb;
+#endif
+#if defined(CONFIG_MUIC_NOTIFIER)
+	struct notifier_block batt_nb;
+#endif
+#endif
+	bool pdic_attach;
+	bool pdic_ps_rdy;
+	bool rp_attach;
+#if defined(CONFIG_CCIC_NOTIFIER)
+	struct pdic_notifier_struct pdic_info;
+	struct sec_bat_pdic_list pd_list;
+#endif
+#if defined(CONFIG_VBUS_NOTIFIER)
+	struct notifier_block vbus_nb;
+	int muic_vbus_status;
+#endif
+
+	bool is_sysovlo;
+	bool is_vbatovlo;
+
+	bool safety_timer_set;
+	bool lcd_status;
+	bool skip_swelling;
+
+	int status;
+	int health;
+	bool present;
+
+	int voltage_now;		/* cell voltage (mV) */
+	int voltage_avg;		/* average voltage (mV) */
+	int voltage_ocv;		/* open circuit voltage (mV) */
+	int current_now;		/* current (mA) */
+	int inbat_adc;                  /* inbat adc */
+	int current_avg;		/* average current (mA) */
+	int current_max;		/* input current limit (mA) */
+	int current_adc;
+
+	unsigned int capacity;			/* SOC (%) */
+	unsigned int input_voltage;		/* CHGIN/WCIN input voltage (V) */
+	unsigned int charge_power;		/* charge power (mW) */
+	unsigned int max_charge_power;		/* max charge power (mW) */
+	unsigned int pd_max_charge_power;		/* max charge power for pd (mW) */
+	unsigned int aicl_current;
+
+	struct mutex adclock;
+	struct adc_sample_info	adc_sample[ADC_CH_COUNT];
+
+	/* keep awake until monitor is done */
+	struct wake_lock monitor_wake_lock;
+	struct workqueue_struct *monitor_wqueue;
+	struct delayed_work monitor_work;
+#ifdef CONFIG_SAMSUNG_BATTERY_FACTORY
+	struct wake_lock lpm_wake_lock;
+#endif
+	unsigned int polling_count;
+	unsigned int polling_time;
+	bool polling_in_sleep;
+	bool polling_short;
+
+	struct delayed_work polling_work;
+	struct alarm polling_alarm;
+	ktime_t last_poll_time;
+
+#if defined(CONFIG_BATTERY_CISD)
+	struct cisd cisd;
+#endif
+
+	/* battery check */
+	unsigned int check_count;
+	/* ADC check */
+	unsigned int check_adc_count;
+	unsigned int check_adc_value;
+
+	/* health change check*/
+	bool health_change;
+	/* ovp-uvlo health check */
+	int health_check_count;
+
+	/* time check */
+	unsigned long charging_start_time;
+	unsigned long charging_passed_time;
+	unsigned long charging_next_time;
+	unsigned long charging_fullcharged_time;
+
+	unsigned long wc_heating_start_time;
+	unsigned long wc_heating_passed_time;
+	unsigned int wc_heat_limit;
+
+	/* chg temperature check */
+	unsigned int chg_limit;
+	unsigned int chg_limit_recovery_cable;
+	unsigned int vbus_chg_by_siop;
+	unsigned int mix_limit;
+
+	/* temperature check */
+	int temperature;	/* battery temperature */
+	int temper_amb;		/* target temperature */
+	int usb_temp;
+	int chg_temp;		/* charger temperature */
+	int wpc_temp;
+	int slave_chg_temp;
+
+	int temp_adc;
+	int temp_ambient_adc;
+	int chg_temp_adc;
+	int wpc_temp_adc;
+	int slave_chg_temp_adc;
+	int usb_temp_adc;
+
+	int temp_highlimit_threshold;
+	int temp_highlimit_recovery;
+	int temp_high_threshold;
+	int temp_high_recovery;
+	int temp_low_threshold;
+	int temp_low_recovery;
+
+	unsigned int temp_highlimit_cnt;
+	unsigned int temp_high_cnt;
+	unsigned int temp_low_cnt;
+	unsigned int temp_recover_cnt;
+
+	/* charging */
+	unsigned int charging_mode;
+	bool is_recharging;
+	int wdt_kick_disable;
+
+	bool is_jig_on;
+	int cable_type;
+	int muic_cable_type;
+	int extended_cable_type;
+
+	struct wake_lock cable_wake_lock;
+	struct delayed_work cable_work;
+	struct wake_lock vbus_wake_lock;
+	struct delayed_work siop_work;
+	struct wake_lock siop_wake_lock;
+	struct wake_lock afc_wake_lock;
+	struct delayed_work afc_work;
+#if defined(CONFIG_WIRELESS_FIRMWARE_UPDATE)
+	struct delayed_work update_work;
+	struct delayed_work fw_init_work;
+#endif
+	struct delayed_work siop_event_work;
+	struct wake_lock siop_event_wake_lock;
+	struct delayed_work siop_level_work;
+	struct wake_lock siop_level_wake_lock;
+	struct delayed_work wc_headroom_work;
+	struct wake_lock wc_headroom_wake_lock;
+#if defined(CONFIG_UPDATE_BATTERY_DATA)
+	struct delayed_work batt_data_work;
+	struct wake_lock batt_data_wake_lock;
+	char *data_path;
+#endif
+	struct delayed_work init_chg_work;
+
+	char batt_type[48];
+	unsigned int full_check_cnt;
+	unsigned int recharge_check_cnt;
+
+	struct mutex iolock;
+	int input_current;
+	int charging_current;
+	int topoff_current;
+	int wpc_vout_level;
+	unsigned int current_event;
+
+	/* wireless charging enable */
+	int wc_enable;
+	int wc_enable_cnt;
+	int wc_enable_cnt_value;
+	int wc_status;
+	bool wc_cv_mode;
+	bool wc_pack_max_curr;
+
+	int wire_status;
+
+	/* pogo status */
+	int pogo_status;
+
+	/* wearable charging */
+	int ps_status;
+	int ps_enable;
+
+	/* test mode */
+	int test_mode;
+	bool factory_mode;
+	bool store_mode;
+	bool slate_mode;
+
+	/* MTBF test for CMCC */
+	bool is_hc_usb;
+
+	int siop_level;
+	int siop_event;
+	int siop_prev_event;
+	int stability_test;
+	int eng_not_full_status;
+
+	bool skip_chg_temp_check;
+	bool skip_wpc_temp_check;
+	bool wpc_temp_mode;
+	bool charging_block;
+#if defined(CONFIG_BATTERY_SWELLING)
+	unsigned int swelling_mode;
+	int swelling_full_check_cnt;
+#endif
+#if defined(CONFIG_AFC_CHARGER_MODE)
+	char *hv_chg_name;
+#endif
+#if defined(CONFIG_CALC_TIME_TO_FULL)
+	int timetofull;
+	bool complete_timetofull;
+	struct delayed_work timetofull_work;
+#endif
+	struct delayed_work slowcharging_work;
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	int batt_cycle;
+#endif
+#if defined(CONFIG_DCM_JPN_CONCEPT_FG_CYCLE_CHECK)
+	int fg_cycle_check_value;
+#endif
+#if defined(CONFIG_STEP_CHARGING)
+	unsigned int step_charging_type;
+	unsigned int step_charging_charge_power;
+	int step_charging_status;
+	int step_charging_step;
+#else
+	unsigned int base_charge_power;
+#endif
+	unsigned int pd_current_efficiency;
+	unsigned int prepare_afc_delay;
+
+	struct mutex misclock;
+	unsigned int misc_event;
+	unsigned int prev_misc_event;
+	struct delayed_work misc_event_work;
+	struct wake_lock misc_event_wake_lock;
+	struct mutex batt_handlelock;
+	struct mutex current_eventlock;
+
+	bool stop_timer;
+	unsigned long prev_safety_time;
+	unsigned long expired_time;
+	unsigned long cal_safety_time;
+
+	bool block_water_event;
+	int water_det;
+};
+
+ssize_t sec_bat_show_attrs(struct device *dev,
+				struct device_attribute *attr, char *buf);
+
+ssize_t sec_bat_store_attrs(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count);
+
+#define SEC_BATTERY_ATTR(_name)						\
+{									\
+	.attr = {.name = #_name, .mode = 0664},	\
+	.show = sec_bat_show_attrs,					\
+	.store = sec_bat_store_attrs,					\
+}
+
+/* event check */
+#define EVENT_NONE				(0)
+#define EVENT_2G_CALL			(0x1 << 0)
+#define EVENT_3G_CALL			(0x1 << 1)
+#define EVENT_MUSIC				(0x1 << 2)
+#define EVENT_VIDEO				(0x1 << 3)
+#define EVENT_BROWSER			(0x1 << 4)
+#define EVENT_HOTSPOT			(0x1 << 5)
+#define EVENT_CAMERA			(0x1 << 6)
+#define EVENT_CAMCORDER			(0x1 << 7)
+#define EVENT_DATA_CALL			(0x1 << 8)
+#define EVENT_WIFI				(0x1 << 9)
+#define EVENT_WIBRO				(0x1 << 10)
+#define EVENT_LTE				(0x1 << 11)
+#define EVENT_LCD			(0x1 << 12)
+#define EVENT_GPS			(0x1 << 13)
+
+enum {
+	BATT_RESET_SOC = 0,
+	BATT_READ_RAW_SOC,
+	BATT_READ_ADJ_SOC,
+	BATT_TYPE,
+	BATT_VFOCV,
+	BATT_VOL_ADC,
+	BATT_VOL_ADC_CAL,
+	BATT_VOL_AVER,
+	BATT_VOL_ADC_AVER,
+	BATT_CURRENT_UA_NOW,
+	BATT_CURRENT_UA_AVG,
+	BATT_FILTER_CFG,
+	BATT_TEMP,
+	BATT_TEMP_ADC,
+	BATT_TEMP_AVER,
+	BATT_TEMP_ADC_AVER,
+	USB_TEMP,
+	USB_TEMP_ADC,
+	BATT_CHG_TEMP,
+	BATT_CHG_TEMP_ADC,
+	BATT_SLAVE_CHG_TEMP,
+	BATT_SLAVE_CHG_TEMP_ADC,
+	BATT_VF_ADC,
+	BATT_SLATE_MODE,
+
+	BATT_LP_CHARGING,
+	SIOP_ACTIVATED,
+	SIOP_LEVEL,
+	SIOP_EVENT,
+	BATT_CHARGING_SOURCE,
+	FG_REG_DUMP,
+	FG_RESET_CAP,
+	FG_CAPACITY,
+	FG_ASOC,
+	AUTH,
+	CHG_CURRENT_ADC,
+	WC_ADC,
+	WC_STATUS,
+	WC_ENABLE,
+	WC_CONTROL,
+	WC_CONTROL_CNT,
+	HV_CHARGER_STATUS,
+	HV_WC_CHARGER_STATUS,
+	HV_CHARGER_SET,
+	FACTORY_MODE,
+	STORE_MODE,
+	UPDATE,
+	TEST_MODE,
+
+	BATT_EVENT_CALL,
+	BATT_EVENT_2G_CALL,
+	BATT_EVENT_TALK_GSM,
+	BATT_EVENT_3G_CALL,
+	BATT_EVENT_TALK_WCDMA,
+	BATT_EVENT_MUSIC,
+	BATT_EVENT_VIDEO,
+	BATT_EVENT_BROWSER,
+	BATT_EVENT_HOTSPOT,
+	BATT_EVENT_CAMERA,
+	BATT_EVENT_CAMCORDER,
+	BATT_EVENT_DATA_CALL,
+	BATT_EVENT_WIFI,
+	BATT_EVENT_WIBRO,
+	BATT_EVENT_LTE,
+	BATT_EVENT_LCD,
+	BATT_EVENT_GPS,
+	BATT_EVENT,
+	BATT_TEMP_TABLE,
+	BATT_HIGH_CURRENT_USB,
+#if defined(CONFIG_SAMSUNG_BATTERY_ENG_TEST)
+	BATT_TEST_CHARGE_CURRENT,
+#endif
+	BATT_STABILITY_TEST,
+	BATT_CAPACITY_MAX,
+	BATT_INBAT_VOLTAGE,
+	BATT_INBAT_VOLTAGE_OCV,
+	BATT_INBAT_VOLTAGE_ADC,
+	CHECK_SLAVE_CHG,
+	BATT_INBAT_WIRELESS_CS100,
+	HMT_TA_CONNECTED,
+	HMT_TA_CHARGE,
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	FG_CYCLE,
+	FG_FULL_VOLTAGE,
+	FG_FULLCAPNOM,
+	BATTERY_CYCLE,
+#if defined(CONFIG_BATTERY_AGE_FORECAST_DETACHABLE)
+	BATT_AFTER_MANUFACTURED,
+#endif
+#endif
+#if defined(CONFIG_DCM_JPN_CONCEPT_FG_CYCLE_CHECK)
+	FG_CYCLE_CHECK_VALUE,
+#endif
+	BATT_WPC_TEMP,
+	BATT_WPC_TEMP_ADC,
+#if defined(CONFIG_WIRELESS_FIRMWARE_UPDATE)
+	BATT_WIRELESS_FIRMWARE_UPDATE,
+	BATT_WIRELESS_OTP_FIRMWARE_RESULT,
+	BATT_WIRELESS_IC_GRADE,
+	BATT_WIRELESS_FIRMWARE_VER_BIN,
+	BATT_WIRELESS_FIRMWARE_VER,
+	BATT_WIRELESS_TX_FIRMWARE_RESULT,
+	BATT_WIRELESS_TX_FIRMWARE_VER,
+	BATT_TX_STATUS,
+#endif
+	BATT_WIRELESS_VOUT,
+	BATT_WIRELESS_VRCT,
+	BATT_HV_WIRELESS_STATUS,
+	BATT_HV_WIRELESS_PAD_CTRL,
+	BATT_WIRELESS_OP_FREQ,
+	BATT_WIRELESS_CMD_INFO,
+	BATT_TUNE_FLOAT_VOLTAGE,
+	BATT_TUNE_INPUT_CHARGE_CURRENT,
+	BATT_TUNE_FAST_CHARGE_CURRENT,
+	BATT_TUNE_UI_TERM_CURRENT_1ST,
+	BATT_TUNE_UI_TERM_CURRENT_2ND,
+	BATT_TUNE_TEMP_HIGH_NORMAL,
+	BATT_TUNE_TEMP_HIGH_REC_NORMAL,
+	BATT_TUNE_TEMP_LOW_NORMAL,
+	BATT_TUNE_TEMP_LOW_REC_NORMAL,
+	BATT_TUNE_CHG_TEMP_HIGH,
+	BATT_TUNE_CHG_TEMP_REC,
+	BATT_TUNE_CHG_LIMMIT_CURRENT,
+	BATT_TUNE_COIL_TEMP_HIGH,
+	BATT_TUNE_COIL_TEMP_REC,
+	BATT_TUNE_COIL_LIMMIT_CURRENT,
+
+#if defined(CONFIG_UPDATE_BATTERY_DATA)
+	BATT_UPDATE_DATA,
+#endif
+
+	BATT_MISC_EVENT,
+	BATT_EXT_DEV_CHG,
+	CISD_FULLCAPREP_MAX,
+#if defined(CONFIG_BATTERY_CISD)
+	CISD_DATA,
+	CISD_DATA_JSON,
+	CISD_WIRE_COUNT,
+	CISD_DATA_EFS_PATH,
+#endif
+	BATT_WDT_CONTROL,
+	BATT_SWELLING_CONTROL,
+	SAFETY_TIMER_SET,
+	SAFETY_TIMER_INFO,
+	MODE,
+	CHECK_PS_READY,
+	FACTORY_MODE_RELIEVE,
+	FACTORY_MODE_BYPASS,
+	NORMAL_MODE_BYPASS,
+	FACTORY_VOLTAGE_REGULATION,
+	FACTORY_MODE_DISABLE,
+	BATT_PRESENT,
+};
+
+enum {
+	EXT_DEV_NONE = 0,
+	EXT_DEV_GAMEPAD_CHG,
+	EXT_DEV_GAMEPAD_OTG,
+};
+
+extern void select_pdo(int num);
+#ifdef CONFIG_OF
+extern int adc_read(struct sec_battery_info *battery, int channel);
+extern void adc_init(struct platform_device *pdev, struct sec_battery_info *battery);
+extern void adc_exit(struct sec_battery_info *battery);
+#endif
+
+#if defined(CONFIG_STEP_CHARGING)
+extern void sec_bat_reset_step_charging(struct sec_battery_info *battery);
+extern void sec_step_charging_init(struct sec_battery_info *battery, struct device *dev);
+extern bool sec_bat_check_step_charging(struct sec_battery_info *battery);
+#endif
+
+#if defined(CONFIG_BATTERY_CISD)
+extern bool sec_bat_cisd_check(struct sec_battery_info *battery);
+extern void sec_battery_cisd_init(struct sec_battery_info *battery);
+#endif
+
+#if defined(CONFIG_UPDATE_BATTERY_DATA)
+extern int sec_battery_update_data(const char* file_path);
+#endif
+
+#endif /* __SEC_BATTERY_H */
diff -Naur linux-3.18.14/drivers/battery_v2/include/sec_charging_common.h samsung/drivers/battery_v2/include/sec_charging_common.h
--- linux-3.18.14/drivers/battery_v2/include/sec_charging_common.h	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/include/sec_charging_common.h	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,1060 @@
+/*
+ * sec_charging_common.h
+ * Samsung Mobile Charging Common Header
+ *
+ * Copyright (C) 2012 Samsung Electronics, Inc.
+ *
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __SEC_CHARGING_COMMON_H
+#define __SEC_CHARGING_COMMON_H __FILE__
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+#include <linux/power_supply.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+
+/* definitions */
+#define	SEC_SIZEOF_POWER_SUPPLY_TYPE	POWER_SUPPLY_TYPE_MAX
+
+enum power_supply_ext_property {
+	POWER_SUPPLY_EXT_PROP_CHECK_SLAVE_I2C = POWER_SUPPLY_PROP_MAX,
+	POWER_SUPPLY_EXT_PROP_MULTI_CHARGER_MODE,
+	POWER_SUPPLY_EXT_PROP_WIRELESS_OP_FREQ,
+	POWER_SUPPLY_EXT_PROP_WIRELESS_TX_CMD,
+	POWER_SUPPLY_EXT_PROP_WIRELESS_TX_VAL,
+	POWER_SUPPLY_EXT_PROP_AICL_CURRENT,
+	POWER_SUPPLY_EXT_PROP_CHECK_MULTI_CHARGE,
+	POWER_SUPPLY_EXT_PROP_CHIP_ID,
+	POWER_SUPPLY_EXT_PROP_SYSOVLO,
+	POWER_SUPPLY_EXT_PROP_VBAT_OVP,
+	POWER_SUPPLY_EXT_PROP_INBAT_VOLTAGE_FGSRC_SWITCHING,
+	POWER_SUPPLY_EXT_PROP_USB_CONFIGURE,
+	POWER_SUPPLY_EXT_PROP_WATER_DETECT,
+	POWER_SUPPLY_EXT_PROP_SURGE,
+	POWER_SUPPLY_EXT_PROP_FUELGAUGE_RESET,
+	POWER_SUPPLY_EXT_PROP_FACTORY_VOLTAGE_REGULATION,
+	POWER_SUPPLY_EXT_PROP_DISABLE_FACTORY_MODE,
+	POWER_SUPPLY_EXT_PROP_ANDIG_IVR_SWITCH,
+	POWER_SUPPLY_EXT_PROP_FUELGAUGE_FACTORY,
+	POWER_SUPPLY_EXT_PROP_CURRENT_MEASURE,
+	POWER_SUPPLY_EXT_PROP_HV_DISABLE,
+#if defined(CONFIG_FUELGAUGE_S2MU004) || defined(CONFIG_FUELGAUGE_S2MU005)
+	POWER_SUPPLY_EXT_PROP_UPDATE_BATTERY_DATA,
+#endif
+};
+
+enum sec_battery_usb_conf {
+	USB_CURRENT_UNCONFIGURED = 100,
+	USB_CURRENT_HIGH_SPEED = 500,
+	USB_CURRENT_SUPER_SPEED = 900,
+};
+
+enum sec_battery_rp_curr {
+	RP_CURRENT_RP1 = 500,
+	RP_CURRENT_RP2 = 1500,
+	RP_CURRENT_RP3 = 3000,
+};
+
+enum power_supply_ext_health {
+	POWER_SUPPLY_HEALTH_VSYS_OVP = POWER_SUPPLY_HEALTH_MAX,
+	POWER_SUPPLY_HEALTH_VBAT_OVP,
+};
+
+enum sec_battery_voltage_mode {
+	/* average voltage */
+	SEC_BATTERY_VOLTAGE_AVERAGE = 0,
+	/* open circuit voltage */
+	SEC_BATTERY_VOLTAGE_OCV,
+};
+
+enum sec_battery_current_mode {
+	/* uA */
+	SEC_BATTERY_CURRENT_UA = 0,
+	/* mA */
+	SEC_BATTERY_CURRENT_MA,
+};
+
+enum sec_battery_capacity_mode {
+	/* designed capacity */
+	SEC_BATTERY_CAPACITY_DESIGNED = 0,
+	/* absolute capacity by fuel gauge */
+	SEC_BATTERY_CAPACITY_ABSOLUTE,
+	/* temperary capacity in the time */
+	SEC_BATTERY_CAPACITY_TEMPERARY,
+	/* current capacity now */
+	SEC_BATTERY_CAPACITY_CURRENT,
+	/* cell aging information */
+	SEC_BATTERY_CAPACITY_AGEDCELL,
+	/* charge count */
+	SEC_BATTERY_CAPACITY_CYCLE,
+	/* full capacity rep */
+	SEC_BATTERY_CAPACITY_FULL,
+};
+
+enum sec_wireless_info_mode {
+	SEC_WIRELESS_OTP_FIRM_RESULT = 0,
+	SEC_WIRELESS_IC_GRADE,
+	SEC_WIRELESS_IC_REVISION,
+	SEC_WIRELESS_OTP_FIRM_VER_BIN,
+	SEC_WIRELESS_OTP_FIRM_VER,
+	SEC_WIRELESS_TX_FIRM_RESULT,
+	SEC_WIRELESS_TX_FIRM_VER,
+	SEC_TX_FIRMWARE,
+	SEC_WIRELESS_OTP_FIRM_VERIFY,
+};
+
+enum sec_wireless_firm_update_mode {
+	SEC_WIRELESS_RX_SDCARD_MODE = 0,
+	SEC_WIRELESS_RX_BUILT_IN_MODE,
+	SEC_WIRELESS_TX_ON_MODE,
+	SEC_WIRELESS_TX_OFF_MODE,
+	SEC_WIRELESS_RX_INIT,
+};
+
+enum sec_tx_firmware_mode {
+	SEC_TX_OFF = 0,
+	SEC_TX_STANDBY,
+	SEC_TX_POWER_TRANSFER,
+	SEC_TX_ERROR,
+};
+
+enum sec_wireless_control_mode {
+	WIRELESS_VOUT_OFF = 0,
+	WIRELESS_VOUT_NORMAL_VOLTAGE,	/* 5V , reserved by factory */
+	WIRELESS_VOUT_RESERVED,			/* 6V */
+	WIRELESS_VOUT_HIGH_VOLTAGE,		/* 9V , reserved by factory */
+	WIRELESS_VOUT_CC_CV_VOUT,
+	WIRELESS_VOUT_CV_CALL,
+	WIRELESS_VOUT_CC_CALL,
+	WIRELESS_VOUT_5V,
+	WIRELESS_VOUT_9V,
+	WIRELESS_VOUT_9V_OTG,
+	WIRELESS_PAD_FAN_OFF,
+	WIRELESS_PAD_FAN_ON,
+	WIRELESS_PAD_LED_OFF,
+	WIRELESS_PAD_LED_ON,
+	WIRELESS_VRECT_ADJ_ON,
+	WIRELESS_VRECT_ADJ_OFF,
+	WIRELESS_VRECT_ADJ_ROOM_0,
+	WIRELESS_VRECT_ADJ_ROOM_1,
+	WIRELESS_VRECT_ADJ_ROOM_2,
+	WIRELESS_VRECT_ADJ_ROOM_3,
+	WIRELESS_VRECT_ADJ_ROOM_4,
+	WIRELESS_VRECT_ADJ_ROOM_5,
+	WIRELESS_CLAMP_ENABLE,
+};
+
+enum sec_siop_event_mode {
+	SIOP_EVENT_IDLE = 0,
+	SIOP_EVENT_WPC_CALL_START,		/* 5V wireless charging + Call */
+	SIOP_EVENT_WPC_CALL_END,		/* 5V wireless charging + Call */
+	SIOP_EVENT_MAX,					/* end */
+};
+
+enum sec_wireless_pad_mode {
+	SEC_WIRELESS_PAD_NONE = 0,
+	SEC_WIRELESS_PAD_WPC,
+	SEC_WIRELESS_PAD_WPC_HV,
+	SEC_WIRELESS_PAD_WPC_PACK,
+	SEC_WIRELESS_PAD_WPC_PACK_TA,
+	SEC_WIRELESS_PAD_WPC_STAND,
+	SEC_WIRELESS_PAD_WPC_STAND_HV,
+	SEC_WIRELESS_PAD_PMA,
+	SEC_WIRELESS_PAD_VEHICLE,
+};
+
+/* ADC type */
+enum sec_battery_adc_type {
+	/* NOT using this ADC channel */
+	SEC_BATTERY_ADC_TYPE_NONE = 0,
+	/* ADC in AP */
+	SEC_BATTERY_ADC_TYPE_AP,
+	/* ADC by additional IC */
+	SEC_BATTERY_ADC_TYPE_IC,
+	SEC_BATTERY_ADC_TYPE_NUM
+};
+
+enum sec_battery_adc_channel {
+	SEC_BAT_ADC_CHANNEL_CABLE_CHECK = 0,
+	SEC_BAT_ADC_CHANNEL_BAT_CHECK,
+	SEC_BAT_ADC_CHANNEL_TEMP,
+	SEC_BAT_ADC_CHANNEL_TEMP_AMBIENT,
+	SEC_BAT_ADC_CHANNEL_FULL_CHECK,
+	SEC_BAT_ADC_CHANNEL_VOLTAGE_NOW,
+	SEC_BAT_ADC_CHANNEL_CHG_TEMP,
+	SEC_BAT_ADC_CHANNEL_INBAT_VOLTAGE,
+	SEC_BAT_ADC_CHANNEL_WPC_TEMP,
+	SEC_BAT_ADC_CHANNEL_SLAVE_CHG_TEMP,
+	SEC_BAT_ADC_CHANNEL_USB_TEMP,
+	SEC_BAT_ADC_CHANNEL_NUM,
+};
+
+enum sec_battery_charge_mode {
+	SEC_BAT_CHG_MODE_CHARGING = 0,
+	SEC_BAT_CHG_MODE_CHARGING_OFF,
+	SEC_BAT_CHG_MODE_BUCK_OFF,
+};
+
+/* charging mode */
+enum sec_battery_charging_mode {
+	/* no charging */
+	SEC_BATTERY_CHARGING_NONE = 0,
+	/* 1st charging */
+	SEC_BATTERY_CHARGING_1ST,
+	/* 2nd charging */
+	SEC_BATTERY_CHARGING_2ND,
+	/* recharging */
+	SEC_BATTERY_CHARGING_RECHARGING,
+};
+
+struct sec_bat_adc_api {
+	bool (*init)(struct platform_device *);
+	bool (*exit)(void);
+	int (*read)(unsigned int);
+};
+#define sec_bat_adc_api_t struct sec_bat_adc_api
+
+/* monitor activation */
+enum sec_battery_polling_time_type {
+	/* same order with power supply status */
+	SEC_BATTERY_POLLING_TIME_BASIC = 0,
+	SEC_BATTERY_POLLING_TIME_CHARGING,
+	SEC_BATTERY_POLLING_TIME_DISCHARGING,
+	SEC_BATTERY_POLLING_TIME_NOT_CHARGING,
+	SEC_BATTERY_POLLING_TIME_SLEEP,
+};
+
+enum sec_battery_monitor_polling {
+	/* polling work queue */
+	SEC_BATTERY_MONITOR_WORKQUEUE,
+	/* alarm polling */
+	SEC_BATTERY_MONITOR_ALARM,
+	/* timer polling (NOT USE) */
+	SEC_BATTERY_MONITOR_TIMER,
+};
+#define sec_battery_monitor_polling_t \
+	enum sec_battery_monitor_polling
+
+/* full charged check : POWER_SUPPLY_PROP_STATUS */
+enum sec_battery_full_charged {
+	SEC_BATTERY_FULLCHARGED_NONE = 0,
+	/* current check by ADC */
+	SEC_BATTERY_FULLCHARGED_ADC,
+	/* fuel gauge current check */
+	SEC_BATTERY_FULLCHARGED_FG_CURRENT,
+	/* time check */
+	SEC_BATTERY_FULLCHARGED_TIME,
+	/* SOC check */
+	SEC_BATTERY_FULLCHARGED_SOC,
+	/* charger GPIO, NO additional full condition */
+	SEC_BATTERY_FULLCHARGED_CHGGPIO,
+	/* charger interrupt, NO additional full condition */
+	SEC_BATTERY_FULLCHARGED_CHGINT,
+	/* charger power supply property, NO additional full condition */
+	SEC_BATTERY_FULLCHARGED_CHGPSY,
+};
+
+/* BATT_INBAT_VOLTAGE */
+enum sec_battery_inbat_fgsrc_switching {
+	SEC_BAT_INBAT_FGSRC_SWITCHING_ON = 0,
+	SEC_BAT_INBAT_FGSRC_SWITCHING_OFF,
+};
+
+#define sec_battery_full_charged_t \
+	enum sec_battery_full_charged
+
+/* full check condition type (can be used overlapped) */
+#define sec_battery_full_condition_t unsigned int
+/* SEC_BATTERY_FULL_CONDITION_NOTIMEFULL
+  * full-charged by absolute-timer only in high voltage
+  */
+#define SEC_BATTERY_FULL_CONDITION_NOTIMEFULL	1
+/* SEC_BATTERY_FULL_CONDITION_NOSLEEPINFULL
+  * do not set polling time as sleep polling time in full-charged
+  */
+#define SEC_BATTERY_FULL_CONDITION_NOSLEEPINFULL	2
+/* SEC_BATTERY_FULL_CONDITION_SOC
+  * use capacity for full-charged check
+  */
+#define SEC_BATTERY_FULL_CONDITION_SOC		4
+/* SEC_BATTERY_FULL_CONDITION_VCELL
+  * use VCELL for full-charged check
+  */
+#define SEC_BATTERY_FULL_CONDITION_VCELL	8
+/* SEC_BATTERY_FULL_CONDITION_AVGVCELL
+  * use average VCELL for full-charged check
+  */
+#define SEC_BATTERY_FULL_CONDITION_AVGVCELL	16
+/* SEC_BATTERY_FULL_CONDITION_OCV
+  * use OCV for full-charged check
+  */
+#define SEC_BATTERY_FULL_CONDITION_OCV		32
+
+/* recharge check condition type (can be used overlapped) */
+#define sec_battery_recharge_condition_t unsigned int
+/* SEC_BATTERY_RECHARGE_CONDITION_SOC
+  * use capacity for recharging check
+  */
+#define SEC_BATTERY_RECHARGE_CONDITION_SOC		1
+/* SEC_BATTERY_RECHARGE_CONDITION_AVGVCELL
+  * use average VCELL for recharging check
+  */
+#define SEC_BATTERY_RECHARGE_CONDITION_AVGVCELL		2
+/* SEC_BATTERY_RECHARGE_CONDITION_VCELL
+  * use VCELL for recharging check
+  */
+#define SEC_BATTERY_RECHARGE_CONDITION_VCELL		4
+
+/* battery check : POWER_SUPPLY_PROP_PRESENT */
+enum sec_battery_check {
+	/* No Check for internal battery */
+	SEC_BATTERY_CHECK_NONE,
+	/* by ADC */
+	SEC_BATTERY_CHECK_ADC,
+	/* by callback function (battery certification by 1 wired)*/
+	SEC_BATTERY_CHECK_CALLBACK,
+	/* by PMIC */
+	SEC_BATTERY_CHECK_PMIC,
+	/* by fuel gauge */
+	SEC_BATTERY_CHECK_FUELGAUGE,
+	/* by charger */
+	SEC_BATTERY_CHECK_CHARGER,
+	/* by interrupt (use check_battery_callback() to check battery) */
+	SEC_BATTERY_CHECK_INT,
+};
+#define sec_battery_check_t \
+	enum sec_battery_check
+
+/* OVP, UVLO check : POWER_SUPPLY_PROP_HEALTH */
+enum sec_battery_ovp_uvlo {
+	/* by callback function */
+	SEC_BATTERY_OVP_UVLO_CALLBACK,
+	/* by PMIC polling */
+	SEC_BATTERY_OVP_UVLO_PMICPOLLING,
+	/* by PMIC interrupt */
+	SEC_BATTERY_OVP_UVLO_PMICINT,
+	/* by charger polling */
+	SEC_BATTERY_OVP_UVLO_CHGPOLLING,
+	/* by charger interrupt */
+	SEC_BATTERY_OVP_UVLO_CHGINT,
+};
+#define sec_battery_ovp_uvlo_t \
+	enum sec_battery_ovp_uvlo
+
+/* thermal source */
+enum sec_battery_thermal_source {
+	/* by fuel gauge */
+	SEC_BATTERY_THERMAL_SOURCE_FG,
+	/* by external source */
+	SEC_BATTERY_THERMAL_SOURCE_CALLBACK,
+	/* by ADC */
+	SEC_BATTERY_THERMAL_SOURCE_ADC,
+};
+#define sec_battery_thermal_source_t \
+	enum sec_battery_thermal_source
+
+/* charger thermal source */
+enum sec_charger_thermal_source {
+	/* by external source */
+	SEC_CHARGER_THERMAL_SOURCE_CALLBACK,
+	/* by ADC */
+	SEC_CHARGER_THERMAL_SOURCE_ADC,
+	/* by fuel gauge */
+	SEC_CHARGER_THERMAL_SOURCE_FG,
+};
+#define sec_charger_thermal_source_t \
+	enum sec_charger_thermal_source
+
+enum sec_battery_heating_prevention_method {
+	/* voltage based change */
+	SEC_BATTERY_BY_CHANGING_VOLTAGE = 0,
+	/* current based change */
+	SEC_BATTERY_BY_CHANGING_CURRENT,
+};
+#define sec_battery_heating_prevention_method_t \
+	enum sec_battery_heating_prevention_method
+
+/* temperature check type */
+enum sec_battery_temp_check {
+	SEC_BATTERY_TEMP_CHECK_NONE = 0,	/* no temperature check */
+	SEC_BATTERY_TEMP_CHECK_ADC,	/* by ADC value */
+	SEC_BATTERY_TEMP_CHECK_TEMP,	/* by temperature */
+};
+#define sec_battery_temp_check_t \
+	enum sec_battery_temp_check
+
+/* cable check (can be used overlapped) */
+#define sec_battery_cable_check_t unsigned int
+/* SEC_BATTERY_CABLE_CHECK_NOUSBCHARGE
+  * for USB cable in tablet model,
+  * status is stuck into discharging,
+  * but internal charging logic is working
+  */
+#define SEC_BATTERY_CABLE_CHECK_NOUSBCHARGE		1
+/* SEC_BATTERY_CABLE_CHECK_NOINCOMPATIBLECHARGE
+  * for incompatible charger
+  * (Not compliant to USB specification,
+  *  cable type is POWER_SUPPLY_TYPE_UNKNOWN),
+  * do NOT charge and show message to user
+  * (only for VZW)
+  */
+#define SEC_BATTERY_CABLE_CHECK_NOINCOMPATIBLECHARGE	2
+/* SEC_BATTERY_CABLE_CHECK_PSY
+  * check cable by power supply set_property
+  */
+#define SEC_BATTERY_CABLE_CHECK_PSY			4
+/* SEC_BATTERY_CABLE_CHECK_INT
+  * check cable by interrupt
+  */
+#define SEC_BATTERY_CABLE_CHECK_INT			8
+/* SEC_BATTERY_CABLE_CHECK_CHGINT
+  * check cable by charger interrupt
+  */
+#define SEC_BATTERY_CABLE_CHECK_CHGINT			16
+/* SEC_BATTERY_CABLE_CHECK_POLLING
+  * check cable by GPIO polling
+  */
+#define SEC_BATTERY_CABLE_CHECK_POLLING			32
+
+/* check cable source (can be used overlapped) */
+#define sec_battery_cable_source_t unsigned int
+/* SEC_BATTERY_CABLE_SOURCE_EXTERNAL
+ * already given by external argument
+ */
+#define	SEC_BATTERY_CABLE_SOURCE_EXTERNAL	1
+/* SEC_BATTERY_CABLE_SOURCE_CALLBACK
+ * by callback (MUIC, USB switch)
+ */
+#define	SEC_BATTERY_CABLE_SOURCE_CALLBACK	2
+/* SEC_BATTERY_CABLE_SOURCE_ADC
+ * by ADC
+ */
+#define	SEC_BATTERY_CABLE_SOURCE_ADC		4
+
+/* capacity calculation type (can be used overlapped) */
+#define sec_fuelgauge_capacity_type_t int
+/* SEC_FUELGAUGE_CAPACITY_TYPE_RESET
+  * use capacity information to reset fuel gauge
+  * (only for driver algorithm, can NOT be set by user)
+  */
+#define SEC_FUELGAUGE_CAPACITY_TYPE_RESET	(-1)
+/* SEC_FUELGAUGE_CAPACITY_TYPE_RAW
+  * use capacity information from fuel gauge directly
+  */
+#define SEC_FUELGAUGE_CAPACITY_TYPE_RAW		1
+/* SEC_FUELGAUGE_CAPACITY_TYPE_SCALE
+  * rescale capacity by scaling, need min and max value for scaling
+  */
+#define SEC_FUELGAUGE_CAPACITY_TYPE_SCALE	2
+/* SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE
+  * change only maximum capacity dynamically
+  * to keep time for every SOC unit
+  */
+#define SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE	4
+/* SEC_FUELGAUGE_CAPACITY_TYPE_ATOMIC
+  * change capacity value by only -1 or +1
+  * no sudden change of capacity
+  */
+#define SEC_FUELGAUGE_CAPACITY_TYPE_ATOMIC	8
+/* SEC_FUELGAUGE_CAPACITY_TYPE_SKIP_ABNORMAL
+  * skip current capacity value
+  * if it is abnormal value
+  */
+#define SEC_FUELGAUGE_CAPACITY_TYPE_SKIP_ABNORMAL	16
+
+/* charger function settings (can be used overlapped) */
+#define sec_charger_functions_t unsigned int
+/* SEC_CHARGER_NO_GRADUAL_CHARGING_CURRENT
+ * disable gradual charging current setting
+ * SUMMIT:AICL, MAXIM:regulation loop
+ */
+#define SEC_CHARGER_NO_GRADUAL_CHARGING_CURRENT		1
+
+/* SEC_CHARGER_MINIMUM_SIOP_CHARGING_CURRENT
+ * charging current should be over than USB charging current
+ */
+#define SEC_CHARGER_MINIMUM_SIOP_CHARGING_CURRENT	2
+
+/**
+ * struct sec_bat_adc_table_data - adc to temperature table for sec battery
+ * driver
+ * @adc: adc value
+ * @temperature: temperature(C) * 10
+ */
+struct sec_bat_adc_table_data {
+	int adc;
+	int data;
+};
+#define sec_bat_adc_table_data_t \
+	struct sec_bat_adc_table_data
+
+struct sec_bat_adc_region {
+	int min;
+	int max;
+};
+#define sec_bat_adc_region_t \
+	struct sec_bat_adc_region
+
+struct sec_charging_current {
+#ifdef CONFIG_OF
+	unsigned int input_current_limit;
+	unsigned int fast_charging_current;
+	unsigned int full_check_current_1st;
+	unsigned int full_check_current_2nd;
+#else
+	int input_current_limit;
+	int fast_charging_current;
+	int full_check_current_1st;
+	int full_check_current_2nd;
+#endif
+};
+
+#define sec_charging_current_t \
+	struct sec_charging_current
+
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+struct sec_age_data {
+	int cycle;
+	unsigned int float_voltage;
+	unsigned int recharge_condition_vcell;
+	unsigned int full_condition_vcell;
+	unsigned int full_condition_soc;
+#if defined(CONFIG_BATTERY_AGE_FORECAST_B2B)
+	unsigned int max_charging_current;
+#endif
+};
+
+#define sec_age_data_t \
+	struct sec_age_data
+
+#define sec_age_data_t \
+	struct sec_age_data
+#endif
+
+struct sec_battery_platform_data {
+	/* NO NEED TO BE CHANGED */
+	/* callback functions */
+	void (*initial_check)(void);
+	void (*monitor_additional_check)(void);
+	bool (*bat_gpio_init)(void);
+	bool (*fg_gpio_init)(void);
+	bool (*is_lpm)(void);
+	bool (*check_jig_status)(void);
+	bool (*is_interrupt_cable_check_possible)(int);
+	int (*check_cable_callback)(void);
+	int (*get_cable_from_extended_cable_type)(int);
+	bool (*cable_switch_check)(void);
+	bool (*cable_switch_normal)(void);
+	bool (*check_cable_result_callback)(int);
+	bool (*check_battery_callback)(void);
+	bool (*check_battery_result_callback)(void);
+	int (*ovp_uvlo_callback)(void);
+	bool (*ovp_uvlo_result_callback)(int);
+	bool (*fuelalert_process)(bool);
+	bool (*get_temperature_callback)(
+			enum power_supply_property,
+			union power_supply_propval*);
+
+	/* ADC API for each ADC type */
+	sec_bat_adc_api_t adc_api[SEC_BATTERY_ADC_TYPE_NUM];
+	/* ADC region by power supply type
+	 * ADC region should be exclusive
+	 */
+	sec_bat_adc_region_t *cable_adc_value;
+	/* charging current for type (0: not use) */
+	sec_charging_current_t *charging_current;
+#ifdef CONFIG_OF
+	unsigned int *polling_time;
+	char *chip_vendor;
+	unsigned int temp_adc_type;
+#else
+	int *polling_time;
+#endif
+	/* NO NEED TO BE CHANGED */
+	unsigned int pre_afc_input_current;
+	unsigned int pre_wc_afc_input_current;
+	unsigned int store_mode_afc_input_current;
+	unsigned int store_mode_hv_wireless_input_current;
+
+	char *pmic_name;
+
+	/* battery */
+	char *vendor;
+	int technology;
+	int battery_type;
+	void *battery_data;
+
+	int bat_gpio_ta_nconnected;
+	/* 1 : active high, 0 : active low */
+	int bat_polarity_ta_nconnected;
+	int bat_irq;
+	int bat_irq_gpio; /* BATT_INT(BAT_ID detecting) */
+	unsigned int bat_irq_attr;
+	int jig_irq;
+	unsigned long jig_irq_attr;
+	sec_battery_cable_check_t cable_check_type;
+	sec_battery_cable_source_t cable_source_type;
+
+	bool use_LED;				/* use charging LED */
+
+	/* flag for skipping the swelling mode */
+	bool swelling_mode_skip_in_high_temp;
+	/* sustaining event after deactivated (second) */
+	unsigned int event_waiting_time;
+
+	/* battery swelling */
+	int swelling_high_temp_block;
+	int swelling_high_temp_recov;
+	int swelling_low_temp_block_1st;
+	int swelling_low_temp_recov_1st;
+	int swelling_low_temp_block_2nd;
+	int swelling_low_temp_recov_2nd;
+	int swelling_low_temp_2step_mode;
+	int swelling_low_temp_additional;
+	unsigned int swelling_low_temp_current;
+	unsigned int swelling_low_temp_additional_current;
+	unsigned int swelling_low_temp_topoff;
+	unsigned int swelling_high_temp_current;
+	unsigned int swelling_high_temp_topoff;
+	unsigned int swelling_normal_float_voltage;
+	unsigned int swelling_drop_float_voltage;
+	unsigned int swelling_high_rechg_voltage;
+	unsigned int swelling_low_rechg_voltage;
+
+#if defined(CONFIG_CALC_TIME_TO_FULL)
+	unsigned int ttf_hv_12v_charge_current;
+	unsigned int ttf_hv_charge_current;
+	unsigned int ttf_hv_wireless_charge_current;
+	unsigned int ttf_wireless_charge_current;
+#endif
+
+#if defined(CONFIG_STEP_CHARGING)
+	/* step charging */
+	unsigned int *step_charging_condition;
+	unsigned int *step_charging_current;
+#endif
+
+	/* Monitor setting */
+	sec_battery_monitor_polling_t polling_type;
+	/* for initial check */
+	unsigned int monitor_initial_count;
+
+	/* Battery check */
+	sec_battery_check_t battery_check_type;
+	/* how many times do we need to check battery */
+	unsigned int check_count;
+	/* ADC */
+	/* battery check ADC maximum value */
+	unsigned int check_adc_max;
+	/* battery check ADC minimum value */
+	unsigned int check_adc_min;
+
+	/* OVP/UVLO check */
+	sec_battery_ovp_uvlo_t ovp_uvlo_check_type;
+
+	sec_battery_thermal_source_t thermal_source;
+
+	/*
+	 * inbat_adc_table
+	 * in-battery voltage check for table models:
+	 * To read real battery voltage with Jig cable attached,
+	 * dedicated hw pin & conversion table of adc-voltage are required
+	 */
+#ifdef CONFIG_OF
+	sec_bat_adc_table_data_t *temp_adc_table;
+	sec_bat_adc_table_data_t *temp_amb_adc_table;
+	sec_bat_adc_table_data_t *chg_temp_adc_table;
+	sec_bat_adc_table_data_t *wpc_temp_adc_table;
+	sec_bat_adc_table_data_t *usb_temp_adc_table;
+	sec_bat_adc_table_data_t *slave_chg_temp_adc_table;
+	sec_bat_adc_table_data_t *inbat_adc_table;
+#else
+	const sec_bat_adc_table_data_t *temp_adc_table;
+	const sec_bat_adc_table_data_t *temp_amb_adc_table;
+#endif
+	unsigned int temp_adc_table_size;
+	unsigned int temp_amb_adc_table_size;
+	unsigned int chg_temp_adc_table_size;
+	unsigned int wpc_temp_adc_table_size;
+	unsigned int usb_temp_adc_table_size;
+	unsigned int slave_chg_temp_adc_table_size;
+	unsigned int inbat_adc_table_size;
+
+	sec_battery_temp_check_t temp_check_type;
+	unsigned int temp_check_count;
+	unsigned int chg_temp_check; /* Control the charging current depending on the chg_thm */
+	sec_charger_thermal_source_t chg_thermal_source; /* To confirm the charger temperature source */
+	sec_battery_heating_prevention_method_t chg_heating_prevention_method; /* To select heating prevention method */
+	unsigned int wpc_temp_check;
+	unsigned int wpc_thermal_source; /* To confirm the wpc temperature */
+	unsigned int slave_chg_temp_check;
+	unsigned int slave_thermal_source; /* To confirm the slave charger temperature */
+	unsigned int inbat_voltage;
+	unsigned int usb_thermal_source; /* To confirm the usb temperature */		
+	
+#if defined(CONFIG_XADC_SHARE_BATT_WITH_USB_THM)
+	/* To use xadc mux for BAT_THM with USB_THM */
+	int xadc_mux_sel_pin;
+#endif
+
+	/*
+	 * limit can be ADC value or Temperature
+	 * depending on temp_check_type
+	 * temperature should be temp x 10 (0.1 degree)
+	 */
+	int temp_highlimit_threshold_normal;
+	int temp_highlimit_recovery_normal;
+	int temp_high_threshold_normal;
+	int temp_high_recovery_normal;
+	int temp_low_threshold_normal;
+	int temp_low_recovery_normal;
+	int temp_highlimit_threshold_lpm;
+	int temp_highlimit_recovery_lpm;
+	int temp_high_threshold_lpm;
+	int temp_high_recovery_lpm;
+	int temp_low_threshold_lpm;
+	int temp_low_recovery_lpm;
+	int chg_12v_high_temp;
+	int chg_high_temp;
+	int chg_high_temp_recovery;
+	unsigned int chg_charging_limit_current;
+	int wpc_high_temp_size;
+	int *wpc_high_temp;
+	int *wpc_high_temp_recovery;
+	unsigned int *wpc_charging_limit_current;
+	int wpc_heat_temp_recovery;
+	int wpc_lcd_on_high_temp;
+	int wpc_lcd_on_high_temp_rec;
+	unsigned int wpc_hv_lcd_on_input_limit_current;
+	unsigned int sleep_mode_limit_current;
+	unsigned int wc_full_input_limit_current;
+	unsigned int wc_heating_input_limit_current;
+	unsigned int wc_heating_time;
+	unsigned int wc_cv_current;
+	unsigned int wc_cv_pack_current;
+	unsigned int max_charging_current;
+	int mix_high_temp;
+	int mix_high_chg_temp;
+	int mix_high_temp_recovery;
+
+	/* If these is NOT full check type or NONE full check type,
+	 * it is skipped
+	 */
+	/* 1st full check */
+	sec_battery_full_charged_t full_check_type;
+	/* 2nd full check */
+	sec_battery_full_charged_t full_check_type_2nd;
+	unsigned int full_check_count;
+	int chg_gpio_full_check;
+	/* 1 : active high, 0 : active low */
+	int chg_polarity_full_check;
+	sec_battery_full_condition_t full_condition_type;
+	unsigned int full_condition_soc;
+	unsigned int full_condition_vcell;
+	unsigned int full_condition_avgvcell;
+	unsigned int full_condition_ocv;
+
+	unsigned int recharge_check_count;
+	sec_battery_recharge_condition_t recharge_condition_type;
+	unsigned int recharge_condition_soc;
+	unsigned int recharge_condition_avgvcell;
+	unsigned int recharge_condition_vcell;
+
+	/* for absolute timer (second) */
+	unsigned long charging_total_time;
+	/* for recharging timer (second) */
+	unsigned long recharging_total_time;
+	/* reset charging for abnormal malfunction (0: not use) */
+	unsigned long charging_reset_time;
+	unsigned int hv_charging_total_time;
+	unsigned int normal_charging_total_time;
+	unsigned int usb_charging_total_time;
+
+	/* fuel gauge */
+	char *fuelgauge_name;
+	int fg_irq;
+	unsigned long fg_irq_attr;
+	/* fuel alert SOC (-1: not use) */
+	int fuel_alert_soc;
+	/* fuel alert can be repeated */
+	bool repeated_fuelalert;
+	sec_fuelgauge_capacity_type_t capacity_calculation_type;
+	/* soc should be soc x 10 (0.1% degree)
+	 * only for scaling
+	 */
+	int capacity_max;
+	int capacity_max_hv;
+
+	int capacity_max_margin;
+	int capacity_min;
+
+	/* charger */
+	char *charger_name;
+	char *fgsrc_switch_name;
+	bool support_fgsrc_change;
+
+	/* wireless charger */
+	char *wireless_charger_name;
+	int wireless_cc_cv;
+	int wpc_det;
+	int wpc_en;
+
+	int thm_mux;
+
+	int chg_gpio_en;
+	int chg_irq;
+	unsigned long chg_irq_attr;
+	/* float voltage (mV) */
+	unsigned int chg_float_voltage;
+	unsigned int chg_float_voltage_conv;
+
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	int num_age_step;
+	int age_step;
+	int age_data_length;
+	sec_age_data_t* age_data;
+#endif
+	unsigned int siop_event_check_type;
+	unsigned int siop_call_cc_current;
+	unsigned int siop_call_cv_current;
+
+	int siop_input_limit_current;
+	int siop_charging_limit_current;
+	int siop_hv_input_limit_current;
+	int siop_hv_charging_limit_current;
+	int siop_hv_12v_input_limit_current;
+	int siop_hv_12v_charging_limit_current;
+
+	int siop_wireless_input_limit_current;
+	int siop_wireless_charging_limit_current;
+	int siop_hv_wireless_input_limit_current;
+	int siop_hv_wireless_charging_limit_current;
+
+	int default_input_current;
+	int default_charging_current;
+	int default_usb_input_current;
+ 	int default_usb_charging_current;
+	int max_input_voltage;
+	int max_input_current;
+	int pre_afc_work_delay;
+	
+	/* if siop level 0, set minimum fast charging current */
+	int minimum_charging_current_by_siop_0;
+
+	sec_charger_functions_t chg_functions_setting;
+
+	bool fake_capacity;
+
+#if defined(CONFIG_BATTERY_CISD)
+	unsigned int battery_full_capacity;
+	unsigned int cisd_cap_high_thr;
+	unsigned int cisd_cap_low_thr;
+	unsigned int cisd_cap_limit;
+	unsigned int max_voltage_thr;
+	char *cisd_data_efs_path;
+#endif
+
+	/* ADC setting */
+	unsigned int adc_check_count;
+	unsigned int expired_time;
+	unsigned int recharging_expired_time;
+	int standard_curr;
+
+	/* ADC type for each channel */
+	unsigned int adc_type[];
+};
+
+struct sec_charger_platform_data {
+	bool (*chg_gpio_init)(void);
+
+	/* charging current for type (0: not use) */
+	sec_charging_current_t *charging_current;
+
+	/* wirelss charger */
+	char *wireless_charger_name;
+	int wireless_cc_cv;
+
+	int vbus_ctrl_gpio;
+	int chg_gpio_en;
+	/* float voltage (mV) */
+	int chg_float_voltage;
+	int irq_gpio;
+	int chg_irq;
+	unsigned long chg_irq_attr;
+
+	/* otg_en setting */
+	int otg_en;
+	unsigned int slow_current_threshold;
+
+	/* OVP/UVLO check */
+	sec_battery_ovp_uvlo_t ovp_uvlo_check_type;
+	/* 1st full check */
+	sec_battery_full_charged_t full_check_type;
+	/* 2nd full check */
+	sec_battery_full_charged_t full_check_type_2nd;
+
+	sec_charger_functions_t chg_functions_setting;
+};
+
+struct sec_fuelgauge_platform_data {
+	bool (*fg_gpio_init)(void);
+	bool (*check_jig_status)(void);
+	int (*check_cable_callback)(void);
+	bool (*fuelalert_process)(bool);
+
+	/* charging current for type (0: not use) */
+	sec_charging_current_t *charging_current;
+
+	int jig_irq;
+	int jig_gpio;
+	unsigned long jig_irq_attr;
+
+	sec_battery_thermal_source_t thermal_source;
+
+	int fg_irq;
+	unsigned long fg_irq_attr;
+	/* fuel alert SOC (-1: not use) */
+	int fuel_alert_soc;
+	int fuel_alert_vol;
+	/* fuel alert can be repeated */
+	bool repeated_fuelalert;
+	sec_fuelgauge_capacity_type_t capacity_calculation_type;
+	/* soc should be soc x 10 (0.1% degree)
+	 * only for scaling
+	 */
+	int capacity_max;
+	int capacity_max_hv;
+	int capacity_max_margin;
+	int capacity_min;
+
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	unsigned int full_condition_soc;
+#endif
+};
+
+#define sec_battery_platform_data_t \
+	struct sec_battery_platform_data
+
+#define sec_charger_platform_data_t \
+	struct sec_charger_platform_data
+
+#define sec_fuelgauge_platform_data_t \
+	struct sec_fuelgauge_platform_data
+
+static inline struct power_supply *get_power_supply_by_name(char *name)
+{
+	if (!name)
+		return (struct power_supply *)NULL;
+	else
+		return power_supply_get_by_name(name);
+}
+
+#define psy_do_property(name, function, property, value) \
+{	\
+	struct power_supply *psy;	\
+	int ret;	\
+	psy = get_power_supply_by_name((name));	\
+	if (!psy) {	\
+		pr_err("%s: Fail to "#function" psy (%s)\n",	\
+			__func__, (name));	\
+		value.intval = 0;	\
+	} else {	\
+		if (psy->function##_property != NULL) { \
+			ret = psy->function##_property(psy, (property), &(value)); \
+			if (ret < 0) {	\
+				pr_err("%s: Fail to %s "#function" (%d=>%d)\n", \
+						__func__, name, (property), ret);	\
+				value.intval = 0;	\
+			}	\
+		}	\
+	}	\
+}
+
+#ifndef CONFIG_OF
+#define adc_init(pdev, pdata, channel)	\
+	(((pdata)->adc_api)[((((pdata)->adc_type[(channel)]) <	\
+	SEC_BATTERY_ADC_TYPE_NUM) ? ((pdata)->adc_type[(channel)]) :	\
+	SEC_BATTERY_ADC_TYPE_NONE)].init((pdev)))
+
+#define adc_exit(pdata, channel)	\
+	(((pdata)->adc_api)[((pdata)->adc_type[(channel)])].exit())
+
+#define adc_read(pdata, channel)	\
+	(((pdata)->adc_api)[((pdata)->adc_type[(channel)])].read((channel)))
+#endif
+
+#define get_battery_data(driver)	\
+	(((struct battery_data_t *)(driver)->pdata->battery_data)	\
+	[(driver)->pdata->battery_type])
+
+#define is_hv_wireless_type(cable_type) ( \
+	cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS || \
+	cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS_ETX || \
+	cable_type == POWER_SUPPLY_TYPE_WIRELESS_HV_STAND)
+
+#define is_nv_wireless_type(cable_type)	( \
+	cable_type == POWER_SUPPLY_TYPE_WIRELESS || \
+	cable_type == POWER_SUPPLY_TYPE_PMA_WIRELESS || \
+	cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK || \
+	cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK_TA || \
+	cable_type == POWER_SUPPLY_TYPE_WIRELESS_STAND)
+
+#define is_wireless_type(cable_type) \
+	(is_hv_wireless_type(cable_type) || is_nv_wireless_type(cable_type))
+
+#define is_not_wireless_type(cable_type) ( \
+	cable_type != POWER_SUPPLY_TYPE_WIRELESS && \
+	cable_type != POWER_SUPPLY_TYPE_PMA_WIRELESS && \
+	cable_type != POWER_SUPPLY_TYPE_WIRELESS_PACK && \
+	cable_type != POWER_SUPPLY_TYPE_WIRELESS_PACK_TA && \
+	cable_type != POWER_SUPPLY_TYPE_WIRELESS_STAND && \
+	cable_type != POWER_SUPPLY_TYPE_HV_WIRELESS && \
+	cable_type != POWER_SUPPLY_TYPE_HV_WIRELESS_ETX && \
+	cable_type != POWER_SUPPLY_TYPE_WIRELESS_HV_STAND)
+
+#define is_wired_type(cable_type) \
+	(is_not_wireless_type(cable_type) && (cable_type != POWER_SUPPLY_TYPE_BATTERY))
+
+#define is_hv_qc_wire_type(cable_type) ( \
+	cable_type == POWER_SUPPLY_TYPE_HV_QC20 || \
+	cable_type == POWER_SUPPLY_TYPE_HV_QC30)
+
+#define is_hv_afc_wire_type(cable_type) ( \
+	cable_type == POWER_SUPPLY_TYPE_HV_ERR || \
+	cable_type == POWER_SUPPLY_TYPE_HV_MAINS || \
+	cable_type == POWER_SUPPLY_TYPE_HV_UNKNOWN || \
+	cable_type == POWER_SUPPLY_TYPE_HV_MAINS_12V)
+
+#define is_hv_wire_9v_type(cable_type) ( \
+	cable_type == POWER_SUPPLY_TYPE_HV_ERR || \
+	cable_type == POWER_SUPPLY_TYPE_HV_MAINS || \
+	cable_type == POWER_SUPPLY_TYPE_HV_UNKNOWN || \
+	cable_type == POWER_SUPPLY_TYPE_HV_QC20)
+
+#define is_hv_wire_12v_type(cable_type) ( \
+	cable_type == POWER_SUPPLY_TYPE_HV_MAINS_12V || \
+	cable_type == POWER_SUPPLY_TYPE_HV_QC30)
+
+#define is_hv_wire_type(cable_type) ( \
+	is_hv_afc_wire_type(cable_type) || is_hv_qc_wire_type(cable_type))
+
+#endif /* __SEC_CHARGING_COMMON_H */
diff -Naur linux-3.18.14/drivers/battery_v2/include/sec_cisd.h samsung/drivers/battery_v2/include/sec_cisd.h
--- linux-3.18.14/drivers/battery_v2/include/sec_cisd.h	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/include/sec_cisd.h	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,132 @@
+/*
+ * sec_cisd.h
+ * Samsung Mobile Charger Header
+ *
+ * Copyright (C) 2015 Samsung Electronics, Inc.
+ *
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef __SEC_CISD_H
+#define __SEC_CISD_H __FILE__
+
+#define CISD_STATE_NONE			0x00
+#define CISD_STATE_CAP_OVERFLOW	0x01
+#define CISD_STATE_VOLT_DROP	0x02
+#define CISD_STATE_SOC_DROP		0x04
+#define CISD_STATE_RESET		0x08
+#define CISD_STATE_LEAK_A		0x10
+#define CISD_STATE_LEAK_B		0x20
+#define CISD_STATE_LEAK_C		0x40
+#define CISD_STATE_LEAK_D		0x80
+#define CISD_STATE_OVER_VOLTAGE		0x100
+#define CISD_STATE_LEAK_E		0x200
+#define CISD_STATE_LEAK_F		0x400
+#define CISD_STATE_LEAK_G		0x800
+
+#define is_cisd_check_type(cable_type) ( \
+	cable_type == POWER_SUPPLY_TYPE_MAINS || \
+	cable_type == POWER_SUPPLY_TYPE_HV_MAINS || \
+	cable_type == POWER_SUPPLY_TYPE_HV_ERR || \
+	cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS || \
+	cable_type == POWER_SUPPLY_TYPE_WIRELESS_HV_STAND)
+
+enum cisd_data {
+	CISD_DATA_FULL_COUNT = 0,
+	CISD_DATA_CAP_MAX,
+	CISD_DATA_CAP_MIN,
+	CISD_DATA_CAP_ONCE,
+	CISD_DATA_LEAKAGE_A,
+	CISD_DATA_LEAKAGE_B,
+	CISD_DATA_LEAKAGE_C,
+	CISD_DATA_LEAKAGE_D,
+	CISD_DATA_CAP_PER_TIME,
+	CISD_DATA_ERRCAP_LOW,
+	CISD_DATA_ERRCAP_HIGH,
+
+	CISD_DATA_OVER_VOLTAGE,
+	CISD_DATA_LEAKAGE_E,
+	CISD_DATA_LEAKAGE_F,
+	CISD_DATA_LEAKAGE_G,
+	CISD_DATA_RECHARGING_TIME,
+	CISD_DATA_VALERT_COUNT,
+	CISD_DATA_CYCLE,
+	CISD_DATA_WIRE_COUNT,
+	CISD_DATA_WIRELESS_COUNT,
+	CISD_DATA_HIGH_TEMP_SWELLING,
+
+	CISD_DATA_LOW_TEMP_SWELLING,
+	CISD_DATA_SWELLING_CHARGING_COUNT,
+	CISD_DATA_SAFETY_TIMER_3,
+	CISD_DATA_SAFETY_TIMER_5,
+	CISD_DATA_SAFETY_TIMER_10,
+	CISD_DATA_AICL_COUNT,
+	CISD_DATA_BATT_TEMP_MAX,
+	CISD_DATA_BATT_TEMP_MIN,
+	CISD_DATA_CHG_TEMP_MAX,
+	CISD_DATA_CHG_TEMP_MIN,
+
+	CISD_DATA_WPC_TEMP_MAX,
+	CISD_DATA_WPC_TEMP_MIN,
+	CISD_UNSAFE_VOLTAGE,
+	CISD_UNSAFE_TEMPERATURE,
+	CISD_SAFETY_TIMER,
+	CISD_VSYS_OVP,
+	CISD_VBAT_OVP,
+	CISD_WATER_DETECT,
+	CISD_AFC_FAIL,
+
+	CISD_DATA_MAX,
+};
+
+struct cisd {
+	unsigned int cisd_alg_index;
+	unsigned int state;
+
+	unsigned int delay_time;
+	int diff_volt_now;
+	int diff_cap_now;
+	int curr_cap_max;
+	int err_cap_max_thrs;
+	int err_cap_high_thr;
+	int err_cap_low_thr;
+	int overflow_cap_thr;
+	unsigned int cc_delay_time;
+	unsigned int full_delay_time;
+	unsigned int lcd_off_delay_time;
+	unsigned int recharge_delay_time;
+	unsigned int diff_time;
+	unsigned long cc_start_time;
+	unsigned long full_start_time;
+	unsigned long lcd_off_start_time;
+	unsigned long overflow_start_time;
+	unsigned long charging_end_time;
+	unsigned long charging_end_time_2;
+	unsigned int recharge_count;
+	unsigned int recharge_count_2;
+	unsigned int recharge_count_thres;
+	unsigned long leakage_e_time;
+	unsigned long leakage_f_time;
+	unsigned long leakage_g_time;
+	int current_max_thres;
+	int charging_current_thres;
+	int current_avg_thres;
+
+	unsigned int ab_vbat_max_count;
+	unsigned int ab_vbat_check_count;
+	unsigned int max_voltage_thr;
+
+	/* Big Data Field */
+	int capacity_now;
+	int data[CISD_DATA_MAX];
+};
+
+#endif /* __SEC_CISD_H */
diff -Naur linux-3.18.14/drivers/battery_v2/include/sec_multi_charger.h samsung/drivers/battery_v2/include/sec_multi_charger.h
--- linux-3.18.14/drivers/battery_v2/include/sec_multi_charger.h	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/include/sec_multi_charger.h	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,92 @@
+/*
+ * sec_multi_charger.h
+ * Samsung Mobile Charger Header
+ *
+ * Copyright (C) 2015 Samsung Electronics, Inc.
+ *
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef __SEC_MULTI_CHARGER_H
+#define __SEC_MULTI_CHARGER_H __FILE__
+
+#include "sec_charging_common.h"
+
+#define SEC_SUB_CHARGER_CONDITION_NONE			0x00
+#define SEC_SUB_CHARGER_CONDITION_ONLINE		0x01
+#define SEC_SUB_CHARGER_CONDITION_CV			0x02
+#define SEC_SUB_CHARGER_CONDITION_CHARGE_DONE	0x04
+#define SEC_SUB_CHARGER_CONDITION_CURRENT_MAX	0x10
+#define SEC_SUB_CHARGER_CONDITION_CURRENT_NOW	0x20
+#define SEC_SUB_CHARGER_CONDITION_CHARGE_POWER	0x40
+
+#define SEC_SUB_CHARGER_CURRENT_MARGIN			100
+
+#define SEC_MULTI_CHARGER_TEST_MASTER_MODE_CURRENT	1450
+#define SEC_MULTI_CHARGER_TEST_SLAVE_MODE_CURRENT	700
+
+enum sec_multi_charger_mode {
+	SEC_MULTI_CHARGER_NORMAL = 0, /* Main Charger Default ON;  Sub charger: depend on sub_charger_condition */
+	SEC_MULTI_CHARGER_MAIN_ONLY,
+	SEC_MULTI_CHARGER_SUB_ONLY,
+	SEC_MULTI_CHARGER_ALL_ENABLE,
+};
+
+struct sec_multi_charger_platform_data {
+	char *battery_name;
+	char *main_charger_name;
+	char *sub_charger_name;
+
+	bool is_serial;
+	bool aicl_disable;
+
+	unsigned int sub_charger_condition;
+	unsigned int sub_charger_condition_charge_power;
+	int sub_charger_condition_current_max;
+	unsigned int *sub_charger_condition_online;
+	unsigned int sub_charger_condition_online_size;
+};
+
+struct sec_multi_charger_info {
+	struct device *dev;
+	struct sec_multi_charger_platform_data *pdata;
+	struct power_supply		psy_chg;
+
+	int cable_type;
+	int siop_level;
+	int status;
+
+	/* sub_charger should be disabled before 1st EOC */
+	bool sub_is_charging;
+	int multi_mode;
+
+	sec_charging_current_t total_current;
+	sec_charging_current_t main_current;
+	sec_charging_current_t sub_current;
+
+	int chg_mode;
+#if 0
+	int cable_type;
+	int status;
+	bool is_charging;
+
+	/* charging current : + charging, - OTG */
+	int charging_current;
+	unsigned charging_current_max;
+
+	/* register programming */
+	int reg_addr;
+	int reg_data;
+	int irq_base;
+#endif
+};
+
+#endif /* __SEC_MULTI_CHARGER_H */
diff -Naur linux-3.18.14/drivers/battery_v2/Kconfig samsung/drivers/battery_v2/Kconfig
--- linux-3.18.14/drivers/battery_v2/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/Kconfig	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,611 @@
+
+config BATTERY_SAMSUNG
+	tristate "samsung battery driver"
+	help
+	 Say Y to include support for samsung battery driver
+	 This battery driver integrated all battery-related functions
+	 To see battery-related functions,
+	 refer to sec_charging_common.h
+
+config BATTERY_SAMSUNG_V2
+	tristate "samsung battery driver version 2"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support for samsung battery driver
+	 This battery driver integrated all battery-related functions
+	 To see battery-related functions,
+	 refer to sec_charging_common.h
+
+config BATTERY_SWELLING
+	bool "prevent battery swelling"
+	help
+	  Say Y to include support for prevent battery swelling
+
+config BATTERY_SWELLING_SELF_DISCHARGING
+	bool "prevent battery swelling with self discharging"
+	help
+	  Say Y to include support for prevent battery swelling with self discharging
+
+config CALC_TIME_TO_FULL
+	tristate "calculate time to full"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	  Say Y to use calc time to full function.
+
+config SW_SELF_DISCHARGING
+	bool "enable sw_self_discharging"
+	default n
+	help
+	  Say Y to enable CONFIG_SW_SELF_DISCHARGING
+
+config BATTERY_AGE_FORECAST
+	tristate "battery age forecast"
+	default n
+	depends on BATTERY_SWELLING
+	help
+	Say Y to use battery age forecast
+
+config BATTERY_AGE_FORECAST_DETACHABLE
+	tristate "battery age forecast for detachable"
+	default n
+	select BATTERY_AGE_FORECAST
+	help
+	Say Y to use battery age forecast for detachable
+
+config BATTERY_AGE_FORECAST_B2B
+	tristate "battery age forecast for B2B"
+	default n
+	select BATTERY_AGE_FORECAST
+	help
+	Say Y to use battery age forecast for B2B
+
+config FUELGAUGE_ASOC_FROM_CYCLES
+	bool "FUELGAUGE ASOC output based on mapping with battery cycles"
+	default n
+	depends on BATTERY_AGE_FORECAST
+	help
+	 Say Y to enable support for the mapping of ASOC with charging cycles.
+	 Support for this feature implies that a mapping table has been shared
+	 from HW team and big data side. This feature is providing
+	 support for platform required battery health monitoring concepts.
+
+config DCM_JPN_CONCEPT_FG_CYCLE_CHECK
+	bool "enable fg_cycle_check_value for dcm jpn"
+	default n
+	help
+	 Say Y to use fg_cycle_check_value.
+
+config MULTI_CHARGING
+	bool "support for multi charger ICs"
+	help
+	Say Y to include support for multi charger ICs
+	
+config BATTERY_AGE_FORECAST
+	bool "battery age forecast"
+	default n
+	help
+	Say Y to use enable age forecast algorithm.
+	
+config BATTERY_AGE_FORECAST_DETACHABLE
+	tristate "battery age forecast for detachable"
+	default n
+	select BATTERY_AGE_FORECAST
+	help
+	Say Y to use battery age forecast for detachable
+
+config STEP_CHARGING
+	bool "support for step charging"
+	help
+	 Say Y to include support for step charging
+
+config BATTERY_CISD
+	bool "support for cisd"
+	help
+	 Say Y to include support for cisd
+	 cisd means cell internal short detection
+
+config UPDATE_BATTERY_DATA
+	bool "support for updating battery data"
+	default n
+	depends on BATTERY_SAMSUNG && OF
+	help
+	 Say Y to include support for step charging
+
+config SAMSUNG_BATTERY_ENG_TEST
+	tristate "set test mode in eng build"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to set test mode in eng build
+
+# Fuel Gauge
+
+config FUELGAUGE_DUMMY
+	tristate "dummy fuel gauge driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for dummy fuel gauge driver.
+	 This driver source code implemented
+	 skeleton source code for fuel gauge functions.
+
+config FUELGAUGE_MAX17042
+	tristate "MAX17042 fuel gauge driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for MAXIM MAX17042 fuel gauge driver.
+	 This fuel-gauge can be used in voltage-tracking mode
+	 or coulomb-counting mode.
+
+config FUELGAUGE_MAX17042_VOLTAGE_TRACKING
+	tristate "use MAX17042 fuel gauge only as voltage tracking"
+	default n
+	depends on FUELGAUGE_MAX17042
+	help
+	 Say Y to use MAX17042 fuel gauge
+	 only as voltage tracking.
+	 This mode is for target that consumes low current
+	 like smart-phone.
+
+config FUELGAUGE_MAX17042_COULOMB_COUNTING
+	tristate "use MAX17042 fuel gauge as coulomb counting (including voltage tracking)"
+	default n
+	depends on FUELGAUGE_MAX17042
+	help
+	 Say Y to use MAX17042 fuel gauge
+	 as coulomb counting (including voltage tracking).
+	 This mode is for target that consumes high current
+	 like tablet.
+
+config FUELGAUGE_MAX17048
+	tristate "MAX17048 fuel gauge driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for MAXIM MAX17048 fuel gauge driver.
+	 This fuel-gauge can be used
+	 only in voltage-tracking mode.
+
+config FUELGAUGE_MAX17050
+	tristate "MAX17050 fuel gauge driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for MAXIM MAX17047 or MAX17050 fuel gauge driver.
+	 This fuel-gauge can be used in voltage-tracking mode
+	 or coulomb-counting mode.
+
+config FUELGAUGE_MAX17050_VOLTAGE_TRACKING
+	tristate "use MAX17050 fuel gauge only as voltage tracking"
+	default n
+	depends on FUELGAUGE_MAX17050
+	help
+	 Say Y to use MAX17050 fuel gauge
+	 only as voltage tracking.
+	 This mode is for target that consumes low current
+	 like smart-phone.
+
+config FUELGAUGE_MAX17050_COULOMB_COUNTING
+	tristate "use MAX17050 fuel gauge as coulomb counting (including voltage tracking)"
+	default n
+	depends on FUELGAUGE_MAX17050
+	help
+	 Say Y to use MAX17050 fuel gauge
+	 as coulomb counting (including voltage tracking).
+	 This mode is for target that consumes high current
+	 like tablet.
+
+config FUELGAUGE_MAX77823
+	tristate "MAX77823 fuel gauge driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for MAXIM MAX17047 or MAX17050 fuel gauge driver.
+	 This fuel-gauge can be used in voltage-tracking mode
+	 or coulomb-counting mode.
+
+config FUELGAUGE_MAX77843
+	tristate "MAX77843 fuel gauge driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for MAXIM MAX17047 or MAX17050 fuel gauge driver.
+	 This fuel-gauge can be used in voltage-tracking mode
+	 or coulomb-counting mode.
+
+config FUELGAUGE_MAX77833
+	tristate "MAX77833 fuel gauge driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for MAXIM MAX77833 fuel gauge driver.
+	 This fuel-gauge can be used in coulomb-counting mode.
+
+config FUELGAUGE_MAX77854
+	tristate "MAX77854 fuel gauge driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for MAXIM MAX77854 fuel gauge driver.
+	 This fuel-gauge can be used in coulomb-counting mode.
+
+config FUELGAUGE_MAX77823_VOLTAGE_TRACKING
+	tristate "use MAX77823 fuel gauge only as voltage tracking"
+	default n
+	depends on FUELGAUGE_MAX77823
+	help
+	 Say Y to use MAX17050 fuel gauge
+	 only as voltage tracking.
+	 This mode is for target that consumes low current
+	 like smart-phone.
+
+config FUELGAUGE_MAX77823_COULOMB_COUNTING
+	tristate "use MAX77823 fuel gauge as coulomb counting (including voltage tracking)"
+	default n
+	depends on FUELGAUGE_MAX77823
+	help
+	 Say Y to use MAX77823 fuel gauge
+	 as coulomb counting (including voltage tracking).
+	 This mode is for target that consumes high current
+	 like tablet.
+
+config FUELGAUGE_S2MU004
+	tristate "S2MU004 fuel gauge driver"
+	default n
+	depends on (MFD_S2MU004) && I2C
+	help
+	 Say y to include support for s.lsi s2mu004 fuel gauge driver.
+
+config FUELGAUGE_S2MU005
+	tristate "S2MU005 fuel gauge driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	  Say Y to include support
+	  for S.LSI S2MU005 fuel gauge driver.
+
+
+config FUELGAUGE_SM5703
+	 tristate "SM5703 fuel gauge driver"
+	 default n
+	 depends on BATTERY_SAMSUNG
+	 help
+	  Say Y to include support SM5703 FUELGAUGE.
+	  Using coulomb counting.
+ 
+config FUELGAUGE_SM5705
+	tristate "Siliconmitus SM5705 Fuel Gauge"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	  SM5705 is fuel-gauge systems for lithium-ion (Li+) batteries
+	  in handheld and portable equipment. The SM5705 is configured
+	  to operate with a single lithium cell
+ 
+# Charger
+
+config CHARGER_DUMMY
+	tristate "dummy charger driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for dummy charger driver.
+	 This driver source code implemented
+	 skeleton source code for charger functions.
+
+config CHARGER_MAX8903
+	tristate "MAX8903 charger driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for MAXIM MAX8903 charger driver.
+	 This driver source code implemented
+	 all functions for MAX8903 charger.
+
+config CHARGER_SMB328
+	tristate "SMB328 charger driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for Summit SMB328 charger driver.
+	 This driver source code implemented
+	 all functions for SMB328 charger.
+
+config CHARGER_SMB347
+	tristate "SMB347 charger driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for Summit SMB347 charger driver.
+	 This driver source code implemented
+	 all functions for SMB347 charger.
+
+config CHARGER_BQ24157
+	tristate "BQ24157 charger driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for TI BQ24157 charger driver.
+	 This driver source code implemented
+	 all functions for BQ24157 charger.
+
+config CHARGER_BQ24190
+	tristate "BQ24190 charger driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for TI BQ24190 charger driver.
+	 This driver source code implemented
+	 all functions for BQ24190 charger.
+
+config CHARGER_BQ24191
+	tristate "BQ24191 charger driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for TI BQ24191 charger driver.
+	 This driver source code implemented
+	 all functions for BQ24191 charger.
+
+config CHARGER_BQ24260
+	tristate "BQ24260 charger driver"
+	default n
+	depends on BATTERY_SAMSUNG
+	help
+	 Say Y to include support
+	 for TI BQ24260 charger driver.
+	 This driver source code implemented
+	 all functions for BQ24260 charger.
+
+config CHARGER_MAX77693
+	tristate "MAX77693 battery charger support"
+	depends on MFD_MAX77693 && I2C
+	help
+	  Say Y here to enable support for the MAX77693 charger
+	  MAX77693 incluse muic, pmic, haptic, led,
+	  flash driver.
+	  You have to define MFD_MAX77693
+
+config CHARGER_MAX77823
+	tristate "MAX77823 battery charger support"
+	depends on BATTERY_SAMSUNG
+	help
+	  Say Y here to enable support for the MAX77823 charger
+
+config CHARGER_MAX77843
+	tristate "MAX77843 battery charger support"
+	depends on BATTERY_SAMSUNG
+	help
+	  Say Y here to enable support for the MAX77843 charger
+
+config CHARGER_MAX77833
+	tristate "MAX77833 battery charger support"
+	depends on BATTERY_SAMSUNG
+	help
+	  Say Y here to enable support for the MAX77833 charger
+
+config CHARGER_MAX77854
+	tristate "MAX77854 battery charger support"
+	depends on BATTERY_SAMSUNG
+	help
+	  Say Y here to enable support for the MAX77854 charger
+
+config CHARGER_MAX77804
+	tristate "MAX77804 battery charger support"
+	depends on (MFD_MAX77804 || MFD_MAX77804K) && I2C
+	help
+	  Say Y here to enable support for the MAX77804 charger
+	  MAX77804 incluse muic, pmic, haptic, led,
+	  flash driver.
+	  You have to define MFD_MAX77804
+
+config CHARGER_MAX77888
+	tristate "MAX77888 battery charger support"
+	depends on (MFD_MAX77888) && I2C
+	help
+	  Say Y here to enable support for the MAX77888 charger
+	  MAX77888 incluse muic, pmic, haptic, led,
+	  flash driver.
+	  You have to define MFD_MAX77888
+
+
+config CHARGER_SM5703
+	tristate "SM5703 battery charger support"
+	depends on MFD_SM5703 && I2C
+	help
+	  Say Y here to enable support for the SM5703 charger
+	  SM5703 incluse led, flash driver.
+	  You have to define MFD_SM5703
+
+config CHARGER_SM5705
+	tristate "SM5705 battery charger support"
+	depends on MFD_SM5705 && I2C
+	help
+	  Say Y here to enable support for the SM5705 charger
+
+config CHARGER_SM5703_SOFT_START_CHARGING
+	bool "SM5703 soft step charging"
+	default n
+	depends on CHARGER_SM5703
+	help
+	 Say Y here to enable support for SM5703 soft step charging
+	 You have to define CHARGER_SM5703
+
+config CHARGER_SM5703_DUALPATH
+	bool "SM5703 dual path"
+	default n
+	depends on CHARGER_SM5703
+	help
+	  Say Y here to enable support for SM5703 dual path setting for suspending the charger in battery removal/VF open test scenario
+	  You have to define CHARGER_SM5703
+
+config CHARGER_S2MU003
+        tristate "S2MU003 charger support"
+        depends on (MFD_S2MU003) && I2C
+        help
+         Say Y here to enable support for the S2MU003 charger
+         S2MU003 incluse pmic, led driver.
+         You have to define MFD_S2MU003
+
+config CHARGER_S2MU004
+	tristate "S2MU004 charger support"
+	depends on (MFD_S2MU004) && I2C
+	help
+	 Say Y here to enable support for the S2MU004 charger.
+	 S2MU004 includes pmic, led, haptic, flash.
+	 You have to define MFD_S2MU004
+
+config CHARGER_S2MU005
+	tristate "S2MU005 charger support"
+	depends on (MFD_S2MU005) && I2C
+	help
+	  Say Y here to enable support for the S2MU005 charger
+	  S2MU005 incluse pmic, led driver.
+	  You have to define MFD_S2MU005
+
+config S2MU005_INNER_BATTERY
+	tristate "S2MU005 inner battery type"
+	depends on (MFD_S2MU005) && I2C
+	help
+	  Say Y here to enable support marking project using S2MU005
+	  which use internal battery type
+	  You have to define MFD_S2MU005
+
+config CHARGER_SMA7P10
+	tristate "SMA7P01 sub-charger support"
+	depends on I2C
+	help
+	 Say Y here to enable support for the SMA7P01 charger.
+
+config CHARGER_DA9155
+	tristate "DA9155 charger driver"
+	default n
+	help
+	Say Y here to support for the da9155 charger
+	The DA9155 is a slave charger that extends
+	the current capability of an existing charging solution.
+
+config WIRELESS_CHARGER_HIGH_VOLTAGE
+	tristate "high voltage wireless charger"
+	depends on BATTERY_SAMSUNG && I2C
+	help
+	  Say Y here to enable support for the wireless charger charger
+	  driver.
+
+config CS100_JPNCONCEPT
+	tristate "cs100 command support"
+	depends on BATTERY_SAMSUNG && I2C
+	help
+	 Say Y here to support for CS100 command to stop when full-charged
+	 on wireless charging for JPN models
+
+config WIRELESS_CHARGER_BQ51221
+        tristate "bq51221 battery charger support"
+        depends on BATTERY_SAMSUNG && I2C
+        help
+          Say Y here to enable support for the bq51221 charger
+          bq51221 wireless charger driver.
+
+config WIRELESS_CHARGER_P9220
+	tristate "p9220 battery charger support"
+	depends on BATTERY_SAMSUNG && I2C
+	help
+	  Say Y here to enable support for the p9220 charger
+	  p9220 wireless charger driver.
+
+config WIRELESS_FIRMWARE_UPDATE
+	tristate "p9220 battery charger support"
+	depends on WIRELESS_CHARGER_P9220
+	help
+	  Say Y here to enable support for the p9220 charger firmware update
+	  p9220 wireless charger IC firmware update.
+
+config AFC_CHARGER_MODE
+	bool "afc charging support in sec battery driver"
+	default n
+	depends on (CHARGER_MAX77854 || CHARGER_S2MU004) && BATTERY_SAMSUNG
+	help
+	  Say Y to include support for sec afc charging support
+
+config SAMSUNG_LPM_MODE
+	bool "Off charging mode support in sec battery driver"
+	default n
+	help
+	  Say Y to include support for sec off charging support
+	  This value defined at bootloader.
+	  Before enable this feature,
+	  implemet power off charging in the bootloader.
+
+config EN_OOPS
+	bool "enable oops filter"
+	default n
+	help
+	  Say Y to enable oops filter
+
+config USE_POGO
+       bool "enable pogo charging"
+       default n
+       help
+	 Say Y to enable CONFIG_USE_POGO
+
+config STORE_MODE
+       bool "enable store mode"
+       default n
+       help
+	 Say Y to enable CONFIG_STORE_MODE
+
+config BATTERY_NOTIFIER
+	bool "battery notifier"
+	default n
+	help
+	  Say Y to enable battery notifier
+	  
+config XADC_SHARE_BATT_WITH_USB_THM
+	bool "To use xadc mux for BAT_THM with USB_THM"
+	default n
+	help
+	  Say Y to enable use xadc mux for BAT_THM with USB_THM
+
+config THM_MUX_SHARE
+	bool "To use xadc mux for BAT_THM with AP_THM"
+	default n
+	help
+	  Say Y to enable use xadc mux for BAT_THM with AP_THM
+	  
+config S2MU005_EVT4_DISABLE_BUCK_MODE
+	bool "Disable buck only mode in S2MU005X03"
+	default n
+	depends on CHARGER_S2MU005
+	help
+	  Say Y to enable use all-off mode in S2MU005X03
+
+config ENABLE_100MA_CHARGING_BEFORE_USB_CONFIGURED
+	bool "enable 100mA before usb configured"
+	default n
+	help
+	  Say Y to enable 100mA before usb configured
+
+config TYPEB_WATERPROOF_MODEL
+	bool "enable typeb_waterproof_model"
+	default n
+	help
+	  Say Y here to enable typeb_waterproof_model
+
diff -Naur linux-3.18.14/drivers/battery_v2/Makefile samsung/drivers/battery_v2/Makefile
--- linux-3.18.14/drivers/battery_v2/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/Makefile	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,44 @@
+obj-$(CONFIG_BATTERY_SAMSUNG)	+= sec_battery.o
+obj-$(CONFIG_OF)		+= sec_adc.o
+obj-$(CONFIG_MULTI_CHARGING)	+= sec_multi_charger.o
+obj-$(CONFIG_STEP_CHARGING)	+= sec_step_charging.o
+obj-$(CONFIG_BATTERY_CISD)	+= sec_cisd.o
+obj-$(CONFIG_UPDATE_BATTERY_DATA)	+= sec_battery_data.o
+obj-$(CONFIG_BATTERY_NOTIFIER)	+= battery_notifier.o
+
+obj-$(CONFIG_FUELGAUGE_MAX17042)	+= max17042_fuelgauge.o sec_fuelgauge.o
+obj-$(CONFIG_FUELGAUGE_MAX17048)	+= max17048_fuelgauge.o sec_fuelgauge.o
+obj-$(CONFIG_FUELGAUGE_MAX17050)	+= max17050_fuelgauge.o sec_fuelgauge.o
+obj-$(CONFIG_FUELGAUGE_MAX77823)	+= max77823_fuelgauge.o
+obj-$(CONFIG_FUELGAUGE_MAX77843)	+= max77843_fuelgauge.o
+obj-$(CONFIG_FUELGAUGE_MAX77833)	+= max77833_fuelgauge.o
+obj-$(CONFIG_FUELGAUGE_S2MU005)        += s2mu005_fuelgauge.o
+obj-$(CONFIG_FUELGAUGE_SM5703)		+= sm5703_fuelgauge.o
+obj-$(CONFIG_FUELGAUGE_MAX77854)	+= max77854_fuelgauge.o
+obj-$(CONFIG_FUELGAUGE_SM5705)		+= sm5705_fuelgauge.o
+obj-$(CONFIG_FUELGAUGE_S2MU004)		+= s2mu004_fuelgauge.o
+
+obj-$(CONFIG_CHARGER_MAX8903)	+= max8903_charger.o
+obj-$(CONFIG_CHARGER_SMB328)	+= smb328_charger.o
+obj-$(CONFIG_CHARGER_SMB347)	+= smb347_charger.o sec_charger.o
+obj-$(CONFIG_CHARGER_BQ24157)	+= bq24157_charger.o sec_charger.o
+obj-$(CONFIG_CHARGER_BQ24190)	+= bq24190_charger.o
+obj-$(CONFIG_CHARGER_BQ24191)	+= bq24190_charger.o
+obj-$(CONFIG_CHARGER_BQ24260)	+= bq24260_charger.o sec_charger.o
+obj-$(CONFIG_CHARGER_MAX77804)  += max77804_charger.o
+obj-$(CONFIG_CHARGER_MAX77693)	+= max77693_charger.o
+obj-$(CONFIG_CHARGER_MAX77823)	+= max77823_charger.o
+obj-$(CONFIG_CHARGER_MAX77843)	+= max77843_charger.o
+obj-$(CONFIG_CHARGER_MAX77888)	+= max77888_charger.o
+obj-$(CONFIG_CHARGER_MAX77833)	+= max77833_charger.o
+obj-$(CONFIG_CHARGER_MAX77854)	+= max77854_charger.o
+obj-$(CONFIG_CHARGER_S2MU003)   += s2mu003_charger.o
+obj-$(CONFIG_CHARGER_DA9155)    += da9155_charger.o
+obj-$(CONFIG_CHARGER_S2MU004)   += s2mu004_charger.o
+obj-$(CONFIG_CHARGER_SMA7P10)   += sma7p10_charger.o
+
+obj-$(CONFIG_WIRELESS_CHARGER_BQ51221)	+= bq51221_charger.o
+obj-$(CONFIG_CHARGER_S2MU005)   += s2mu005_charger.o
+obj-$(CONFIG_CHARGER_SM5703)	+= sm5703_charger.o
+obj-$(CONFIG_CHARGER_SM5705)	+= sm5705_charger.o sm5705_charger_oper.o
+obj-$(CONFIG_WIRELESS_CHARGER_P9220)	+= p9220_charger.o
diff -Naur linux-3.18.14/drivers/battery_v2/max77854_charger.c samsung/drivers/battery_v2/max77854_charger.c
--- linux-3.18.14/drivers/battery_v2/max77854_charger.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/max77854_charger.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,2058 @@
+/*
+ *  max77854_charger.c
+ *  Samsung MAX77854 Charger Driver
+ *
+ *  Copyright (C) 2012 Samsung Electronics
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#define DEBUG
+
+#include <linux/mfd/max77854-private.h>
+#if defined(CONFIG_BATTERY_NOTIFIER)
+#include <linux/battery/battery_notifier.h>
+#endif
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/power_supply.h>
+#include <linux/mfd/max77854.h>
+#include <linux/of_gpio.h>
+#include "include/charger/max77854_charger.h"
+#ifdef CONFIG_USB_HOST_NOTIFY
+#include <linux/usb_notify.h>
+#endif
+
+#define ENABLE 1
+#define DISABLE 0
+
+#if defined(CONFIG_SEC_FACTORY)
+#define WC_CURRENT_WORK_STEP	250
+#else
+#define WC_CURRENT_WORK_STEP	1000
+#endif
+
+extern unsigned int lpcharge;
+
+static enum power_supply_property max77854_charger_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_CHARGE_TYPE,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_CURRENT_MAX,
+	POWER_SUPPLY_PROP_CURRENT_AVG,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL,
+	POWER_SUPPLY_PROP_USB_HC,
+#if defined(CONFIG_BATTERY_SWELLING)
+	POWER_SUPPLY_PROP_VOLTAGE_MAX,
+#endif
+#if defined(CONFIG_AFC_CHARGER_MODE)
+	POWER_SUPPLY_PROP_AFC_CHARGER_MODE,
+#endif
+	POWER_SUPPLY_PROP_CHARGE_NOW,
+};
+
+static enum power_supply_property max77854_otg_props[] = {
+	POWER_SUPPLY_PROP_ONLINE,
+};
+
+static struct device_attribute max77854_charger_attrs[] = {
+	MAX77854_CHARGER_ATTR(chip_id),
+	MAX77854_CHARGER_ATTR(data),
+};
+
+static void max77854_charger_initialize(struct max77854_charger_data *charger);
+static int max77854_get_vbus_state(struct max77854_charger_data *charger);
+static int max77854_get_charger_state(struct max77854_charger_data *charger);
+static void max77854_set_charger_state(struct max77854_charger_data *charger,
+				       int enable);
+static void max77854_enable_aicl_irq(struct max77854_charger_data *charger);
+static bool max77854_charger_unlock(struct max77854_charger_data *charger)
+{
+	u8 reg_data;
+	u8 chgprot;
+	int retry_cnt = 0;
+	bool need_init = false;
+
+	do {
+		max77854_read_reg(charger->i2c, MAX77854_CHG_REG_CNFG_06, &reg_data);
+		chgprot = ((reg_data & 0x0C) >> 2);
+		if (chgprot != 0x03) {
+			pr_err("%s: unlock err, chgprot(0x%x), retry(%d)\n",
+					__func__, chgprot, retry_cnt);
+			max77854_update_reg(charger->i2c, MAX77854_CHG_REG_CNFG_06,
+					(0x03 << 2), (0x03 << 2));
+			need_init = true;
+			msleep(20);
+		} else {
+			pr_debug("%s: unlock success, chgprot(0x%x)\n",
+				__func__, chgprot);
+			break;
+		}
+	} while ((chgprot != 0x03) && (++retry_cnt < 10));
+
+	return need_init;
+}
+
+static void check_charger_unlock_state(struct max77854_charger_data *charger)
+{
+	bool need_reg_init;
+	pr_debug("%s\n", __func__);
+
+	need_reg_init = max77854_charger_unlock(charger);
+	if (need_reg_init) {
+		pr_err("%s: charger locked state, reg init\n", __func__);
+		max77854_charger_initialize(charger);
+	}
+}
+
+static void max77854_test_read(struct max77854_charger_data *charger)
+{
+	u8 data = 0;
+	u32 addr = 0;
+	char str[1024]={0,};
+
+	for (addr = 0xB1; addr <= 0xC3; addr++) {
+		max77854_read_reg(charger->i2c, addr, &data);
+		sprintf(str + strlen(str), "[0x%02x]0x%02x, ", addr, data);
+	}
+	pr_info("MAX77854 : %s\n", str);
+}
+
+static int max77854_get_vbus_state(struct max77854_charger_data *charger)
+{
+	u8 reg_data;
+
+	max77854_read_reg(charger->i2c,
+			  MAX77854_CHG_REG_DETAILS_00, &reg_data);
+
+	if (is_wireless_type(charger->cable_type))
+		reg_data = ((reg_data & MAX77854_WCIN_DTLS) >>
+			    MAX77854_WCIN_DTLS_SHIFT);
+	else
+		reg_data = ((reg_data & MAX77854_CHGIN_DTLS) >>
+			    MAX77854_CHGIN_DTLS_SHIFT);
+
+	switch (reg_data) {
+	case 0x00:
+		pr_info("%s: VBUS is invalid. CHGIN < CHGIN_UVLO\n",
+			__func__);
+		break;
+	case 0x01:
+		pr_info("%s: VBUS is invalid. CHGIN < MBAT+CHGIN2SYS" \
+			"and CHGIN > CHGIN_UVLO\n", __func__);
+		break;
+	case 0x02:
+		pr_info("%s: VBUS is invalid. CHGIN > CHGIN_OVLO",
+			__func__);
+		break;
+	case 0x03:
+		pr_info("%s: VBUS is valid. CHGIN < CHGIN_OVLO", __func__);
+		break;
+	default:
+		break;
+	}
+
+	return reg_data;
+}
+
+static int max77854_get_charger_state(struct max77854_charger_data *charger)
+{
+	int status = POWER_SUPPLY_STATUS_UNKNOWN;
+	u8 reg_data;
+
+	max77854_read_reg(charger->i2c,
+			  MAX77854_CHG_REG_DETAILS_01, &reg_data);
+
+	pr_info("%s : charger status (0x%02x)\n", __func__, reg_data);
+
+	reg_data &= 0x0f;
+
+	switch (reg_data)
+	{
+	case 0x00:
+	case 0x01:
+	case 0x02:
+		status = POWER_SUPPLY_STATUS_CHARGING;
+		break;
+	case 0x03:
+	case 0x04:
+		status = POWER_SUPPLY_STATUS_FULL;
+		break;
+	case 0x05:
+	case 0x06:
+	case 0x07:
+		status = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		break;
+	case 0x08:
+	case 0xA:
+	case 0xB:
+		status = POWER_SUPPLY_STATUS_DISCHARGING;
+		break;
+	default:
+		status = POWER_SUPPLY_STATUS_UNKNOWN;
+		break;
+	}
+
+	return (int)status;
+}
+
+static bool max77854_is_constant_current(struct max77854_charger_data *charger)
+{
+	u8 reg_data;
+
+	max77854_read_reg(charger->i2c,
+			  MAX77854_CHG_REG_DETAILS_01, &reg_data);
+	pr_info("%s : charger status (0x%02x)\n", __func__, reg_data);
+	reg_data &= 0x0f;
+
+	if (reg_data == 0x01)
+		return true;
+	return false;
+}
+
+static void max77854_set_float_voltage(struct max77854_charger_data *charger, int float_voltage)
+{
+	u8 reg_data = 0;
+
+	reg_data = float_voltage <= 40500 ? 0x0 :
+		float_voltage >= 45000 ? 0x24 :
+		(float_voltage - 40500) / 125;
+
+	max77854_update_reg(charger->i2c, MAX77854_CHG_REG_CNFG_04,
+	        (reg_data << CHG_CNFG_04_CHG_CV_PRM_SHIFT),
+	        CHG_CNFG_04_CHG_CV_PRM_MASK);
+
+	max77854_read_reg(charger->i2c, MAX77854_CHG_REG_CNFG_04, &reg_data);
+	pr_info("%s: battery cv voltage 0x%x\n", __func__, reg_data);
+}
+
+static u8 max77854_get_float_voltage(struct max77854_charger_data *charger)
+{
+	u8 reg_data = 0;
+	int float_voltage;
+
+	max77854_read_reg(charger->i2c, MAX77854_CHG_REG_CNFG_04, &reg_data);
+	reg_data &= 0x3F;
+	float_voltage = reg_data * 125 + 40500;
+	pr_debug("%s: battery cv reg : 0x%x, float voltage val : %d\n",
+		__func__, reg_data, float_voltage);
+
+	return reg_data;
+}
+static int max77854_get_charging_health(struct max77854_charger_data *charger)
+{
+	int state;
+	int vbus_state;
+	int retry_cnt;
+	u8 chg_dtls, reg_data;
+	u8 chg_cnfg_00;
+
+	/* watchdog kick */
+	max77854_update_reg(charger->i2c, MAX77854_CHG_REG_CNFG_06,
+			MAX77854_WDTCLR, MAX77854_WDTCLR);
+
+	max77854_read_reg(charger->i2c,
+			MAX77854_CHG_REG_DETAILS_01, &reg_data);
+	reg_data = ((reg_data & MAX77854_BAT_DTLS) >> MAX77854_BAT_DTLS_SHIFT);
+
+	pr_info("%s: reg_data(0x%x)\n", __func__, reg_data);
+	switch (reg_data) {
+	case 0x00:
+		pr_info("%s: No battery and the charger is suspended\n",
+			__func__);
+		state = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;
+		break;
+	case 0x01:
+		pr_info("%s: battery is okay "
+			"but its voltage is low(~VPQLB)\n", __func__);
+		state = POWER_SUPPLY_HEALTH_GOOD;
+		break;
+	case 0x02:
+		pr_info("%s: battery dead\n", __func__);
+		state = POWER_SUPPLY_HEALTH_DEAD;
+		break;
+	case 0x03:
+		state = POWER_SUPPLY_HEALTH_GOOD;
+		break;
+	case 0x04:
+		pr_info("%s: battery is okay" \
+			"but its voltage is low\n", __func__);
+		state = POWER_SUPPLY_HEALTH_GOOD;
+		break;
+	case 0x05:
+		pr_info("%s: battery ovp\n", __func__);
+		state = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+		break;
+	default:
+		pr_info("%s: battery unknown : 0x%x\n", __func__, reg_data);
+		state = POWER_SUPPLY_HEALTH_UNKNOWN;
+		break;
+	}
+
+	if (state == POWER_SUPPLY_HEALTH_GOOD) {
+		union power_supply_propval value;
+		psy_do_property("battery", get,
+				POWER_SUPPLY_PROP_HEALTH, value);
+		/* VBUS OVP state return battery OVP state */
+		vbus_state = max77854_get_vbus_state(charger);
+		/* read CHG_DTLS and detecting battery terminal error */
+		max77854_read_reg(charger->i2c,
+				  MAX77854_CHG_REG_DETAILS_01, &chg_dtls);
+		chg_dtls = ((chg_dtls & MAX77854_CHG_DTLS) >>
+			    MAX77854_CHG_DTLS_SHIFT);
+		max77854_read_reg(charger->i2c,
+				  MAX77854_CHG_REG_CNFG_00, &chg_cnfg_00);
+
+		/* print the log at the abnormal case */
+		if((charger->is_charging == 1) && (chg_dtls & 0x08)) {
+			max77854_test_read(charger);
+			max77854_set_charger_state(charger, DISABLE);
+			max77854_set_float_voltage(charger, charger->float_voltage);
+			max77854_set_charger_state(charger, ENABLE);
+		}
+
+		pr_info("%s: vbus_state : 0x%x, chg_dtls : 0x%x\n", __func__, vbus_state, chg_dtls);
+		/*  OVP is higher priority */
+		if (vbus_state == 0x02) { /*  CHGIN_OVLO */
+			pr_info("%s: vbus ovp\n", __func__);
+			state = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+			if (is_wireless_type(charger->cable_type)) {
+				retry_cnt = 0;
+				do {
+					msleep(50);
+					vbus_state = max77854_get_vbus_state(charger);
+				} while((retry_cnt++ < 2) && (vbus_state == 0x02));
+				if (vbus_state == 0x02) {
+					state = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+					pr_info("%s: wpc and over-voltage\n", __func__);
+				} else
+					state = POWER_SUPPLY_HEALTH_GOOD;
+			}
+		} else if (((vbus_state == 0x0) || (vbus_state == 0x01)) && (chg_dtls & 0x08) && \
+			    (chg_cnfg_00 & MAX77854_MODE_BUCK) &&	\
+			    (chg_cnfg_00 & MAX77854_MODE_CHGR) &&	\
+			    is_not_wireless_type(charger->cable_type)) {
+			pr_info("%s: vbus is under\n", __func__);
+			state = POWER_SUPPLY_HEALTH_UNDERVOLTAGE;
+		} else if ((value.intval == POWER_SUPPLY_HEALTH_UNDERVOLTAGE) && \
+				((vbus_state == 0x0) || (vbus_state == 0x01)) && \
+				is_not_wireless_type(charger->cable_type)) {
+			pr_info("%s: keep under-voltage\n", __func__);
+			state = POWER_SUPPLY_HEALTH_UNDERVOLTAGE;
+		}
+	}
+
+	return (int)state;
+}
+
+static int max77854_get_charge_current(struct max77854_charger_data *charger)
+{
+	u8 reg_data;
+	int get_current = 0;
+
+	max77854_read_reg(charger->i2c,
+		MAX77854_CHG_REG_CNFG_02, &reg_data);
+	reg_data &= MAX77854_CHG_CC;
+
+	get_current = reg_data <= 0x2 ? 100 : reg_data * 50;
+
+	return get_current;
+}
+
+static int max77854_get_input_current_type(struct max77854_charger_data *charger,
+	int cable_type)
+{
+	u8 reg_data;
+	int get_current = 0;
+
+	if (cable_type == POWER_SUPPLY_TYPE_WIRELESS) {
+		max77854_read_reg(charger->i2c,
+			MAX77854_CHG_REG_CNFG_10, &reg_data);
+		/* AND operation for removing the formal 2bit  */
+		reg_data &= 0x3F;
+
+		if (reg_data <= 0x3)
+			get_current = 90;
+		else
+			get_current = reg_data * 30;
+	} else {
+		max77854_read_reg(charger->i2c,
+			MAX77854_CHG_REG_CNFG_09, &reg_data);
+		/* AND operation for removing the formal 1bit  */
+		reg_data &= 0x7F;
+
+		if (reg_data <= 0x3) {
+			get_current = 100;
+		} else if (reg_data >= 0x78) {
+			get_current = 4000;
+		} else {
+			int quotient, remainder;
+			quotient = reg_data / 3;
+			remainder = reg_data % 3;
+			if (remainder == 0)
+				get_current = quotient * 100;
+			else if (remainder == 1)
+				get_current = quotient * 100 + 33;
+			else
+				get_current = quotient * 100 + 67;
+		}
+	}
+
+	return get_current;
+}
+
+static int max77854_get_input_current(struct max77854_charger_data *charger)
+{
+	if (is_wireless_type(charger->cable_type))
+		return max77854_get_input_current_type(charger, POWER_SUPPLY_TYPE_WIRELESS);
+	else
+		return max77854_get_input_current_type(charger, POWER_SUPPLY_TYPE_MAINS);
+}
+
+static void reduce_input_current(struct max77854_charger_data *charger, int cur)
+{
+	u8 set_reg, set_value;
+	unsigned int input_curr_limit_step = 0;
+
+	if (is_wireless_type(charger->cable_type)) {
+		set_reg = MAX77854_CHG_REG_CNFG_10;
+		input_curr_limit_step = 30;
+	} else {
+		set_reg = MAX77854_CHG_REG_CNFG_09;
+		input_curr_limit_step = 33;
+	}
+
+	if (!max77854_read_reg(charger->i2c, set_reg, &set_value)) {
+		if (set_value <= (MINIMUM_INPUT_CURRENT / input_curr_limit_step) ||
+		    set_value <= (cur / input_curr_limit_step))
+			return;
+		set_value -= (cur / input_curr_limit_step);
+		set_value = (set_value < (MINIMUM_INPUT_CURRENT / input_curr_limit_step)) ?
+			(MINIMUM_INPUT_CURRENT / input_curr_limit_step) : set_value;
+		max77854_write_reg(charger->i2c, set_reg, set_value);
+		pr_info("%s: set current: reg:(0x%x), val:(0x%x)\n",
+			__func__, set_reg, set_value);
+		charger->input_current = max77854_get_input_current(charger);
+		charger->aicl_on = true;
+	}
+}
+
+static bool max77854_check_battery(struct max77854_charger_data *charger)
+{
+	u8 reg_data;
+	u8 reg_data2;
+
+	max77854_read_reg(charger->i2c,
+			  MAX77854_CHG_REG_INT_OK, &reg_data);
+
+	pr_info("%s : CHG_INT_OK(0x%x)\n", __func__, reg_data);
+
+	max77854_read_reg(charger->i2c,
+			  MAX77854_CHG_REG_DETAILS_00, &reg_data2);
+
+	pr_info("%s : CHG_DETAILS00(0x%x)\n", __func__, reg_data2);
+
+	if ((reg_data & MAX77854_BATP_OK) ||
+	    !(reg_data2 & MAX77854_BATP_DTLS))
+		return true;
+	else
+		return false;
+}
+
+static void max77854_set_buck(struct max77854_charger_data *charger,
+		int enable)
+{
+	u8 reg_data;
+
+	if (enable) {
+		max77854_update_reg(charger->i2c, MAX77854_CHG_REG_CNFG_00,
+				CHG_CNFG_00_BUCK_MASK, CHG_CNFG_00_BUCK_MASK);
+	} else {
+		max77854_update_reg(charger->i2c, MAX77854_CHG_REG_CNFG_00,
+				0, CHG_CNFG_00_BUCK_MASK);
+	}
+	max77854_read_reg(charger->i2c, MAX77854_CHG_REG_CNFG_00, &reg_data);
+	pr_info("%s : CHG_CNFG_00(0x%02x)\n", __func__, reg_data);
+}
+
+static void max77854_change_charge_path(struct max77854_charger_data *charger,
+		int path)
+{
+	u8 cnfg12;
+
+	if (is_wireless_type(path)) {
+		cnfg12 = (0 << CHG_CNFG_12_CHGINSEL_SHIFT);
+	} else {
+		cnfg12 = (1 << CHG_CNFG_12_CHGINSEL_SHIFT);
+	}
+
+	max77854_update_reg(charger->i2c, MAX77854_CHG_REG_CNFG_12,
+		cnfg12,	CHG_CNFG_12_CHGINSEL_MASK);
+	max77854_read_reg(charger->i2c, MAX77854_CHG_REG_CNFG_12, &cnfg12);
+	pr_info("%s : CHG_CNFG_12(0x%02x)\n", __func__, cnfg12);
+}
+
+static void max77854_set_input_current(struct max77854_charger_data *charger,
+				       int input_current)
+{
+	int quotient, remainder;
+	u8 set_reg, reg_data;
+
+	mutex_lock(&charger->charger_mutex);
+	if (is_wireless_type(charger->cable_type)) {
+		set_reg = MAX77854_CHG_REG_CNFG_10;
+		max77854_read_reg(charger->i2c,
+				  set_reg, &reg_data);
+		reg_data &= ~MAX77854_CHG_WCIN_LIM;
+	} else {
+		set_reg = MAX77854_CHG_REG_CNFG_09;
+		max77854_read_reg(charger->i2c,
+				  set_reg, &reg_data);
+		reg_data &= ~MAX77854_CHG_CHGIN_LIM;
+	}
+
+	if (!input_current) {
+		max77854_write_reg(charger->i2c,
+				   set_reg, reg_data);
+	} else if (is_wireless_type(charger->cable_type)) {
+		input_current = (input_current > 1890) ? 1890 : input_current;
+		quotient = input_current / 30;
+		reg_data |= quotient;
+		max77854_write_reg(charger->i2c, set_reg, reg_data);
+	} else {
+		input_current = (input_current > 4000) ? 4000 : input_current;
+		quotient = input_current / 100;
+		remainder = input_current % 100;
+
+		if (remainder >= 67)
+			reg_data |= (quotient * 3) + 2;
+		else if (remainder >= 33)
+			reg_data |= (quotient * 3) + 1;
+		else if (remainder < 33)
+			reg_data |= quotient * 3;
+
+		max77854_write_reg(charger->i2c,
+				   set_reg, reg_data);
+	}
+
+	mutex_unlock(&charger->charger_mutex);
+	pr_info("[%s] REG(0x%02x) DATA(0x%02x), CURRENT(%d)\n",
+		__func__, set_reg, reg_data, input_current);
+}
+
+static void max77854_set_charge_current(struct max77854_charger_data *charger,
+					int fast_charging_current)
+{
+	int curr_step = 50;
+	u8 reg_data;
+
+	max77854_read_reg(charger->i2c,
+			  MAX77854_CHG_REG_CNFG_02, &reg_data);
+	reg_data &= ~MAX77854_CHG_CC;
+
+	if (!fast_charging_current) {
+		max77854_write_reg(charger->i2c,
+				   MAX77854_CHG_REG_CNFG_02, reg_data);
+	} else {
+		fast_charging_current = (fast_charging_current > 3150) ? 3150 : fast_charging_current;
+		reg_data |= (fast_charging_current / curr_step);
+		max77854_write_reg(charger->i2c,MAX77854_CHG_REG_CNFG_02, reg_data);
+	}
+
+	pr_info("[%s] REG(0x%02x) DATA(0x%02x), CURRENT(%d)\n",
+		__func__, MAX77854_CHG_REG_CNFG_02,
+		reg_data, fast_charging_current);
+}
+
+static void max77854_set_wireless_input_current(struct max77854_charger_data *charger,
+				       int input_current)
+{
+	union power_supply_propval value;
+
+	wake_lock(&charger->wc_current_wake_lock);
+	if (is_wireless_type(charger->cable_type)) {
+		/* Wcurr-A) In cases of wireless input current change,
+			configure the Vrect adj room to 270mV for safe wireless charging. */
+		wake_lock(&charger->wc_current_wake_lock);
+		value.intval = WIRELESS_VRECT_ADJ_ROOM_1; /* 270mV */
+		psy_do_property(charger->pdata->wireless_charger_name, set,
+			POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+		msleep(500); /* delay 0.5sec */
+		charger->wc_pre_current = max77854_get_input_current(charger);
+		charger->wc_current = input_current;
+		if (charger->wc_current > charger->wc_pre_current) {
+			max77854_set_charge_current(charger, charger->charging_current);
+		}
+	}
+	queue_delayed_work(charger->wqueue, &charger->wc_current_work, 0);
+}
+
+static void max77854_set_topoff_current(struct max77854_charger_data *charger,
+					int termination_current)
+{
+	int curr_base = 150, curr_step = 50;
+	u8 reg_data;
+
+	if (termination_current < curr_base)
+		termination_current = curr_base;
+	else if (termination_current > 500)
+		termination_current = 500;
+
+	reg_data = (termination_current - curr_base) / curr_step;
+	max77854_update_reg(charger->i2c, MAX77854_CHG_REG_CNFG_03,
+		reg_data, MAX77854_CHG_TO_ITH);
+
+	pr_info("%s: reg_data(0x%02x), topoff(%dmA)\n",
+		__func__, reg_data, termination_current);
+}
+
+static void max77854_set_charger_state(struct max77854_charger_data *charger,
+	int enable)
+{
+	u8 cnfg_00, cnfg_12;
+
+	if (enable) {
+		max77854_update_reg(charger->i2c, MAX77854_CHG_REG_CNFG_00,
+				CHG_CNFG_00_CHG_MASK, CHG_CNFG_00_CHG_MASK);
+		max77854_update_reg(charger->i2c, MAX77854_CHG_REG_CNFG_12,
+				0x1, CHG_CNFG_12_DISSKIP);
+	} else {
+		max77854_update_reg(charger->i2c, MAX77854_CHG_REG_CNFG_00,
+				0, CHG_CNFG_00_CHG_MASK);
+		max77854_update_reg(charger->i2c, MAX77854_CHG_REG_CNFG_12,
+				0x0, CHG_CNFG_12_DISSKIP);
+	}
+	max77854_read_reg(charger->i2c, MAX77854_CHG_REG_CNFG_00, &cnfg_00);
+	max77854_read_reg(charger->i2c, MAX77854_CHG_REG_CNFG_12, &cnfg_12);
+	pr_info("%s : CHG_CNFG_00(0x%02x), CHG_CNFG_12(0x%02x)\n", __func__, cnfg_00, cnfg_12);
+}
+
+static void max77854_check_slow_charging(struct max77854_charger_data *charger,
+	int input_current)
+{
+	/* under 400mA considered as slow charging concept for VZW */
+	if (input_current <= SLOW_CHARGING_CURRENT_STANDARD &&
+		charger->cable_type != POWER_SUPPLY_TYPE_BATTERY) {
+		union power_supply_propval value;
+
+		charger->slow_charging = true;
+		pr_info("%s: slow charging on : input current(%dmA), cable type(%d)\n",
+			__func__, input_current, charger->cable_type);
+
+		psy_do_property("battery", set,
+			POWER_SUPPLY_PROP_CHARGE_TYPE, value);
+	}
+	else
+		charger->slow_charging = false;
+}
+
+static void max77854_charger_initialize(struct max77854_charger_data *charger)
+{
+	u8 reg_data;
+	int jig_gpio;
+	pr_info("%s\n", __func__);
+
+	/* unmasked: CHGIN_I, WCIN_I, BATP_I, BYP_I	*/
+	/*max77854_write_reg(charger->i2c, MAX77854_CHG_REG_INT_MASK, 0x9a);*/
+
+	/* unlock charger setting protect */
+	reg_data = (0x03 << 2);
+	max77854_update_reg(charger->i2c, MAX77854_CHG_REG_CNFG_06, reg_data, reg_data);
+
+	/*
+	 * fast charge timer disable
+	 * restart threshold disable
+	 * pre-qual charge disable
+	 */
+	reg_data = (0x03 << 4);
+	reg_data |= 0x08;
+	max77854_write_reg(charger->i2c, MAX77854_CHG_REG_CNFG_01, reg_data);
+
+	/*
+	 * charge current 466mA(default)
+	 * otg current limit 900mA
+	 */
+	max77854_update_reg(charger->i2c, MAX77854_CHG_REG_CNFG_02,
+			(0x01 << 6), 0xC0);
+
+	/* BAT to SYS OCP 5.00A */
+	max77854_update_reg(charger->i2c, MAX77854_CHG_REG_CNFG_05, 0x05, 0x07);
+	/*
+	 * top off current 150mA
+	 * top off timer 70min
+	 */
+	reg_data = 0x38;
+	max77854_write_reg(charger->i2c, MAX77854_CHG_REG_CNFG_03, reg_data);
+
+	/*
+	 * cv voltage 4.2V or 4.35V
+	 * MINVSYS 3.6V(default)
+	 */
+	max77854_set_float_voltage(charger, charger->pdata->chg_float_voltage);
+
+	/* 
+	* VCHGIN & WCHGIN regulation threshold set 4.3v, uvlo 4.5V
+	* Auto skip mode
+	*/
+	max77854_update_reg(charger->i2c, MAX77854_CHG_REG_CNFG_12,
+		0x0, CHG_CNFG_12_VCHGIN_REG_MASK|CHG_CNFG_12_WCIN_REG_MASK);
+
+	/* Boost mode possible in FACTORY MODE */
+	max77854_update_reg(charger->i2c, MAX77854_CHG_REG_CNFG_07,
+			MAX77854_CHG_FMBST, CHG_CNFG_07_REG_FMBST_MASK);
+
+	jig_gpio = gpio_get_value(charger->jig_gpio);
+	max77854_update_reg(charger->i2c, MAX77854_CHG_REG_CNFG_07,
+			(jig_gpio << CHG_CNFG_07_REG_FGSRC_SHIFT),
+			CHG_CNFG_07_REG_FGSRC_MASK);
+
+	/* Watchdog Enable */
+	max77854_update_reg(charger->i2c, MAX77854_CHG_REG_CNFG_00,
+			MAX77854_WDTEN, MAX77854_WDTEN);
+
+	//max77854_test_read(charger);
+}
+
+static int max77854_chg_create_attrs(struct device *dev)
+{
+	int i, rc;
+
+	for (i = 0; i < ARRAY_SIZE(max77854_charger_attrs); i++) {
+		rc = device_create_file(dev, &max77854_charger_attrs[i]);
+		if (rc)
+			goto create_attrs_failed;
+	}
+	return rc;
+
+create_attrs_failed:
+	dev_err(dev, "%s: failed (%d)\n", __func__, rc);
+	while (i--)
+		device_remove_file(dev, &max77854_charger_attrs[i]);
+	return rc;
+}
+
+ssize_t max77854_chg_show_attrs(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct max77854_charger_data *charger =
+		container_of(psy, struct max77854_charger_data, psy_chg);
+	const ptrdiff_t offset = attr - max77854_charger_attrs;
+	int i = 0;
+	u8 addr, data;
+
+	switch(offset) {
+	case CHIP_ID:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%s\n",
+			       (charger->pmic_ver >= 0x1 && charger->pmic_ver <= 0x03) ?
+			       "MAX77854" : "Unknown");
+		break;
+	case DATA:
+		for (addr = 0xB1; addr <= 0xC3; addr++) {
+			max77854_read_reg(charger->i2c, addr, &data);
+			i += scnprintf(buf + i, PAGE_SIZE - i, "0x%02x : 0x%02x\n", addr, data);
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+	return i;
+}
+
+ssize_t max77854_chg_store_attrs(struct device *dev,
+			    struct device_attribute *attr,
+			    const char *buf, size_t count)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct max77854_charger_data *charger =
+		container_of(psy, struct max77854_charger_data, psy_chg);
+	const ptrdiff_t offset = attr - max77854_charger_attrs;
+	int ret = 0;
+	int x,y;
+
+	switch(offset) {
+	case CHIP_ID:
+		ret = count;
+		break;
+	case DATA:
+		if (sscanf(buf, "0x%x 0x%x", &x, &y) == 2) {
+			if (x >= 0xB1 && x <= 0xC3) {
+				u8 addr = x;
+				u8 data = y;
+				if (max77854_write_reg(charger->i2c, addr, data) < 0) {
+					dev_info(charger->dev,
+							"%s: addr: 0x%x write fail\n", __func__, addr);
+				}
+			} else {
+				dev_info(charger->dev,
+						"%s: addr: 0x%x is wrong\n", __func__, x);
+			}
+		}
+		ret = count;
+		break;
+	default:
+		ret = -EINVAL;
+	}
+	return ret;
+}
+
+static int max77854_chg_get_property(struct power_supply *psy,
+			      enum power_supply_property psp,
+			      union power_supply_propval *val)
+{
+	struct max77854_charger_data *charger =
+		container_of(psy, struct max77854_charger_data, psy_chg);
+	u8 reg_data;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = POWER_SUPPLY_TYPE_BATTERY;
+		if (max77854_read_reg(charger->i2c,
+			MAX77854_CHG_REG_INT_OK, &reg_data) == 0) {
+			if (reg_data & MAX77854_WCIN_OK) {
+				val->intval = POWER_SUPPLY_TYPE_WIRELESS;
+				charger->wc_w_state = 1;
+			} else if (reg_data & MAX77854_CHGIN_OK) {
+				val->intval = POWER_SUPPLY_TYPE_MAINS;
+			}
+		}
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = max77854_check_battery(charger);
+		break;
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = max77854_get_charger_state(charger);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+		if (!charger->is_charging)
+			val->intval = POWER_SUPPLY_CHARGE_TYPE_NONE;
+		else if (charger->slow_charging)
+		{
+			val->intval = POWER_SUPPLY_CHARGE_TYPE_SLOW;
+			pr_info("%s: slow-charging mode\n", __func__);
+		}
+		else
+			val->intval = POWER_SUPPLY_CHARGE_TYPE_FAST;
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = max77854_get_charging_health(charger);
+		max77854_test_read(charger);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		val->intval = charger->input_current;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+		if (is_wireless_type(val->intval))
+			val->intval = max77854_get_input_current_type(charger, POWER_SUPPLY_TYPE_WIRELESS);
+		else
+			val->intval = max77854_get_input_current_type(charger, POWER_SUPPLY_TYPE_MAINS);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = charger->charging_current;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+		val->intval = max77854_get_float_voltage(charger);
+		break;
+#if defined(CONFIG_AFC_CHARGER_MODE)
+	case POWER_SUPPLY_PROP_AFC_CHARGER_MODE:
+		return -ENODATA;
+#endif
+	case POWER_SUPPLY_PROP_CHARGE_NOW:
+		max77854_read_reg(charger->i2c,
+				  MAX77854_CHG_REG_DETAILS_01, &reg_data);
+		reg_data &= 0x0F;
+		switch (reg_data) {
+		case 0x01:
+			val->strval = "CC Mode";
+			break;
+		case 0x02:
+			val->strval = "CV Mode";
+			break;
+		case 0x03:
+			val->strval = "EOC";
+			break;
+		case 0x04:
+			val->strval = "DONE";
+			break;
+		default:
+			val->strval = "NONE";
+			break;
+		}
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL:
+		val->intval = charger->otg_on;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_UNO_CONTROL:
+		max77854_read_reg(charger->i2c, MAX77854_CHG_REG_CNFG_00,
+			&reg_data);
+		if ((reg_data & CHG_CNFG_00_UNO_CTRL) == CHG_CNFG_00_BOOST_MASK)
+			val->intval = 1;
+		else
+			val->intval = 0;
+		break;
+	case POWER_SUPPLY_PROP_USB_HC:
+		return -ENODATA;
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:
+		if (max77854_is_constant_current(charger)) {
+			val->intval = 0;
+		} else {
+			val->intval = 1;
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+#if defined(CONFIG_UPDATE_BATTERY_DATA)
+static int max77854_charger_parse_dt(struct max77854_charger_data *charger);
+#endif
+static int max77854_chg_set_property(struct power_supply *psy,
+			  enum power_supply_property psp,
+			  const union power_supply_propval *val)
+{
+	struct max77854_charger_data *charger =
+		container_of(psy, struct max77854_charger_data, psy_chg);
+	union power_supply_propval value;
+	u8 chg_cnfg_00 = 0;
+	static u8 chg_int_state;
+	int buck_state = ENABLE;
+
+	switch (psp) {
+	/* val->intval : type */
+	case POWER_SUPPLY_PROP_STATUS:
+		charger->status = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_CHARGING_ENABLED:
+		charger->charge_mode = val->intval;
+		switch (charger->charge_mode) {
+		case SEC_BAT_CHG_MODE_BUCK_OFF:
+			buck_state = DISABLE;
+		case SEC_BAT_CHG_MODE_CHARGING_OFF:
+			charger->is_charging = false;
+			break;
+		case SEC_BAT_CHG_MODE_CHARGING:
+			charger->is_charging = true;
+			break;
+		}
+		max77854_set_buck(charger, buck_state);
+		max77854_set_charger_state(charger, charger->is_charging);
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		charger->cable_type = val->intval;
+		charger->aicl_on = false;
+		charger->slow_charging = false;
+		charger->input_current = max77854_get_input_current(charger);
+		max77854_change_charge_path(charger, charger->cable_type);
+		if (charger->cable_type == POWER_SUPPLY_TYPE_BATTERY) {
+			charger->wc_pre_current = WC_CURRENT_START;
+			wake_unlock(&charger->wpc_wake_lock);
+			cancel_delayed_work(&charger->wpc_work);
+			max77854_update_reg(charger->i2c,
+				MAX77854_CHG_REG_INT_MASK, 0, MAX77854_WCIN_IM);
+		}
+		break;
+	/* val->intval : input charging current */
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+	{
+		int input_current = val->intval;
+		if (is_wireless_type(charger->cable_type)) {
+			max77854_set_wireless_input_current(charger, input_current);
+		} else {
+			max77854_set_input_current(charger, input_current);
+		}
+		if (charger->cable_type == POWER_SUPPLY_TYPE_BATTERY)
+			max77854_set_wireless_input_current(charger, input_current);
+		charger->input_current = input_current;
+	}
+		break;
+	/*  val->intval : charging current */
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+		charger->charging_current = val->intval;
+		max77854_set_charge_current(charger,
+			val->intval);
+		break;
+	/* val->intval : charging current */
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		charger->charging_current = val->intval;
+		if (is_not_wireless_type(charger->cable_type)) {
+			max77854_set_charge_current(charger, charger->charging_current);
+		}
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_FULL:
+		max77854_set_topoff_current(charger, val->intval);
+		break;
+#if defined(CONFIG_AFC_CHARGER_MODE)
+	case POWER_SUPPLY_PROP_AFC_CHARGER_MODE:
+#if defined(CONFIG_MUIC_HV)
+		max77854_hv_muic_charger_init();
+#endif
+		break;
+#endif
+#if defined(CONFIG_BATTERY_SWELLING)
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+		charger->float_voltage = val->intval;
+		pr_info("%s: float voltage(%d)\n", __func__, val->intval);
+		max77854_set_float_voltage(charger, val->intval);
+		break;
+#endif
+	case POWER_SUPPLY_PROP_USB_HC:
+		break;
+	case POWER_SUPPLY_PROP_ENERGY_NOW:
+		/* if jig attached, change the power source
+		from the VBATFG to the internal VSYS*/
+		max77854_update_reg(charger->i2c, MAX77854_CHG_REG_CNFG_07,
+			(val->intval << CHG_CNFG_07_REG_FGSRC_SHIFT),
+			CHG_CNFG_07_REG_FGSRC_MASK);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL:
+		pr_info("%s: CHGIN-OTG %s\n", __func__, val->intval > 0 ? "on" : "off");
+		if (charger->otg_on == val->intval || lpcharge)
+			return 0;
+		mutex_lock(&charger->charger_mutex);
+		/* CHGIN-OTG */
+		if (val->intval) {
+			if (is_hv_wireless_type(charger->cable_type)) {
+				pr_info("%s: OTG enabled on HV_WC, set 5V", __func__);
+				value.intval = WIRELESS_VOUT_5V;
+				psy_do_property(charger->pdata->wireless_charger_name, set,
+					POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+				mdelay(200);
+			}
+			max77854_read_reg(charger->i2c, MAX77854_CHG_REG_INT_MASK,
+				&chg_int_state);
+
+			/* disable charger interrupt: CHG_I, CHGIN_I */
+			/* enable charger interrupt: BYP_I */
+			max77854_update_reg(charger->i2c, MAX77854_CHG_REG_INT_MASK,
+				MAX77854_CHG_IM | MAX77854_CHGIN_IM,
+				MAX77854_CHG_IM | MAX77854_CHGIN_IM | MAX77854_BYP_IM);
+
+			/* OTG on, boost on */
+			max77854_update_reg(charger->i2c, MAX77854_CHG_REG_CNFG_00,
+				CHG_CNFG_00_OTG_CTRL, CHG_CNFG_00_OTG_CTRL);
+
+			/* Update CHG_CNFG_11 to 0x50(5V) */
+			max77854_write_reg(charger->i2c,
+				MAX77854_CHG_REG_CNFG_11, 0x50);
+		} else {
+			/* OTG off(UNO on), boost off */
+			max77854_update_reg(charger->i2c, MAX77854_CHG_REG_CNFG_00,
+				0, CHG_CNFG_00_OTG_CTRL);
+
+			/* Update CHG_CNFG_11 to 0x00(3V) */
+			max77854_write_reg(charger->i2c,
+				MAX77854_CHG_REG_CNFG_11, 0x00);
+			mdelay(50);
+
+			/* enable charger interrupt */
+			max77854_write_reg(charger->i2c,
+				MAX77854_CHG_REG_INT_MASK, chg_int_state);
+
+			if (is_hv_wireless_type(charger->cable_type)) {
+				pr_info("%s: OTG disabled on HV_WC, set 9V", __func__);
+				value.intval = WIRELESS_VOUT_9V_OTG;
+				psy_do_property(charger->pdata->wireless_charger_name, set,
+					POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+			}
+		}
+		charger->otg_on = val->intval;
+		max77854_read_reg(charger->i2c, MAX77854_CHG_REG_INT_MASK,
+			&chg_int_state);
+		max77854_read_reg(charger->i2c, MAX77854_CHG_REG_CNFG_00,
+			&chg_cnfg_00);
+		mutex_unlock(&charger->charger_mutex);
+		pr_info("%s: INT_MASK(0x%x), CHG_CNFG_00(0x%x)\n",
+			__func__, chg_int_state, chg_cnfg_00);
+		power_supply_changed(&charger->psy_otg);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_UNO_CONTROL:
+		pr_info("%s: WCIN-UNO %s\n", __func__, val->intval > 0 ? "on" : "off");
+		/* WCIN-UNO */
+		if (val->intval) {
+			max77854_read_reg(charger->i2c, MAX77854_CHG_REG_INT_MASK,
+				&chg_int_state);
+
+			/* disable charger interrupt: CHG_I, CHGIN_I */
+			/* enable charger interrupt: BYP_I */
+			max77854_update_reg(charger->i2c, MAX77854_CHG_REG_INT_MASK,
+				MAX77854_CHG_IM | MAX77854_CHGIN_IM,
+				MAX77854_CHG_IM | MAX77854_CHGIN_IM | MAX77854_BYP_IM);
+
+			/* UNO on, boost on */
+			max77854_update_reg(charger->i2c, MAX77854_CHG_REG_CNFG_00,
+				CHG_CNFG_00_BOOST_MASK, CHG_CNFG_00_UNO_CTRL);
+
+			/* Update CHG_CNFG_11 to 0x50(5V) */
+			max77854_write_reg(charger->i2c,
+				MAX77854_CHG_REG_CNFG_11, 0x50);
+		} else {
+			/* boost off*/
+			max77854_update_reg(charger->i2c, MAX77854_CHG_REG_CNFG_00,
+				0, CHG_CNFG_00_BOOST_MASK);
+
+			/* Update CHG_CNFG_11 to 0x00(3V) */
+			max77854_write_reg(charger->i2c,
+				MAX77854_CHG_REG_CNFG_11, 0x00);
+			mdelay(50);
+
+			/* enable charger interrupt */
+			max77854_write_reg(charger->i2c,
+				MAX77854_CHG_REG_INT_MASK, chg_int_state);
+		}
+		max77854_read_reg(charger->i2c, MAX77854_CHG_REG_INT_MASK,
+			&chg_int_state);
+		max77854_read_reg(charger->i2c, MAX77854_CHG_REG_CNFG_00,
+			&chg_cnfg_00);
+		pr_info("%s: INT_MASK(0x%x), CHG_CNFG_00(0x%x)\n",
+			__func__, chg_int_state, chg_cnfg_00);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX:
+		max77854_enable_aicl_irq(charger);
+		queue_delayed_work(charger->wqueue, &charger->aicl_work, msecs_to_jiffies(50));
+		break;
+#if defined(CONFIG_UPDATE_BATTERY_DATA)
+	case POWER_SUPPLY_PROP_POWER_DESIGN:
+		max77854_charger_parse_dt(charger);
+		break;
+#endif
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int max77854_otg_get_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		union power_supply_propval *val)
+{
+	struct max77854_charger_data *charger =
+		container_of(psy, struct max77854_charger_data, psy_otg);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = charger->otg_on;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int max77854_otg_set_property(struct power_supply *psy,
+				enum power_supply_property psp,
+				const union power_supply_propval *val)
+{
+	struct max77854_charger_data *charger =
+		container_of(psy, struct max77854_charger_data, psy_otg);
+	union power_supply_propval value;
+	static u8 chg_int_state;
+	u8 chg_cnfg_00;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		pr_info("%s: CHGIN-OTG %s\n", __func__, val->intval > 0 ? "on" : "off");
+		if (charger->otg_on == val->intval || lpcharge)
+			return 0;
+		mutex_lock(&charger->charger_mutex);
+		/* CHGIN-OTG */
+		if (val->intval) {
+			if (is_hv_wireless_type(charger->cable_type)) {
+				pr_info("%s: OTG enabled on HV_WC, set 5V", __func__);
+				value.intval = WIRELESS_VOUT_5V;
+				psy_do_property(charger->pdata->wireless_charger_name, set,
+					POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+				mdelay(200);
+			}
+			max77854_read_reg(charger->i2c, MAX77854_CHG_REG_INT_MASK,
+				&chg_int_state);
+
+			/* disable charger interrupt: CHG_I, CHGIN_I */
+			/* enable charger interrupt: BYP_I */
+			max77854_update_reg(charger->i2c, MAX77854_CHG_REG_INT_MASK,
+				MAX77854_CHG_IM | MAX77854_CHGIN_IM,
+				MAX77854_CHG_IM | MAX77854_CHGIN_IM | MAX77854_BYP_IM);
+
+			/* OTG on, boost on */
+			max77854_update_reg(charger->i2c, MAX77854_CHG_REG_CNFG_00,
+				CHG_CNFG_00_OTG_CTRL, CHG_CNFG_00_OTG_CTRL);
+
+			/* Update CHG_CNFG_11 to 0x50(5V) */
+			max77854_write_reg(charger->i2c,
+				MAX77854_CHG_REG_CNFG_11, 0x50);
+		} else {
+			/* OTG off(UNO on), boost off */
+			max77854_update_reg(charger->i2c, MAX77854_CHG_REG_CNFG_00,
+				0, CHG_CNFG_00_OTG_CTRL);
+
+			/* Update CHG_CNFG_11 to 0x00(3V) */
+			max77854_write_reg(charger->i2c,
+				MAX77854_CHG_REG_CNFG_11, 0x00);
+			mdelay(50);
+
+			/* enable charger interrupt */
+			max77854_write_reg(charger->i2c,
+				MAX77854_CHG_REG_INT_MASK, chg_int_state);
+
+			if (is_hv_wireless_type(charger->cable_type)) {
+				pr_info("%s: OTG disabled on HV_WC, set 9V", __func__);
+				value.intval = WIRELESS_VOUT_9V_OTG;
+				psy_do_property(charger->pdata->wireless_charger_name, set,
+					POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+			}
+		}
+		charger->otg_on = val->intval;
+		max77854_read_reg(charger->i2c, MAX77854_CHG_REG_INT_MASK,
+			&chg_int_state);
+		max77854_read_reg(charger->i2c, MAX77854_CHG_REG_CNFG_00,
+			&chg_cnfg_00);
+		mutex_unlock(&charger->charger_mutex);
+		pr_info("%s: INT_MASK(0x%x), CHG_CNFG_00(0x%x)\n",
+			__func__, chg_int_state, chg_cnfg_00);
+		power_supply_changed(&charger->psy_otg);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int max77854_debugfs_show(struct seq_file *s, void *data)
+{
+	struct max77854_charger_data *charger = s->private;
+	u8 reg;
+	u8 reg_data;
+
+	seq_printf(s, "MAX77854 CHARGER IC :\n");
+	seq_printf(s, "===================\n");
+	for (reg = 0xB0; reg <= 0xC3; reg++) {
+		max77854_read_reg(charger->i2c, reg, &reg_data);
+		seq_printf(s, "0x%02x:\t0x%02x\n", reg, reg_data);
+	}
+
+	seq_printf(s, "\n");
+	return 0;
+}
+
+static int max77854_debugfs_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, max77854_debugfs_show, inode->i_private);
+}
+
+static const struct file_operations max77854_debugfs_fops = {
+	.open           = max77854_debugfs_open,
+	.read           = seq_read,
+	.llseek         = seq_lseek,
+	.release        = single_release,
+};
+
+static void max77854_chg_isr_work(struct work_struct *work)
+{
+	struct max77854_charger_data *charger =
+		container_of(work, struct max77854_charger_data, isr_work.work);
+
+	union power_supply_propval val;
+
+	if (charger->pdata->full_check_type ==
+	    SEC_BATTERY_FULLCHARGED_CHGINT) {
+
+		val.intval = max77854_get_charger_state(charger);
+
+		switch (val.intval) {
+		case POWER_SUPPLY_STATUS_DISCHARGING:
+			pr_err("%s: Interrupted but Discharging\n", __func__);
+			break;
+
+		case POWER_SUPPLY_STATUS_NOT_CHARGING:
+			pr_err("%s: Interrupted but NOT Charging\n", __func__);
+			break;
+
+		case POWER_SUPPLY_STATUS_FULL:
+			pr_info("%s: Interrupted by Full\n", __func__);
+			psy_do_property("battery", set,
+				POWER_SUPPLY_PROP_STATUS, val);
+			break;
+
+		case POWER_SUPPLY_STATUS_CHARGING:
+			pr_err("%s: Interrupted but Charging\n", __func__);
+			break;
+
+		case POWER_SUPPLY_STATUS_UNKNOWN:
+		default:
+			pr_err("%s: Invalid Charger Status\n", __func__);
+			break;
+		}
+	}
+
+	if (charger->pdata->ovp_uvlo_check_type ==
+		SEC_BATTERY_OVP_UVLO_CHGINT) {
+		val.intval = max77854_get_charging_health(charger);
+		switch (val.intval) {
+		case POWER_SUPPLY_HEALTH_OVERHEAT:
+		case POWER_SUPPLY_HEALTH_COLD:
+			pr_err("%s: Interrupted but Hot/Cold\n", __func__);
+			break;
+
+		case POWER_SUPPLY_HEALTH_DEAD:
+			pr_err("%s: Interrupted but Dead\n", __func__);
+			break;
+
+		case POWER_SUPPLY_HEALTH_OVERVOLTAGE:
+		case POWER_SUPPLY_HEALTH_UNDERVOLTAGE:
+			pr_info("%s: Interrupted by OVP/UVLO\n", __func__);
+			psy_do_property("battery", set,
+				POWER_SUPPLY_PROP_HEALTH, val);
+			break;
+
+		case POWER_SUPPLY_HEALTH_UNSPEC_FAILURE:
+			pr_err("%s: Interrupted but Unspec\n", __func__);
+			break;
+
+		case POWER_SUPPLY_HEALTH_GOOD:
+			pr_err("%s: Interrupted but Good\n", __func__);
+			break;
+
+		case POWER_SUPPLY_HEALTH_UNKNOWN:
+		default:
+			pr_err("%s: Invalid Charger Health\n", __func__);
+			break;
+		}
+	}
+}
+
+static irqreturn_t max77854_chg_irq_thread(int irq, void *irq_data)
+{
+	struct max77854_charger_data *charger = irq_data;
+
+	pr_info("%s: Charger interrupt occured\n", __func__);
+
+	if ((charger->pdata->full_check_type ==
+	     SEC_BATTERY_FULLCHARGED_CHGINT) ||
+	    (charger->pdata->ovp_uvlo_check_type ==
+	     SEC_BATTERY_OVP_UVLO_CHGINT))
+		schedule_delayed_work(&charger->isr_work, 0);
+
+	return IRQ_HANDLED;
+}
+
+/* If we have external wireless TRx, enable WCIN interrupt to detect Mis-align only */
+static void wpc_detect_work(struct work_struct *work)
+{
+	struct max77854_charger_data *charger = container_of(work,
+						struct max77854_charger_data,
+						wpc_work.work);
+
+	max77854_update_reg(charger->i2c,
+		MAX77854_CHG_REG_INT_MASK, 0, MAX77854_WCIN_IM);
+
+	if (is_wireless_type(charger->cable_type)) {
+		u8 reg_data, wcin_state, wcin_dtls, wcin_cnt = 0;
+		do {
+			wcin_cnt++;
+			max77854_read_reg(charger->i2c, MAX77854_CHG_REG_INT_OK,
+				&reg_data);
+			wcin_state = (reg_data & MAX77854_WCIN_OK) >> MAX77854_WCIN_OK_SHIFT;
+			max77854_read_reg(charger->i2c, MAX77854_CHG_REG_DETAILS_00,
+				&reg_data);
+			wcin_dtls = (reg_data & MAX77854_WCIN_DTLS) >> MAX77854_WCIN_DTLS_SHIFT;
+			if (!wcin_state && !wcin_dtls && wcin_cnt >= 2) {
+				union power_supply_propval value;
+				pr_info("%s: invalid WCIN, Misalign occurs!\n", __func__);
+				value.intval = POWER_SUPPLY_STATUS_NOT_CHARGING;
+				psy_do_property(charger->pdata->wireless_charger_name, set,
+					POWER_SUPPLY_PROP_STATUS, value);
+			}
+			mdelay(50);
+		} while (!wcin_state && !wcin_dtls && wcin_cnt < 2);
+	} 
+
+	/* Do unmask again. (for frequent wcin irq problem) */
+	max77854_update_reg(charger->i2c,
+		MAX77854_CHG_REG_INT_MASK, 0, MAX77854_WCIN_IM);
+
+	wake_unlock(&charger->wpc_wake_lock);
+}
+
+static irqreturn_t wpc_charger_irq(int irq, void *data)
+{
+	struct max77854_charger_data *charger = data;
+	
+	pr_info("%s: irq(%d)\n", __func__, irq);
+
+	max77854_update_reg(charger->i2c, MAX77854_CHG_REG_INT_MASK,
+		MAX77854_WCIN_IM, MAX77854_WCIN_IM);
+	wake_lock(&charger->wpc_wake_lock);
+	queue_delayed_work(charger->wqueue, &charger->wpc_work, msecs_to_jiffies(10000));
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t max77854_batp_irq(int irq, void *data)
+{
+	struct max77854_charger_data *charger = data;
+	union power_supply_propval value;
+	u8 reg_data;
+
+	pr_info("%s : irq(%d)\n", __func__, irq);
+
+	max77854_read_reg(charger->i2c,
+			  MAX77854_CHG_REG_INT_MASK, &reg_data);
+	reg_data |= (1 << 2);
+	max77854_write_reg(charger->i2c,
+		MAX77854_CHG_REG_INT_MASK, reg_data);
+
+	check_charger_unlock_state(charger);
+
+	max77854_read_reg(charger->i2c,
+			  MAX77854_CHG_REG_INT_OK,
+			  &reg_data);
+
+	if (!(reg_data & MAX77854_BATP_OK))
+		psy_do_property("battery", set, POWER_SUPPLY_PROP_PRESENT, value);
+
+	max77854_read_reg(charger->i2c,
+			  MAX77854_CHG_REG_INT_MASK, &reg_data);
+	reg_data &= ~(1 << 2);
+	max77854_write_reg(charger->i2c,
+			   MAX77854_CHG_REG_INT_MASK, reg_data);
+
+	return IRQ_HANDLED;
+}
+
+
+static irqreturn_t max77854_bypass_irq(int irq, void *data)
+{
+	struct max77854_charger_data *charger = data;
+	u8 dtls_02;
+	u8 byp_dtls;
+	u8 vbus_state;
+#ifdef CONFIG_USB_HOST_NOTIFY
+	struct otg_notify *o_notify;
+
+	o_notify = get_otg_notify();
+#endif
+
+	pr_info("%s: irq(%d)\n", __func__, irq);
+
+	/* check and unlock */
+	check_charger_unlock_state(charger);
+
+	max77854_read_reg(charger->i2c,
+			  MAX77854_CHG_REG_DETAILS_02,
+			  &dtls_02);
+
+	byp_dtls = ((dtls_02 & MAX77854_BYP_DTLS) >>
+				MAX77854_BYP_DTLS_SHIFT);
+	pr_info("%s: BYP_DTLS(0x%02x)\n", __func__, byp_dtls);
+	vbus_state = max77854_get_vbus_state(charger);
+
+	if (byp_dtls & 0x1) {
+	        union power_supply_propval val;
+		pr_info("%s: bypass overcurrent limit\n", __func__);
+#ifdef CONFIG_USB_HOST_NOTIFY
+		send_otg_notify(o_notify, NOTIFY_EVENT_OVERCURRENT, 0);
+#endif
+		/* disable the register values just related to OTG and
+		   keep the values about the charging */
+                val.intval = 0;
+                psy_do_property("otg", set,
+                        POWER_SUPPLY_PROP_ONLINE, val);
+	}
+	return IRQ_HANDLED;
+}
+
+static void max77854_aicl_isr_work(struct work_struct *work)
+{
+	struct max77854_charger_data *charger = container_of(work,
+				struct max77854_charger_data, aicl_work.work);
+	u8 aicl_state, aicl_cnt = 0;
+
+	pr_info("%s: \n", __func__);
+
+	wake_lock(&charger->aicl_wake_lock);
+	mutex_lock(&charger->charger_mutex);
+	max77854_update_reg(charger->i2c,
+		MAX77854_CHG_REG_INT_MASK, MAX77854_AICL_IM, MAX77854_AICL_IM);
+	/* check and unlock */
+	check_charger_unlock_state(charger);
+	max77854_read_reg(charger->i2c, MAX77854_CHG_REG_INT_OK, &aicl_state);
+	while (!(aicl_state & 0x80) && charger->cable_type != POWER_SUPPLY_TYPE_BATTERY) {
+		if (++aicl_cnt >= 2) {
+			reduce_input_current(charger, REDUCE_CURRENT_STEP);
+			aicl_cnt = 0;
+		}
+		mdelay(50);
+		max77854_read_reg(charger->i2c, MAX77854_CHG_REG_INT_OK, &aicl_state);
+		if (max77854_get_input_current(charger) <= MINIMUM_INPUT_CURRENT)
+			break;
+	}
+
+	if (charger->aicl_on) {
+		union power_supply_propval value;
+		value.intval = max77854_get_input_current(charger);
+		psy_do_property("battery", set,
+			POWER_SUPPLY_EXT_PROP_AICL_CURRENT, value);
+	}
+
+	if (is_not_wireless_type(charger->cable_type))
+		max77854_check_slow_charging(charger, charger->input_current);
+
+	max77854_update_reg(charger->i2c,
+		MAX77854_CHG_REG_INT_MASK, 0, MAX77854_AICL_IM);
+	mutex_unlock(&charger->charger_mutex);
+	wake_unlock(&charger->aicl_wake_lock);
+}
+
+static irqreturn_t max77854_aicl_irq(int irq, void *data)
+{
+	struct max77854_charger_data *charger = data;
+	queue_delayed_work(charger->wqueue, &charger->aicl_work, msecs_to_jiffies(50));
+
+	pr_info("%s: irq(%d)\n", __func__, irq);
+	wake_unlock(&charger->wc_current_wake_lock);
+	cancel_delayed_work(&charger->wc_current_work);
+
+	return IRQ_HANDLED;
+}
+
+static void max77854_enable_aicl_irq(struct max77854_charger_data *charger)
+{
+	int ret;
+
+	pr_info("%s \n", __func__);
+	ret = request_threaded_irq(charger->irq_aicl, NULL,
+			max77854_aicl_irq, 0, "aicl-irq", charger);
+	if (ret < 0) {
+		pr_err("%s: fail to request aicl IRQ: %d: %d\n",
+				__func__, charger->irq_aicl, ret);
+	} else {
+		max77854_update_reg(charger->i2c,
+			MAX77854_CHG_REG_INT_MASK, 0, MAX77854_AICL_IM);
+	}
+}
+
+static void max77854_chgin_isr_work(struct work_struct *work)
+{
+	struct max77854_charger_data *charger = container_of(work,
+				     struct max77854_charger_data, chgin_work);
+	u8 chgin_dtls, chg_dtls, chg_cnfg_00, reg_data;
+	u8 prev_chgin_dtls = 0xff;
+	int battery_health;
+	union power_supply_propval value;
+	int stable_count = 0;
+
+	wake_lock(&charger->chgin_wake_lock);
+
+	max77854_read_reg(charger->i2c,
+			  MAX77854_CHG_REG_INT_MASK, &reg_data);
+	reg_data |= (1 << 6);
+	max77854_write_reg(charger->i2c,
+		MAX77854_CHG_REG_INT_MASK, reg_data);
+
+	while (1) {
+		psy_do_property("battery", get,
+				POWER_SUPPLY_PROP_HEALTH, value);
+		battery_health = value.intval;
+
+		max77854_read_reg(charger->i2c,
+				MAX77854_CHG_REG_DETAILS_00,
+				&chgin_dtls);
+		chgin_dtls = ((chgin_dtls & MAX77854_CHGIN_DTLS) >>
+				MAX77854_CHGIN_DTLS_SHIFT);
+		max77854_read_reg(charger->i2c,
+				MAX77854_CHG_REG_DETAILS_01, &chg_dtls);
+		chg_dtls = ((chg_dtls & MAX77854_CHG_DTLS) >>
+				MAX77854_CHG_DTLS_SHIFT);
+		max77854_read_reg(charger->i2c,
+			MAX77854_CHG_REG_CNFG_00, &chg_cnfg_00);
+
+		if (prev_chgin_dtls == chgin_dtls)
+			stable_count++;
+		else
+			stable_count = 0;
+		if (stable_count > 10) {
+			pr_info("%s: irq(%d), chgin(0x%x), chg_dtls(0x%x) prev 0x%x\n",
+					__func__, charger->irq_chgin,
+					chgin_dtls, chg_dtls, prev_chgin_dtls);
+			if (charger->is_charging) {
+				if ((chgin_dtls == 0x02) && \
+					(battery_health != POWER_SUPPLY_HEALTH_OVERVOLTAGE)) {
+					pr_info("%s: charger is over voltage\n",
+							__func__);
+					value.intval = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+					psy_do_property("battery", set,
+						POWER_SUPPLY_PROP_HEALTH, value);
+				} else if (((chgin_dtls == 0x0) || (chgin_dtls == 0x01)) &&(chg_dtls & 0x08) && \
+						(chg_cnfg_00 & MAX77854_MODE_BUCK) && \
+						(chg_cnfg_00 & MAX77854_MODE_CHGR) && \
+						(battery_health != POWER_SUPPLY_HEALTH_UNDERVOLTAGE) && \
+						is_not_wireless_type(charger->cable_type)) {
+					pr_info("%s, vbus_state : 0x%d, chg_state : 0x%d\n", __func__, chgin_dtls, chg_dtls);
+					pr_info("%s: vBus is undervoltage\n", __func__);
+					value.intval = POWER_SUPPLY_HEALTH_UNDERVOLTAGE;
+					psy_do_property("battery", set,
+							POWER_SUPPLY_PROP_HEALTH, value);
+				}
+			} else {
+				if ((battery_health == \
+							POWER_SUPPLY_HEALTH_OVERVOLTAGE) &&
+						(chgin_dtls != 0x02)) {
+					pr_info("%s: vbus_state : 0x%d, chg_state : 0x%d\n", __func__, chgin_dtls, chg_dtls);
+					pr_info("%s: overvoltage->normal\n", __func__);
+					value.intval = POWER_SUPPLY_HEALTH_GOOD;
+					psy_do_property("battery", set,
+							POWER_SUPPLY_PROP_HEALTH, value);
+				} else if ((battery_health == \
+							POWER_SUPPLY_HEALTH_UNDERVOLTAGE) &&
+						!((chgin_dtls == 0x0) || (chgin_dtls == 0x01))){
+					pr_info("%s: vbus_state : 0x%d, chg_state : 0x%d\n", __func__, chgin_dtls, chg_dtls);
+					pr_info("%s: undervoltage->normal\n", __func__);
+					value.intval = POWER_SUPPLY_HEALTH_GOOD;
+					psy_do_property("battery", set,
+							POWER_SUPPLY_PROP_HEALTH, value);
+					max77854_set_input_current(charger,
+							charger->input_current);
+				}
+			}
+			break;
+		}
+
+		prev_chgin_dtls = chgin_dtls;
+		msleep(100);
+	}
+	max77854_read_reg(charger->i2c,
+		MAX77854_CHG_REG_INT_MASK, &reg_data);
+	reg_data &= ~(1 << 6);
+	max77854_write_reg(charger->i2c,
+		MAX77854_CHG_REG_INT_MASK, reg_data);
+	wake_unlock(&charger->chgin_wake_lock);
+}
+
+static irqreturn_t max77854_chgin_irq(int irq, void *data)
+{
+	struct max77854_charger_data *charger = data;
+	queue_work(charger->wqueue, &charger->chgin_work);
+
+	return IRQ_HANDLED;
+}
+
+/* register chgin isr after sec_battery_probe */
+static void max77854_chgin_init_work(struct work_struct *work)
+{
+	struct max77854_charger_data *charger = container_of(work,
+						struct max77854_charger_data,
+						chgin_init_work.work);
+	int ret;
+
+	pr_info("%s \n", __func__);
+	ret = request_threaded_irq(charger->irq_chgin, NULL,
+			max77854_chgin_irq, 0, "chgin-irq", charger);
+	if (ret < 0) {
+		pr_err("%s: fail to request chgin IRQ: %d: %d\n",
+				__func__, charger->irq_chgin, ret);
+	} else {
+		max77854_update_reg(charger->i2c,
+			MAX77854_CHG_REG_INT_MASK, 0, MAX77854_CHGIN_IM);
+	}
+}
+
+static void max77854_wc_current_work(struct work_struct *work)
+{
+	struct max77854_charger_data *charger = container_of(work,
+					struct max77854_charger_data,
+					wc_current_work.work);
+	int diff_current = 0;
+
+	if (is_not_wireless_type(charger->cable_type)) {
+		charger->wc_pre_current = WC_CURRENT_START;
+		max77854_write_reg(charger->i2c,
+			MAX77854_CHG_REG_CNFG_10, 0x10);
+		wake_unlock(&charger->wc_current_wake_lock);
+		return;
+	}
+
+	if (charger->wc_pre_current == charger->wc_current) {
+		union power_supply_propval value;
+		max77854_set_charge_current(charger, charger->charging_current);
+		/* Wcurr-B) Restore Vrect adj room to previous value
+			after finishing wireless input current setting. Refer to Wcurr-A) step */
+		msleep(500);
+		if (is_nv_wireless_type(charger->cable_type)) {
+			psy_do_property("battery", get, POWER_SUPPLY_PROP_CAPACITY, value);
+			if (value.intval < charger->pdata->wireless_cc_cv)
+				value.intval = WIRELESS_VRECT_ADJ_ROOM_4; /* WPC 4.5W, Vrect Room 30mV */
+			else 
+				value.intval = WIRELESS_VRECT_ADJ_ROOM_5; /* WPC 4.5W, Vrect Room 80mV */
+		} else if (is_hv_wireless_type(charger->cable_type)) {
+			value.intval = WIRELESS_VRECT_ADJ_ROOM_5; /* WPC 9W, Vrect Room 80mV */
+		} else
+			value.intval = WIRELESS_VRECT_ADJ_OFF; /* PMA 4.5W, Vrect Room 0mV */
+		psy_do_property(charger->pdata->wireless_charger_name, set,
+			POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+		wake_unlock(&charger->wc_current_wake_lock);
+	} else {
+		if (charger->wc_pre_current > charger->wc_current) {
+			diff_current = charger->wc_pre_current - charger->wc_current;
+			if (diff_current < WC_CURRENT_STEP)
+				charger->wc_pre_current -= diff_current;
+			else
+				charger->wc_pre_current -= WC_CURRENT_STEP;
+		} else {
+			diff_current = charger->wc_current - charger->wc_pre_current;
+			if (diff_current < WC_CURRENT_STEP)
+				charger->wc_pre_current += diff_current;
+			else
+				charger->wc_pre_current += WC_CURRENT_STEP;
+		}
+		max77854_set_input_current(charger, charger->wc_pre_current);
+		queue_delayed_work(charger->wqueue, &charger->wc_current_work,
+				msecs_to_jiffies(WC_CURRENT_WORK_STEP));
+	}
+	pr_info("%s: wc_current(%d), wc_pre_current(%d), diff(%d)\n",
+		__func__, charger->wc_current, charger->wc_pre_current, diff_current);
+}
+
+#ifdef CONFIG_OF
+static int max77854_charger_parse_dt(struct max77854_charger_data *charger)
+{
+	struct device_node *np;
+	sec_charger_platform_data_t *pdata = charger->pdata;
+	int ret = 0;
+
+	np = of_find_node_by_name(NULL, "battery");
+	if (!np) {
+		pr_err("%s np NULL\n", __func__);
+	} else {
+		ret = of_property_read_u32(np, "battery,chg_float_voltage",
+					   &pdata->chg_float_voltage);
+		if (ret) {
+			pr_info("%s: battery,chg_float_voltage is Empty\n", __func__);
+			pdata->chg_float_voltage = 42000;
+		}
+		pr_info("%s: battery,chg_float_voltage is %d\n", __func__, pdata->chg_float_voltage);
+		charger->float_voltage = pdata->chg_float_voltage;
+
+		ret = of_property_read_string(np,
+			"battery,wireless_charger_name", (char const **)&pdata->wireless_charger_name);
+		if (ret)
+			pr_info("%s: Wireless charger name is Empty\n", __func__);
+
+		ret = of_property_read_u32(np, "battery,full_check_type_2nd",
+					&pdata->full_check_type_2nd);
+		if (ret)
+			pr_info("%s : Full check type 2nd is Empty\n", __func__);
+
+		ret = of_property_read_u32(np, "battery,wireless_cc_cv", &pdata->wireless_cc_cv);
+		if (ret)
+			pr_info("%s : wireless_cc_cv is Empty\n", __func__);
+	}
+
+	np = of_find_node_by_name(NULL, "max77854-fuelgauge");
+	if (!np) {
+		pr_err("%s: np NULL\n", __func__);
+	} else {
+		charger->jig_gpio = of_get_named_gpio(np, "fuelgauge,jig_gpio", 0);
+		if (charger->jig_gpio < 0) {
+			pr_err("%s error reading jig_gpio = %d\n",
+					__func__, charger->jig_gpio);
+			charger->jig_gpio = 0;
+		}
+	}
+
+	return ret;
+}
+#endif
+
+static int __devinit max77854_charger_probe(struct platform_device *pdev)
+{
+	struct max77854_dev *max77854 = dev_get_drvdata(pdev->dev.parent);
+	struct max77854_platform_data *pdata = dev_get_platdata(max77854->dev);
+	sec_charger_platform_data_t *charger_data;
+	struct max77854_charger_data *charger;
+	int ret = 0;
+	u8 reg_data;
+
+	pr_info("%s: Max77854 Charger Driver Loading\n", __func__);
+
+	charger = kzalloc(sizeof(*charger), GFP_KERNEL);
+	if (!charger)
+		return -ENOMEM;
+
+	charger_data = kzalloc(sizeof(sec_charger_platform_data_t), GFP_KERNEL);
+	if (!charger_data) {
+		ret = -ENOMEM;
+		goto err_free;
+	}
+
+	mutex_init(&charger->charger_mutex);
+
+	charger->dev = &pdev->dev;
+	charger->i2c = max77854->charger;
+	charger->pmic_i2c = max77854->i2c;
+	charger->pdata = charger_data;
+	charger->aicl_on = false;
+	charger->slow_charging = false;
+	charger->is_mdock = false;
+	charger->otg_on = false;
+	charger->max77854_pdata = pdata;
+	charger->wc_pre_current = WC_CURRENT_START;
+
+#if defined(CONFIG_OF)
+	ret = max77854_charger_parse_dt(charger);
+	if (ret < 0) {
+		pr_err("%s not found charger dt! ret[%d]\n",
+		       __func__, ret);
+	}
+#endif
+	platform_set_drvdata(pdev, charger);
+
+	charger->psy_chg.name		= "max77854-charger";
+	charger->psy_chg.type		= POWER_SUPPLY_TYPE_UNKNOWN;
+	charger->psy_chg.get_property	= max77854_chg_get_property;
+	charger->psy_chg.set_property	= max77854_chg_set_property;
+	charger->psy_chg.properties	= max77854_charger_props;
+	charger->psy_chg.num_properties	= ARRAY_SIZE(max77854_charger_props);
+	charger->psy_otg.name		= "otg";
+	charger->psy_otg.type		= POWER_SUPPLY_TYPE_OTG;
+	charger->psy_otg.get_property	= max77854_otg_get_property;
+	charger->psy_otg.set_property	= max77854_otg_set_property;
+	charger->psy_otg.properties	= max77854_otg_props;
+	charger->psy_otg.num_properties	= ARRAY_SIZE(max77854_otg_props);
+
+	max77854_charger_initialize(charger);
+
+	max77854_read_reg(charger->i2c, MAX77854_CHG_REG_INT_OK, &reg_data);
+	if (reg_data & MAX77854_WCIN_OK)
+		charger->cable_type = POWER_SUPPLY_TYPE_WIRELESS;
+	charger->input_current = max77854_get_input_current(charger);
+	charger->charging_current = max77854_get_charge_current(charger);
+
+	if (max77854_read_reg(max77854->i2c, MAX77854_PMIC_REG_PMICREV, &reg_data) < 0) {
+		pr_err("device not found on this channel (this is not an error)\n");
+		ret = -ENOMEM;
+		goto err_pdata_free;
+	} else {
+		charger->pmic_ver = (reg_data & 0x7);
+		pr_info("%s : device found : ver.0x%x\n", __func__, charger->pmic_ver);
+	}
+
+	(void) debugfs_create_file("max77854-regs",
+		S_IRUGO, NULL, (void *)charger, &max77854_debugfs_fops);
+
+	charger->wqueue =
+	    create_singlethread_workqueue(dev_name(&pdev->dev));
+	if (!charger->wqueue) {
+		pr_err("%s: Fail to Create Workqueue\n", __func__);
+		goto err_pdata_free;
+	}
+	wake_lock_init(&charger->chgin_wake_lock, WAKE_LOCK_SUSPEND,
+		       "charger->chgin");
+	INIT_WORK(&charger->chgin_work, max77854_chgin_isr_work);
+	wake_lock_init(&charger->aicl_wake_lock, WAKE_LOCK_SUSPEND,
+		"charger-aicl");
+	INIT_DELAYED_WORK(&charger->aicl_work, max77854_aicl_isr_work);
+	INIT_DELAYED_WORK(&charger->chgin_init_work, max77854_chgin_init_work);
+	wake_lock_init(&charger->wpc_wake_lock, WAKE_LOCK_SUSPEND,
+					       "charger-wpc");
+	INIT_DELAYED_WORK(&charger->wpc_work, wpc_detect_work);
+	wake_lock_init(&charger->wc_current_wake_lock, WAKE_LOCK_SUSPEND,
+		       "charger->wc-current");
+	INIT_DELAYED_WORK(&charger->wc_current_work, max77854_wc_current_work);
+
+	ret = power_supply_register(&pdev->dev, &charger->psy_chg);
+	if (ret) {
+		pr_err("%s: Failed to Register psy_chg\n", __func__);
+		goto err_power_supply_register;
+	}
+
+	ret = power_supply_register(&pdev->dev, &charger->psy_otg);
+	if (ret) {
+		pr_err("%s: Failed to Register otg_chg\n", __func__);
+		goto err_power_supply_register_otg;
+	}
+
+	if (charger->pdata->chg_irq) {
+		INIT_DELAYED_WORK(&charger->isr_work, max77854_chg_isr_work);
+
+		ret = request_threaded_irq(charger->pdata->chg_irq,
+				NULL, max77854_chg_irq_thread,
+				charger->pdata->chg_irq_attr,
+				"charger-irq", charger);
+		if (ret) {
+			pr_err("%s: Failed to Request IRQ\n", __func__);
+			goto err_irq;
+		}
+
+			ret = enable_irq_wake(charger->pdata->chg_irq);
+			if (ret < 0)
+				pr_err("%s: Failed to Enable Wakeup Source(%d)\n",
+					__func__, ret);
+		}
+
+	charger->wc_w_irq = pdata->irq_base + MAX77854_CHG_IRQ_WCIN_I;
+	ret = request_threaded_irq(charger->wc_w_irq,
+				   NULL, wpc_charger_irq,
+				   IRQF_TRIGGER_FALLING,
+				   "wpc-int", charger);
+	if (ret) {
+		pr_err("%s: Failed to Request IRQ\n", __func__);
+		goto err_wc_irq;
+	}
+
+	max77854_read_reg(charger->i2c,
+			  MAX77854_CHG_REG_INT_OK, &reg_data);
+	charger->wc_w_state = (reg_data & MAX77854_WCIN_OK)
+		>> MAX77854_WCIN_OK_SHIFT;
+
+	charger->irq_chgin = pdata->irq_base + MAX77854_CHG_IRQ_CHGIN_I;
+	/* enable chgin irq after sec_battery_probe */
+	queue_delayed_work(charger->wqueue, &charger->chgin_init_work,
+			msecs_to_jiffies(3000));
+
+	charger->irq_bypass = pdata->irq_base + MAX77854_CHG_IRQ_BYP_I;
+	ret = request_threaded_irq(charger->irq_bypass, NULL,
+			max77854_bypass_irq, 0, "bypass-irq", charger);
+	if (ret < 0) {
+		pr_err("%s: fail to request bypass IRQ: %d: %d\n",
+				__func__, charger->irq_bypass, ret);
+	} else {
+		max77854_update_reg(charger->i2c,
+			MAX77854_CHG_REG_INT_MASK, 0, MAX77854_BYP_IM);
+	}
+
+	charger->irq_aicl = pdata->irq_base + MAX77854_CHG_IRQ_AICL_I;
+	charger->irq_batp = pdata->irq_base + MAX77854_CHG_IRQ_BATP_I;
+	ret = request_threaded_irq(charger->irq_batp, NULL,
+				   max77854_batp_irq, 0,
+				   "batp-irq", charger);
+	if (ret < 0)
+		pr_err("%s: fail to request bypass IRQ: %d: %d\n",
+		       __func__, charger->irq_batp, ret);
+
+	ret = max77854_chg_create_attrs(charger->psy_chg.dev);
+	if (ret) {
+		dev_err(charger->dev,
+			"%s : Failed to create_attrs\n", __func__);
+		goto err_wc_irq;
+	}
+
+	/* watchdog kick */
+	max77854_update_reg(charger->i2c, MAX77854_CHG_REG_CNFG_06,
+			MAX77854_WDTCLR, MAX77854_WDTCLR);
+
+	pr_info("%s: MAX77854 Charger Driver Loaded\n", __func__);
+
+	return 0;
+
+err_wc_irq:
+	free_irq(charger->pdata->chg_irq, NULL);
+err_irq:
+	power_supply_unregister(&charger->psy_otg);
+err_power_supply_register_otg:
+	power_supply_unregister(&charger->psy_chg);
+err_power_supply_register:
+	destroy_workqueue(charger->wqueue);
+err_pdata_free:
+	kfree(charger_data);
+err_free:
+	kfree(charger);
+
+	return ret;
+}
+
+static int __devexit max77854_charger_remove(struct platform_device *pdev)
+{
+	struct max77854_charger_data *charger =
+		platform_get_drvdata(pdev);
+
+	destroy_workqueue(charger->wqueue);
+
+	free_irq(charger->wc_w_irq, NULL);
+	free_irq(charger->pdata->chg_irq, NULL);
+	power_supply_unregister(&charger->psy_chg);
+	power_supply_unregister(&charger->psy_otg);
+	kfree(charger);
+
+	return 0;
+}
+
+#if defined CONFIG_PM
+static int max77854_charger_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int max77854_charger_resume(struct device *dev)
+{
+	return 0;
+}
+#else
+#define max77854_charger_suspend NULL
+#define max77854_charger_resume NULL
+#endif
+
+static void max77854_charger_shutdown(struct device *dev)
+{
+	struct max77854_charger_data *charger =
+				dev_get_drvdata(dev);
+	u8 reg_data;
+
+	pr_info("%s: MAX77854 Charger driver shutdown\n", __func__);
+	if (!charger->i2c) {
+		pr_err("%s: no max77854 i2c client\n", __func__);
+		return;
+	}
+	reg_data = 0x04;
+	max77854_write_reg(charger->i2c,
+		MAX77854_CHG_REG_CNFG_00, reg_data);
+	reg_data = 0x0F;
+	max77854_write_reg(charger->i2c,
+		MAX77854_CHG_REG_CNFG_09, reg_data);
+	reg_data = 0x10;
+	max77854_write_reg(charger->i2c,
+		MAX77854_CHG_REG_CNFG_10, reg_data);
+	reg_data = 0x60;
+	max77854_write_reg(charger->i2c,
+		MAX77854_CHG_REG_CNFG_12, reg_data);
+	pr_info("func:%s \n", __func__);
+}
+
+static SIMPLE_DEV_PM_OPS(max77854_charger_pm_ops, max77854_charger_suspend,
+			 max77854_charger_resume);
+
+static struct platform_driver max77854_charger_driver = {
+	.driver = {
+		.name = "max77854-charger",
+		.owner = THIS_MODULE,
+#ifdef CONFIG_PM
+		.pm = &max77854_charger_pm_ops,
+#endif
+		.shutdown = max77854_charger_shutdown,
+	},
+	.probe = max77854_charger_probe,
+	.remove = __devexit_p(max77854_charger_remove),
+};
+
+static int __init max77854_charger_init(void)
+{
+	pr_info("%s : \n", __func__);
+	return platform_driver_register(&max77854_charger_driver);
+}
+
+static void __exit max77854_charger_exit(void)
+{
+	platform_driver_unregister(&max77854_charger_driver);
+}
+
+module_init(max77854_charger_init);
+module_exit(max77854_charger_exit);
+
+MODULE_DESCRIPTION("Samsung MAX77854 Charger Driver");
+MODULE_AUTHOR("Samsung Electronics");
+MODULE_LICENSE("GPL");
diff -Naur linux-3.18.14/drivers/battery_v2/max77854_fuelgauge.c samsung/drivers/battery_v2/max77854_fuelgauge.c
--- linux-3.18.14/drivers/battery_v2/max77854_fuelgauge.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/max77854_fuelgauge.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,2245 @@
+/*
+ *  max77854_fuelgauge.c
+ *  Samsung MAX77854 Fuel Gauge Driver
+ *
+ *  Copyright (C) 2015 Samsung Electronics
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#define DEBUG
+/* #define BATTERY_LOG_MESSAGE */
+
+#include <linux/mfd/max77854-private.h>
+#include <linux/of_gpio.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include "include/fuelgauge/max77854_fuelgauge.h"
+
+static enum power_supply_property max77854_fuelgauge_props[] = {
+};
+
+bool max77854_fg_fuelalert_init(struct max77854_fuelgauge_data *fuelgauge,
+				int soc);
+
+#if !defined(CONFIG_SEC_FACTORY)
+static void max77854_fg_periodic_read(struct max77854_fuelgauge_data *fuelgauge)
+{
+	u8 reg;
+	int i;
+	int data[0x10];
+	char *str = NULL;
+
+	str = kzalloc(sizeof(char)*1024, GFP_KERNEL);
+	if (!str)
+		return;
+
+	for (i = 0; i < 16; i++) {
+		if (i == 5)
+			i = 11;
+		else if (i == 12)
+			i = 13;
+		for (reg = 0; reg < 0x10; reg++) {
+			data[reg] = max77854_read_word(fuelgauge->i2c, reg + i * 0x10);
+			if (data[reg] < 0) {
+				kfree(str);
+				return;
+			}
+		}
+		sprintf(str+strlen(str),
+			"%04xh,%04xh,%04xh,%04xh,%04xh,%04xh,%04xh,%04xh,",
+			data[0x00], data[0x01], data[0x02], data[0x03],
+			data[0x04], data[0x05], data[0x06], data[0x07]);
+		sprintf(str+strlen(str),
+			"%04xh,%04xh,%04xh,%04xh,%04xh,%04xh,%04xh,%04xh,",
+			data[0x08], data[0x09], data[0x0a], data[0x0b],
+			data[0x0c], data[0x0d], data[0x0e], data[0x0f]);
+		if (!fuelgauge->initial_update_of_soc) {
+			msleep(1);
+		}
+	}
+
+	pr_info("[FG] %s\n", str);
+
+	kfree(str);
+}
+#endif
+
+static int max77854_fg_read_vcell(struct max77854_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u32 vcell;
+	u16 w_data;
+	u32 temp;
+	u32 temp2;
+
+	if (max77854_bulk_read(fuelgauge->i2c, VCELL_REG, 2, data) < 0) {
+		pr_err("%s: Failed to read VCELL\n", __func__);
+		return -1;
+	}
+
+	w_data = (data[1]<<8) | data[0];
+
+	temp = (w_data & 0xFFF) * 78125;
+	vcell = temp / 1000000;
+
+	temp = ((w_data & 0xF000) >> 4) * 78125;
+	temp2 = temp / 1000000;
+	vcell += (temp2 << 4);
+
+	if (!(fuelgauge->info.pr_cnt++ % PRINT_COUNT)) {
+		fuelgauge->info.pr_cnt = 1;
+		pr_info("%s: VCELL(%d), data(0x%04x)\n",
+			__func__, vcell, (data[1]<<8) | data[0]);
+	}
+
+	if ((fuelgauge->vempty_mode == VEMPTY_MODE_SW_VALERT) && 
+		(vcell >= fuelgauge->battery_data->sw_v_empty_recover_vol)) {
+		fuelgauge->vempty_mode = VEMPTY_MODE_SW_RECOVERY;
+		max77854_fg_fuelalert_init(fuelgauge,
+					   fuelgauge->pdata->fuel_alert_soc);
+		pr_info("%s : Recoverd from SW V EMPTY Activation\n", __func__);
+	}
+
+	return vcell;
+}
+
+static int max77854_fg_read_vfocv(struct max77854_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u32 vfocv = 0;
+	u16 w_data;
+	u32 temp;
+	u32 temp2;
+
+	if (max77854_bulk_read(fuelgauge->i2c, VFOCV_REG, 2, data) < 0) {
+		pr_err("%s: Failed to read VFOCV\n", __func__);
+		return -1;
+	}
+
+	w_data = (data[1]<<8) | data[0];
+
+	temp = (w_data & 0xFFF) * 78125;
+	vfocv = temp / 1000000;
+
+	temp = ((w_data & 0xF000) >> 4) * 78125;
+	temp2 = temp / 1000000;
+	vfocv += (temp2 << 4);
+
+#if !defined(CONFIG_SEC_FACTORY)
+	max77854_fg_periodic_read(fuelgauge);
+#endif
+
+	return vfocv;
+}
+
+static int max77854_fg_read_avg_vcell(struct max77854_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u32 avg_vcell = 0;
+	u16 w_data;
+	u32 temp;
+	u32 temp2;
+
+	if (max77854_bulk_read(fuelgauge->i2c, AVR_VCELL_REG,
+			       2, data) < 0) {
+		pr_err("%s: Failed to read AVG_VCELL\n", __func__);
+		return -1;
+	}
+
+	w_data = (data[1]<<8) | data[0];
+
+	temp = (w_data & 0xFFF) * 78125;
+	avg_vcell = temp / 1000000;
+
+	temp = ((w_data & 0xF000) >> 4) * 78125;
+	temp2 = temp / 1000000;
+	avg_vcell += (temp2 << 4);
+
+	return avg_vcell;
+}
+
+static int max77854_fg_check_battery_present(struct max77854_fuelgauge_data *fuelgauge)
+{
+	u8 status_data[2];
+	int ret = 1;
+
+	/* 1. Check Bst bit */
+	if (max77854_bulk_read(fuelgauge->i2c, STATUS_REG,
+			       2, status_data) < 0) {
+		pr_err("%s: Failed to read STATUS_REG\n", __func__);
+		return 0;
+	}
+
+	if (status_data[0] & (0x1 << 3)) {
+		pr_info("%s: addr(0x01), data(0x%04x)\n", __func__,
+			(status_data[1]<<8) | status_data[0]);
+		pr_info("%s: battery is absent!!\n", __func__);
+		ret = 0;
+	}
+
+	return ret;
+}
+
+static void max77854_fg_set_vempty(struct max77854_fuelgauge_data *fuelgauge, int vempty_mode)
+{
+	u16 data = 0;
+	u8 valrt_data[2] = {0,};
+
+	if (!fuelgauge->using_temp_compensation) {
+		pr_info("%s: does not use temp compensation, default hw vempty\n", __func__);
+		vempty_mode = VEMPTY_MODE_HW;
+	}
+
+	fuelgauge->vempty_mode = vempty_mode;
+	switch (vempty_mode) {
+	case VEMPTY_MODE_SW:
+		/* HW Vempty Disable */
+		max77854_write_word(fuelgauge->i2c, VEMPTY_REG, fuelgauge->battery_data->V_empty_origin);
+		/* Reset VALRT Threshold setting (enable) */
+		valrt_data[1] = 0xFF;
+		valrt_data[0] = fuelgauge->battery_data->sw_v_empty_vol / 20;
+		if (max77854_bulk_write(fuelgauge->i2c, VALRT_THRESHOLD_REG,
+				2, valrt_data) < 0) {
+			pr_info("%s: Failed to write VALRT_THRESHOLD_REG\n", __func__);
+			return;
+		}
+		data = max77854_read_word(fuelgauge->i2c, (u8)VALRT_THRESHOLD_REG);
+		pr_info("%s: HW V EMPTY Disable, SW V EMPTY Enable with %d mV (%d) \n",
+			__func__, fuelgauge->battery_data->sw_v_empty_vol, (data&0x00ff)*20);
+		break;
+	default:
+		/* HW Vempty Enable */
+		max77854_write_word(fuelgauge->i2c, VEMPTY_REG, fuelgauge->battery_data->V_empty);
+		/* Reset VALRT Threshold setting (disable) */
+		valrt_data[1] = 0xFF;
+		valrt_data[0] = 0;
+		if (max77854_bulk_write(fuelgauge->i2c, VALRT_THRESHOLD_REG,
+				2, valrt_data) < 0) {
+			pr_info("%s: Failed to write VALRT_THRESHOLD_REG\n", __func__);
+			return;
+		}
+		data = max77854_read_word(fuelgauge->i2c, (u8)VALRT_THRESHOLD_REG);
+		pr_info("%s: HW V EMPTY Enable, SW V EMPTY Disable %d mV (%d) \n",
+			__func__, 0, (data&0x00ff)*20);
+		break;
+	}
+}
+
+static int max77854_fg_write_temp(struct max77854_fuelgauge_data *fuelgauge,
+			 int temperature)
+{
+	u8 data[2];
+
+	data[0] = (temperature%10) * 1000 / 39;
+	data[1] = temperature / 10;
+	max77854_bulk_write(fuelgauge->i2c, TEMPERATURE_REG, 2, data);
+
+	pr_debug("%s: temperature to (%d, 0x%02x%02x)\n",
+		__func__, temperature, data[1], data[0]);
+
+	fuelgauge->temperature = temperature;
+	return temperature;
+}
+
+static int max77854_fg_read_temp(struct max77854_fuelgauge_data *fuelgauge)
+{
+	u8 data[2] = {0, 0};
+	int temper = 0;
+
+	if (max77854_fg_check_battery_present(fuelgauge)) {
+		if (max77854_bulk_read(fuelgauge->i2c,
+				       TEMPERATURE_REG, 2, data) < 0) {
+			pr_err("%s: Failed to read TEMPERATURE_REG\n",
+				__func__);
+			return -1;
+		}
+
+		if (data[1]&(0x1 << 7)) {
+			temper = ((~(data[1]))&0xFF)+1;
+			temper *= (-1000);
+			temper -= ((~((int)data[0]))+1) * 39 / 10;
+		} else {
+			temper = data[1] & 0x7f;
+			temper *= 1000;
+			temper += data[0] * 39 / 10;
+		}
+	} else
+		temper = 20000;
+
+	if (!(fuelgauge->info.pr_cnt % PRINT_COUNT))
+		pr_info("%s: TEMPERATURE(%d), data(0x%04x)\n",
+			__func__, temper, (data[1]<<8) | data[0]);
+
+	return temper/100;
+}
+
+/* soc should be 0.1% unit */
+static int max77854_fg_read_vfsoc(struct max77854_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	int soc;
+
+	if (max77854_bulk_read(fuelgauge->i2c, VFSOC_REG,
+			       2, data) < 0) {
+		pr_err("%s: Failed to read VFSOC\n", __func__);
+		return -1;
+	}
+
+	soc = ((data[1] * 100) + (data[0] * 100 / 256)) / 10;
+
+	return min(soc, 1000);
+}
+
+/* soc should be 0.1% unit */
+static int max77854_fg_read_avsoc(struct max77854_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	int soc;
+
+	if (max77854_bulk_read(fuelgauge->i2c, SOCAV_REG,
+			       2, data) < 0) {
+		pr_err("%s: Failed to read AVSOC\n", __func__);
+		return -1;
+	}
+
+	soc = ((data[1] * 100) + (data[0] * 100 / 256)) / 10;
+
+	return min(soc, 1000);
+}
+
+/* soc should be 0.1% unit */
+static int max77854_fg_read_soc(struct max77854_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	int soc, vf_soc;
+
+	if (max77854_bulk_read(fuelgauge->i2c, SOCREP_REG, 2, data) < 0) {
+		pr_err("%s: Failed to read SOCREP\n", __func__);
+		return -1;
+	}
+
+	soc = ((data[1] * 100) + (data[0] * 100 / 256)) / 10;
+	vf_soc = max77854_fg_read_vfsoc(fuelgauge);
+
+#ifdef BATTERY_LOG_MESSAGE
+	pr_debug("%s: raw capacity (%d)\n", __func__, soc);
+
+	if (!(fuelgauge->info.pr_cnt % PRINT_COUNT)) {
+		pr_debug("%s: raw capacity (%d), data(0x%04x)\n",
+			 __func__, soc, (data[1]<<8) | data[0]);
+		pr_debug("%s: REPSOC (%d), VFSOC (%d), data(0x%04x)\n",
+				__func__, soc/10, vf_soc/10, (data[1]<<8) | data[0]);
+	}
+#endif
+
+	return min(soc, 1000);
+}
+
+/* soc should be 0.01% unit */
+static int max77854_fg_read_rawsoc(struct max77854_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	int soc;
+
+	if (max77854_bulk_read(fuelgauge->i2c, SOCREP_REG,
+			       2, data) < 0) {
+		pr_err("%s: Failed to read SOCREP\n", __func__);
+		return -1;
+	}
+
+	soc = (data[1] * 100) + (data[0] * 100 / 256);
+
+	pr_debug("%s: raw capacity (0.01%%) (%d)\n",
+		 __func__, soc);
+
+	if (!(fuelgauge->info.pr_cnt % PRINT_COUNT))
+		pr_debug("%s: raw capacity (%d), data(0x%04x)\n",
+			 __func__, soc, (data[1]<<8) | data[0]);
+
+	return min(soc, 10000);
+}
+
+static int max77854_fg_read_fullcap(struct max77854_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	int ret;
+
+	if (max77854_bulk_read(fuelgauge->i2c, FULLCAP_REG,
+			       2, data) < 0) {
+		pr_err("%s: Failed to read FULLCAP\n", __func__);
+		return -1;
+	}
+
+	ret = (data[1] << 8) + data[0];
+
+	return ret;
+}
+
+static int max77854_fg_read_fullcaprep(struct max77854_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	int ret;
+
+	if (max77854_bulk_read(fuelgauge->i2c, FG_FULLCAPREP,
+			       2, data) < 0) {
+		pr_err("%s: Failed to read FULLCAP\n", __func__);
+		return -1;
+	}
+
+	ret = (data[1] << 8) + data[0];
+
+	return ret;
+}
+
+
+static int max77854_fg_read_fullcapnom(struct max77854_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	int ret;
+
+	if (max77854_bulk_read(fuelgauge->i2c, FULLCAP_NOM_REG,
+			       2, data) < 0) {
+		pr_err("%s: Failed to read FULLCAP\n", __func__);
+		return -1;
+	}
+
+	ret = (data[1] << 8) + data[0];
+
+	return ret;
+}
+
+static int max77854_fg_read_mixcap(struct max77854_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	int ret;
+
+	if (max77854_bulk_read(fuelgauge->i2c, REMCAP_MIX_REG,
+			       2, data) < 0) {
+		pr_err("%s: Failed to read REMCAP_MIX_REG\n",
+		       __func__);
+		return -1;
+	}
+
+	ret = (data[1] << 8) + data[0];
+
+	return ret;
+}
+
+static int max77854_fg_read_avcap(struct max77854_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	int ret;
+
+	if (max77854_bulk_read(fuelgauge->i2c, REMCAP_AV_REG,
+			       2, data) < 0) {
+		pr_err("%s: Failed to read REMCAP_AV_REG\n",
+		       __func__);
+		return -1;
+	}
+
+	ret = (data[1] << 8) + data[0];
+
+	return ret;
+}
+
+static int max77854_fg_read_repcap(struct max77854_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	int ret;
+
+	if (max77854_bulk_read(fuelgauge->i2c, REMCAP_REP_REG,
+			       2, data) < 0) {
+		pr_err("%s: Failed to read REMCAP_REP_REG\n",
+		       __func__);
+		return -1;
+	}
+
+	ret = (data[1] << 8) + data[0];
+
+	return ret;
+}
+
+static int max77854_fg_read_current(struct max77854_fuelgauge_data *fuelgauge, int unit)
+{
+	u8 data1[2];
+	u32 temp, sign;
+	s32 i_current;
+
+	if (max77854_bulk_read(fuelgauge->i2c, CURRENT_REG,
+			      2, data1) < 0) {
+		pr_err("%s: Failed to read CURRENT\n", __func__);
+		return -1;
+	}
+
+	temp = ((data1[1]<<8) | data1[0]) & 0xFFFF;
+	/* Debug log for abnormal current case */
+	if (temp & (0x1 << 15)) {
+		sign = NEGATIVE;
+		temp = (~temp & 0xFFFF) + 1;
+	} else
+		sign = POSITIVE;
+
+	/* 1.5625uV/0.01Ohm(Rsense) = 156.25uA */
+	/* 1.5625uV/0.005Ohm(Rsense) = 312.5uA */
+	switch (unit) {
+	case SEC_BATTERY_CURRENT_UA:
+		i_current = temp * 15625 * fuelgauge->fg_resistor / 100;
+		break;
+	case SEC_BATTERY_CURRENT_MA:
+	default:
+		i_current = temp * 15625 * fuelgauge->fg_resistor / 100000;
+	}
+
+	if (sign)
+		i_current *= -1;
+
+	pr_debug("%s: current=%d\n", __func__, i_current);
+
+	return i_current;
+}
+
+static int max77854_fg_read_avg_current(struct max77854_fuelgauge_data *fuelgauge, int unit)
+{
+	u8  data2[2];
+	u32 temp, sign;
+	s32 avg_current;
+	int vcell;
+	static int cnt;
+
+	if (max77854_bulk_read(fuelgauge->i2c, AVG_CURRENT_REG,
+			       2, data2) < 0) {
+		pr_err("%s: Failed to read AVERAGE CURRENT\n",
+		       __func__);
+		return -1;
+	}
+
+	temp = ((data2[1]<<8) | data2[0]) & 0xFFFF;
+	if (temp & (0x1 << 15)) {
+		sign = NEGATIVE;
+		temp = (~temp & 0xFFFF) + 1;
+	} else
+		sign = POSITIVE;
+
+	/* 1.5625uV/0.01Ohm(Rsense) = 156.25uA */
+	/* 1.5625uV/0.005Ohm(Rsense) = 312.5uA */
+	switch (unit) {
+	case SEC_BATTERY_CURRENT_UA:
+		avg_current = temp * 15625 * fuelgauge->fg_resistor / 100;
+		break;
+	case SEC_BATTERY_CURRENT_MA:
+	default:
+		avg_current = temp * 15625 * fuelgauge->fg_resistor / 100000;
+	}
+
+	if (sign)
+		avg_current *= -1;
+
+	vcell = max77854_fg_read_vcell(fuelgauge);
+	if ((vcell < 3500) && (cnt < 10) && (avg_current < 0) &&
+	    fuelgauge->is_charging) {
+		avg_current = 1;
+		cnt++;
+	}
+
+	pr_debug("%s: avg_current=%d\n", __func__, avg_current);
+
+	return avg_current;
+}
+
+static int max77854_fg_read_cycle(struct max77854_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	int ret;
+
+	if (max77854_bulk_read(fuelgauge->i2c, CYCLES_REG,
+			       2, data) < 0) {
+		pr_err("%s: Failed to read FULLCAPCYCLE\n", __func__);
+		return -1;
+	}
+
+	ret = (data[1] << 8) + data[0];
+
+	return ret;
+}
+
+static bool max77854_check_jig_status(struct max77854_fuelgauge_data *fuelgauge)
+{
+	bool ret = false;
+	if(fuelgauge->pdata->jig_gpio)
+		ret = gpio_get_value(fuelgauge->pdata->jig_gpio);
+
+	return ret;
+}
+
+int max77854_fg_reset_soc(struct max77854_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	int vfocv, fullcap;
+
+	/* delay for current stablization */
+	msleep(500);
+
+	pr_info("%s: Before quick-start - VCELL(%d), VFOCV(%d), VfSOC(%d), RepSOC(%d)\n",
+		__func__, max77854_fg_read_vcell(fuelgauge), max77854_fg_read_vfocv(fuelgauge),
+		max77854_fg_read_vfsoc(fuelgauge), max77854_fg_read_soc(fuelgauge));
+	pr_info("%s: Before quick-start - current(%d), avg current(%d)\n",
+		__func__, max77854_fg_read_current(fuelgauge, SEC_BATTERY_CURRENT_MA),
+		max77854_fg_read_avg_current(fuelgauge, SEC_BATTERY_CURRENT_MA));
+
+	if (!max77854_check_jig_status(fuelgauge)) {
+		pr_info("%s : Return by No JIG_ON signal\n", __func__);
+		return 0;
+	}
+
+	max77854_write_word(fuelgauge->i2c, CYCLES_REG, 0);
+
+	if (max77854_bulk_read(fuelgauge->i2c, MISCCFG_REG,
+			       2, data) < 0) {
+		pr_err("%s: Failed to read MiscCFG\n", __func__);
+		return -1;
+	}
+
+	data[1] |= (0x1 << 2);
+	if (max77854_bulk_write(fuelgauge->i2c, MISCCFG_REG,
+				2, data) < 0) {
+		pr_err("%s: Failed to write MiscCFG\n", __func__);
+		return -1;
+	}
+
+	msleep(250);
+	max77854_write_word(fuelgauge->i2c, FULLCAP_REG,
+			    fuelgauge->battery_data->Capacity);
+	msleep(500);
+
+	pr_info("%s: After quick-start - VCELL(%d), VFOCV(%d), VfSOC(%d), RepSOC(%d)\n",
+		__func__, max77854_fg_read_vcell(fuelgauge), max77854_fg_read_vfocv(fuelgauge),
+		max77854_fg_read_vfsoc(fuelgauge), max77854_fg_read_soc(fuelgauge));
+	pr_info("%s: After quick-start - current(%d), avg current(%d)\n",
+		__func__, max77854_fg_read_current(fuelgauge, SEC_BATTERY_CURRENT_MA),
+		max77854_fg_read_avg_current(fuelgauge, SEC_BATTERY_CURRENT_MA));
+
+	max77854_write_word(fuelgauge->i2c, CYCLES_REG, 0x00a0);
+
+/* P8 is not turned off by Quickstart @3.4V
+ * (It's not a problem, depend on mode data)
+ * Power off for factory test(File system, etc..) */
+	vfocv = max77854_fg_read_vfocv(fuelgauge);
+	if (vfocv < POWER_OFF_VOLTAGE_LOW_MARGIN) {
+		pr_info("%s: Power off condition(%d)\n", __func__, vfocv);
+
+		fullcap = max77854_read_word(fuelgauge->i2c, FULLCAP_REG);
+
+		/* FullCAP * 0.009 */
+		max77854_write_word(fuelgauge->i2c, REMCAP_REP_REG,
+				    (u16)(fullcap * 9 / 1000));
+		msleep(200);
+		pr_info("%s: new soc=%d, vfocv=%d\n", __func__,
+			max77854_fg_read_soc(fuelgauge), vfocv);
+	}
+
+	pr_info("%s: Additional step - VfOCV(%d), VfSOC(%d), RepSOC(%d)\n",
+		__func__, max77854_fg_read_vfocv(fuelgauge),
+		max77854_fg_read_vfsoc(fuelgauge), max77854_fg_read_soc(fuelgauge));
+
+	return 0;
+}
+
+int max77854_fg_reset_capacity_by_jig_connection(struct max77854_fuelgauge_data *fuelgauge)
+{
+	union power_supply_propval val;
+	val.intval = 1;
+	psy_do_property("max77854-charger", set,
+			POWER_SUPPLY_PROP_ENERGY_NOW, val);
+	pr_info("%s: DesignCap = Capacity - 1 (Jig Connection)\n", __func__);
+
+	return max77854_write_word(fuelgauge->i2c, DESIGNCAP_REG,
+				   fuelgauge->battery_data->Capacity-1);
+}
+
+static int max77854_fg_check_status_reg(struct max77854_fuelgauge_data *fuelgauge)
+{
+	u8 status_data[2];
+	int ret = 0;
+
+	/* 1. Check Smn was generatedread */
+	if (max77854_bulk_read(fuelgauge->i2c, STATUS_REG,
+			       2, status_data) < 0) {
+		pr_err("%s: Failed to read STATUS_REG\n", __func__);
+		return -1;
+	}
+
+#ifdef BATTERY_LOG_MESSAGE
+	pr_info("%s: addr(0x00), data(0x%04x)\n", __func__,
+		(status_data[1]<<8) | status_data[0]);
+#endif
+
+	if (status_data[1] & (0x1 << 2))
+		ret = 1;
+
+	/* 2. clear Status reg */
+	status_data[1] = 0;
+	if (max77854_bulk_write(fuelgauge->i2c, STATUS_REG,
+				2, status_data) < 0) {
+		pr_info("%s: Failed to write STATUS_REG\n", __func__);
+		return -1;
+	}
+
+	return ret;
+}
+
+int max77854_get_fuelgauge_value(struct max77854_fuelgauge_data *fuelgauge, int data)
+{
+	int ret;
+
+	switch (data) {
+	case FG_LEVEL:
+		ret = max77854_fg_read_soc(fuelgauge);
+		break;
+
+	case FG_TEMPERATURE:
+		ret = max77854_fg_read_temp(fuelgauge);
+		break;
+
+	case FG_VOLTAGE:
+		ret = max77854_fg_read_vcell(fuelgauge);
+		break;
+
+	case FG_CURRENT:
+		ret = max77854_fg_read_current(fuelgauge, SEC_BATTERY_CURRENT_MA);
+		break;
+
+	case FG_CURRENT_AVG:
+		ret = max77854_fg_read_avg_current(fuelgauge, SEC_BATTERY_CURRENT_MA);
+		break;
+
+	case FG_CHECK_STATUS:
+		ret = max77854_fg_check_status_reg(fuelgauge);
+		break;
+
+	case FG_RAW_SOC:
+		ret = max77854_fg_read_rawsoc(fuelgauge);
+		break;
+
+	case FG_VF_SOC:
+		ret = max77854_fg_read_vfsoc(fuelgauge);
+		break;
+
+	case FG_AV_SOC:
+		ret = max77854_fg_read_avsoc(fuelgauge);
+		break;
+
+	case FG_FULLCAP:
+		ret = max77854_fg_read_fullcap(fuelgauge);
+		break;
+
+	case FG_FULLCAPNOM:
+		ret = max77854_fg_read_fullcapnom(fuelgauge);
+		break;
+
+	case FG_FULLCAPREP:
+		ret = max77854_fg_read_fullcaprep(fuelgauge);
+		break;
+
+	case FG_MIXCAP:
+		ret = max77854_fg_read_mixcap(fuelgauge);
+		break;
+
+	case FG_AVCAP:
+		ret = max77854_fg_read_avcap(fuelgauge);
+		break;
+
+	case FG_REPCAP:
+		ret = max77854_fg_read_repcap(fuelgauge);
+		break;
+
+	case FG_CYCLE:
+		ret = max77854_fg_read_cycle(fuelgauge);
+		break;
+
+	default:
+		ret = -1;
+		break;
+	}
+
+	return ret;
+}
+
+int max77854_fg_alert_init(struct max77854_fuelgauge_data *fuelgauge, int soc)
+{
+	u8 misccgf_data[2];
+	u8 salrt_data[2];
+	u8 config_data[2];
+	u8 talrt_data[2];
+	u16 read_data = 0;
+
+	fuelgauge->is_fuel_alerted = false;
+
+	/* Using RepSOC */
+	if (max77854_bulk_read(fuelgauge->i2c, MISCCFG_REG, 2,
+			       misccgf_data) < 0) {
+		pr_err("%s: Failed to read MISCCFG_REG\n", __func__);
+		return -1;
+	}
+	misccgf_data[0] = misccgf_data[0] & ~(0x03);
+
+	if (max77854_bulk_write(fuelgauge->i2c, MISCCFG_REG,
+				2, misccgf_data) < 0) {
+		pr_info("%s: Failed to write MISCCFG_REG\n", __func__);
+		return -1;
+	}
+
+	/* SALRT Threshold setting */
+	salrt_data[1] = 0xff;
+	salrt_data[0] = soc;
+	if (max77854_bulk_write(fuelgauge->i2c, SALRT_THRESHOLD_REG,
+				2, salrt_data) < 0) {
+		pr_info("%s: Failed to write SALRT_THRESHOLD_REG\n", __func__);
+		return -1;
+	}
+
+	/* Reset TALRT Threshold setting (disable) */
+	talrt_data[1] = 0x7F;
+	talrt_data[0] = 0x80;
+	if (max77854_bulk_write(fuelgauge->i2c, TALRT_THRESHOLD_REG,
+				2, talrt_data) < 0) {
+		pr_info("%s: Failed to write TALRT_THRESHOLD_REG\n", __func__);
+		return -1;
+	}
+
+	read_data = max77854_read_word(fuelgauge->i2c, (u8)TALRT_THRESHOLD_REG);
+	if (read_data != 0x7f80)
+		pr_err("%s: TALRT_THRESHOLD_REG is not valid (0x%x)\n",
+			__func__, read_data);
+
+	/*mdelay(100);*/
+
+	/* Enable SOC alerts */
+	if (max77854_bulk_read(fuelgauge->i2c, CONFIG_REG,
+			       2, config_data) < 0) {
+		pr_err("%s: Failed to read CONFIG_REG\n", __func__);
+		return -1;
+	}
+	config_data[0] = config_data[0] | (0x1 << 2);
+
+	if (max77854_bulk_write(fuelgauge->i2c, CONFIG_REG,
+				2, config_data) < 0) {
+		pr_info("%s: Failed to write CONFIG_REG\n", __func__);
+		return -1;
+	}
+
+	max77854_update_reg(fuelgauge->pmic,
+			    MAX77854_PMIC_REG_INTSRC_MASK,
+			    ~MAX77854_IRQSRC_FG,
+			    MAX77854_IRQSRC_FG);
+
+	pr_info("[%s] SALRT(0x%02x%02x), CONFIG(0x%02x%02x)\n",
+		__func__,
+		salrt_data[1], salrt_data[0],
+		config_data[1], config_data[0]);
+
+	return 1;
+}
+
+static int max77854_get_fuelgauge_soc(struct max77854_fuelgauge_data *fuelgauge)
+{
+	int fg_soc = 0;
+	int fg_vfsoc;
+	int fg_vcell;
+	int fg_current;
+	int avg_current;
+
+	fg_soc = max77854_get_fuelgauge_value(fuelgauge, FG_LEVEL);
+	if (fg_soc < 0) {
+		pr_info("Can't read soc!!!");
+		fg_soc = fuelgauge->info.soc;
+	}
+
+	fg_vcell = max77854_get_fuelgauge_value(fuelgauge, FG_VOLTAGE);
+	fg_current = max77854_get_fuelgauge_value(fuelgauge, FG_CURRENT);
+	avg_current = max77854_get_fuelgauge_value(fuelgauge, FG_CURRENT_AVG);
+	fg_vfsoc = max77854_get_fuelgauge_value(fuelgauge, FG_VF_SOC);
+
+	if (fuelgauge->info.is_first_check)
+		fuelgauge->info.is_first_check = false;
+
+	if ((fg_vcell < 3400) && (avg_current < 0) && (fg_soc <= 10))
+		fg_soc = 0;
+
+	fuelgauge->info.soc = fg_soc;
+
+	pr_debug("%s: soc(%d)\n",
+		__func__, fuelgauge->info.soc);
+
+	return fg_soc;
+}
+
+static irqreturn_t max77854_jig_irq_thread(int irq, void *irq_data)
+{
+	struct max77854_fuelgauge_data *fuelgauge = irq_data;
+
+	if (max77854_check_jig_status(fuelgauge))
+		max77854_fg_reset_capacity_by_jig_connection(fuelgauge);
+	else
+		pr_info("%s: jig removed\n", __func__);
+	return IRQ_HANDLED;
+}
+
+bool max77854_fg_init(struct max77854_fuelgauge_data *fuelgauge)
+{
+	ktime_t	current_time;
+	struct timespec ts;
+	u8 data[2] = {0, 0};
+	u32 volt_threshold = 0;
+	u32 temp_threshold = 0;
+
+#if defined(ANDROID_ALARM_ACTIVATED)
+	current_time = alarm_get_elapsed_realtime();
+	ts = ktime_to_timespec(current_time);
+#else
+	current_time = ktime_get_boottime();
+	ts = ktime_to_timespec(current_time);
+#endif
+
+	fuelgauge->info.fullcap_check_interval = ts.tv_sec;
+
+	fuelgauge->info.is_first_check = true;
+
+	/* Init parameters to prevent wrong compensation. */
+	fuelgauge->info.previous_fullcap =
+		max77854_read_word(fuelgauge->i2c, FULLCAP_REG);
+	fuelgauge->info.previous_vffullcap =
+		max77854_read_word(fuelgauge->i2c, FULLCAP_NOM_REG);
+
+	if (fuelgauge->pdata->jig_gpio) {
+		int ret;
+		ret = request_threaded_irq(fuelgauge->pdata->jig_irq,
+				NULL, max77854_jig_irq_thread,
+				IRQF_TRIGGER_RISING | IRQF_ONESHOT,
+				"jig-irq", fuelgauge);
+		if (ret) {
+			pr_info("%s: Failed to Request IRQ\n",
+					__func__);
+		}
+		pr_info("%s: jig_result : %d\n", __func__, max77854_check_jig_status(fuelgauge));
+
+		/* initial check for the JIG */
+		if (max77854_check_jig_status(fuelgauge))
+			max77854_fg_reset_capacity_by_jig_connection(fuelgauge);
+	}
+
+	/* NOT using FG for temperature */
+	if (fuelgauge->pdata->thermal_source != SEC_BATTERY_THERMAL_SOURCE_FG) {
+		if (max77854_bulk_read(fuelgauge->i2c, CONFIG_REG,
+				       2, data) < 0) {
+			pr_err ("%s : Failed to read CONFIG_REG\n", __func__);
+			return false;
+		}
+		data[1] |= 0x1;
+
+		if (max77854_bulk_write(fuelgauge->i2c, CONFIG_REG,
+					2, data) < 0) {
+			pr_info("%s : Failed to write CONFIG_REG\n", __func__);
+			return false;
+		}
+	} else {
+		if (max77854_bulk_read(fuelgauge->i2c, CONFIG_REG,
+				       2, data) < 0) {
+			pr_err ("%s : Failed to read CONFIG_REG\n", __func__);
+			return false;
+		}
+		data[1] &= 0xFE;
+		data[0] |= 0x10;
+
+		if (max77854_bulk_write(fuelgauge->i2c, CONFIG_REG,
+					2, data) < 0) {
+			pr_info("%s : Failed to write CONFIG_REG\n", __func__);
+			return false;
+		}
+	}
+
+	if (fuelgauge->auto_discharge_en) {
+		/* Auto discharge EN & Alert Enable */
+		max77854_bulk_read(fuelgauge->i2c, CONFIG2_REG, 2, data);
+		data[1] |= 0x2;
+		max77854_bulk_write(fuelgauge->i2c, CONFIG2_REG, 2, data);
+
+		/* Set Auto Discharge temperature & Voltage threshold */
+		volt_threshold =
+			fuelgauge->discharge_volt_threshold < 3900 ? 0x0 :
+			fuelgauge->discharge_volt_threshold > 4540 ? 0x20 :
+			(fuelgauge->discharge_volt_threshold - 3900) / 20;
+
+		temp_threshold =
+			fuelgauge->discharge_temp_threshold < 470 ? 0x0 :
+			fuelgauge->discharge_temp_threshold > 630 ? 0x20 :
+			(fuelgauge->discharge_temp_threshold - 470) / 5;
+
+		max77854_bulk_read(fuelgauge->i2c, DISCHARGE_THRESHOLD_REG, 2, data);
+		data[1] &= ~0xF8;
+		data[1] |= volt_threshold << 3;
+
+		data[0] &= ~0xF8;
+		data[0] |= temp_threshold << 3;
+
+		max77854_bulk_write(fuelgauge->i2c, DISCHARGE_THRESHOLD_REG, 2, data);
+
+		pr_info("%s: DISCHARGE_THRESHOLD Value : 0x%x\n",
+			__func__, (data[1]<<8) | data[0]);
+	}
+
+	return true;
+}
+
+bool max77854_fg_fuelalert_init(struct max77854_fuelgauge_data *fuelgauge,
+				int soc)
+{
+	/* 1. Set max77854 alert configuration. */
+	if (max77854_fg_alert_init(fuelgauge, soc) > 0)
+		return true;
+	else
+		return false;
+}
+
+void max77854_fg_fuelalert_set(struct max77854_fuelgauge_data *fuelgauge,
+			       int enable)
+{
+	u8 config_data[2];
+	u8 status_data[2];
+
+	if (max77854_bulk_read(fuelgauge->i2c, CONFIG_REG,
+			       2, config_data) < 0)
+		pr_err("%s: Failed to read CONFIG_REG\n", __func__);
+
+	if (enable)
+		config_data[0] |= ALERT_EN;
+	else
+		config_data[0] &= ~ALERT_EN;
+
+	pr_info("%s : CONFIG(0x%02x%02x)\n", __func__, config_data[1], config_data[0]);
+
+	if (max77854_bulk_write(fuelgauge->i2c, CONFIG_REG,
+				2, config_data) < 0)
+		pr_info("%s: Failed to write CONFIG_REG\n", __func__);
+
+	if (max77854_bulk_read(fuelgauge->i2c, STATUS_REG,
+			       2, status_data) < 0)
+		pr_err("%s : Failed to read STATUS_REG\n", __func__);
+
+	if ((status_data[1] & 0x01) && !lpcharge && !fuelgauge->is_charging) {
+		pr_info("%s : Battery Voltage is Very Low!! SW V EMPTY ENABLE\n", __func__);
+		fuelgauge->vempty_mode = VEMPTY_MODE_SW_VALERT;
+	}
+}
+
+
+bool max77854_fg_fuelalert_process(void *irq_data)
+{
+	struct max77854_fuelgauge_data *fuelgauge =
+		(struct max77854_fuelgauge_data *)irq_data;
+
+	max77854_fg_fuelalert_set(fuelgauge, 0);
+
+	return true;
+}
+
+bool max77854_fg_reset(struct max77854_fuelgauge_data *fuelgauge)
+{
+	if (!max77854_fg_reset_soc(fuelgauge))
+		return true;
+	else
+		return false;
+}
+
+static int max77854_fg_check_capacity_max(
+	struct max77854_fuelgauge_data *fuelgauge, int capacity_max)
+{
+	int cap_max, cap_min;
+
+	cap_max = (fuelgauge->pdata->capacity_max +
+			fuelgauge->pdata->capacity_max_margin) * 100 / 101;
+	cap_min = (fuelgauge->pdata->capacity_max -
+		fuelgauge->pdata->capacity_max_margin) * 100 / 101;
+
+	return (capacity_max < cap_min) ? cap_min :
+		((capacity_max > cap_max) ? cap_max : capacity_max);
+}
+
+#define CAPACITY_MAX_CONTROL_THRESHOLD 300
+static void max77854_fg_get_scaled_capacity(
+	struct max77854_fuelgauge_data *fuelgauge,
+	union power_supply_propval *val)
+{
+#if defined(CONFIG_DISABLE_SAVE_CAPACITY_MAX)
+	u16 reg_data;
+#endif
+	union power_supply_propval cable_val, chg_val, chg_val2;
+#if defined(CONFIG_BATTERY_SWELLING)
+	union power_supply_propval swelling_val;
+#endif
+	int current_standard, raw_capacity = val->intval;
+	struct power_supply *psy = get_power_supply_by_name("battery");
+
+	if(!psy) {
+		pr_info("%s : battery is not initailized\n", __func__);
+		return;
+	}
+
+	psy_do_property("battery", get, POWER_SUPPLY_PROP_ONLINE, cable_val);
+#if defined(CONFIG_BATTERY_SWELLING)
+	/* Check whether DUT is in the swelling mode or not */
+	psy_do_property("battery", get, POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT, swelling_val);
+#endif
+
+	chg_val.intval = cable_val.intval;
+	psy_do_property("max77854-charger", get, POWER_SUPPLY_PROP_CURRENT_AVG,
+			chg_val);
+	psy_do_property("max77854-charger", get, POWER_SUPPLY_PROP_CHARGE_NOW,
+			chg_val2);
+
+	if (is_hv_wireless_type(fuelgauge->cable_type) || is_hv_wire_type(fuelgauge->cable_type))
+		current_standard = CAPACITY_SCALE_HV_CURRENT;
+	else
+		current_standard = CAPACITY_SCALE_DEFAULT_CURRENT;
+
+	pr_info("%s : current_standard(%d)\n", __func__, current_standard);
+
+	if ((cable_val.intval != POWER_SUPPLY_TYPE_BATTERY) &&
+#if defined(CONFIG_BATTERY_SWELLING)
+		(!swelling_val.intval) &&
+#endif
+		(!strcmp(chg_val2.strval, "CV Mode")) &&
+		(chg_val.intval >= current_standard)) {
+		int max_temp;
+		int temp, sample;
+		int curr;
+		int topoff;
+		int capacity_threshold;
+		static int cnt;
+
+		max_temp = fuelgauge->capacity_max;
+		curr = max77854_get_fuelgauge_value(fuelgauge, FG_CURRENT_AVG);
+		topoff = fuelgauge->pdata->charging_current[POWER_SUPPLY_TYPE_MAINS].full_check_current_1st;
+		capacity_threshold = topoff + CAPACITY_MAX_CONTROL_THRESHOLD;
+
+		pr_info("%s : curr(%d) topoff(%d) capacity_max(%d)\n", __func__, curr, topoff, max_temp);
+
+		if ((curr < capacity_threshold) && (curr > topoff)) {
+			if (!cnt) {
+				cnt = 1;
+				fuelgauge->standard_capacity = (val->intval < fuelgauge->pdata->capacity_min) ?
+					0 : ((val->intval - fuelgauge->pdata->capacity_min) * 999 /
+					(fuelgauge->capacity_max - fuelgauge->pdata->capacity_min));
+			} else if (fuelgauge->standard_capacity < 999) {
+				temp = (val->intval < fuelgauge->pdata->capacity_min) ?
+					0 : ((val->intval - fuelgauge->pdata->capacity_min) * 999 /
+					(fuelgauge->capacity_max - fuelgauge->pdata->capacity_min));
+
+				sample = ((capacity_threshold - curr) * (999 - fuelgauge->standard_capacity)) /
+					(capacity_threshold - topoff);
+
+				pr_info("%s : %d = ((%d - %d) * (999 - %d)) / (%d - %d)\n",
+					__func__,
+					sample, capacity_threshold, curr, fuelgauge->standard_capacity,
+					capacity_threshold, topoff);
+
+				if ((temp - fuelgauge->standard_capacity) >= sample) {
+					pr_info("%s : TEMP > SAMPLE\n", __func__);
+				} else if ((sample - (temp - fuelgauge->standard_capacity)) < 5) {
+					pr_info("%s : TEMP < SAMPLE && GAP UNDER 5\n", __func__);
+					max_temp -= (sample - (temp - fuelgauge->standard_capacity));
+				} else {
+					pr_info("%s : TEMP > SAMPLE && GAP OVER 5\n", __func__);
+					max_temp -= 5;
+				}
+				pr_info("%s : TEMP(%d) SAMPLE(%d) CAPACITY_MAX(%d)\n",
+					__func__, temp, sample, fuelgauge->capacity_max);
+
+				fuelgauge->capacity_max =
+					max77854_fg_check_capacity_max(fuelgauge, max_temp);
+			}
+		} else {
+			cnt = 0;
+		}
+	}
+
+	val->intval = (val->intval < fuelgauge->pdata->capacity_min) ?
+		0 : ((val->intval - fuelgauge->pdata->capacity_min) * 1000 /
+		     (fuelgauge->capacity_max - fuelgauge->pdata->capacity_min));
+
+#if defined(CONFIG_DISABLE_SAVE_CAPACITY_MAX)
+	reg_data = max77854_read_word(fuelgauge->i2c, 0xD0);
+	if (reg_data != fuelgauge->capacity_max) {
+		pr_info("%s : 0xD0 Register Update (%d) -> (%d)\n",
+			__func__, reg_data, fuelgauge->capacity_max);
+		reg_data = fuelgauge->capacity_max;
+		max77854_write_word(fuelgauge->i2c, 0xD0, reg_data);
+	}
+#endif
+
+	pr_info("%s : CABLE TYPE(%d) INPUT CURRENT(%d) CHARGING MODE(%s)" \
+		"capacity_max (%d) scaled capacity(%d.%d), raw_soc(%d.%d)\n",
+		__func__, cable_val.intval, chg_val.intval, chg_val2.strval,
+		fuelgauge->capacity_max, val->intval/10, val->intval%10, raw_capacity/10, raw_capacity%10);
+}
+
+/* capacity is integer */
+static void max77854_fg_get_atomic_capacity(
+	struct max77854_fuelgauge_data *fuelgauge,
+	union power_supply_propval *val)
+{
+
+	pr_debug("%s : NOW(%d), OLD(%d)\n",
+		__func__, val->intval, fuelgauge->capacity_old);
+
+	if (fuelgauge->pdata->capacity_calculation_type &
+		SEC_FUELGAUGE_CAPACITY_TYPE_ATOMIC) {
+	if (fuelgauge->capacity_old < val->intval)
+		val->intval = fuelgauge->capacity_old + 1;
+	else if (fuelgauge->capacity_old > val->intval)
+		val->intval = fuelgauge->capacity_old - 1;
+	}
+
+	/* keep SOC stable in abnormal status */
+	if (fuelgauge->pdata->capacity_calculation_type &
+		SEC_FUELGAUGE_CAPACITY_TYPE_SKIP_ABNORMAL) {
+		if (!fuelgauge->is_charging &&
+			fuelgauge->capacity_old < val->intval) {
+			pr_err("%s: capacity (old %d : new %d)\n",
+				__func__, fuelgauge->capacity_old, val->intval);
+			val->intval = fuelgauge->capacity_old;
+		}
+	}
+
+	/* updated old capacity */
+	fuelgauge->capacity_old = val->intval;
+}
+
+static int max77854_fg_calculate_dynamic_scale(
+	struct max77854_fuelgauge_data *fuelgauge, int capacity)
+{
+	union power_supply_propval raw_soc_val;
+	raw_soc_val.intval = max77854_get_fuelgauge_value(fuelgauge,
+						 FG_RAW_SOC) / 10;
+
+	if (raw_soc_val.intval <
+		fuelgauge->pdata->capacity_max -
+		fuelgauge->pdata->capacity_max_margin) {
+		pr_info("%s: raw soc(%d) is very low, skip routine\n",
+			__func__, raw_soc_val.intval);
+		return fuelgauge->capacity_max;
+	} else {
+		fuelgauge->capacity_max =
+			(raw_soc_val.intval >
+			fuelgauge->pdata->capacity_max +
+			fuelgauge->pdata->capacity_max_margin) ?
+			(fuelgauge->pdata->capacity_max +
+			fuelgauge->pdata->capacity_max_margin) :
+			raw_soc_val.intval;
+		pr_debug("%s: raw soc (%d)", __func__,
+			 fuelgauge->capacity_max);
+	}
+
+	fuelgauge->capacity_max =
+		(fuelgauge->capacity_max * 100 / (capacity + 1));
+	fuelgauge->capacity_old = capacity;
+
+	pr_info("%s: %d is used for capacity_max, capacity(%d)\n",
+		__func__, fuelgauge->capacity_max, capacity);
+
+	return fuelgauge->capacity_max;
+}
+
+static void max77854_fg_check_qrtable(struct max77854_fuelgauge_data *fuelgauge)
+{
+	u16 data;
+
+	data = max77854_read_word(fuelgauge->i2c, QRTABLE20_REG);
+	if (data != fuelgauge->battery_data->QResidual20) {
+		if (max77854_write_word(fuelgauge->i2c, QRTABLE20_REG,
+			    fuelgauge->battery_data->QResidual20) < 0)
+			pr_err("%s: Failed to write QRTABLE20\n", __func__);
+	}
+
+	data = max77854_read_word(fuelgauge->i2c, QRTABLE30_REG);
+	if (data != fuelgauge->battery_data->QResidual30) {
+		if (max77854_write_word(fuelgauge->i2c, QRTABLE30_REG,
+			    fuelgauge->battery_data->QResidual30) <0)
+			pr_err("%s: Failed to write QRTABLE30\n", __func__);
+	}
+
+	pr_debug("%s: QRTABLE20_REG(0x%04x), QRTABLE30_REG(0x%04x)\n", __func__,
+		fuelgauge->battery_data->QResidual20,
+		fuelgauge->battery_data->QResidual30);
+}
+
+#if defined(CONFIG_EN_OOPS)
+static void max77854_set_full_value(struct max77854_fuelgauge_data *fuelgauge,
+				    int cable_type)
+{
+	u16 ichgterm, misccfg, fullsocthr;
+
+	if (is_hv_wireless_type(cable_type) || is_hv_wire_type(cable_type)) {
+		ichgterm = fuelgauge->battery_data->ichgterm_2nd;
+		misccfg = fuelgauge->battery_data->misccfg_2nd;
+		fullsocthr = fuelgauge->battery_data->fullsocthr_2nd;
+	} else {
+		ichgterm = fuelgauge->battery_data->ichgterm;
+		misccfg = fuelgauge->battery_data->misccfg;
+		fullsocthr = fuelgauge->battery_data->fullsocthr;
+	}
+
+	max77854_write_word(fuelgauge->i2c, ICHGTERM_REG, ichgterm);
+	max77854_write_word(fuelgauge->i2c, MISCCFG_REG, misccfg);
+	max77854_write_word(fuelgauge->i2c, FULLSOCTHR_REG, fullsocthr);
+
+	pr_info("%s : ICHGTERM(0x%04x) FULLSOCTHR(0x%04x), MISCCFG(0x%04x)\n",
+		__func__, ichgterm, misccfg, fullsocthr);
+}
+#endif
+
+static int calc_ttf(struct max77854_fuelgauge_data *fuelgauge, union power_supply_propval *val)
+{
+	int i;
+	int cc_time = 0, cv_time = 0;
+
+	int soc = fuelgauge->raw_capacity;
+	int charge_current = val->intval;
+	struct cv_slope *cv_data = fuelgauge->cv_data;
+	int design_cap = fuelgauge->battery_data->Capacity * fuelgauge->fg_resistor / 2;
+
+	if(!cv_data || (val->intval <= 0)) {
+		pr_info("%s: no cv_data or val: %d\n", __func__, val->intval);
+		return -1;
+	}
+	for (i = 0; i < fuelgauge->cv_data_lenth ;i++) {
+		if (charge_current >= cv_data[i].fg_current)
+			break;
+	}
+	i = i >= fuelgauge->cv_data_lenth ? fuelgauge->cv_data_lenth - 1 : i;
+	if (cv_data[i].soc < soc) {
+		for (i = 0; i < fuelgauge->cv_data_lenth; i++) {
+			if (soc <= cv_data[i].soc)
+				break;
+		}
+		cv_time = ((cv_data[i-1].time - cv_data[i].time) * (cv_data[i].soc - soc)\
+				/ (cv_data[i].soc - cv_data[i-1].soc)) + cv_data[i].time;
+	} else { //CC mode || NONE
+		cv_time = cv_data[i].time;
+		cc_time = design_cap * (cv_data[i].soc - soc)\
+				/ val->intval * 3600 / 1000;
+		pr_debug("%s: cc_time: %d\n", __func__, cc_time);
+		if (cc_time < 0) {
+
+			cc_time = 0;
+		}
+	}
+
+        pr_debug("%s: cap: %d, soc: %4d, T: %6d, avg: %4d, cv soc: %4d, i: %4d, val: %d\n",
+         __func__, design_cap, soc, cv_time + cc_time, fuelgauge->current_avg, cv_data[i].soc, i, val->intval);
+
+        if (cv_time + cc_time >= 0)
+                return cv_time + cc_time + 60;
+        else
+                return 60; //minimum 1minutes
+}
+
+static int max77854_fg_get_property(struct power_supply *psy,
+			     enum power_supply_property psp,
+			     union power_supply_propval *val)
+{
+	struct max77854_fuelgauge_data *fuelgauge =
+		container_of(psy, struct max77854_fuelgauge_data, psy_fg);
+	static int abnormal_current_cnt = 0;
+	union power_supply_propval value;
+	u8 data[2] = {0, 0};
+
+	switch (psp) {
+		/* Cell voltage (VCELL, mV) */
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = max77854_get_fuelgauge_value(fuelgauge, FG_VOLTAGE);
+		break;
+		/* Additional Voltage Information (mV) */
+	case POWER_SUPPLY_PROP_VOLTAGE_AVG:
+		switch (val->intval) {
+		case SEC_BATTERY_VOLTAGE_OCV:
+			val->intval = max77854_fg_read_vfocv(fuelgauge);
+			break;
+		case SEC_BATTERY_VOLTAGE_AVERAGE:
+		default:
+			val->intval = max77854_fg_read_avg_vcell(fuelgauge);
+			break;
+		}
+		break;
+		/* Current */
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		switch (val->intval) {
+		case SEC_BATTERY_CURRENT_UA:
+			val->intval =
+				max77854_fg_read_current(fuelgauge,
+						SEC_BATTERY_CURRENT_UA);
+			break;
+		case SEC_BATTERY_CURRENT_MA:
+		default:
+			fuelgauge->current_now = val->intval = max77854_get_fuelgauge_value(fuelgauge,
+							  FG_CURRENT);
+			psy_do_property("battery", get,
+					POWER_SUPPLY_PROP_STATUS, value);
+			/* To save log for abnormal case */
+			if (value.intval == POWER_SUPPLY_STATUS_DISCHARGING && val->intval > 0) {
+				abnormal_current_cnt++;
+				if (abnormal_current_cnt >= 5) {
+					pr_info("%s : Inow is increasing in not charging status\n",
+						__func__);
+					value.intval = fuelgauge->capacity_old + 15;
+					psy_do_property("battery", set,
+							POWER_SUPPLY_PROP_CAPACITY, value);
+					abnormal_current_cnt = 0;
+					value.intval = fuelgauge->capacity_old;
+					psy_do_property("battery", set,
+							POWER_SUPPLY_PROP_CAPACITY, value);
+				}
+			} else {
+				abnormal_current_cnt = 0;
+			}
+			break;
+		}
+		break;
+		/* Average Current */
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+		switch (val->intval) {
+		case SEC_BATTERY_CURRENT_UA:
+			val->intval =
+				max77854_fg_read_avg_current(fuelgauge,
+						    SEC_BATTERY_CURRENT_UA);
+			break;
+		case SEC_BATTERY_CURRENT_MA:
+		default:
+			fuelgauge->current_avg = val->intval =
+				max77854_get_fuelgauge_value(fuelgauge,
+						    FG_CURRENT_AVG);
+			break;
+		}
+		break;
+		/* Full Capacity */
+	case POWER_SUPPLY_PROP_ENERGY_NOW:
+		switch (val->intval) {
+		case SEC_BATTERY_CAPACITY_DESIGNED:
+			val->intval = max77854_get_fuelgauge_value(fuelgauge,
+							  FG_FULLCAP);
+			break;
+		case SEC_BATTERY_CAPACITY_ABSOLUTE:
+			val->intval = max77854_get_fuelgauge_value(fuelgauge,
+							  FG_MIXCAP);
+			break;
+		case SEC_BATTERY_CAPACITY_TEMPERARY:
+			val->intval = max77854_get_fuelgauge_value(fuelgauge,
+							  FG_AVCAP);
+			break;
+		case SEC_BATTERY_CAPACITY_CURRENT:
+			val->intval = max77854_get_fuelgauge_value(fuelgauge,
+							  FG_REPCAP);
+			break;
+		case SEC_BATTERY_CAPACITY_AGEDCELL:
+			val->intval = max77854_get_fuelgauge_value(fuelgauge,
+							  FG_FULLCAPNOM);
+			break;
+		case SEC_BATTERY_CAPACITY_CYCLE:
+			val->intval = max77854_get_fuelgauge_value(fuelgauge,
+							  FG_CYCLE);
+			break;
+		}
+		break;
+		/* SOC (%) */
+	case POWER_SUPPLY_PROP_CAPACITY:
+		if (val->intval == SEC_FUELGAUGE_CAPACITY_TYPE_RAW) {
+			val->intval = max77854_get_fuelgauge_value(fuelgauge,
+							  FG_RAW_SOC);
+		} else {
+			val->intval = max77854_get_fuelgauge_soc(fuelgauge);
+
+			if (fuelgauge->pdata->capacity_calculation_type &
+			    (SEC_FUELGAUGE_CAPACITY_TYPE_SCALE |
+			     SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE))
+				max77854_fg_get_scaled_capacity(fuelgauge, val);
+
+			/* capacity should be between 0% and 100%
+			 * (0.1% degree)
+			 */
+			if (val->intval > 1000)
+				val->intval = 1000;
+			if (val->intval < 0)
+				val->intval = 0;
+
+			fuelgauge->raw_capacity = val->intval;
+			/* get only integer part */
+			val->intval /= 10;
+
+			/* SW/HW V Empty setting */
+			if (fuelgauge->using_hw_vempty) {
+				if (fuelgauge->temperature <= (int)fuelgauge->low_temp_limit) {
+					if (fuelgauge->raw_capacity <= 50) {
+						if (fuelgauge->vempty_mode != VEMPTY_MODE_HW) {
+							max77854_fg_set_vempty(fuelgauge, VEMPTY_MODE_HW);
+						}
+					} else if (fuelgauge->vempty_mode == VEMPTY_MODE_HW) {
+						max77854_fg_set_vempty(fuelgauge, VEMPTY_MODE_SW);
+					}
+				} else if (fuelgauge->vempty_mode != VEMPTY_MODE_HW) {
+					max77854_fg_set_vempty(fuelgauge, VEMPTY_MODE_HW);
+				}
+			}
+
+			if (!fuelgauge->is_charging &&
+			    fuelgauge->vempty_mode == VEMPTY_MODE_SW_VALERT && !lpcharge) {
+				pr_info("%s : SW V EMPTY. Decrease SOC\n", __func__);
+				val->intval = 0;
+			} else if ((fuelgauge->vempty_mode == VEMPTY_MODE_SW_RECOVERY) &&
+				   (val->intval == fuelgauge->capacity_old)) {
+				fuelgauge->vempty_mode = VEMPTY_MODE_SW;
+			}
+
+			/* check whether doing the wake_unlock */
+			if ((val->intval > fuelgauge->pdata->fuel_alert_soc) &&
+			     fuelgauge->is_fuel_alerted) {
+				max77854_fg_fuelalert_init(fuelgauge,
+					  fuelgauge->pdata->fuel_alert_soc);
+			}
+
+			/* (Only for atomic capacity)
+			 * In initial time, capacity_old is 0.
+			 * and in resume from sleep,
+			 * capacity_old is too different from actual soc.
+			 * should update capacity_old
+			 * by val->intval in booting or resume.
+			 */
+			if ((fuelgauge->initial_update_of_soc) &&
+			    (fuelgauge->vempty_mode == VEMPTY_MODE_HW)) {
+				/* updated old capacity */
+				fuelgauge->capacity_old = val->intval;
+				fuelgauge->initial_update_of_soc = false;
+				break;
+			}
+
+			if (fuelgauge->pdata->capacity_calculation_type &
+			    (SEC_FUELGAUGE_CAPACITY_TYPE_ATOMIC |
+			     SEC_FUELGAUGE_CAPACITY_TYPE_SKIP_ABNORMAL))
+				max77854_fg_get_atomic_capacity(fuelgauge, val);
+		}
+		break;
+		/* Battery Temperature */
+	case POWER_SUPPLY_PROP_TEMP:
+		/* Target Temperature */
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		val->intval = max77854_get_fuelgauge_value(fuelgauge,
+							   FG_TEMPERATURE);
+		break;
+#if defined(CONFIG_EN_OOPS)
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+		return -ENODATA;
+#endif
+	case POWER_SUPPLY_PROP_ENERGY_FULL:
+		{
+			int fullcap = max77854_get_fuelgauge_value(fuelgauge, FG_FULLCAPNOM);
+			val->intval = fullcap * 100 / fuelgauge->battery_data->Capacity;
+			pr_info("%s: asoc(%d), fullcap(0x%x)\n",
+				__func__, val->intval, fullcap);
+#if !defined(CONFIG_SEC_FACTORY)
+			max77854_fg_periodic_read(fuelgauge);
+#endif
+		}
+		break;
+	case POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:
+		val->intval = fuelgauge->capacity_max;
+		break;
+	case POWER_SUPPLY_PROP_TIME_TO_FULL_NOW:
+		val->intval = calc_ttf(fuelgauge, val);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_ENABLED:
+		max77854_bulk_read(fuelgauge->i2c, STATUS_REG, 2, data);
+		val->intval = data[0] & 0x40;
+		break;
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	case POWER_SUPPLY_PROP_CAPACITY_LEVEL:
+		return -ENODATA;
+#endif
+	case POWER_SUPPLY_PROP_FILTER_CFG:
+		max77854_bulk_read(fuelgauge->i2c, FILTER_CFG_REG, 2, data);
+		val->intval = data[1] << 8 | data[0];
+		pr_debug("%s: FilterCFG=0x%04X\n", __func__, data[1] << 8 | data[0]);
+		break;
+
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+#if defined(CONFIG_UPDATE_BATTERY_DATA)
+static int max77854_fuelgauge_parse_dt(struct max77854_fuelgauge_data *fuelgauge);
+#endif
+static int max77854_fg_set_property(struct power_supply *psy,
+			     enum power_supply_property psp,
+			     const union power_supply_propval *val)
+{
+	struct max77854_fuelgauge_data *fuelgauge =
+		container_of(psy, struct max77854_fuelgauge_data, psy_fg);
+	u8 data[2] = {0, 0};
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+		if (fuelgauge->pdata->capacity_calculation_type &
+			SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE)
+			max77854_fg_calculate_dynamic_scale(fuelgauge, val->intval);
+		break;
+#if defined(CONFIG_EN_OOPS)
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+		max77854_set_full_value(fuelgauge, val->intval);
+		break;
+#endif
+	case POWER_SUPPLY_PROP_ONLINE:
+		fuelgauge->cable_type = val->intval;
+		if (val->intval == POWER_SUPPLY_TYPE_BATTERY) {
+			fuelgauge->is_charging = false;
+		} else {
+			fuelgauge->is_charging = true;
+
+			/* enable alert */
+			if (fuelgauge->vempty_mode >= VEMPTY_MODE_SW_VALERT) {
+				max77854_fg_set_vempty(fuelgauge, VEMPTY_MODE_HW);
+				fuelgauge->initial_update_of_soc = true;
+				max77854_fg_fuelalert_init(fuelgauge,
+							   fuelgauge->pdata->fuel_alert_soc);
+			}
+		}
+		break;
+		/* Battery Temperature */
+	case POWER_SUPPLY_PROP_CAPACITY:
+		if (val->intval == SEC_FUELGAUGE_CAPACITY_TYPE_RESET) {
+			fuelgauge->initial_update_of_soc = true;
+			if (!max77854_fg_reset(fuelgauge))
+				return -EINVAL;
+			else
+				break;
+		}
+	case POWER_SUPPLY_PROP_TEMP:
+		if(val->intval < 0) {
+			u16 reg_data;
+			reg_data = max77854_read_word(fuelgauge->i2c, DESIGNCAP_REG);
+			if(reg_data == fuelgauge->battery_data->Capacity) {
+				max77854_write_word(fuelgauge->i2c, DESIGNCAP_REG,
+						fuelgauge->battery_data->Capacity+3);
+				pr_info("%s: set the low temp reset! temp : %d, capacity : 0x%x, original capacity : 0x%x\n",
+						__func__, val->intval, reg_data , fuelgauge->battery_data->Capacity);
+			}
+		}
+
+		max77854_fg_write_temp(fuelgauge, val->intval);
+		max77854_fg_check_qrtable(fuelgauge);
+		break;
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		break;
+	case POWER_SUPPLY_PROP_ENERGY_NOW:
+		max77854_fg_reset_capacity_by_jig_connection(fuelgauge);
+		break;
+	case POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:
+		pr_info("%s: capacity_max changed, %d -> %d\n",
+			__func__, fuelgauge->capacity_max, val->intval);
+		fuelgauge->capacity_max = max77854_fg_check_capacity_max(fuelgauge, val->intval);
+		fuelgauge->initial_update_of_soc = true;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_ENABLED:
+		/* Forcedly discharge EN */
+		max77854_bulk_read(fuelgauge->i2c, CONFIG2_REG, 2, data);
+		data[1] &= ~0x6;
+		data[1] |= val->intval ? 0x1 << 2 :
+			fuelgauge->auto_discharge_en ? 0x1 << 1 : 0x0 << 1;
+		max77854_bulk_write(fuelgauge->i2c, CONFIG2_REG, 2, data);
+		break;
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	case POWER_SUPPLY_PROP_CAPACITY_LEVEL:
+		{
+			u16 reg_fullsocthr;
+			int val_soc = val->intval;
+			if (val->intval > fuelgauge->pdata->full_condition_soc ||
+				val->intval <= (fuelgauge->pdata->full_condition_soc - 10)) {
+				pr_info("%s: abnormal value(%d). so thr is changed to default(%d)\n",
+					__func__, val->intval, fuelgauge->pdata->full_condition_soc);
+				val_soc = fuelgauge->pdata->full_condition_soc;
+			}
+
+			reg_fullsocthr = val_soc << 8;
+			if (max77854_write_word(fuelgauge->i2c, FULLSOCTHR_REG, reg_fullsocthr) < 0) {
+				pr_err("%s: Failed to write FULLSOCTHR_REG\n", __func__);
+			} else {
+				reg_fullsocthr = max77854_read_word(fuelgauge->i2c, FULLSOCTHR_REG);
+				pr_info("%s: FullSOCThr %d%%(0x%04X)\n", __func__, val_soc, reg_fullsocthr);
+			}
+		}
+		break;
+#endif
+#if defined(CONFIG_UPDATE_BATTERY_DATA)
+	case POWER_SUPPLY_PROP_POWER_DESIGN:
+		max77854_fuelgauge_parse_dt(fuelgauge);
+		break;
+#endif
+	case POWER_SUPPLY_PROP_FILTER_CFG:
+		/* Set FilterCFG */
+		max77854_bulk_read(fuelgauge->i2c, FILTER_CFG_REG, 2, data);
+		pr_debug("%s: FilterCFG=0x%04X\n", __func__, data[1] << 8 | data[0]);
+		data[0] &= ~0xF;
+		data[0] |= (val->intval & 0xF);
+		max77854_bulk_write(fuelgauge->i2c, FILTER_CFG_REG, 2, data);
+
+		max77854_bulk_read(fuelgauge->i2c, FILTER_CFG_REG, 2, data);
+		pr_debug("%s: FilterCFG=0x%04X\n", __func__, data[1] << 8 | data[0]);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static void max77854_fg_isr_work(struct work_struct *work)
+{
+	struct max77854_fuelgauge_data *fuelgauge =
+		container_of(work, struct max77854_fuelgauge_data, isr_work.work);
+
+	/* process for fuel gauge chip */
+	max77854_fg_fuelalert_process(fuelgauge);
+
+	wake_unlock(&fuelgauge->fuel_alert_wake_lock);
+}
+
+static irqreturn_t max77854_fg_irq_thread(int irq, void *irq_data)
+{
+	struct max77854_fuelgauge_data *fuelgauge = irq_data;
+
+	max77854_update_reg(fuelgauge->pmic,
+			    MAX77854_PMIC_REG_INTSRC_MASK,
+			    MAX77854_IRQSRC_FG,
+			    MAX77854_IRQSRC_FG);
+
+	pr_info("%s\n", __func__);
+
+	if (fuelgauge->is_fuel_alerted) {
+		return IRQ_HANDLED;
+	} else {
+		wake_lock(&fuelgauge->fuel_alert_wake_lock);
+		fuelgauge->is_fuel_alerted = true;
+		schedule_delayed_work(&fuelgauge->isr_work, 0);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int max77854_fuelgauge_debugfs_show(struct seq_file *s, void *data)
+{
+	struct max77854_fuelgauge_data *fuelgauge = s->private;
+	int i;
+	u8 reg;
+	u16 reg_data;
+
+	seq_printf(s, "MAX77854 FUELGAUGE IC :\n");
+	seq_printf(s, "===================\n");
+	for (i = 0; i < 16; i++) {
+		if (i == 12)
+			continue;
+		for (reg = 0; reg < 0x10; reg++) {
+			reg_data = max77854_read_word(fuelgauge->i2c, reg + i * 0x10);
+			seq_printf(s, "0x%02x:\t0x%04x\n", reg + i * 0x10, reg_data);
+		}
+		if (i == 4)
+			i = 10;
+	}
+	seq_printf(s, "\n");
+	return 0;
+}
+
+static int max77854_fuelgauge_debugfs_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, max77854_fuelgauge_debugfs_show, inode->i_private);
+}
+
+static const struct file_operations max77854_fuelgauge_debugfs_fops = {
+	.open           = max77854_fuelgauge_debugfs_open,
+	.read           = seq_read,
+	.llseek         = seq_lseek,
+	.release        = single_release,
+};
+
+#ifdef CONFIG_OF
+static int max77854_fuelgauge_parse_dt(struct max77854_fuelgauge_data *fuelgauge)
+{
+	struct device_node *np = of_find_node_by_name(NULL, "max77854-fuelgauge");
+	sec_fuelgauge_platform_data_t *pdata = fuelgauge->pdata;
+	int ret;
+	int i, len;
+	const u32 *p;
+
+	/* reset, irq gpio info */
+	if (np == NULL) {
+		pr_err("%s np NULL\n", __func__);
+	} else {
+		ret = of_property_read_u32(np, "fuelgauge,capacity_max",
+				&pdata->capacity_max);
+		if (ret < 0)
+			pr_err("%s error reading capacity_max %d\n", __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_max_hv",
+				&pdata->capacity_max_hv);
+		if (ret < 0) {
+			pr_err("%s error reading capacity_max_hv %d\n", __func__, ret);
+			fuelgauge->pdata->capacity_max_hv = fuelgauge->pdata->capacity_max;
+		}
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_max_margin",
+				&pdata->capacity_max_margin);
+		if (ret < 0)
+			pr_err("%s error reading capacity_max_margin %d\n", __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_min",
+				&pdata->capacity_min);
+		if (ret < 0)
+			pr_err("%s error reading capacity_min %d\n", __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_calculation_type",
+				&pdata->capacity_calculation_type);
+		if (ret < 0)
+			pr_err("%s error reading capacity_calculation_type %d\n",
+					__func__, ret);
+		ret = of_property_read_u32(np, "fuelgauge,fuel_alert_soc",
+				&pdata->fuel_alert_soc);
+		if (ret < 0)
+			pr_err("%s error reading pdata->fuel_alert_soc %d\n",
+					__func__, ret);
+
+		pdata->repeated_fuelalert = of_property_read_bool(np,
+				"fuelgauge,repeated_fuelalert");
+
+		fuelgauge->using_temp_compensation = of_property_read_bool(np,
+						   "fuelgauge,using_temp_compensation");
+		if (fuelgauge->using_temp_compensation) {
+			ret = of_property_read_u32(np, "fuelgauge,low_temp_limit",
+						   &fuelgauge->low_temp_limit);
+			if (ret < 0)
+				pr_err("%s error reading low temp limit %d\n", __func__, ret);
+
+			pr_info("%s : LOW TEMP LIMIT(%d)\n",
+				__func__, fuelgauge->low_temp_limit);
+		}
+
+		fuelgauge->using_hw_vempty = of_property_read_bool(np,
+								   "fuelgauge,using_hw_vempty");
+		if (fuelgauge->using_hw_vempty) {
+			ret = of_property_read_u32(np, "fuelgauge,v_empty",
+						   &fuelgauge->battery_data->V_empty);
+			if (ret < 0)
+				pr_err("%s error reading v_empty %d\n",
+				       __func__, ret);
+
+			ret = of_property_read_u32(np, "fuelgauge,v_empty_origin",
+						   &fuelgauge->battery_data->V_empty_origin);
+			if(ret < 0)
+				pr_err("%s error reading v_empty_origin %d\n",
+				       __func__, ret);
+
+			ret = of_property_read_u32(np, "fuelgauge,sw_v_empty_voltage",
+						   &fuelgauge->battery_data->sw_v_empty_vol);
+			if(ret < 0)
+				pr_err("%s error reading sw_v_empty_default_vol %d\n",
+					   __func__, ret);
+			
+			ret = of_property_read_u32(np, "fuelgauge,sw_v_empty_recover_voltage",
+						   &fuelgauge->battery_data->sw_v_empty_recover_vol);
+			if(ret < 0)
+				pr_err("%s error reading sw_v_empty_recover_vol %d\n",
+					   __func__, ret);
+			
+			pr_info("%s : SW V Empty (%d)mV,  SW V Empty recover (%d)mV\n",
+				__func__, fuelgauge->battery_data->sw_v_empty_vol, fuelgauge->battery_data->sw_v_empty_recover_vol);
+		}
+
+		pdata->jig_gpio = of_get_named_gpio(np, "fuelgauge,jig_gpio", 0);
+		if (pdata->jig_gpio < 0) {
+			pr_err("%s error reading jig_gpio = %d\n",
+					__func__,pdata->jig_gpio);
+			pdata->jig_gpio = 0;
+		} else {
+			pdata->jig_irq = gpio_to_irq(pdata->jig_gpio);
+		}
+
+		ret = of_property_read_u32(np, "fuelgauge,qrtable20",
+					   &fuelgauge->battery_data->QResidual20);
+		if (ret < 0)
+			pr_err("%s error reading qrtable20 %d\n",
+			       __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,qrtable30",
+					   &fuelgauge->battery_data->QResidual30);
+		if (ret < 0)
+			pr_err("%s error reading qrtabel30 %d\n",
+			       __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,fg_resistor",
+				&fuelgauge->fg_resistor);
+		if (ret < 0) {
+			pr_err("%s error reading fg_resistor %d\n",
+					__func__, ret);
+			fuelgauge->fg_resistor = 1;
+		}
+#if defined(CONFIG_EN_OOPS)
+		ret = of_property_read_u32(np, "fuelgauge,ichgterm",
+					   &fuelgauge->battery_data->ichgterm);
+		if (ret < 0)
+			pr_err("%s error reading ichgterm %d\n",
+					__func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,ichgterm_2nd",
+					   &fuelgauge->battery_data->ichgterm_2nd);
+		if (ret < 0)
+			pr_err("%s error reading ichgterm_2nd %d\n",
+					__func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,misccfg",
+					   &fuelgauge->battery_data->misccfg);
+		if (ret < 0)
+			pr_err("%s error reading misccfg %d\n",
+					__func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,misccfg_2nd",
+					   &fuelgauge->battery_data->misccfg_2nd);
+		if (ret < 0)
+			pr_err("%s error reading misccfg_2nd %d\n",
+					__func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,fullsocthr",
+					   &fuelgauge->battery_data->fullsocthr);
+		if (ret < 0)
+			pr_err("%s error reading fullsocthr %d\n",
+					__func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,fullsocthr_2nd",
+					   &fuelgauge->battery_data->fullsocthr_2nd);
+		if (ret < 0)
+			pr_err("%s error reading fullsocthr_2nd %d\n",
+					__func__, ret);
+#endif
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity",
+					   &fuelgauge->battery_data->Capacity);
+		if (ret < 0)
+			pr_err("%s error reading capacity_calculation_type %d\n",
+					__func__, ret);
+
+		fuelgauge->auto_discharge_en = of_property_read_bool(np,
+				"fuelgauge,auto_discharge_en");
+		if (fuelgauge->auto_discharge_en) {
+	                ret = of_property_read_u32(np, "fuelgauge,discharge_temp_threshold",
+				&fuelgauge->discharge_temp_threshold);
+			if (ret < 0)
+				fuelgauge->discharge_temp_threshold = 600;
+
+	                ret = of_property_read_u32(np, "fuelgauge,discharge_volt_threshold",
+				&fuelgauge->discharge_volt_threshold);
+			if (ret < 0)
+				fuelgauge->discharge_volt_threshold = 4200;
+		}
+
+		p = of_get_property(np, "fuelgauge,cv_data", &len);
+		if (p) {
+			fuelgauge->cv_data = kzalloc(len,
+						  GFP_KERNEL);
+			fuelgauge->cv_data_lenth = len / sizeof(struct cv_slope);
+			pr_err("%s len: %ld, lenth: %d, %d\n",
+					__func__, sizeof(int) * len, len, fuelgauge->cv_data_lenth);
+			ret = of_property_read_u32_array(np, "fuelgauge,cv_data",
+					 (u32 *)fuelgauge->cv_data, len/sizeof(u32));
+#if 0
+			for(i = 0; i < fuelgauge->cv_data_lenth; i++) {
+				pr_err("%s  %5d, %5d, %5d\n",
+						__func__, fuelgauge->cv_data[i].fg_current,
+						fuelgauge->cv_data[i].soc, fuelgauge->cv_data[i].time);
+			}
+#endif
+
+			if (ret) {
+				pr_err("%s failed to read fuelgauge->cv_data: %d\n",
+						__func__, ret);
+				kfree(fuelgauge->cv_data);
+				fuelgauge->cv_data = NULL;
+			}
+		} else {
+			pr_err("%s there is not cv_data\n", __func__);
+		}
+
+		np = of_find_node_by_name(NULL, "battery");
+		ret = of_property_read_u32(np, "battery,thermal_source",
+					   &pdata->thermal_source);
+		if (ret < 0) {
+			pr_err("%s error reading pdata->thermal_source %d\n",
+			       __func__, ret);
+		}
+
+		p = of_get_property(np, "battery,input_current_limit", &len);
+		if (!p)
+			return 1;
+		len = len / sizeof(u32);
+
+		pdata->charging_current = kzalloc(sizeof(sec_charging_current_t) * len,
+						  GFP_KERNEL);
+
+		for(i = 0; i < len; i++) {
+			ret = of_property_read_u32_index(np,
+				 "battery,input_current_limit", i,
+				 &pdata->charging_current[i].input_current_limit);
+			ret = of_property_read_u32_index(np,
+				 "battery,fast_charging_current", i,
+				 &pdata->charging_current[i].fast_charging_current);
+			ret = of_property_read_u32_index(np,
+				 "battery,full_check_current_1st", i,
+				 &pdata->charging_current[i].full_check_current_1st);
+			ret = of_property_read_u32_index(np,
+				 "battery,full_check_current_2nd", i,
+				 &pdata->charging_current[i].full_check_current_2nd);
+		}
+
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+		ret = of_property_read_u32(np, "battery,full_condition_soc",
+			&pdata->full_condition_soc);
+		if (ret) {
+			pdata->full_condition_soc = 93;
+			pr_info("%s : Full condition soc is Empty\n", __func__);
+		}
+#endif
+
+		pr_info("%s thermal: %d, fg_irq: %d, capacity_max: %d\n"
+			"qrtable20: 0x%x, qrtable30 : 0x%x\n"
+			"capacity_max_margin: %d, capacity_min: %d\n"
+			"calculation_type: 0x%x, fuel_alert_soc: %d,\n"
+			"repeated_fuelalert: %d\n",
+			__func__, pdata->thermal_source, pdata->fg_irq, pdata->capacity_max,
+			fuelgauge->battery_data->QResidual20,
+			fuelgauge->battery_data->QResidual30,
+			pdata->capacity_max_margin, pdata->capacity_min,
+			pdata->capacity_calculation_type, pdata->fuel_alert_soc,
+			pdata->repeated_fuelalert);
+	}
+
+	pr_info("[%s][%d]\n",
+		__func__, fuelgauge->battery_data->Capacity);
+
+	return 0;
+}
+#endif
+
+static int max77854_fuelgauge_probe(struct platform_device *pdev)
+{
+	struct max77854_dev *max77854 = dev_get_drvdata(pdev->dev.parent);
+	struct max77854_platform_data *pdata = dev_get_platdata(max77854->dev);
+	sec_fuelgauge_platform_data_t *fuelgauge_data;
+	struct max77854_fuelgauge_data *fuelgauge;
+	int ret = 0;
+	union power_supply_propval raw_soc_val;
+#if defined(CONFIG_DISABLE_SAVE_CAPACITY_MAX)	
+	u16 reg_data;
+#endif
+
+	pr_info("%s: MAX77854 Fuelgauge Driver Loading\n", __func__);
+
+	fuelgauge = kzalloc(sizeof(*fuelgauge), GFP_KERNEL);
+	if (!fuelgauge)
+		return -ENOMEM;
+
+	fuelgauge_data = kzalloc(sizeof(sec_fuelgauge_platform_data_t), GFP_KERNEL);
+	if (!fuelgauge_data) {
+		ret = -ENOMEM;
+		goto err_free;
+	}
+
+	mutex_init(&fuelgauge->fg_lock);
+
+	fuelgauge->dev = &pdev->dev;
+	fuelgauge->pdata = fuelgauge_data;
+	fuelgauge->i2c = max77854->fuelgauge;
+	fuelgauge->pmic = max77854->i2c;
+	fuelgauge->max77854_pdata = pdata;
+
+#if defined(CONFIG_OF)
+	fuelgauge->battery_data = kzalloc(sizeof(struct battery_data_t),
+					  GFP_KERNEL);
+	if(!fuelgauge->battery_data) {
+		pr_err("Failed to allocate memory\n");
+		ret = -ENOMEM;
+		goto err_pdata_free;
+	}
+	ret = max77854_fuelgauge_parse_dt(fuelgauge);
+	if (ret < 0) {
+		pr_err("%s not found charger dt! ret[%d]\n",
+		       __func__, ret);
+	}
+#endif
+
+	platform_set_drvdata(pdev, fuelgauge);
+
+	fuelgauge->psy_fg.name		= "max77854-fuelgauge";
+	fuelgauge->psy_fg.type		= POWER_SUPPLY_TYPE_UNKNOWN;
+	fuelgauge->psy_fg.get_property	= max77854_fg_get_property;
+	fuelgauge->psy_fg.set_property	= max77854_fg_set_property;
+	fuelgauge->psy_fg.properties	= max77854_fuelgauge_props;
+	fuelgauge->psy_fg.num_properties =
+		ARRAY_SIZE(max77854_fuelgauge_props);
+	fuelgauge->capacity_max = fuelgauge->pdata->capacity_max;
+	raw_soc_val.intval = max77854_get_fuelgauge_value(fuelgauge, FG_RAW_SOC) / 10;
+
+#if defined(CONFIG_DISABLE_SAVE_CAPACITY_MAX)
+	reg_data = max77854_read_word(fuelgauge->i2c, 0xD0);
+
+	if (reg_data >= 900 && reg_data <= 1000 && reg_data != fuelgauge->capacity_max) {
+		pr_info("%s : Capacity Max Update (%d) -> (%d)\n",
+			__func__, fuelgauge->capacity_max, reg_data);
+		fuelgauge->capacity_max = reg_data;
+	} else {
+		pr_info("%s : 0xD0 Register Update (%d) -> (%d)\n",
+			__func__, reg_data, fuelgauge->capacity_max);
+		reg_data = fuelgauge->capacity_max;
+		max77854_write_word(fuelgauge->i2c, 0xD0, reg_data);
+	}
+#endif
+
+	if (raw_soc_val.intval > fuelgauge->capacity_max)
+		max77854_fg_calculate_dynamic_scale(fuelgauge, 100);
+
+	(void) debugfs_create_file("max77854-fuelgauge-regs",
+		S_IRUGO, NULL, (void *)fuelgauge, &max77854_fuelgauge_debugfs_fops);
+
+	if (!max77854_fg_init(fuelgauge)) {
+		pr_err("%s: Failed to Initialize Fuelgauge\n", __func__);
+		goto err_data_free;
+	}
+
+	/* SW/HW init code. SW/HW V Empty mode must be opposite ! */
+	fuelgauge->temperature = 300; /* default value */
+	pr_info("%s: SW/HW V empty init \n", __func__);
+	max77854_fg_set_vempty(fuelgauge, VEMPTY_MODE_HW);
+
+	ret = power_supply_register(&pdev->dev, &fuelgauge->psy_fg);
+	if (ret) {
+		pr_err("%s: Failed to Register psy_fg\n", __func__);
+		goto err_data_free;
+	}
+
+	fuelgauge->fg_irq = pdata->irq_base + MAX77854_FG_IRQ_ALERT;
+	pr_info("[%s]IRQ_BASE(%d) FG_IRQ(%d)\n",
+		__func__, pdata->irq_base, fuelgauge->fg_irq);
+
+	fuelgauge->is_fuel_alerted = false;
+	if (fuelgauge->pdata->fuel_alert_soc >= 0) {
+		if (max77854_fg_fuelalert_init(fuelgauge,
+				       fuelgauge->pdata->fuel_alert_soc)) {
+			wake_lock_init(&fuelgauge->fuel_alert_wake_lock,
+				       WAKE_LOCK_SUSPEND, "fuel_alerted");
+			if (fuelgauge->fg_irq) {
+				INIT_DELAYED_WORK(&fuelgauge->isr_work, max77854_fg_isr_work);
+
+				ret = request_threaded_irq(fuelgauge->fg_irq,
+					   NULL, max77854_fg_irq_thread,
+					   IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+					   "fuelgauge-irq", fuelgauge);
+				if (ret) {
+					pr_err("%s: Failed to Request IRQ\n", __func__);
+					goto err_supply_unreg;
+				}
+			}
+		} else {
+			pr_err("%s: Failed to Initialize Fuel-alert\n",
+			       __func__);
+			goto err_supply_unreg;
+		}
+	}
+
+	fuelgauge->initial_update_of_soc = true;
+	pr_info("%s: MAX77854 Fuelgauge Driver Loaded\n", __func__);
+	return 0;
+
+err_supply_unreg:
+	power_supply_unregister(&fuelgauge->psy_fg);
+err_data_free:
+#if defined(CONFIG_OF)
+	kfree(fuelgauge->battery_data);
+#endif
+err_pdata_free:
+	kfree(fuelgauge_data);
+	mutex_destroy(&fuelgauge->fg_lock);
+err_free:
+	kfree(fuelgauge);
+
+	return ret;
+}
+
+static int max77854_fuelgauge_remove(struct platform_device *pdev)
+{
+	struct max77854_fuelgauge_data *fuelgauge =
+		platform_get_drvdata(pdev);
+
+	if (fuelgauge->pdata->fuel_alert_soc >= 0)
+		wake_lock_destroy(&fuelgauge->fuel_alert_wake_lock);
+
+	return 0;
+}
+
+static int max77854_fuelgauge_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int max77854_fuelgauge_resume(struct device *dev)
+{
+	struct max77854_fuelgauge_data *fuelgauge = dev_get_drvdata(dev);
+
+	fuelgauge->initial_update_of_soc = true;
+
+	return 0;
+}
+
+static void max77854_fuelgauge_shutdown(struct device *dev)
+{
+}
+
+static SIMPLE_DEV_PM_OPS(max77854_fuelgauge_pm_ops, max77854_fuelgauge_suspend,
+			 max77854_fuelgauge_resume);
+
+static struct platform_driver max77854_fuelgauge_driver = {
+	.driver = {
+		   .name = "max77854-fuelgauge",
+		   .owner = THIS_MODULE,
+#ifdef CONFIG_PM
+		   .pm = &max77854_fuelgauge_pm_ops,
+#endif
+		.shutdown = max77854_fuelgauge_shutdown,
+	},
+	.probe	= max77854_fuelgauge_probe,
+	.remove	= max77854_fuelgauge_remove,
+};
+
+static int __init max77854_fuelgauge_init(void)
+{
+	pr_info("%s: \n", __func__);
+	return platform_driver_register(&max77854_fuelgauge_driver);
+}
+
+static void __exit max77854_fuelgauge_exit(void)
+{
+	platform_driver_unregister(&max77854_fuelgauge_driver);
+}
+module_init(max77854_fuelgauge_init);
+module_exit(max77854_fuelgauge_exit);
+
+MODULE_DESCRIPTION("Samsung MAX77854 Fuel Gauge Driver");
+MODULE_AUTHOR("Samsung Electronics");
+MODULE_LICENSE("GPL");
diff -Naur linux-3.18.14/drivers/battery_v2/p9220_charger.c samsung/drivers/battery_v2/p9220_charger.c
--- linux-3.18.14/drivers/battery_v2/p9220_charger.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/p9220_charger.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,2458 @@
+/*
+ *  p9220_charger.c
+ *  Samsung p9220 Charger Driver
+ *
+ *  Copyright (C) 2015 Samsung Electronics
+ * Yeongmi Ha <yeongmi86.ha@samsung.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include "include/charger/p9220_charger.h"
+#include <linux/errno.h>
+#include <linux/version.h>
+#include <linux/device.h>
+#include <linux/pm.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/pm_runtime.h>
+#include <linux/irqdomain.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/kernel.h>
+#include <asm/uaccess.h>
+#include <linux/sysctl.h>
+#include <linux/proc_fs.h>
+#include <linux/vmalloc.h>
+#include <linux/ctype.h>
+#include <linux/firmware.h>
+
+#define ENABLE 1
+#define DISABLE 0
+#define CMD_CNT 3
+
+#define P9220S_FW_SDCARD_BIN_PATH	"sdcard/p9220_otp.bin"
+#define P9220S_OTP_FW_HEX_PATH		"idt/p9220_otp.bin"
+#define P9220S_SRAM_FW_HEX_PATH		"idt/p9220_sram.bin"
+
+extern bool sleep_mode;
+
+static enum power_supply_property sec_charger_props[] = {
+	/*
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_MANUFACTURER,
+	POWER_SUPPLY_PROP_CHARGE_TYPE,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_VOLTAGE_MAX,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
+	POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL,
+	POWER_SUPPLY_PROP_CHARGE_POWERED_OTG_CONTROL,
+	POWER_SUPPLY_PROP_ENERGY_NOW,
+	POWER_SUPPLY_PROP_ENERGY_AVG,
+	POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION,
+	POWER_SUPPLY_PROP_SCOPE,
+	*/
+};
+
+int p9220_otp_update = 0;
+u8 adc_cal = 0;
+
+extern unsigned int lpcharge;
+int p9220_get_firmware_version(struct p9220_charger_data *charger, int firm_mode);
+static irqreturn_t p9220_wpc_det_irq_thread(int irq, void *irq_data);
+static irqreturn_t p9220_wpc_irq_thread(int irq, void *irq_data);
+
+static int p9220_reg_read(struct i2c_client *client, u16 reg, u8 *val)
+{
+	struct p9220_charger_data *charger = i2c_get_clientdata(client);
+	int ret;
+	struct i2c_msg msg[2];
+	u8 wbuf[2];
+	u8 rbuf[2];
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags & I2C_M_TEN;
+	msg[0].len = 2;
+	msg[0].buf = wbuf;
+
+	wbuf[0] = (reg & 0xFF00) >> 8;
+	wbuf[1] = (reg & 0xFF);
+
+	msg[1].addr = client->addr;
+	msg[1].flags = I2C_M_RD;
+	msg[1].len = 1;
+	msg[1].buf = rbuf;
+
+	mutex_lock(&charger->io_lock);
+	ret = i2c_transfer(client->adapter, msg, 2);
+	mutex_unlock(&charger->io_lock);	
+	if (ret < 0)
+	{
+		dev_err(&client->dev, "%s: i2c read error, reg: 0x%x, ret: %d\n",
+			__func__, reg, ret);
+		return -1;
+	}
+	*val = rbuf[0];
+
+	return ret;
+}
+
+static int p9220_reg_multi_read(struct i2c_client *client, u16 reg, u8 *val, int size)
+{
+	struct p9220_charger_data *charger = i2c_get_clientdata(client);
+	int ret;
+	struct i2c_msg msg[2];
+	u8 wbuf[2];
+
+//	pr_debug("%s: reg = 0x%x, size = 0x%x\n", __func__, reg, size);
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags & I2C_M_TEN;
+	msg[0].len = 2;
+	msg[0].buf = wbuf;
+
+	wbuf[0] = (reg & 0xFF00) >> 8;
+	wbuf[1] = (reg & 0xFF);
+
+	msg[1].addr = client->addr;
+	msg[1].flags = I2C_M_RD;
+	msg[1].len = size;
+	msg[1].buf = val;
+
+	mutex_lock(&charger->io_lock);
+	ret = i2c_transfer(client->adapter, msg, 2);
+	mutex_unlock(&charger->io_lock);
+	if (ret < 0)
+	{
+		pr_err("%s: i2c transfer fail", __func__);
+		return -1;
+	}
+
+	return ret;
+}
+
+static int p9220_reg_write(struct i2c_client *client, u16 reg, u8 val)
+{
+	struct p9220_charger_data *charger = i2c_get_clientdata(client);
+	int ret;
+	unsigned char data[3] = { reg >> 8, reg & 0xff, val };
+
+	mutex_lock(&charger->io_lock);
+	ret = i2c_master_send(client, data, 3);
+	mutex_unlock(&charger->io_lock);
+	if (ret < 3) {
+		dev_err(&client->dev, "%s: i2c write error, reg: 0x%x, ret: %d\n",
+				__func__, reg, ret);
+		return ret < 0 ? ret : -EIO;
+	}
+
+	return 0;
+}
+
+static int p9220_reg_update(struct i2c_client *client, u16 reg, u8 val, u8 mask)
+{
+	struct p9220_charger_data *charger = i2c_get_clientdata(client);
+	unsigned char data[3] = { reg >> 8, reg & 0xff, val };
+	u8 data2;
+	int ret;
+
+	ret = p9220_reg_read(client, reg, &data2);
+	if (ret >= 0) {
+		u8 old_val = data2 & 0xff;
+		u8 new_val = (val & mask) | (old_val & (~mask));
+		data[2] = new_val;
+
+		mutex_lock(&charger->io_lock);
+		ret = i2c_master_send(client, data, 3);
+		mutex_unlock(&charger->io_lock);		
+		if (ret < 3) {
+			dev_err(&client->dev, "%s: i2c write error, reg: 0x%x, ret: %d\n",
+				__func__, reg, ret);
+			return ret < 0 ? ret : -EIO;
+		}
+	}
+	p9220_reg_read(client, reg, &data2);
+
+	return ret;
+}
+
+static int p9220_reg_multi_write(struct i2c_client *client, u16 reg, const u8 * val, int size)
+{
+	struct p9220_charger_data *charger = i2c_get_clientdata(client);
+	int ret;
+	const int sendsz = 16;
+	unsigned char data[sendsz+2];
+	int cnt = 0;
+
+	dev_err(&client->dev, "%s: size: 0x%x\n",
+				__func__, size);
+	while(size > sendsz) {
+		data[0] = (reg+cnt) >>8;
+		data[1] = (reg+cnt) & 0xff;
+		memcpy(data+2, val+cnt, sendsz);
+		mutex_lock(&charger->io_lock);
+		ret = i2c_master_send(client, data, sendsz+2);
+		mutex_unlock(&charger->io_lock);
+		if (ret < sendsz+2) {
+			dev_err(&client->dev, "%s: i2c write error, reg: 0x%x\n",
+					__func__, reg);
+			return ret < 0 ? ret : -EIO;
+		}
+		cnt = cnt + sendsz;
+		size = size - sendsz;
+	}
+	if (size > 0) {
+		data[0] = (reg+cnt) >>8;
+		data[1] = (reg+cnt) & 0xff;
+		memcpy(data+2, val+cnt, size);
+		mutex_lock(&charger->io_lock);
+		ret = i2c_master_send(client, data, size+2);
+		mutex_unlock(&charger->io_lock);
+		if (ret < size+2) {
+			dev_err(&client->dev, "%s: i2c write error, reg: 0x%x\n",
+					__func__, reg);
+			return ret < 0 ? ret : -EIO;
+		}
+	}
+
+	return ret;
+}
+
+static int p9220_clear_sram(struct i2c_client *client, u16 reg, const u8 * val, int size)
+{
+	int ret;
+	const int sendsz = 64;
+	unsigned char data[sendsz+2];
+	int cnt = 0;
+
+	while(size > sendsz) {
+		data[0] = (reg+cnt) >>8;
+		data[1] = (reg+cnt) & 0xff;
+		memcpy(data+2, val, sendsz);
+//		dev_dbg(&client->dev, "%s: addr: 0x%x, cnt: 0x%x\n", __func__, reg+cnt, cnt);
+		ret = i2c_master_send(client, data, sendsz+2);
+		if (ret < sendsz+2) {
+			dev_err(&client->dev, "%s: i2c write error, reg: 0x%x\n",
+					__func__, reg);
+			return ret < 0 ? ret : -EIO;
+		}
+		cnt = cnt + sendsz;
+		size = size - sendsz;
+	}
+	if (size > 0) {
+		data[0] = (reg+cnt) >>8;
+		data[1] = (reg+cnt) & 0xff;
+		memcpy(data+2, val, size);
+//		dev_dbg(&client->dev, "%s: addr: 0x%x, cnt: 0x%x, size: 0x%x\n", __func__, reg+cnt, cnt, size);
+		ret = i2c_master_send(client, data, size+2);
+		if (ret < size+2) {
+			dev_err(&client->dev, "%s: i2c write error, reg: 0x%x\n",
+					__func__, reg);
+			return ret < 0 ? ret : -EIO;
+		}
+	}
+
+	return ret;
+}
+
+int p9220_get_adc(struct p9220_charger_data *charger, int adc_type)
+{
+	int ret = 0;
+	u8 data[2] = {0,};
+
+	switch (adc_type) {
+		case P9220_ADC_VOUT:
+			ret = p9220_reg_read(charger->client, P9220_ADC_VOUT_L_REG, &data[0]);
+			ret = p9220_reg_read(charger->client, P9220_ADC_VOUT_H_REG, &data[1]);
+			if(ret >= 0 ) {
+				data[1] &= 0x0f;
+				ret = (data[0] | (data[1] << 8))*12600/4095;
+			} else
+				ret = 0;
+			break;
+		case P9220_ADC_VRECT:
+			ret = p9220_reg_read(charger->client, P9220_ADC_VRECT_L_REG, &data[0]);
+			ret = p9220_reg_read(charger->client, P9220_ADC_VRECT_H_REG, &data[1]);
+			if(ret >= 0 ) {
+				data[1] &= 0x0f;
+				ret = (data[0] | (data[1] << 8))*21000/4095;
+			} else
+				ret = 0;
+			break;
+		case P9220_ADC_TX_ISENSE:
+			ret = p9220_reg_read(charger->client, P9220_ADC_TX_ISENSE_L_REG, &data[0]);
+			ret = p9220_reg_read(charger->client, P9220_ADC_TX_ISENSE_H_REG, &data[1]);
+			if(ret >= 0 ) {
+				data[1] &= 0x0f;
+				ret = (data[0] | (data[1] << 8)); // need to check
+			} else
+				ret = 0;
+			break;
+		case P9220_ADC_RX_IOUT:
+			ret = p9220_reg_read(charger->client, P9220_ADC_RX_IOUT_L_REG, &data[0]);
+			ret = p9220_reg_read(charger->client, P9220_ADC_RX_IOUT_H_REG, &data[1]);
+			if(ret >= 0 ) {
+				data[1] &= 0x0f;
+				ret = (data[0] | (data[1] << 8)); // need to check
+			} else
+				ret = 0;
+			break;
+		case P9220_ADC_DIE_TEMP:
+			ret = p9220_reg_read(charger->client, P9220_ADC_DIE_TEMP_L_REG, &data[0]);
+			ret = p9220_reg_read(charger->client, P9220_ADC_DIE_TEMP_H_REG, &data[1]);
+			if(ret >= 0 ) {
+				data[1] &= 0x0f;
+				ret = (data[0] | (data[1] << 8)); // need to check
+			} else
+				ret = 0;
+			break;
+
+		case P9220_ADC_ALLIGN_X:
+			ret = p9220_reg_read(charger->client, P9220_ADC_ALLIGN_X_REG, &data[0]);
+			if(ret >= 0 ) {
+				ret = data[0]; // need to check
+			} else
+				ret = 0;
+			break;
+
+		case P9220_ADC_ALLIGN_Y:
+			ret = p9220_reg_read(charger->client, P9220_ADC_ALLIGN_Y_REG, &data[0]);
+			if(ret >= 0 ) {
+				ret = data[0]; // need to check
+			} else
+				ret = 0;
+			break;
+		case P9220_ADC_OP_FRQ:
+			ret = p9220_reg_read(charger->client, P9220_OP_FREQ_L_REG, &data[0]);
+			if(ret < 0 ) {
+				ret = 0;
+				return ret;
+			}
+			ret = p9220_reg_read(charger->client, P9220_OP_FREQ_H_REG, &data[1]);
+			if(ret >= 0 )
+				ret = FREQ_OFFSET / (data[0] | (data[1] << 8));
+			else
+				ret = -1;
+			break;
+		case P9220_ADC_TX_PING:
+			ret = p9220_reg_read(charger->client, P9220_TX_PING_FREQ_REG, &data[0]);
+			if(ret >= 0 )
+				ret = data[0];
+			else
+				ret = -1;
+		default:
+			break;
+	}
+
+	return ret;
+}
+
+void p9220_set_vout(struct p9220_charger_data *charger, int vout)
+{
+	union power_supply_propval value;
+	switch (vout) {
+		case P9220_VOUT_5V:
+			p9220_reg_write(charger->client, P9220_VOUT_SET_REG, P9220_VOUT_5V_VAL);
+			msleep(100);
+			pr_info("%s vout read = %d mV \n", __func__,  p9220_get_adc(charger, P9220_ADC_VOUT));
+			break;
+		case P9220_VOUT_6V:
+			p9220_reg_write(charger->client, P9220_VOUT_SET_REG, P9220_VOUT_6V_VAL);
+			msleep(100);
+			pr_info("%s vout read = %d mV \n", __func__,  p9220_get_adc(charger, P9220_ADC_VOUT));
+			break;
+		case P9220_VOUT_9V:
+			psy_do_property(charger->pdata->wired_charger_name, get, POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL, value);
+			if (value.intval) {
+				pr_info("%s CHGIN_OTG now ON, do not set VOUT 9V \n", __func__);
+				break;
+			}
+			/* We set VOUT to 10V actually for HERO for RE/CE standard authentication */
+			if (charger->pdata->hv_vout_wa)
+				p9220_reg_write(charger->client, P9220_VOUT_SET_REG, charger->pdata->hv_vout_wa);
+			else
+				p9220_reg_write(charger->client, P9220_VOUT_SET_REG, P9220_VOUT_9V_VAL);
+			msleep(100);
+			pr_info("%s vout read = %d mV \n", __func__,  p9220_get_adc(charger, P9220_ADC_VOUT));
+			break;
+		case P9220_VOUT_CC_CV:
+			p9220_reg_write(charger->client, P9220_VOUT_SET_REG,
+							(charger->pdata->wpc_cc_cv_vout - 3500) / 100);
+			msleep(100);
+			pr_info("%s vout read = %d mV \n", __func__,  p9220_get_adc(charger, P9220_ADC_VOUT));
+			break;
+		case P9220_VOUT_CV_CALL:
+			p9220_reg_write(charger->client, P9220_VOUT_SET_REG,
+							(charger->pdata->wpc_cv_call_vout - 3500) / 100);
+			msleep(100);
+			pr_info("%s vout read = %d mV \n", __func__,  p9220_get_adc(charger, P9220_ADC_VOUT));
+			break;
+		case P9220_VOUT_CC_CALL:
+			p9220_reg_write(charger->client, P9220_VOUT_SET_REG,
+							(charger->pdata->wpc_cc_call_vout - 3500) / 100);
+			msleep(100);
+			pr_info("%s vout read = %d mV \n", __func__,  p9220_get_adc(charger, P9220_ADC_VOUT));
+			break;
+		case P9220_VOUT_9V_STEP:
+			p9220_reg_write(charger->client, P9220_VOUT_SET_REG, P9220_VOUT_6V_VAL);
+			msleep(1000);
+			p9220_reg_write(charger->client, P9220_VOUT_SET_REG, P9220_VOUT_7V_VAL);
+			msleep(1000);
+			p9220_reg_write(charger->client, P9220_VOUT_SET_REG, P9220_VOUT_8V_VAL);
+			msleep(1000);
+			p9220_reg_write(charger->client, P9220_VOUT_SET_REG, P9220_VOUT_9V_VAL);
+			msleep(1000);		
+			pr_info("%s vout read = %d mV \n", __func__,  p9220_get_adc(charger, P9220_ADC_VOUT));
+			break;
+		default:
+			break;
+	}
+	charger->pdata->vout_status = vout;
+}
+
+int p9220_get_vout(struct p9220_charger_data *charger)
+{
+	u8 data;
+	int ret;
+	ret = p9220_reg_read(charger->client, P9220_VOUT_SET_REG, &data);
+	if (ret < 0) {
+		pr_err("%s: fail to read vout. (%d)\n", __func__, ret);
+		return ret;
+	} else
+		pr_info("%s: vout(0x%x)\n", __func__, data);
+
+	return data;
+}
+
+void p9220_fod_set(struct p9220_charger_data *charger)
+{
+	int i = 0;
+
+	pr_info("%s \n", __func__);
+	if(charger->pdata->fod_data_check) {
+		for(i=0; i< P9220_NUM_FOD_REG; i++)
+			p9220_reg_write(charger->client, P9220_WPC_FOD_0A_REG+i, charger->pdata->fod_data[i]);
+	}
+}
+
+void p9220_fod_set_cv(struct p9220_charger_data *charger)
+{
+	int i = 0;
+
+	pr_info("%s \n", __func__);
+	if(charger->pdata->fod_data_check) {
+		for(i=0; i< P9220_NUM_FOD_REG; i++)
+			p9220_reg_write(charger->client, P9220_WPC_FOD_0A_REG+i, charger->pdata->fod_data_cv[i]);
+	}
+}
+
+void p9220_fod_set_cs100(struct p9220_charger_data *charger)
+{
+	int i = 0;
+
+	pr_info("%s \n", __func__);
+	if(charger->pdata->fod_data_check) {
+		for(i=1; i< P9220_NUM_FOD_REG; i+=2)
+			p9220_reg_write(charger->client, P9220_WPC_FOD_0A_REG+i, 0x7f);
+	}
+}
+
+void p9220_set_cmd_reg(struct p9220_charger_data *charger, u8 val, u8 mask)
+{
+	u8 temp = 0;
+	int ret = 0, i = 0;
+
+	do {
+		pr_info("%s \n", __func__);
+		ret = p9220_reg_update(charger->client, P9220_COMMAND_REG, val, mask); // command
+		if(ret >= 0) {
+			msleep(250);
+			ret = p9220_reg_read(charger->client, P9220_COMMAND_REG, &temp); // check out set bit exists
+			if(ret < 0 || i > 3 )
+				break;
+		}
+		i++;
+	}while(temp != 0);
+}
+
+void p9220_send_eop(struct p9220_charger_data *charger, int health_mode)
+{
+	int i = 0;
+	int ret = 0;
+
+	switch(health_mode) {
+		case POWER_SUPPLY_HEALTH_OVERHEAT:
+		case POWER_SUPPLY_HEALTH_OVERHEATLIMIT:
+		case POWER_SUPPLY_HEALTH_COLD:
+		if(charger->pdata->cable_type == SEC_WIRELESS_PAD_PMA) {
+			pr_info("%s pma mode \n", __func__);
+			for(i = 0; i < CMD_CNT; i++) {
+				ret = p9220_reg_write(charger->client, P9220_END_POWER_TRANSFER_REG, P9220_EPT_END_OF_CHG);
+				if(ret >= 0) {
+					p9220_set_cmd_reg(charger, P9220_CMD_SEND_EOP_MASK, P9220_CMD_SEND_EOP_MASK);
+					msleep(250);
+				} else
+					break;
+			}
+		} else {
+			pr_info("%s wpc mode \n", __func__);
+			for(i = 0; i < CMD_CNT; i++) {
+				ret = p9220_reg_write(charger->client, P9220_END_POWER_TRANSFER_REG, P9220_EPT_OVER_TEMP);
+				if(ret >= 0) {
+					p9220_set_cmd_reg(charger, P9220_CMD_SEND_EOP_MASK, P9220_CMD_SEND_EOP_MASK);
+					msleep(250);
+				} else
+					break;
+			}
+		}
+		break;
+		case POWER_SUPPLY_HEALTH_UNDERVOLTAGE:
+#if 0
+			pr_info("%s ept-reconfigure \n", __func__);
+			ret = p9220_reg_write(charger->client, P9220_END_POWER_TRANSFER_REG, P9220_EPT_RECONFIG);
+			if(ret >= 0) {
+				p9220_set_cmd_reg(charger, P9220_CMD_SEND_EOP_MASK, P9220_CMD_SEND_EOP_MASK);
+				msleep(250);
+			}
+#endif
+		break;
+		default:
+		break;
+	}
+}
+
+int p9220_send_cs100(struct p9220_charger_data *charger)
+{
+	int i = 0;
+	int ret = 0;
+
+	for(i = 0; i < CMD_CNT; i++) {
+		ret = p9220_reg_write(charger->client, P9220_CHG_STATUS_REG, 100);
+		if(ret >= 0) {
+			p9220_set_cmd_reg(charger, P9220_CMD_SEND_CHG_STS_MASK, P9220_CMD_SEND_CHG_STS_MASK);
+			msleep(250);
+			ret = 1;
+		} else {
+			ret = -1;
+			break;
+		}
+	}
+	return ret;
+}
+
+void p9220_send_packet(struct p9220_charger_data *charger, u8 header, u8 rx_data_com, u8 *data_val, int data_size)
+{
+	int ret;
+	int i;
+	ret = p9220_reg_write(charger->client, P9220_PACKET_HEADER, header);
+	ret = p9220_reg_write(charger->client, P9220_RX_DATA_COMMAND, rx_data_com);
+
+	for(i = 0; i< data_size; i++) {
+		ret = p9220_reg_write(charger->client, P9220_RX_DATA_VALUE0 + i, data_val[i]);
+	}
+	p9220_set_cmd_reg(charger, P9220_CMD_SEND_RX_DATA_MASK, P9220_CMD_SEND_RX_DATA_MASK);
+}
+
+void p9220_send_command(struct p9220_charger_data *charger, int cmd_mode)
+{
+	u8 data_val[4];
+	int i = 0;
+	switch (cmd_mode) {
+		case P9220_AFC_CONF_5V:
+			pr_info("%s set 5V \n", __func__);
+
+			data_val[0] = 0x05;
+			p9220_send_packet(charger, P9220_HEADER_AFC_CONF, P9220_RX_DATA_COM_AFC_SET, data_val, 1);
+			msleep(120);
+
+			p9220_set_vout(charger, P9220_VOUT_5V);
+			pr_info("%s vout read = %d \n", __func__,  p9220_get_adc(charger, P9220_ADC_VOUT));
+			p9220_reg_read(charger->client, P9220_RX_DATA_COMMAND, &data_val[0]);
+			p9220_reg_read(charger->client, P9220_RX_DATA_VALUE0, &data_val[0]);
+			p9220_reg_read(charger->client, P9220_COMMAND_REG, &data_val[0]);
+			break;
+		case P9220_AFC_CONF_9V:
+			for(i = 0; i < CMD_CNT - 1; i++) {
+				pr_info("%s set 9V , cnt = %d \n", __func__, i);
+				data_val[0] = 0x2c;
+				p9220_send_packet(charger, P9220_HEADER_AFC_CONF, P9220_RX_DATA_COM_AFC_SET, data_val, 1);
+				p9220_reg_read(charger->client, P9220_RX_DATA_COMMAND, &data_val[0]);
+				p9220_reg_read(charger->client, P9220_RX_DATA_VALUE0, &data_val[0]);
+				p9220_reg_read(charger->client, P9220_COMMAND_REG, &data_val[0]);
+				msleep(10);
+			}
+			p9220_set_vout(charger, P9220_VOUT_9V);
+			/* Enable Clamp1, Clamp2 for WPC 9W, should set after vout set */
+			p9220_reg_update(charger->client, P9220_MOD_DEPTH_REG, 0x30, 0x30);
+			break;
+		case P9220_LED_CONTROL_ON:
+			pr_info("%s led on \n", __func__);
+			data_val[0] = 0x0;
+			p9220_send_packet(charger, P9220_HEADER_AFC_CONF, P9220_RX_DATA_COM_LED_CTRL, data_val, 1);
+			break;
+		case P9220_LED_CONTROL_OFF:
+			pr_info("%s led off \n", __func__);
+			data_val[0] = 0xff;
+			p9220_send_packet(charger, P9220_HEADER_AFC_CONF, P9220_RX_DATA_COM_LED_CTRL, data_val, 1);
+			break;
+		case P9220_FAN_CONTROL_ON:
+			pr_info("%s fan on \n", __func__);
+			data_val[0] = 0x0;
+			p9220_send_packet(charger, P9220_HEADER_AFC_CONF, P9220_RX_DATA_COM_FAN_CTRL, data_val, 1);
+			break;
+		case P9220_FAN_CONTROL_OFF:
+			pr_info("%s fan off \n", __func__);
+			data_val[0] = 0xff;
+			p9220_send_packet(charger, P9220_HEADER_AFC_CONF, P9220_RX_DATA_COM_FAN_CTRL, data_val, 1);
+			break;
+		case P9220_REQUEST_AFC_TX:
+			pr_info("%s request afc tx \n", __func__);
+			data_val[0] = 0x0;
+			p9220_send_packet(charger, P9220_HEADER_AFC_CONF, P9220_RX_DATA_COM_REQ_AFC, data_val, 1);
+			break;
+		case P9220_REQUEST_TX_ID:
+			pr_info("%s request TX ID \n", __func__);
+			data_val[0] = 0x0;
+			p9220_send_packet(charger, P9220_HEADER_AFC_CONF, P9220_RX_DATA_COM_TX_ID, data_val, 1);
+			break;
+		default:
+			break;
+	}
+}
+
+void p9220_led_control(struct p9220_charger_data *charger, bool on)
+{
+	int i = 0;
+
+	if(on) {
+		for(i=0; i< CMD_CNT; i++)
+			p9220_send_command(charger, P9220_LED_CONTROL_ON);
+	} else {
+		for(i=0; i< CMD_CNT; i++)
+			p9220_send_command(charger, P9220_LED_CONTROL_OFF);
+	}
+}
+
+void p9220_fan_control(struct p9220_charger_data *charger, bool on)
+{
+	int i = 0;
+
+	if(on) {
+		for(i=0; i< CMD_CNT -1; i++)
+			p9220_send_command(charger, P9220_FAN_CONTROL_ON);
+	} else {
+		for(i=0; i< CMD_CNT -1; i++)
+			p9220_send_command(charger, P9220_FAN_CONTROL_OFF);
+	}
+}
+
+void p9220_set_vrect_adjust(struct p9220_charger_data *charger, int set)
+{
+	int i = 0;
+
+	switch (set) {
+		case P9220_HEADROOM_0:
+			for(i=0; i<6; i++) {
+				p9220_reg_write(charger->client, P9220_VRECT_SET_REG, 0x0);
+				msleep(50);
+			}
+			break;
+		case P9220_HEADROOM_1:
+			for(i=0; i<6; i++) {
+				p9220_reg_write(charger->client, P9220_VRECT_SET_REG, 0x36);
+				msleep(50);
+			}
+			break;
+		case P9220_HEADROOM_2:
+			for(i=0; i<6; i++) {
+				p9220_reg_write(charger->client, P9220_VRECT_SET_REG, 0x61);
+				msleep(50);
+			}
+			break;
+		case P9220_HEADROOM_3:
+			for(i=0; i<6; i++) {
+				p9220_reg_write(charger->client, P9220_VRECT_SET_REG, 0x7f);
+				msleep(50);
+			}
+			break;
+		case P9220_HEADROOM_4:
+			for(i=0; i<6; i++) {
+				p9220_reg_write(charger->client, P9220_VRECT_SET_REG, 0x06);
+				msleep(50);
+			}
+			break;
+		case P9220_HEADROOM_5:
+			for(i=0; i<6; i++) {
+				p9220_reg_write(charger->client, P9220_VRECT_SET_REG, 0x10);
+				msleep(50);
+			}
+			break;
+		default:
+			pr_info("%s no headroom mode\n", __func__);
+			break;
+	}
+}
+
+void p9220_mis_align(struct p9220_charger_data *charger)
+{
+	pr_info("%s: Reset M0\n",__func__);
+	if (charger->pdata->cable_type == P9220_PAD_MODE_WPC_AFC ||
+		charger->pdata->cable_type == P9220_PAD_MODE_PMA)
+		p9220_reg_write(charger->client, 0x3040, 0x80); /*restart M0 */
+}
+
+int p9220_get_firmware_version(struct p9220_charger_data *charger, int firm_mode)
+{
+	int version = -1;
+	int ret;
+	u8 otp_fw_major[2] = {0,};
+	u8 otp_fw_minor[2] = {0,};
+	u8 tx_fw_major[2] = {0,};
+	u8 tx_fw_minor[2] = {0,};
+
+	switch (firm_mode) {
+		case P9220_RX_FIRMWARE:
+			ret = p9220_reg_read(charger->client, P9220_OTP_FW_MAJOR_REV_L_REG, &otp_fw_major[0]);
+			ret = p9220_reg_read(charger->client, P9220_OTP_FW_MAJOR_REV_H_REG, &otp_fw_major[1]);
+			if (ret >= 0) {
+				version =  otp_fw_major[0] | (otp_fw_major[1] << 8);
+			}
+			pr_info("%s rx major firmware version 0x%x \n", __func__, version);
+
+			ret = p9220_reg_read(charger->client, P9220_OTP_FW_MINOR_REV_L_REG, &otp_fw_minor[0]);
+			ret = p9220_reg_read(charger->client, P9220_OTP_FW_MINOR_REV_H_REG, &otp_fw_minor[1]);
+			if (ret >= 0) {
+				version =  otp_fw_minor[0] | (otp_fw_minor[1] << 8);
+			}
+			pr_info("%s rx minor firmware version 0x%x \n", __func__, version);
+			break;
+		case P9220_TX_FIRMWARE:
+			ret = p9220_reg_read(charger->client, P9220_SRAM_FW_MAJOR_REV_L_REG, &tx_fw_major[0]);
+			ret = p9220_reg_read(charger->client, P9220_SRAM_FW_MAJOR_REV_H_REG, &tx_fw_major[1]);
+			if (ret >= 0) {
+				version =  tx_fw_major[0] | (tx_fw_major[1] << 8);
+			}
+			pr_info("%s tx major firmware version 0x%x \n", __func__, version);
+
+			ret = p9220_reg_read(charger->client, P9220_SRAM_FW_MINOR_REV_L_REG, &tx_fw_minor[0]);
+			ret = p9220_reg_read(charger->client, P9220_SRAM_FW_MINOR_REV_H_REG, &tx_fw_minor[1]);
+			if (ret >= 0) {
+				version =  tx_fw_minor[0] | (tx_fw_minor[1] << 8);
+			}
+			pr_info("%s tx minor firmware version 0x%x \n", __func__, version);
+			break;
+		default:
+			pr_err("%s Wrong firmware mode \n", __func__);
+			version = -1;
+			break;
+	}
+
+	return version;
+}
+
+int p9220_get_ic_grade(struct p9220_charger_data *charger, int read_mode)
+{
+	u8 grade;
+	int ret;
+
+	switch (read_mode) {
+		case P9220_IC_GRADE:
+			ret = p9220_reg_read(charger->client, P9220_CHIP_REVISION_REG, &grade);
+
+			if(ret >= 0) {
+				grade &= P9220_CHIP_GRADE_MASK;
+				pr_info("%s ic grade = %d \n", __func__, grade);
+				ret =  grade;
+			}
+			else
+				ret = -1;
+			break;
+		case P9220_IC_VERSION:
+			ret = p9220_reg_read(charger->client, P9220_CHIP_REVISION_REG, &grade);
+
+			if(ret >= 0) {
+				grade &= P9220_CHIP_REVISION_MASK;
+				pr_info("%s ic version = %d \n", __func__, grade);
+				ret =  grade;
+			}
+			else
+				ret = -1;
+			break;
+		case P9220_IC_VENDOR:
+			ret = -1;
+			break;
+		default :
+			ret = -1;
+			break;
+	}
+	return ret;
+}
+
+void p9220_wireless_chg_init(struct p9220_charger_data *charger)
+{
+	pr_info("%s \n", __func__);
+
+	p9220_set_vout(charger, P9220_VOUT_5V);
+}
+
+static int datacmp(const char *cs, const char *ct, int count)
+{
+	unsigned char c1, c2;
+
+	while (count) {
+		c1 = *cs++;
+		c2 = *ct++;
+		if (c1 != c2) {
+			pr_err("%s, cnt %d\n", __func__, count);
+			return c1 < c2 ? -1 : 1;
+		}
+		count--;
+	}
+	return 0;
+}
+static int LoadOTPLoaderInRAM(struct p9220_charger_data *charger, u16 addr)
+{
+	int i, size;
+	u8 data[1024];
+	if (p9220_reg_multi_write(charger->client, addr, OTPBootloader, sizeof(OTPBootloader)) < 0) {
+		pr_err("%s,fail", __func__);
+	}
+	size = sizeof(OTPBootloader);
+	i = 0;
+	while(size > 0) {
+		if (p9220_reg_multi_read(charger->client, addr+i, data+i, 16) < 0) {
+			pr_err("%s, read failed(%d)", __func__, addr+i);
+			return 0;
+		}
+		i += 16;
+		size -= 16;
+	}
+	size = sizeof(OTPBootloader);
+	if (datacmp(data, OTPBootloader, size)) {
+		pr_err("%s, data is not matched\n", __func__);
+		return 0;
+	}
+	return 1;
+}
+
+static int p9220_firmware_verify(struct p9220_charger_data *charger)
+{
+	int ret = 0;
+	const u16 sendsz = 16;
+	size_t i = 0;
+	int block_len = 0;
+	int block_addr = 0;
+	u8 rdata[sendsz+2];
+
+/* I2C WR to prepare boot-loader write */
+
+	if (p9220_reg_write(charger->client, 0x3C00, 0x80) < 0) {
+		pr_err("%s: reset FDEM error\n", __func__);
+		return 0;
+	}
+
+	if (p9220_reg_write(charger->client, 0x3000, 0x5a) < 0) {
+		pr_err("%s: key error\n", __func__);
+		return 0;
+	}
+
+	if (p9220_reg_write(charger->client, 0x3040, 0x11) < 0) {
+		pr_err("%s: halt M0, OTP_I2C_EN set error\n", __func__);
+		return 0;
+	}
+
+	if (p9220_reg_write(charger->client, 0x3C04, 0x04) < 0) {
+		pr_err("%s: OTP_VRR 2.98V error\n", __func__);
+		return 0;
+	}
+
+	if (p9220_reg_write(charger->client, 0x5C00, 0x11) < 0) {
+		pr_err("%s: OTP_CTRL VPP_EN set error\n", __func__);
+		return 0;
+	}
+
+	dev_err(&charger->client->dev, "%s, request_firmware\n", __func__);
+	ret = request_firmware(&charger->firm_data_bin, P9220S_OTP_FW_HEX_PATH,
+		&charger->client->dev);
+	if ( ret < 0) {
+		dev_err(&charger->client->dev, "%s: failed to request firmware %s (%d) \n",
+				__func__, P9220S_OTP_FW_HEX_PATH, ret);
+		return 0;
+	}
+	ret = 1;
+	wake_lock(&charger->wpc_update_lock);
+	for (i = 0; i < charger->firm_data_bin->size; i += sendsz) {
+		block_len = (i + sendsz) > charger->firm_data_bin->size ? charger->firm_data_bin->size - i : sendsz;
+		block_addr = 0x8000 + i;
+
+		if (p9220_reg_multi_read(charger->client, block_addr, rdata, block_len) < 0) {
+			pr_err("%s, read failed\n", __func__);
+			ret = 0;
+			break;
+		}
+		if (datacmp(charger->firm_data_bin->data + i, rdata, block_len)) {
+			pr_err("%s, verify data is not matched.\n", __func__);
+			ret = -1;
+			break;
+		}
+	}
+	release_firmware(charger->firm_data_bin);
+
+	wake_unlock(&charger->wpc_update_lock);
+	return ret;
+}
+
+static int p9220_reg_multi_write_verify(struct i2c_client *client, u16 reg, const u8 * val, int size)
+{
+	int ret = 0;
+	const int sendsz = 16;
+	int cnt = 0;
+	int retry_cnt = 0;
+	unsigned char data[sendsz+2];
+	u8 rdata[sendsz+2];
+
+//	dev_dbg(&client->dev, "%s: size: 0x%x\n", __func__, size);
+	while(size > sendsz) {
+		data[0] = (reg+cnt) >>8;
+		data[1] = (reg+cnt) & 0xff;
+		memcpy(data+2, val+cnt, sendsz);
+//		dev_dbg(&client->dev, "%s: addr: 0x%x, cnt: 0x%x\n", __func__, reg+cnt, cnt);
+		ret = i2c_master_send(client, data, sendsz+2);
+		if (ret < sendsz+2) {
+			dev_err(&client->dev, "%s: i2c write error, reg: 0x%x\n", __func__, reg);
+			return ret < 0 ? ret : -EIO;
+		}
+		if (p9220_reg_multi_read(client, reg+cnt, rdata, sendsz) < 0) {
+			pr_err("%s, read failed(%d)\n", __func__, reg+cnt);
+			return -1;
+		}
+		if (datacmp(val+cnt, rdata, sendsz)) {
+			pr_err("%s, data is not matched. retry(%d)\n", __func__, retry_cnt);
+			retry_cnt++;
+			if(retry_cnt > 4) {
+				pr_err("%s, data is not matched. write failed\n", __func__);
+				retry_cnt = 0;
+				return -1;
+			}
+			continue;
+		}
+//		pr_debug("%s, data is matched!\n", __func__);
+		cnt += sendsz;
+		size -= sendsz;
+		retry_cnt = 0;
+	}
+	while (size > 0) {
+		data[0] = (reg+cnt) >>8;
+		data[1] = (reg+cnt) & 0xff;
+		memcpy(data+2, val+cnt, size);
+//		dev_dbg(&client->dev, "%s: addr: 0x%x, cnt: 0x%x, size: 0x%x\n", __func__, reg+cnt, cnt, size);
+		ret = i2c_master_send(client, data, size+2);
+		if (ret < size+2) {
+			dev_err(&client->dev, "%s: i2c write error, reg: 0x%x\n", __func__, reg);
+			return ret < 0 ? ret : -EIO;
+		}
+		if (p9220_reg_multi_read(client, reg+cnt, rdata, size) < 0) {
+			pr_err("%s, read failed(%d)\n", __func__, reg+cnt);
+			return -1;
+		}
+		if (datacmp(val+cnt, rdata, size)) {
+			pr_err("%s, data is not matched. retry(%d)\n", __func__, retry_cnt);
+			retry_cnt++;
+			if(retry_cnt > 4) {
+				pr_err("%s, data is not matched. write failed\n", __func__);
+				retry_cnt = 0;
+				return -1;
+			}
+			continue;
+		}
+		size = 0;
+		pr_err("%s, data is matched!\n", __func__);
+	}
+	return ret;
+}
+
+static int p9220_TxFW_SRAM(struct p9220_charger_data *charger, const u8 * srcData, int fw_size)
+{
+	const u8 clear_data[] = {
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+};
+
+	u16 addr;
+	u8 temp;
+	int ret;
+
+	pr_info("%s TX FW update Start \n",__func__);
+
+	if (p9220_reg_write(charger->client, 0x3000, 0x5a) < 0) {
+		pr_err("%s: write key error\n", __func__);
+		return false;
+	}
+	if (p9220_reg_write(charger->client, 0x3040, 0x10) < 0) {
+		pr_err("%s: halt M0 error\n", __func__);
+		return false;
+	}
+
+	/* clear 0x0000 to 0x1FFF */
+	if (p9220_clear_sram(charger->client, 0x0000, clear_data, 0x2000) < 0) {
+		pr_err("%s: clear memory error\n", __func__);
+		return false;
+	}
+	addr = 0x0800;
+	if (p9220_reg_multi_write_verify(charger->client, addr, srcData, fw_size) < 0) {
+		pr_err("%s: write fail", __func__);
+		return false;
+	}
+
+	if (p9220_reg_write(charger->client, 0x3000, 0x5a) < 0) {
+		pr_err("%s: write key error..\n", __func__);
+		return false;
+	}
+
+	if (p9220_reg_write(charger->client, 0x3048, 0xD0) < 0) {
+		pr_err("%s: remapping error..\n", __func__);
+		return false;
+	}
+
+	p9220_reg_write(charger->client, 0x3040, 0x80);
+
+	pr_err("TX firmware update finished.\n");
+	ret = p9220_reg_read(charger->client, P9220_SYS_OP_MODE_REG, &temp);
+	pr_info("%s: SYS_OP_MODE 0x%x, ret: %d\n", __func__, temp, ret);
+	return true;
+}
+
+static int PgmOTPwRAM(struct p9220_charger_data *charger, unsigned short OtpAddr,
+					  const u8 * srcData, int srcOffs, int size)
+{
+	int i, j, cnt;
+	int block_len = 0;
+	u8 fw_major[2] = {0,};
+	u8 fw_minor[2] = {0,};
+
+	p9220_reg_read(charger->client, P9220_OTP_FW_MAJOR_REV_L_REG, &fw_major[0]);
+	p9220_reg_read(charger->client, P9220_OTP_FW_MAJOR_REV_H_REG, &fw_major[1]);
+	p9220_reg_read(charger->client, P9220_OTP_FW_MINOR_REV_L_REG, &fw_minor[0]);
+	p9220_reg_read(charger->client, P9220_OTP_FW_MINOR_REV_H_REG, &fw_minor[1]);
+
+	if (p9220_reg_write(charger->client, 0x3000, 0x5a) < 0) {
+		pr_err("%s: write key error\n", __func__);
+		return false;		// write key
+	}
+	if (p9220_reg_write(charger->client, 0x3040, 0x10) < 0) {
+		pr_err("%s: halt M0 error\n", __func__);
+		return false;		// halt M0
+	}
+	if (!LoadOTPLoaderInRAM(charger, 0x1c00)){
+		pr_err("%s: LoadOTPLoaderInRAM error\n", __func__);
+		return false;		// make sure load address and 1KB size are OK
+	}
+
+	if (p9220_reg_write(charger->client, 0x3048, 0x80) < 0) {
+		pr_err("%s: map RAM to OTP error\n", __func__);
+		return false;		// map RAM to OTP
+	}
+	p9220_reg_write(charger->client, 0x3040, 0x80);
+	msleep(100);
+
+	for (i = 0; i < size; i += 128)		// program pages of 128 bytes
+	{
+		u8 sBuf[136] = {0,};
+		u16 StartAddr = (u16)i;
+		u16 CheckSum = StartAddr;
+		u16 CodeLength = 128;
+
+		block_len = (i + 128) > size ? size - i : 128;
+		if (block_len == 128) {
+			memcpy(sBuf + 8, srcData + i + srcOffs, 128);
+		} else {
+			memset(sBuf, 0, 136);
+			memcpy(sBuf + 8, srcData + i + srcOffs, block_len);
+		}
+
+		for (j = 127; j >= 0; j--)
+		{
+			if (sBuf[j + 8] != 0)
+				break;
+			else
+				CodeLength--;
+		}
+		if (CodeLength == 0)
+			continue;				// skip programming if nothing to program
+		for (; j >= 0; j--)
+			CheckSum += sBuf[j + 8];	// add the non zero values
+		CheckSum += CodeLength;			// finish calculation of the check sum
+
+		memcpy(sBuf+2, &StartAddr,2);
+		memcpy(sBuf+4, &CodeLength,2);
+		memcpy(sBuf+6, &CheckSum,2);
+
+		if (p9220_reg_multi_write_verify(charger->client, 0x400, sBuf, CodeLength + 8) < 0)
+		{
+			pr_err("ERROR: on writing to OTP buffer");
+			return false;
+		}
+		sBuf[0] = 1;
+		if (p9220_reg_write(charger->client, 0x400, sBuf[0]) < 0)
+		{
+			pr_err("ERROR: on OTP buffer validation");
+			return false;
+		}
+
+		cnt = 0;
+		do
+		{
+			msleep(20);
+			if (p9220_reg_read(charger->client, 0x400, sBuf) < 0)
+			{
+				pr_err("ERROR: on readign OTP buffer status(%d)", cnt);
+				return false;
+			}
+			 if (cnt > 1000) {
+				 pr_err("ERROR: time out on buffer program to OTP");
+				 break;
+			 }
+			 cnt++;
+		} while (sBuf[0] == 1);
+
+		if (sBuf[0] != 2)		// not OK
+		{
+			pr_err("ERROR: buffer write to OTP returned status %d ",sBuf[0]);
+			return false;
+		}
+	}
+
+	if (p9220_reg_write(charger->client, 0x3000, 0x5a) < 0) {
+		pr_err("%s: write key error..\n", __func__);
+		return false;		// write key
+	}
+	if (p9220_reg_write(charger->client, 0x3048, 0x00) < 0) {
+		pr_err("%s: remove code remapping error..\n", __func__);
+		return false;		// remove code remapping
+	}
+
+	pr_err("OTP Programming finished in");
+	pr_info("%s------------------------------------------------- \n", __func__);
+	return true;
+}
+
+static int p9220_runtime_sram_change(struct p9220_charger_data *charger)
+{
+	int ret, i = 0;
+	u8 reg;
+
+	pr_info("%s \n", __func__);
+
+	do {
+		ret = p9220_reg_write(charger->client, 0x5834, adc_cal);
+		ret = p9220_reg_read(charger->client, 0x5834, &reg);
+		pr_info("%s [%d] otp : 0x%x, sram : 0x%x \n", __func__, i, adc_cal, reg);
+		if(i > 10 || ret < 0)
+			return false;
+		msleep(10);
+		i++;
+	} while(reg != adc_cal);
+
+	return true;
+}
+
+int p9220_runtime_sram_preprocess(struct p9220_charger_data *charger)
+{
+	u8 reg;
+	u8 pad_mode;
+
+	pr_info("%s \n", __func__);
+
+	if(gpio_get_value(charger->pdata->wpc_det)) {
+		pr_info("%s it is wireless lpm \n", __func__);
+		p9220_reg_read(charger->client, P9220_SYS_OP_MODE_REG, &pad_mode);
+		pr_info("%s pad_mode = %d \n", __func__, pad_mode);
+
+		if(pad_mode & P9220_SYS_MODE_PMA)
+			return true;
+	}
+
+	if (p9220_reg_write(charger->client, 0x3000, 0x5a) < 0) {
+		pr_err("%s: failed unlock register\n", __func__);
+	}
+
+	if (p9220_reg_write(charger->client, 0x3040, 0x11) < 0) {
+		pr_err("%s: failed stop process\n", __func__);
+	}
+
+	//write 1 at bit0 of 0xbfbe
+	if(p9220_reg_read(charger->client, 0xbfbe, &reg) < 0)
+		adc_cal = 0;
+	else {
+		adc_cal = reg = reg | 0x01;
+		pr_info("%s 0xbfbe = 0x%x \n", __func__, reg);
+	}
+
+	return true;
+}
+
+int p9220_firmware_update(struct p9220_charger_data *charger, int cmd)
+{
+	struct file *fp;
+	mm_segment_t old_fs;
+	long fsize, nread;
+	int ret = 0;
+    const u8 *fw_img;
+
+	pr_info("%s firmware update mode is = %d \n", __func__, cmd);
+
+	switch(cmd) {
+		case SEC_WIRELESS_RX_SDCARD_MODE:
+		charger->pdata->otp_firmware_result = P9220_FW_RESULT_DOWNLOADING;
+		msleep(200);
+		disable_irq(charger->pdata->irq_wpc_int);
+		disable_irq(charger->pdata->irq_wpc_det);
+		old_fs = get_fs();
+		set_fs(KERNEL_DS);
+
+		fp = filp_open(P9220S_FW_SDCARD_BIN_PATH, O_RDONLY, S_IRUSR);
+
+		if (IS_ERR(fp)) {
+			pr_err("%s: failed to open %s\n", __func__, P9220S_FW_SDCARD_BIN_PATH);
+			ret = -ENOENT;
+			set_fs(old_fs);
+			return ret;
+		}
+
+		fsize = fp->f_path.dentry->d_inode->i_size;
+		pr_err("%s: start, file path %s, size %ld Bytes\n",
+			__func__, P9220S_FW_SDCARD_BIN_PATH, fsize);
+
+		fw_img = kmalloc(fsize, GFP_KERNEL);
+
+		if (fw_img == NULL) {
+			pr_err("%s, kmalloc failed\n", __func__);
+			ret = -EFAULT;
+			goto malloc_error;
+		}
+
+		nread = vfs_read(fp, (char __user *)fw_img,
+					fsize, &fp->f_pos);
+		pr_err("nread %ld Bytes\n", nread);
+		if (nread != fsize) {
+			pr_err("failed to read firmware file, nread %ld Bytes\n", nread);
+			ret = -EIO;
+			goto read_err;
+		}
+
+		filp_close(fp, current->files);
+		set_fs(old_fs);
+		p9220_otp_update = 1;
+		PgmOTPwRAM(charger, 0 ,fw_img, 0, fsize);
+		p9220_otp_update = 0;
+
+		kfree(fw_img);
+		enable_irq(charger->pdata->irq_wpc_int);
+		enable_irq(charger->pdata->irq_wpc_det);
+		break;
+	case SEC_WIRELESS_RX_BUILT_IN_MODE:
+		dev_err(&charger->client->dev, "%s, Do not write OTP firmware \n", __func__);
+		return 0;
+#if 0
+		charger->pdata->otp_firmware_result = P9220_FW_RESULT_DOWNLOADING;
+		msleep(200);
+		disable_irq(charger->pdata->irq_wpc_int);
+		disable_irq(charger->pdata->irq_wpc_det);
+		dev_err(&charger->client->dev, "%s, request_firmware\n", __func__);
+		ret = request_firmware(&charger->firm_data_bin, P9220S_OTP_FW_HEX_PATH,
+			&charger->client->dev);
+		if ( ret < 0) {
+			dev_err(&charger->client->dev, "%s: failed to request firmware %s (%d) \n", __func__, P9220S_OTP_FW_HEX_PATH, ret);
+			charger->pdata->otp_firmware_result = P9220_FW_RESULT_FAIL;
+			return -EINVAL;
+		}
+		wake_lock(&charger->wpc_update_lock);
+		pr_info("%s data size = %ld \n", __func__, charger->firm_data_bin->size);
+		p9220_otp_update = 1;
+		ret = PgmOTPwRAM(charger, 0 ,charger->firm_data_bin->data, 0, charger->firm_data_bin->size);
+		p9220_otp_update = 0;
+		release_firmware(charger->firm_data_bin);
+
+		charger->pdata->otp_firmware_ver = p9220_get_firmware_version(charger, P9220_RX_FIRMWARE);
+		charger->pdata->wc_ic_grade = p9220_get_ic_grade(charger, P9220_IC_GRADE);
+		charger->pdata->wc_ic_rev = p9220_get_ic_grade(charger, P9220_IC_VERSION);
+
+		if(ret)
+			charger->pdata->otp_firmware_result = P9220_FW_RESULT_PASS;
+		else
+			charger->pdata->otp_firmware_result = P9220_FW_RESULT_FAIL;
+		enable_irq(charger->pdata->irq_wpc_int);
+		enable_irq(charger->pdata->irq_wpc_det);
+		wake_unlock(&charger->wpc_update_lock);
+#endif
+		break;
+	case SEC_WIRELESS_TX_ON_MODE:
+		charger->pdata->tx_firmware_result = P9220_FW_RESULT_DOWNLOADING;
+		msleep(200);
+		dev_err(&charger->client->dev, "%s, built in sram mode on \n", __func__);
+		ret = request_firmware(&charger->firm_data_bin, P9220S_SRAM_FW_HEX_PATH, &charger->client->dev);
+
+		if ( ret < 0) {
+			dev_err(&charger->client->dev, "%s: failed to request firmware %s (%d) \n", __func__,
+								P9220S_SRAM_FW_HEX_PATH, ret);
+			charger->pdata->tx_firmware_result = P9220_FW_RESULT_FAIL;
+			return -EINVAL;
+		}
+
+		wake_lock(&charger->wpc_update_lock);
+		pr_info("%s data size = %ld \n", __func__, charger->firm_data_bin->size);
+		ret = p9220_TxFW_SRAM(charger, charger->firm_data_bin->data, charger->firm_data_bin->size);
+		release_firmware(charger->firm_data_bin);
+
+		charger->pdata->tx_firmware_ver = p9220_get_firmware_version(charger, P9220_TX_FIRMWARE);
+
+		if(ret) {
+			charger->pdata->tx_firmware_result = P9220_FW_RESULT_PASS;
+			charger->pdata->tx_status = SEC_TX_STANDBY;
+		} else {
+			charger->pdata->tx_firmware_result = P9220_FW_RESULT_FAIL;
+			charger->pdata->tx_status = SEC_TX_ERROR;
+		}
+
+		charger->pdata->cable_type = P9220_PAD_MODE_TX;
+		wake_unlock(&charger->wpc_update_lock);
+		break;
+	case SEC_WIRELESS_TX_OFF_MODE:
+		charger->pdata->tx_firmware_result = P9220_FW_RESULT_DOWNLOADING;
+		charger->pdata->cable_type = P9220_PAD_MODE_NONE;
+		dev_err(&charger->client->dev, "%s, built in sram mode off \n", __func__);
+		charger->pdata->tx_status = SEC_TX_OFF;
+		break;
+	case SEC_WIRELESS_RX_INIT:
+		p9220_runtime_sram_preprocess(charger); /* get 0xBFBE value */
+		break;
+	default:
+		return -1;
+		break;
+	}
+
+	pr_info("%s --------------------------------------------------------------- \n", __func__);
+
+	return 0;
+
+read_err:
+	kfree(fw_img);
+malloc_error:
+	filp_close(fp, current->files);
+	set_fs(old_fs);
+	return ret;
+}
+
+static int p9220_chg_get_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		union power_supply_propval *val)
+{
+	struct p9220_charger_data *charger =
+		container_of(psy, struct p9220_charger_data, psy_chg);
+	enum power_supply_ext_property ext_psp = psp;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		pr_info("%s charger->pdata->cs100_status %d \n",__func__,charger->pdata->cs100_status);
+		val->intval = charger->pdata->cs100_status;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+	case POWER_SUPPLY_PROP_HEALTH:
+		return -ENODATA;
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX:	
+		if(charger->pdata->ic_on_mode || charger->pdata->is_charging)
+			val->intval = p9220_get_vout(charger);
+		else
+			val->intval = 0;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+	case POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL:
+	case POWER_SUPPLY_PROP_CHARGE_POWERED_OTG_CONTROL:
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+		return -ENODATA;
+	case POWER_SUPPLY_PROP_ONLINE:
+		pr_info("%s cable_type =%d \n ", __func__, charger->pdata->cable_type);
+		val->intval = charger->pdata->cable_type;
+		break;
+	case POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION:
+		val->intval = charger->pdata->vout_status;
+		break;
+	case POWER_SUPPLY_PROP_MANUFACTURER:
+		if (val->intval == SEC_WIRELESS_OTP_FIRM_RESULT) {
+			pr_info("%s otp firmware result = %d,\n",__func__, charger->pdata->otp_firmware_result);
+			val->intval = charger->pdata->otp_firmware_result;
+		} else if(val->intval == SEC_WIRELESS_IC_GRADE) {
+			val->intval = p9220_get_ic_grade(charger, P9220_IC_GRADE);
+		} else if(val->intval == SEC_WIRELESS_IC_REVISION) {
+			val->intval = p9220_get_ic_grade(charger, P9220_IC_VERSION);
+		} else if(val->intval == SEC_WIRELESS_OTP_FIRM_VER_BIN) {
+			val->intval = P9220_OTP_FIRM_VERSION;
+		} else if(val->intval == SEC_WIRELESS_OTP_FIRM_VER) {
+			val->intval = p9220_get_firmware_version(charger, P9220_RX_FIRMWARE);
+		} else if(val->intval == SEC_WIRELESS_TX_FIRM_RESULT) {
+			val->intval = charger->pdata->tx_firmware_result;
+		} else if (val->intval == SEC_WIRELESS_TX_FIRM_VER) {
+			val->intval = charger->pdata->tx_firmware_ver;
+		} else if(val->intval == SEC_TX_FIRMWARE) {
+			val->intval = charger->pdata->tx_status;
+		} else if(val->intval == SEC_WIRELESS_OTP_FIRM_VERIFY) {
+			val->intval = p9220_firmware_verify(charger);
+		} else{
+			val->intval = -1;
+			pr_err("%s wrong mode \n", __func__);
+		}
+		break;
+	case POWER_SUPPLY_PROP_ENERGY_NOW: /* vout */
+		if(charger->pdata->ic_on_mode || charger->pdata->is_charging) {
+			val->intval = p9220_get_adc(charger, P9220_ADC_VOUT);
+		} else
+			val->intval = 0;
+		break;
+	case POWER_SUPPLY_PROP_ENERGY_AVG: /* vrect */
+		if(charger->pdata->ic_on_mode || charger->pdata->is_charging) {
+			val->intval = p9220_get_adc(charger, P9220_ADC_VRECT);
+		} else
+			val->intval = 0;
+		break;
+	case POWER_SUPPLY_PROP_SCOPE:
+		val->intval = p9220_get_adc(charger, val->intval);
+		break;
+	case POWER_SUPPLY_PROP_MAX ... POWER_SUPPLY_EXT_PROP_MAX:
+		switch (ext_psp) {
+			case POWER_SUPPLY_EXT_PROP_WIRELESS_OP_FREQ:
+   				val->intval = p9220_get_adc(charger, P9220_ADC_OP_FRQ);
+				pr_info("%s: Operating FQ %dkHz\n", __func__, val->intval);
+   				break;
+			case POWER_SUPPLY_EXT_PROP_WIRELESS_TX_CMD:
+   				val->intval = charger->pdata->tx_data_cmd;
+   				break;
+			case POWER_SUPPLY_EXT_PROP_WIRELESS_TX_VAL:
+   				val->intval = charger->pdata->tx_data_cmd;
+   				break;
+  			default:
+				return -EINVAL;
+  		}
+  		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+#if defined(CONFIG_UPDATE_BATTERY_DATA)
+static int p9220_chg_parse_dt(struct device *dev, p9220_charger_platform_data_t *pdata);
+#endif
+static int p9220_chg_set_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		const union power_supply_propval *val)
+{
+	struct p9220_charger_data *charger =
+		container_of(psy, struct p9220_charger_data, psy_chg);
+	int vout, vrect, iout, freq, i = 0;
+	union power_supply_propval value;
+
+	switch (psp) {
+		case POWER_SUPPLY_PROP_STATUS:
+			if(val->intval == POWER_SUPPLY_STATUS_FULL) {
+				pr_info("%s set cs100 \n", __func__);
+				if (charger->pdata->cable_type == SEC_WIRELESS_PAD_WPC) {
+					/* set fake FOD values before send cs100 */
+					p9220_fod_set_cs100(charger);
+				}
+				charger->pdata->cs100_status = p9220_send_cs100(charger);
+			} else if(val->intval == POWER_SUPPLY_STATUS_NOT_CHARGING) {
+				p9220_mis_align(charger);
+			} else if(val->intval == POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE) {
+				p9220_fod_set_cv(charger);
+			}
+			break;
+		case POWER_SUPPLY_PROP_CHARGE_TYPE:
+			value.intval = charger->pdata->cable_type;
+			psy_do_property("wireless", set, POWER_SUPPLY_PROP_ONLINE, value);
+			break;
+		case POWER_SUPPLY_PROP_HEALTH:
+			if(val->intval == POWER_SUPPLY_HEALTH_OVERHEAT ||
+				val->intval == POWER_SUPPLY_HEALTH_OVERHEATLIMIT ||
+				val->intval == POWER_SUPPLY_HEALTH_COLD) {
+				pr_info("%s ept-ot \n", __func__);
+				p9220_send_eop(charger, val->intval);
+			}
+			break;
+		case POWER_SUPPLY_PROP_ONLINE:
+			if(val->intval == POWER_SUPPLY_TYPE_WIRELESS ||
+				val->intval == POWER_SUPPLY_TYPE_HV_WIRELESS ||
+				val->intval == POWER_SUPPLY_TYPE_PMA_WIRELESS ) {
+				charger->pdata->ic_on_mode = true;
+			} else {
+				charger->pdata->ic_on_mode = false;
+			}
+			break;
+		case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+			charger->pdata->siop_level = val->intval;
+			if(charger->pdata->siop_level == 100) {
+				pr_info("%s vrect headroom set ROOM 2, siop = %d \n", __func__, charger->pdata->siop_level);
+				p9220_set_vrect_adjust(charger, P9220_HEADROOM_2);
+			} else if(charger->pdata->siop_level < 100) {
+				pr_info("%s vrect headroom set ROOM 0, siop = %d \n", __func__, charger->pdata->siop_level);
+				p9220_set_vrect_adjust(charger, P9220_HEADROOM_0);
+			}
+			break;
+		case POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL:
+			if(val->intval) {
+				charger->pdata->ic_on_mode = true;
+			} else {
+				charger->pdata->ic_on_mode = false;
+			}
+			break;
+		case POWER_SUPPLY_PROP_CHARGE_POWERED_OTG_CONTROL:
+			p9220_firmware_update(charger, val->intval);
+			pr_info("%s rx result = %d, tx result = %d \n",__func__,
+					charger->pdata->otp_firmware_result,charger->pdata->tx_firmware_result);
+			break;
+		case POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION:
+			if (val->intval == WIRELESS_VOUT_NORMAL_VOLTAGE) {
+				pr_info("%s: Wireless Vout forced set to 5V. + PAD CMD\n",__func__);
+				for(i = 0; i < CMD_CNT; i++) {
+					p9220_send_command(charger, P9220_AFC_CONF_5V);
+					msleep(250);
+				}
+			} else if (val->intval == WIRELESS_VOUT_HIGH_VOLTAGE) {
+				pr_info("%s: Wireless Vout forced set to 9V. + PAD CMD\n",__func__);
+				for(i = 0; i < CMD_CNT; i++) {
+					p9220_send_command(charger, P9220_AFC_CONF_9V);
+					msleep(250);
+				}
+			} else if (val->intval == WIRELESS_VOUT_CC_CV_VOUT) {
+				p9220_set_vout(charger, P9220_VOUT_CC_CV);
+				pr_info("%s: Wireless Vout forced set to %dmV\n",
+								__func__, charger->pdata->wpc_cc_cv_vout);
+			} else if (val->intval == WIRELESS_VOUT_CV_CALL) {
+				p9220_set_vrect_adjust(charger, P9220_HEADROOM_3);
+				msleep(500);
+				p9220_set_vout(charger, P9220_VOUT_CV_CALL);
+				msleep(500);
+				p9220_set_vrect_adjust(charger, P9220_HEADROOM_0);
+				pr_info("%s: Wireless Vout forced set to %dmV\n",
+								__func__, charger->pdata->wpc_cv_call_vout);
+			} else if (val->intval == WIRELESS_VOUT_CC_CALL) {
+				p9220_set_vrect_adjust(charger, P9220_HEADROOM_3);
+				msleep(500);
+				p9220_set_vout(charger, P9220_VOUT_CC_CALL);
+				msleep(500);
+				p9220_set_vrect_adjust(charger, P9220_HEADROOM_0);
+				pr_info("%s: Wireless Vout forced set to %dmV\n",
+								__func__, charger->pdata->wpc_cc_call_vout);
+			} else if (val->intval == WIRELESS_VOUT_5V) {
+				p9220_set_vout(charger, P9220_VOUT_5V);
+				pr_info("%s: Wireless Vout forced set to 5V\n", __func__);
+			} else if (val->intval == WIRELESS_VOUT_9V) {
+				p9220_set_vout(charger, P9220_VOUT_9V);
+				pr_info("%s: Wireless Vout forced set to 9V\n", __func__);
+			} else if (val->intval == WIRELESS_VOUT_9V_OTG) {
+				p9220_set_vout(charger, P9220_VOUT_9V);
+				pr_info("%s: Wireless Vout forced set to 9V OTG\n", __func__);
+			} else if (val->intval == WIRELESS_PAD_FAN_OFF) {
+				pr_info("%s: fan off \n",__func__);
+				p9220_fan_control(charger, 0);
+			} else if (val->intval == WIRELESS_PAD_FAN_ON) {
+				pr_info("%s: fan on \n",__func__);
+				p9220_fan_control(charger, 1);
+			} else if (val->intval == WIRELESS_PAD_LED_OFF) {
+				pr_info("%s: led off \n",__func__);
+				p9220_led_control(charger, 0);
+			} else if (val->intval == WIRELESS_PAD_LED_ON) {
+				pr_info("%s: led on \n",__func__);
+				p9220_led_control(charger, 1);
+			} else if(val->intval == WIRELESS_VRECT_ADJ_ON) {
+				pr_info("%s: vrect adjust to have big headroom(defualt value) \n",__func__);
+				p9220_set_vrect_adjust(charger, P9220_HEADROOM_1);
+			} else if(val->intval == WIRELESS_VRECT_ADJ_OFF) {
+				pr_info("%s: vrect adjust to have small headroom \n",__func__);
+				p9220_set_vrect_adjust(charger, P9220_HEADROOM_0);
+			} else if(val->intval == WIRELESS_VRECT_ADJ_ROOM_0) {
+				pr_info("%s: vrect adjust to have headroom 0(0mV) \n",__func__);
+				p9220_set_vrect_adjust(charger, P9220_HEADROOM_0);
+			} else if(val->intval == WIRELESS_VRECT_ADJ_ROOM_1) {
+				pr_info("%s: vrect adjust to have headroom 1(277mV) \n",__func__);
+				p9220_set_vrect_adjust(charger, P9220_HEADROOM_1);
+			} else if(val->intval == WIRELESS_VRECT_ADJ_ROOM_2) {
+				pr_info("%s: vrect adjust to have headroom 2(497mV) \n",__func__);
+				p9220_set_vrect_adjust(charger, P9220_HEADROOM_2);
+			} else if(val->intval == WIRELESS_VRECT_ADJ_ROOM_3) {
+				pr_info("%s: vrect adjust to have headroom 3(650mV) \n",__func__);
+				p9220_set_vrect_adjust(charger, P9220_HEADROOM_3);
+			} else if(val->intval == WIRELESS_VRECT_ADJ_ROOM_4) {
+				pr_info("%s: vrect adjust to have headroom 4(30mV) \n",__func__);
+				p9220_set_vrect_adjust(charger, P9220_HEADROOM_4);
+			} else if(val->intval == WIRELESS_VRECT_ADJ_ROOM_5) {
+				pr_info("%s: vrect adjust to have headroom 5(82mV) \n",__func__);
+				p9220_set_vrect_adjust(charger, P9220_HEADROOM_5);
+			} else if (val->intval == WIRELESS_CLAMP_ENABLE) {
+				pr_info("%s: enable clamp1, clamp2 for WPC modulation \n",__func__);
+				p9220_reg_update(charger->client, P9220_MOD_DEPTH_REG, 0x30, 0x30);
+			} else {
+				pr_info("%s: Unknown Command(%d)\n",__func__, val->intval);
+			}
+			break;
+		case POWER_SUPPLY_PROP_MANUFACTURER:
+			charger->pdata->otp_firmware_result = val->intval;
+			pr_info("%s otp_firmware result initialize (%d)\n",__func__,
+					charger->pdata->otp_firmware_result);
+			break;
+#if defined(CONFIG_UPDATE_BATTERY_DATA)
+		case POWER_SUPPLY_PROP_POWER_DESIGN:
+			p9220_chg_parse_dt(charger->dev, charger->pdata);
+			break;
+#endif
+		case POWER_SUPPLY_PROP_ENERGY_NOW:
+			vout = p9220_get_adc(charger, P9220_ADC_VOUT);
+			vrect = p9220_get_adc(charger, P9220_ADC_VRECT);
+			iout = p9220_get_adc(charger, P9220_ADC_RX_IOUT);
+			freq = p9220_get_adc(charger, P9220_ADC_OP_FRQ);
+			pr_info("%s RX_VOUT = %dmV, RX_VRECT = %dmV, RX_IOUT = %dmA, OP_FREQ = %dKHz\n", __func__, vout, vrect, iout, freq);
+			break;
+		case POWER_SUPPLY_PROP_SCOPE:
+			return -EINVAL;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void p9220_wpc_opfq_work(struct work_struct *work)
+{
+	struct p9220_charger_data *charger =
+		container_of(work, struct p9220_charger_data, wpc_opfq_work.work);
+
+	u16 op_fq;
+	u8 pad_mode;
+	union power_supply_propval value;
+
+	p9220_reg_read(charger->client, P9220_SYS_OP_MODE_REG, &pad_mode);
+	if (pad_mode & P9220_PAD_MODE_WPC) {
+			op_fq = p9220_get_adc(charger, P9220_ADC_OP_FRQ);
+			pr_info("%s: Operating FQ %dkHz(0x%x)\n", __func__, op_fq, op_fq);
+			if (op_fq > 230) { /* wpc threshold 230kHz */
+				pr_info("%s: Reset M0\n",__func__);
+				p9220_reg_write(charger->client, 0x3040, 0x80); /*restart M0 */
+
+				charger->pdata->opfq_cnt++;
+				if (charger->pdata->opfq_cnt <= CMD_CNT) {
+					queue_delayed_work(charger->wqueue, &charger->wpc_opfq_work, msecs_to_jiffies(10000));
+					return;
+				}
+			}
+	} else if (pad_mode & P9220_PAD_MODE_PMA) {
+			charger->pdata->cable_type = P9220_PAD_MODE_PMA;
+			value.intval = SEC_WIRELESS_PAD_PMA;
+			psy_do_property("wireless", set, POWER_SUPPLY_PROP_ONLINE, value);
+	}
+	charger->pdata->opfq_cnt = 0;
+	wake_unlock(&charger->wpc_opfq_lock);
+
+}
+
+static void p9220_wpc_det_work(struct work_struct *work)
+{
+	struct p9220_charger_data *charger =
+		container_of(work, struct p9220_charger_data, wpc_det_work.work);
+	int wc_w_state;
+	union power_supply_propval value;
+	u8 pad_mode;
+	u8 vrect;
+
+	wake_lock(&charger->wpc_wake_lock);
+	pr_info("%s start.\n",__func__);
+	wc_w_state = gpio_get_value(charger->pdata->wpc_det);
+
+	if ((charger->wc_w_state == 0) && (wc_w_state == 1)) {
+		charger->pdata->vout_status = P9220_VOUT_5V;
+
+		/* read firmware version */
+		if(p9220_get_firmware_version(charger, P9220_RX_FIRMWARE) == P9220_OTP_FIRM_VERSION && adc_cal > 0)
+			p9220_runtime_sram_change(charger);/* change sram */
+
+		/* set fod value */
+		if(charger->pdata->fod_data_check)
+			p9220_fod_set(charger);
+
+		/* enable Mode Change INT */
+		p9220_reg_update(charger->client, P9220_INT_ENABLE_L_REG,
+						P9220_STAT_MODE_CHANGE_MASK, P9220_STAT_MODE_CHANGE_MASK);
+
+		/* read vrect adjust */
+		p9220_reg_read(charger->client, P9220_VRECT_SET_REG, &vrect);
+
+		pr_info("%s: wpc activated, set V_INT as PN\n",__func__);
+
+		/* read pad mode */
+		p9220_reg_read(charger->client, P9220_SYS_OP_MODE_REG, &pad_mode);
+		if(pad_mode & P9220_SYS_MODE_PMA) {
+			charger->pdata->cable_type = P9220_PAD_MODE_PMA;
+			value.intval = SEC_WIRELESS_PAD_PMA;
+			psy_do_property("wireless", set,
+					POWER_SUPPLY_PROP_ONLINE, value);
+		} else {
+			charger->pdata->cable_type = P9220_PAD_MODE_WPC;
+			value.intval = SEC_WIRELESS_PAD_WPC;
+			psy_do_property("wireless", set,
+					POWER_SUPPLY_PROP_ONLINE, value);
+			wake_lock(&charger->wpc_opfq_lock);
+			queue_delayed_work(charger->wqueue, &charger->wpc_opfq_work, msecs_to_jiffies(10000));
+		}
+
+		/* set request afc_tx */
+		p9220_send_command(charger, P9220_REQUEST_AFC_TX);
+#if 0
+		/* set request TX_ID */
+		p9220_send_command(charger, P9220_REQUEST_TX_ID);
+#endif
+
+		charger->pdata->is_charging = 1;
+	} else if ((charger->wc_w_state == 1) && (wc_w_state == 0)) {
+
+		charger->pdata->cable_type = P9220_PAD_MODE_NONE;
+		charger->pdata->is_charging = 0;
+		charger->pdata->vout_status = P9220_VOUT_0V;
+		charger->pdata->opfq_cnt = 0;
+		charger->pdata->tx_data_cmd = 0;
+		charger->pdata->tx_data_val = 0;
+
+		value.intval = SEC_WIRELESS_PAD_NONE;
+		psy_do_property("wireless", set,
+				POWER_SUPPLY_PROP_ONLINE, value);
+		pr_info("%s: wpc deactivated, set V_INT as PD\n",__func__);
+
+		msleep(1000);
+		/* if vrect >= 3000mV and vout <= 2000mV, restart M0 */ 
+		if (p9220_get_adc(charger, P9220_ADC_VRECT) >= 3000 && 
+			p9220_get_adc(charger, P9220_ADC_VOUT) <= 2000) {
+			pr_err("%s Restart M0\n", __func__);
+			p9220_reg_write(charger->client, 0x3040, 0x80); /*restart M0 */
+		}
+
+		if(delayed_work_pending(&charger->wpc_opfq_work)) {
+			wake_unlock(&charger->wpc_opfq_lock);
+			cancel_delayed_work(&charger->wpc_opfq_work);
+		}
+
+		cancel_delayed_work(&charger->wpc_isr_work);
+		cancel_delayed_work(&charger->wpc_opfq_work);
+		cancel_delayed_work(&charger->wpc_tx_id_work);
+	}
+
+	pr_info("%s: w(%d to %d)\n", __func__,
+		charger->wc_w_state, wc_w_state);
+
+	charger->wc_w_state = wc_w_state;
+	wake_unlock(&charger->wpc_wake_lock);
+}
+
+static void p9220_wpc_isr_work(struct work_struct *work)
+{
+	struct p9220_charger_data *charger =
+		container_of(work, struct p9220_charger_data, wpc_isr_work.work);
+
+	u8 cmd_data, val_data;
+	int vout = 0;
+	union power_supply_propval value;
+
+	if (!charger->wc_w_state) {
+		pr_info("%s: charger->wc_w_state is 0. exit wpc_isr_work.\n",__func__);
+		return;
+	}
+
+	wake_lock(&charger->wpc_wake_lock);
+	pr_info("%s start.\n",__func__);
+
+	p9220_reg_read(charger->client, P9220_TX_DATA_COMMAND, &cmd_data);
+	p9220_reg_read(charger->client, P9220_TX_DATA_VALUE0, &val_data);
+	charger->pdata->tx_data_cmd = cmd_data;
+	charger->pdata->tx_data_val = val_data;
+
+	pr_info("%s: WPC Interrupt Occured, CMD : 0x%x, DATA : 0x%x\n",
+		__func__, cmd_data, val_data);
+
+	if (cmd_data == P9220_TX_DATA_COM_AFC_TX) {
+		switch (val_data) {
+		case 0x00:
+			charger->pad_vout = PAD_VOUT_5V;
+			break;
+		case 0x01:
+			pr_info("%s: AFC wireless charger\n", __func__);
+			if (!gpio_get_value(charger->pdata->wpc_det)) {
+				pr_err("%s Wireless charging is paused during set high voltage. \n", __func__);
+				wake_unlock(&charger->wpc_wake_lock);
+				return;
+			}
+			if (charger->pdata->cable_type == P9220_PAD_MODE_WPC_AFC ||
+				charger->pdata->cable_type == P9220_PAD_MODE_WPC_STAND_HV) {
+				pr_err("%s: Is is already HV wireless cable. No need to set again \n", __func__);
+				wake_unlock(&charger->wpc_wake_lock);
+				return;
+			}
+			/* send AFC_SET */
+			p9220_send_command(charger, P9220_AFC_CONF_9V);
+			msleep(500);
+
+			/* change cable type */
+			charger->pdata->cable_type = P9220_PAD_MODE_WPC_AFC;
+			value.intval = SEC_WIRELESS_PAD_WPC_HV;
+			psy_do_property("wireless", set,
+				POWER_SUPPLY_PROP_ONLINE, value);
+
+			/* read vout */
+			vout = p9220_get_adc(charger, P9220_ADC_VOUT);
+			pr_info("%s read vout should be 9V -> (%dmV) \n", __func__, vout);
+
+			if(sleep_mode) {
+				pr_info("%s sleep mode, turn on fan \n", __func__);
+				p9220_fan_control(charger, true);
+				msleep(250);
+
+				pr_info("%s sleep mode, turn off fan \n", __func__);
+				p9220_fan_control(charger, false);
+				msleep(250);
+			}
+			charger->pad_vout = PAD_VOUT_10V;
+			break;
+		case 0x02:
+		case 0x03:
+		case 0x04:
+		case 0x05:
+		case 0x06:
+			break;
+		case 0x11:
+			pr_info("%s: VEHICLE PAD\n", __func__);
+			charger->pdata->cable_type = P9220_PAD_MODE_WPC_VEHICLE;
+			value.intval = SEC_WIRELESS_PAD_VEHICLE;
+			psy_do_property("wireless", set, POWER_SUPPLY_PROP_ONLINE, value);			
+		case 0x40:
+			pr_info("%s: WIRELESS BATTERY PACK\n", __func__);
+			charger->pdata->cable_type = P9220_PAD_MODE_WPC_PACK;
+			value.intval = SEC_WIRELESS_PAD_WPC_PACK;
+			psy_do_property("wireless", set, POWER_SUPPLY_PROP_ONLINE, value);
+			break;
+		case 0x41:
+			pr_info("%s: WIRELESS BATTERY PACK with TA\n", __func__);
+			charger->pdata->cable_type = P9220_PAD_MODE_WPC_PACK_TA;
+			value.intval = SEC_WIRELESS_PAD_WPC_PACK_TA;
+			psy_do_property("wireless", set, POWER_SUPPLY_PROP_ONLINE, value);
+			break;
+		default:
+			pr_info("%s: unsupport : 0x%x", __func__, val_data);
+		}
+
+		queue_delayed_work(charger->wqueue, &charger->wpc_tx_id_work, msecs_to_jiffies(1000));
+	} else if (cmd_data == P9220_TX_DATA_COM_TX_ID) {
+		switch (val_data) {
+		case 0x00:
+			break;
+		case 0x30:
+			if (charger->pad_vout == PAD_VOUT_10V) {
+				charger->pdata->cable_type = P9220_PAD_MODE_WPC_STAND_HV;
+				value.intval = SEC_WIRELESS_PAD_WPC_STAND_HV;
+			} else {
+				charger->pdata->cable_type = P9220_PAD_MODE_WPC_STAND;
+				value.intval = SEC_WIRELESS_PAD_WPC_STAND;
+			}
+			pr_info("%s: STAND Wireless Charge PAD %s\n", __func__,
+				charger->pad_vout == PAD_VOUT_10V ? "HV" : "");
+			break;
+		case 0x40:
+			charger->pdata->cable_type = P9220_PAD_MODE_WPC_PACK;
+			value.intval = SEC_WIRELESS_PAD_WPC_PACK;
+			pr_info("%s: WIRELESS BATTERY PACK\n", __func__);
+			break;
+		case 0x41:
+			charger->pdata->cable_type = P9220_PAD_MODE_WPC_PACK_TA;
+			value.intval = SEC_WIRELESS_PAD_WPC_PACK_TA;
+			pr_info("%s: WIRELESS BATTERY PACK with TA\n", __func__);
+			break;
+		default:
+			value.intval = charger->pdata->cable_type;
+			pr_info("%s: UNDEFINED PAD\n", __func__);
+		}
+
+		psy_do_property("wireless", set, POWER_SUPPLY_PROP_ONLINE, value);
+	}
+
+	wake_unlock(&charger->wpc_wake_lock);
+}
+
+static void p9220_wpc_tx_id_work(struct work_struct *work)
+{
+	struct p9220_charger_data *charger =
+		container_of(work, struct p9220_charger_data, wpc_tx_id_work.work);
+
+	pr_info("%s\n",__func__);
+	
+	p9220_send_command(charger, P9220_REQUEST_TX_ID);
+}
+
+static irqreturn_t p9220_wpc_det_irq_thread(int irq, void *irq_data)
+{
+	struct p9220_charger_data *charger = irq_data;
+
+	pr_info("%s !\n",__func__);
+
+	queue_delayed_work(charger->wqueue, &charger->wpc_det_work, 0);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t p9220_wpc_irq_thread(int irq, void *irq_data)
+{
+	struct p9220_charger_data *charger = irq_data;
+	int wc_w_state_irq;
+	int ret;
+	u8 irq_src[2];
+	u8 reg_data;
+
+	pr_info("%s start.\n",__func__);
+	wake_lock(&charger->wpc_wake_lock);
+
+	ret = p9220_reg_read(charger->client, P9220_INT_L_REG, &irq_src[0]);
+	ret = p9220_reg_read(charger->client, P9220_INT_H_REG, &irq_src[1]);
+
+	wc_w_state_irq = gpio_get_value(charger->pdata->wpc_int);
+	pr_info("%s wc_w_state_irq = %d\n", __func__, wc_w_state_irq);
+
+	if (ret < 0) {
+		pr_err("%s: Failed to read interrupt source: %d\n",
+			__func__, ret);
+		wake_unlock(&charger->wpc_wake_lock);
+		return IRQ_NONE;
+	}
+
+	pr_info("%s: interrupt source(0x%x)\n", __func__, irq_src[1] << 8 | irq_src[0]);
+	p9220_get_firmware_version(charger, P9220_RX_FIRMWARE);
+
+	if(irq_src[0] & P9220_STAT_MODE_CHANGE_MASK) {
+		pr_info("%s MODE CHANGE IRQ ! \n", __func__);
+		ret = p9220_reg_read(charger->client, P9220_SYS_OP_MODE_REG, &reg_data);
+	}
+
+	if(irq_src[0] & P9220_STAT_TX_DATA_RECEIVED_MASK) {
+		pr_info("%s TX RECEIVED IRQ ! \n", __func__);
+		if(charger->pdata->cable_type == P9220_PAD_MODE_WPC_STAND ||
+			charger->pdata->cable_type == P9220_PAD_MODE_WPC_STAND_HV)
+			pr_info("%s Don't run ISR_WORK for NO ACK ! \n", __func__);
+		else if(!delayed_work_pending(&charger->wpc_isr_work))
+			queue_delayed_work(charger->wqueue, &charger->wpc_isr_work, msecs_to_jiffies(1000));
+	}
+
+	if(irq_src[1] & P9220_STAT_OVER_CURR_MASK) {
+		pr_info("%s OVER CURRENT IRQ ! \n", __func__);
+	}
+
+	if(irq_src[1] & P9220_STAT_OVER_TEMP_MASK) {
+		pr_info("%s OVER TEMP IRQ ! \n", __func__);
+	}
+
+	if(irq_src[1] & P9220_STAT_TX_CONNECT_MASK) {
+		pr_info("%s TX CONNECT IRQ ! \n", __func__);
+		charger->pdata->tx_status = SEC_TX_POWER_TRANSFER;
+	}
+
+	msleep(5);
+
+	/* clear intterupt */
+	p9220_reg_write(charger->client, P9220_INT_CLEAR_L_REG, irq_src[0]); // clear int
+	p9220_reg_write(charger->client, P9220_INT_CLEAR_H_REG, irq_src[1]); // clear int
+	p9220_set_cmd_reg(charger, 0x20, P9220_CMD_CLEAR_INT_MASK); // command
+
+	/* debug */
+	ret = p9220_reg_read(charger->client, P9220_INT_L_REG, &irq_src[0]);
+	ret = p9220_reg_read(charger->client, P9220_INT_H_REG, &irq_src[1]);
+	wc_w_state_irq = gpio_get_value(charger->pdata->wpc_int);
+	pr_info("%s end. wc_w_state_irq = %d\n", __func__, wc_w_state_irq);
+	wake_unlock(&charger->wpc_wake_lock);
+
+	return IRQ_HANDLED;
+}
+
+static int p9220_chg_parse_dt(struct device *dev,
+		p9220_charger_platform_data_t *pdata)
+{
+	int ret = 0;
+	struct device_node *np  = dev->of_node;
+	enum of_gpio_flags irq_gpio_flags;
+	int len,i;
+	const u32 *p;
+
+	np  = of_find_node_by_name(NULL, "battery");
+	if (!np) {
+		pr_err("%s np NULL\n", __func__);
+		return 1;
+	} else {
+		p = of_get_property(np, "battery,fod_data", &len);
+		if (p) {
+			len = len / sizeof(u32);
+			pdata->fod_data = kzalloc(sizeof(*pdata->fod_data) * len, GFP_KERNEL);
+			ret = of_property_read_u32_array(np, "battery,fod_data",
+							 pdata->fod_data, len);
+			pdata->fod_data_check = 1;
+
+			for(i = 0; i <len; i++)
+				pr_info("%s fod data = %d ",__func__,pdata->fod_data[i]);
+		} else {
+			pdata->fod_data_check = 0;
+			pr_err("%s there is not fod_data\n", __func__);
+		}
+		p = of_get_property(np, "battery,fod_data_cv", &len);
+		if (p) {
+			len = len / sizeof(u32);
+			pdata->fod_data_cv = kzalloc(sizeof(*pdata->fod_data_cv) * len, GFP_KERNEL);
+			ret = of_property_read_u32_array(np, "battery,fod_data_cv",
+							 pdata->fod_data_cv, len);
+			pdata->fod_data_check = 1;
+
+			for(i = 0; i <len; i++)
+				pr_info("%s fod data_cv = %d ",__func__,pdata->fod_data_cv[i]);
+		} else {
+			pdata->fod_data_check = 0;
+			pr_err("%s there is not fod_data_cv\n", __func__);
+		}
+
+		ret = of_property_read_string(np,
+			"battery,wireless_charger_name", (char const **)&pdata->wireless_charger_name);
+		if (ret < 0)
+			pr_info("%s: Wireless Charger name is Empty\n", __func__);
+
+		ret = of_property_read_string(np,
+			"battery,charger_name", (char const **)&pdata->wired_charger_name);
+		if (ret < 0)
+			pr_info("%s: Charger name is Empty\n", __func__);
+
+		ret = of_property_read_u32(np, "battery,wpc_cc_cv_vout",
+						&pdata->wpc_cc_cv_vout);
+		if (ret < 0)
+			pr_info("%s: wpc_cv_call_vout is Empty \n", __func__);
+		
+		ret = of_property_read_u32(np, "battery,wpc_cv_call_vout",
+						&pdata->wpc_cv_call_vout);
+		if (ret < 0)
+			pr_info("%s: wpc_cv_call_vout is Empty \n", __func__);
+
+		ret = of_property_read_u32(np, "battery,wpc_cc_call_vout",
+						&pdata->wpc_cc_call_vout);
+		if (ret < 0)
+			pr_info("%s: wpc_cc_call_vout is Empty \n", __func__);
+
+		ret = of_property_read_u32(np, "battery,hv_vout_wa",
+						&pdata->hv_vout_wa);
+		if (ret < 0) {
+			pr_info("%s: no need hv_vout_wa. \n", __func__);
+			pdata->hv_vout_wa = 0;
+		}
+
+		/* wpc_det */
+		ret = pdata->wpc_det = of_get_named_gpio_flags(np, "battery,wpc_det",
+				0, &irq_gpio_flags);
+		if (ret < 0) {
+			dev_err(dev, "%s : can't get wpc_det\r\n", __FUNCTION__);
+		} else {
+			pdata->irq_wpc_det = gpio_to_irq(pdata->wpc_det);
+			pr_info("%s wpc_det = 0x%x, irq_wpc_det = 0x%x \n",__func__, pdata->wpc_det, pdata->irq_wpc_det);
+		}
+		/* wpc_int */
+		ret = pdata->wpc_int = of_get_named_gpio_flags(np, "battery,wpc_int",
+				0, &irq_gpio_flags);
+		if (ret < 0) {
+			dev_err(dev, "%s : can't wpc_int\r\n", __FUNCTION__);
+		} else {
+			pdata->irq_wpc_int = gpio_to_irq(pdata->wpc_int);
+			pr_info("%s wpc_int = 0x%x, irq_wpc_int = 0x%x \n",__func__, pdata->wpc_int, pdata->irq_wpc_int);
+		}
+		return ret;
+	}
+}
+
+static ssize_t p9220_store_addr(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct p9220_charger_data *charger = container_of(psy, struct p9220_charger_data, psy_chg);
+	int x;
+	if (sscanf(buf, "0x%x\n", &x) == 1) {
+		charger->addr = x;
+	}
+	return count;
+}
+
+static ssize_t p9220_show_addr(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct p9220_charger_data *charger = container_of(psy, struct p9220_charger_data, psy_chg);
+	return sprintf(buf, "0x%x\n", charger->addr);
+}
+
+static ssize_t p9220_store_size(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct p9220_charger_data *charger = container_of(psy, struct p9220_charger_data, psy_chg);
+	int x;
+	if (sscanf(buf, "%d\n", &x) == 1) {
+		charger->size = x;
+	}
+	return count;
+}
+
+static ssize_t p9220_show_size(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct p9220_charger_data *charger = container_of(psy, struct p9220_charger_data, psy_chg);
+	return sprintf(buf, "0x%x\n", charger->size);
+}
+static ssize_t p9220_store_data(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct p9220_charger_data *charger = container_of(psy, struct p9220_charger_data, psy_chg);
+	int x;
+
+	if (sscanf(buf, "0x%x", &x) == 1) {
+		u8 data = x;
+		if (p9220_reg_write(charger->client, charger->addr, data) < 0)
+		{
+			dev_info(charger->dev,
+					"%s: addr: 0x%x write fail\n", __func__, charger->addr);
+		}
+	}
+	return count;
+}
+
+static ssize_t p9220_show_data(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct p9220_charger_data *charger = container_of(psy, struct p9220_charger_data, psy_chg);
+	u8 data;
+	int i, count = 0;;
+	if (charger->size == 0)
+		charger->size = 1;
+
+	for (i = 0; i < charger->size; i++) {
+		if (p9220_reg_read(charger->client, charger->addr+i, &data) < 0) {
+			dev_info(charger->dev,
+					"%s: read fail\n", __func__);
+			count += sprintf(buf+count, "addr: 0x%x read fail\n", charger->addr+i);
+			continue;
+		}
+		count += sprintf(buf+count, "addr: 0x%x, data: 0x%x\n", charger->addr+i,data);
+	}
+	return count;
+}
+
+static DEVICE_ATTR(addr, 0644, p9220_show_addr, p9220_store_addr);
+static DEVICE_ATTR(size, 0644, p9220_show_size, p9220_store_size);
+static DEVICE_ATTR(data, 0644, p9220_show_data, p9220_store_data);
+
+static struct attribute *p9220_attributes[] = {
+	&dev_attr_addr.attr,
+	&dev_attr_size.attr,
+	&dev_attr_data.attr,
+	NULL
+};
+
+static const struct attribute_group p9220_attr_group = {
+	.attrs = p9220_attributes,
+};
+
+
+static int p9220_charger_probe(
+						struct i2c_client *client,
+						const struct i2c_device_id *id)
+{
+	struct device_node *of_node = client->dev.of_node;
+	struct p9220_charger_data *charger;
+	p9220_charger_platform_data_t *pdata = client->dev.platform_data;
+	int ret = 0;
+	int wc_w_state_irq;
+
+	dev_info(&client->dev,
+		"%s: p9220 Charger Driver Loading\n", __func__);
+
+	if (of_node) {
+		pdata = devm_kzalloc(&client->dev, sizeof(*pdata), GFP_KERNEL);
+		if (!pdata) {
+			dev_err(&client->dev, "Failed to allocate memory\n");
+			return -ENOMEM;
+		}
+		ret = p9220_chg_parse_dt(&client->dev, pdata);
+		if (ret < 0)
+			goto err_parse_dt;
+	} else {
+		pdata = client->dev.platform_data;
+	}
+
+	charger = kzalloc(sizeof(*charger), GFP_KERNEL);
+	if (charger == NULL) {
+		dev_err(&client->dev, "Memory is not enough.\n");
+		ret = -ENOMEM;
+		goto err_wpc_nomem;
+	}
+	charger->dev = &client->dev;
+
+	ret = i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA |
+		I2C_FUNC_SMBUS_WORD_DATA | I2C_FUNC_SMBUS_I2C_BLOCK);
+	if (!ret) {
+		ret = i2c_get_functionality(client->adapter);
+		dev_err(charger->dev, "I2C functionality is not supported.\n");
+		ret = -ENOSYS;
+		goto err_i2cfunc_not_support;
+	}
+
+	charger->client = client;
+	charger->pdata = pdata;
+
+    pr_info("%s: %s\n", __func__, charger->pdata->wireless_charger_name );
+
+	i2c_set_clientdata(client, charger);
+
+	charger->pdata->ic_on_mode = false;
+	charger->pdata->cable_type = P9220_PAD_MODE_NONE;
+	charger->pdata->is_charging = 0;
+
+	charger->pdata->otp_firmware_result = P9220_FW_RESULT_DOWNLOADING;
+	charger->pdata->tx_firmware_result = P9220_FW_RESULT_DOWNLOADING;
+	charger->pdata->tx_status = 0;
+	charger->pdata->cs100_status = 0;
+	charger->pdata->vout_status = P9220_VOUT_0V;
+	charger->pdata->opfq_cnt = 0;
+	charger->pdata->tx_data_cmd = 0;
+	charger->pdata->tx_data_val = 0;
+
+	charger->psy_chg.name		= pdata->wireless_charger_name;
+	charger->psy_chg.type		= POWER_SUPPLY_TYPE_UNKNOWN;
+	charger->psy_chg.get_property	= p9220_chg_get_property;
+	charger->psy_chg.set_property	= p9220_chg_set_property;
+	charger->psy_chg.properties	= sec_charger_props;
+	charger->psy_chg.num_properties	= ARRAY_SIZE(sec_charger_props);
+
+	mutex_init(&charger->io_lock);
+
+	/* wpc_det */
+	if (charger->pdata->irq_wpc_det) {
+		INIT_DELAYED_WORK(&charger->wpc_det_work, p9220_wpc_det_work);
+		INIT_DELAYED_WORK(&charger->wpc_opfq_work, p9220_wpc_opfq_work);
+	}
+
+	/* wpc_irq */
+	if (charger->pdata->irq_wpc_int) {
+		INIT_DELAYED_WORK(&charger->wpc_isr_work, p9220_wpc_isr_work);	
+		INIT_DELAYED_WORK(&charger->wpc_tx_id_work, p9220_wpc_tx_id_work);	
+	}
+
+	ret = power_supply_register(&client->dev, &charger->psy_chg);
+	if (ret) {
+		dev_err(&client->dev,
+			"%s: Failed to Register psy_chg\n", __func__);
+		goto err_supply_unreg;
+	}
+
+	charger->wqueue = create_singlethread_workqueue("p9220_workqueue");
+	if (!charger->wqueue) {
+		pr_err("%s: Fail to Create Workqueue\n", __func__);
+		goto err_pdata_free;
+	}
+
+	wake_lock_init(&charger->wpc_wake_lock, WAKE_LOCK_SUSPEND,
+			"wpc_wakelock");
+	wake_lock_init(&charger->wpc_update_lock, WAKE_LOCK_SUSPEND,
+			"wpc_update_lock");
+	wake_lock_init(&charger->wpc_opfq_lock, WAKE_LOCK_SUSPEND,
+			"wpc_opfq_lock");
+
+	/* Enable interrupts after battery driver load */
+	/* wpc_det */
+	if (charger->pdata->irq_wpc_det) {
+		ret = request_threaded_irq(charger->pdata->irq_wpc_det,
+				NULL, p9220_wpc_det_irq_thread,
+				IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING |
+				IRQF_ONESHOT,
+				"wpd-det-irq", charger);
+		if (ret) {
+			pr_err("%s: Failed to Reqeust IRQ\n", __func__);
+			goto err_irq_wpc_det;
+		}
+	}
+
+	/* wpc_irq */
+	if (charger->pdata->irq_wpc_int) {
+		msleep(100);
+		ret = request_threaded_irq(charger->pdata->irq_wpc_int,
+				NULL, p9220_wpc_irq_thread,
+				IRQF_TRIGGER_FALLING |
+				IRQF_ONESHOT,
+				"wpc-irq", charger);
+		if (ret) {
+			pr_err("%s: Failed to Reqeust IRQ\n", __func__);
+			goto err_irq_wpc_int;
+		}
+	}
+
+	wc_w_state_irq = gpio_get_value(charger->pdata->wpc_int);
+	pr_info("%s wc_w_state_irq = %d\n", __func__, wc_w_state_irq);
+	if (gpio_get_value(charger->pdata->wpc_det)) {
+		u8 irq_src[2];
+		pr_info("%s: Charger interrupt occured during lpm \n", __func__);
+
+		p9220_reg_read(charger->client, P9220_INT_L_REG, &irq_src[0]);
+		p9220_reg_read(charger->client, P9220_INT_H_REG, &irq_src[1]);
+		/* clear intterupt */
+		p9220_reg_write(charger->client, P9220_INT_CLEAR_L_REG, irq_src[0]); // clear int
+		p9220_reg_write(charger->client, P9220_INT_CLEAR_H_REG, irq_src[1]); // clear int
+		p9220_set_cmd_reg(charger, 0x20, P9220_CMD_CLEAR_INT_MASK); // command
+		queue_delayed_work(charger->wqueue, &charger->wpc_det_work, 0);
+		if(!wc_w_state_irq && !delayed_work_pending(&charger->wpc_isr_work))
+			queue_delayed_work(charger->wqueue, &charger->wpc_isr_work, msecs_to_jiffies(2000));
+	}
+
+	ret = sysfs_create_group(&charger->psy_chg.dev->kobj, &p9220_attr_group);
+	if (ret) {
+		dev_info(&client->dev,
+			"%s: sysfs_create_group failed\n", __func__);
+	}
+	dev_info(&client->dev,
+		"%s: p9220 Charger Driver Loaded\n", __func__);
+
+	device_init_wakeup(charger->dev, 1);
+	return 0;
+err_irq_wpc_int:
+	free_irq(charger->pdata->irq_wpc_det, NULL);
+err_irq_wpc_det:
+err_pdata_free:
+	power_supply_unregister(&charger->psy_chg);
+err_supply_unreg:
+	mutex_destroy(&charger->io_lock);
+err_i2cfunc_not_support:
+	kfree(charger);
+err_wpc_nomem:
+err_parse_dt:
+	devm_kfree(&client->dev, pdata);
+	return ret;
+}
+
+static int p9220_charger_remove(struct i2c_client *client)
+{
+	return 0;
+}
+
+#if defined CONFIG_PM
+static int p9220_charger_suspend(struct i2c_client *client,
+				pm_message_t state)
+{
+	struct p9220_charger_data *charger = i2c_get_clientdata(client);
+
+	if (device_may_wakeup(charger->dev)){
+		enable_irq_wake(charger->pdata->irq_wpc_int);
+		enable_irq_wake(charger->pdata->irq_wpc_det);
+	}
+	disable_irq(charger->pdata->irq_wpc_int);
+	disable_irq(charger->pdata->irq_wpc_det);
+
+	return 0;
+}
+
+static int p9220_charger_resume(struct i2c_client *client)
+{
+	struct p9220_charger_data *charger = i2c_get_clientdata(client);
+
+	pr_info("%s \n", __func__);
+
+	if (device_may_wakeup(charger->dev)) {
+		disable_irq_wake(charger->pdata->irq_wpc_int);
+		disable_irq_wake(charger->pdata->irq_wpc_det);
+	}
+	enable_irq(charger->pdata->irq_wpc_int);
+	enable_irq(charger->pdata->irq_wpc_det);
+
+	return 0;
+}
+#else
+#define p9220_charger_suspend NULL
+#define p9220_charger_resume NULL
+#endif
+
+static void p9220_charger_shutdown(struct i2c_client *client)
+{
+	struct p9220_charger_data *charger = i2c_get_clientdata(client);
+
+	pr_info("%s \n", __func__);
+	if(charger->pdata->is_charging)
+		p9220_set_vrect_adjust(charger, P9220_HEADROOM_1);
+}
+
+static const struct i2c_device_id p9220_charger_id_table[] = {
+	{ "p9220-charger", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, p9220_id_table);
+
+#ifdef CONFIG_OF
+static struct of_device_id p9220_charger_match_table[] = {
+	{ .compatible = "idt,p9220-charger",},
+	{},
+};
+#else
+#define p9220_charger_match_table NULL
+#endif
+
+static struct i2c_driver p9220_charger_driver = {
+	.driver = {
+		.name	= "p9220-charger",
+		.owner	= THIS_MODULE,
+		.of_match_table = p9220_charger_match_table,
+	},
+	.shutdown	= p9220_charger_shutdown,
+	.suspend	= p9220_charger_suspend,
+	.resume		= p9220_charger_resume,
+	.probe	= p9220_charger_probe,
+	.remove	= p9220_charger_remove,
+	.id_table	= p9220_charger_id_table,
+};
+
+static int __init p9220_charger_init(void)
+{
+	pr_info("%s \n",__func__);
+	return i2c_add_driver(&p9220_charger_driver);
+}
+
+static void __exit p9220_charger_exit(void)
+{
+	pr_info("%s \n",__func__);
+	i2c_del_driver(&p9220_charger_driver);
+}
+
+module_init(p9220_charger_init);
+module_exit(p9220_charger_exit);
+
+MODULE_DESCRIPTION("Samsung p9220 Charger Driver");
+MODULE_AUTHOR("Samsung Electronics");
+MODULE_LICENSE("GPL");
diff -Naur linux-3.18.14/drivers/battery_v2/s2mu004_charger.c samsung/drivers/battery_v2/s2mu004_charger.c
--- linux-3.18.14/drivers/battery_v2/s2mu004_charger.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/s2mu004_charger.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,1666 @@
+/*
+ * s2mu004_charger.c - S2MU004 Charger Driver
+ *
+ * Copyright (C) 2016 Samsung Electronics Co.Ltd
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include <linux/mfd/samsung/s2mu004.h>
+#include "include/charger/s2mu004_charger.h"
+#include <linux/version.h>
+#include <linux/sec_batt.h>
+
+#define ENABLE_MIVR 0
+
+#define EN_OVP_IRQ 1
+#define EN_IEOC_IRQ 1
+#define EN_TOPOFF_IRQ 1
+#define EN_RECHG_REQ_IRQ 0
+#define EN_TR_IRQ 0
+#define EN_MIVR_SW_REGULATION 0
+#define EN_BST_IRQ 0
+#define EN_BAT_DET_IRQ 0
+#define MINVAL(a, b) ((a <= b) ? a : b)
+
+#define EOC_DEBOUNCE_CNT 2
+#define HEALTH_DEBOUNCE_CNT 1
+#define DEFAULT_CHARGING_CURRENT 500
+
+#define EOC_SLEEP 200
+#define EOC_TIMEOUT (EOC_SLEEP * 6)
+#ifndef EN_TEST_READ
+#define EN_TEST_READ 1
+#endif
+
+#define ENABLE 1
+#define DISABLE 0
+
+static struct device_attribute s2mu004_charger_attrs[] = {
+	S2MU004_CHARGER_ATTR(chip_id),
+};
+
+static enum power_supply_property s2mu004_charger_props[] = {
+};
+
+static enum power_supply_property s2mu004_otg_props[] = {
+	POWER_SUPPLY_PROP_ONLINE,
+};
+
+static int s2mu004_get_charging_health(struct s2mu004_charger_data *charger);
+
+static void s2mu004_test_read(struct i2c_client *i2c)
+{
+	u8 data;
+	char str[1016] = {0,};
+	int i;
+
+	for (i = 0x0A; i <= 0x24; i++) {
+		s2mu004_read_reg(i2c, i, &data);
+
+		sprintf(str+strlen(str), "0x%02x:0x%02x, ", i, data);
+	}
+	s2mu004_read_reg(i2c, 0x33, &data);
+	pr_err("%s: %s0x33:0x%02x\n", __func__, str, data);
+}
+
+static int s2mu004_charger_otg_control(
+	struct s2mu004_charger_data *charger, bool enable)
+{
+	pr_info("%s: called charger otg control : %s\n", __func__,
+			enable ? "ON" : "OFF");
+
+	if (charger->otg_on == enable)
+		return 0;
+
+	mutex_lock(&charger->charger_mutex);
+	if (!enable) {
+		s2mu004_update_reg(charger->i2c,
+			S2MU004_CHG_CTRL0, CHG_MODE, REG_MODE_MASK);
+	} else {
+#ifndef CONFIG_SEC_FACTORY
+		s2mu004_update_reg(charger->i2c, S2MU004_CHG_CTRL7, 0x0 << SET_VF_VBYP_SHIFT, SET_VF_VBYP_MASK);
+#endif
+		s2mu004_update_reg(charger->i2c, 0x14, 0x03 << 2, 0x03 << 2);
+		msleep(30);
+		s2mu004_update_reg(charger->i2c,
+			S2MU004_CHG_CTRL0, OTG_BST_MODE, REG_MODE_MASK);
+		charger->cable_type = POWER_SUPPLY_TYPE_OTG;
+#ifndef CONFIG_SEC_FACTORY		
+		cancel_delayed_work(&charger->otg_vbus_work);
+		schedule_delayed_work(&charger->otg_vbus_work, msecs_to_jiffies(1500));
+#endif
+	}
+	charger->otg_on = enable;
+	mutex_unlock(&charger->charger_mutex);
+	power_supply_changed(&charger->psy_otg);
+	return enable;
+}
+
+#if !defined(CONFIG_SEC_FACTORY)
+static void s2mu004_analog_ivr_switch(
+	struct s2mu004_charger_data *charger, int enable)
+{
+	u8 reg_data = 0;
+	int cable_type = POWER_SUPPLY_TYPE_BATTERY;
+#if defined(CONFIG_BATTERY_SWELLING)
+	int swelling_mode = 0;
+#endif	
+	union power_supply_propval value;
+
+	if (charger->dev_id >= 0x3) {
+		/* control IVRl only under PMIC REV < 0x3 */
+		return;
+	}
+
+	if (factory_mode) {
+		pr_info("%s: Factory Mode Skip Analog IVR Control\n", __func__);
+		return;
+	}
+
+#if defined(CONFIG_BATTERY_SWELLING)
+	psy_do_property("battery", get,
+		POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT, value);
+	swelling_mode = value.intval;
+#endif
+	psy_do_property("battery", get,
+		POWER_SUPPLY_PROP_ONLINE, value);
+	cable_type = value.intval;
+
+	if (charger->charge_mode == SEC_BAT_CHG_MODE_CHARGING_OFF ||
+		charger->charge_mode == SEC_BAT_CHG_MODE_BUCK_OFF ||
+#if defined(CONFIG_BATTERY_SWELLING)
+		swelling_mode ||
+#endif
+		(is_hv_wire_type(cable_type)) ||
+		(cable_type == POWER_SUPPLY_TYPE_PDIC) ||
+		(cable_type == POWER_SUPPLY_TYPE_UARTOFF) ||
+		(cable_type == POWER_SUPPLY_TYPE_HV_PREPARE_MAINS)) {
+			pr_info("[DEBUG]%s(%d): digital IVR \n", __func__, __LINE__);
+			enable = 0;
+	}
+
+	s2mu004_read_reg(charger->i2c, 0xB3, &reg_data);
+	pr_info("%s : 0xB3 : 0x%x\n", __func__, reg_data);
+
+	if (enable) {
+		if (!(reg_data & 0x08)) {
+			/* Enable Analog IVR */
+			pr_info("[DEBUG]%s: Enable Analog IVR\n", __func__);
+			s2mu004_update_reg(charger->i2c, 0xB3, 0x1 << 3, 0x1 << 3);
+		}
+	} else {
+		if (reg_data & 0x08) {
+			/* Disable Analog IVR - Digital IVR enable*/
+			pr_info("[DEBUG]%s: Disable Analog IVR - Digital IVR enable\n",
+				__func__);
+			s2mu004_update_reg(charger->i2c, 0xB3, 0x0, 0x1 << 3);
+		}
+	}
+}
+#endif
+
+static void s2mu004_enable_charger_switch(
+	struct s2mu004_charger_data *charger, int onoff)
+{
+	if (factory_mode) {
+		pr_info("%s: Factory Mode Skip CHG_EN Control\n", __func__);
+		return;
+	}
+
+	if (charger->otg_on) {
+		pr_info("[DEBUG] %s: skipped set(%d) : OTG is on\n", __func__, onoff);
+		return;
+	}
+
+	if (onoff > 0) {
+		pr_info("[DEBUG]%s: turn on charger\n", __func__);
+ 
+#if !defined(CONFIG_SEC_FACTORY)
+		if (charger->dev_id < 0x3) {
+			int cable_type = POWER_SUPPLY_TYPE_BATTERY;
+#if defined(CONFIG_BATTERY_SWELLING)
+			int swelling_mode = 0;
+#endif			
+			union power_supply_propval value;
+
+#if defined(CONFIG_BATTERY_SWELLING)
+			psy_do_property("battery", get,
+				POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT, value);
+			swelling_mode = value.intval;
+#endif			
+			psy_do_property("battery", get,
+				POWER_SUPPLY_PROP_ONLINE, value);
+			cable_type = value.intval;
+
+			if ((is_hv_wire_type(cable_type)) ||
+				(cable_type == POWER_SUPPLY_TYPE_HV_PREPARE_MAINS) ||
+#if defined(CONFIG_BATTERY_SWELLING)
+				swelling_mode ||
+#endif
+				(cable_type == POWER_SUPPLY_TYPE_PDIC) ||
+				(cable_type == POWER_SUPPLY_TYPE_UARTOFF)) {
+				/* Digital IVR */
+				s2mu004_analog_ivr_switch(charger, DISABLE);
+			}
+		}
+#endif
+		/* forced ASYNC */
+		s2mu004_update_reg(charger->i2c, 0x30, 0x03, 0x03);
+
+		mdelay(30);
+
+		s2mu004_update_reg(charger->i2c, S2MU004_CHG_CTRL0, CHG_MODE, REG_MODE_MASK);
+
+		/* timer fault set 16hr(max) */
+		s2mu004_update_reg(charger->i2c, S2MU004_CHG_CTRL16,
+				S2MU004_FC_CHG_TIMER_16hr << SET_TIME_CHG_SHIFT,
+				SET_TIME_CHG_MASK);
+
+		mdelay(100);
+
+		/* Auto SYNC to ASYNC - default */
+		s2mu004_update_reg(charger->i2c, 0x30, 0x01, 0x03);
+
+		/* async off */
+		s2mu004_update_reg(charger->i2c, 0x96, 0x00, 0x01 << 3);
+	} else {
+		pr_info("[DEBUG] %s: turn off charger\n", __func__);
+
+#if !defined(CONFIG_SEC_FACTORY)
+		if (charger->dev_id < 0x3) {
+			/* Disable Analog IVR - Digital IVR enable*/
+			s2mu004_analog_ivr_switch(charger, DISABLE);
+		}
+#endif
+		mdelay(30);
+		s2mu004_update_reg(charger->i2c, S2MU004_CHG_CTRL0, BUCK_MODE, REG_MODE_MASK);
+
+		/* async on */
+		s2mu004_update_reg(charger->i2c, 0x96, 0x01 << 3, 0x01 << 3);
+		mdelay(100);
+	}
+}
+
+static void s2mu004_set_buck(
+	struct s2mu004_charger_data *charger,int enable) {
+
+	if (enable) {
+		pr_info("[DEBUG]%s: set buck on\n", __func__);
+		s2mu004_enable_charger_switch(charger, charger->is_charging);
+	} else {
+		pr_info("[DEBUG]%s: set buck off (charger off mode)\n", __func__);
+
+#if !defined(CONFIG_SEC_FACTORY)
+		if (charger->dev_id < 0x3) {
+			/* Disable Analog IVR - Digital IVR enable*/
+			s2mu004_analog_ivr_switch(charger, DISABLE);
+		}
+#endif
+		
+		s2mu004_update_reg(charger->i2c, S2MU004_CHG_CTRL0, CHARGER_OFF_MODE, REG_MODE_MASK);
+
+		/* async on */
+		s2mu004_update_reg(charger->i2c, 0x96, 0x01 << 3, 0x01 << 3);
+		mdelay(100);
+	}
+}
+
+static void s2mu004_set_regulation_vsys(
+	struct s2mu004_charger_data *charger, int vsys)
+{
+	u8 data;
+
+	pr_info("[DEBUG]%s: VSYS regulation %d \n", __func__, vsys);
+	if (vsys <= 3800)
+		data = 0;
+	else if (vsys > 3800 && vsys <= 4400)
+		data = (vsys - 3800) / 100;
+	else
+		data = 0x06;
+
+	s2mu004_update_reg(charger->i2c,
+		S2MU004_CHG_CTRL7, data << SET_VSYS_SHIFT, SET_VSYS_MASK);
+}
+
+static void s2mu004_set_regulation_voltage(
+	struct s2mu004_charger_data *charger, int float_voltage)
+{
+	u8 data;
+
+	if (factory_mode)
+		return;
+
+	pr_info("[DEBUG]%s: float_voltage %d \n", __func__, float_voltage);
+	if (float_voltage <= 3900)
+		data = 0;
+	else if (float_voltage > 3900 && float_voltage <= 4530)
+		data = (float_voltage - 3900) / 10;
+	else
+		data = 0x3f;
+
+	s2mu004_update_reg(charger->i2c,
+		S2MU004_CHG_CTRL6, data << SET_VF_VBAT_SHIFT, SET_VF_VBAT_MASK);
+}
+
+static int s2mu004_get_regulation_voltage(struct s2mu004_charger_data *charger)
+{
+	u8 reg_data = 0;
+	int float_voltage;
+
+	s2mu004_read_reg(charger->i2c, S2MU004_CHG_CTRL6, &reg_data);
+	reg_data &= 0x3F;
+	float_voltage = reg_data * 10 + 3900;
+	pr_debug("%s: battery cv reg : 0x%x, float voltage val : %d\n",
+		__func__, reg_data, float_voltage);
+
+	return float_voltage;
+}
+
+static void s2mu004_set_input_current_limit(
+	struct s2mu004_charger_data *charger, int charging_current)
+{
+	u8 data;
+
+	if (factory_mode)
+		return;
+
+	if (is_wireless_type(charger->cable_type)) {
+		pr_info("[DEBUG]%s: Wireless current limit %d \n",
+			__func__, charging_current);
+		if (charging_current <= 50)
+			data = 0x02;
+		else if (charging_current > 50 && charging_current <= 1025) {
+			/* Need to re-write dts file if we need to use 5 digit current (eg. 1.0125A) */
+			charging_current = charging_current * 10;
+			data = (charging_current - 250) / 125;
+		} else
+			data = 0x12;
+
+		s2mu004_update_reg(charger->i2c, S2MU004_CHG_CTRL3,
+			data << INPUT_CURRENT_LIMIT_SHIFT, INPUT_CURRENT_LIMIT_MASK);
+	} else {
+		if (charging_current <= 100)
+			data = 0x02;
+		else if (charging_current > 100 && charging_current <= 2500)
+			data = (charging_current - 50) / 25;
+		else
+			data = 0x62;
+
+		s2mu004_update_reg(charger->i2c, S2MU004_CHG_CTRL2,
+				data << INPUT_CURRENT_LIMIT_SHIFT, INPUT_CURRENT_LIMIT_MASK);
+	}
+
+	pr_info("[DEBUG]%s: current  %d, 0x%x\n", __func__, charging_current, data);
+
+#if EN_TEST_READ
+	s2mu004_test_read(charger->i2c);
+#endif
+}
+
+static int s2mu004_get_input_current_limit(struct s2mu004_charger_data *charger)
+{
+	u8 data;
+	int w_current;
+
+	if (is_wireless_type(charger->cable_type)) {
+		data = s2mu004_read_reg(charger->i2c, S2MU004_CHG_CTRL3, &data);
+		if (data < 0)
+			return data;
+
+		data = data & INPUT_CURRENT_LIMIT_MASK;
+
+		if (data > 0x62) {
+			pr_err("%s: Invalid WC current limit in register\n", __func__);
+			data = 0x62;
+		}
+
+		/* note: if use value with 5 digits the fractional 0.5 will be truncated */
+		w_current = (data * 125 + 250) / 10;
+
+		pr_debug("[DEBUG]%s: Wireless current limit out: %d\n",
+					__func__, w_current);
+
+		return w_current;
+	} else {
+		s2mu004_read_reg(charger->i2c, S2MU004_CHG_CTRL2, &data);
+		if (data < 0)
+			return data;
+
+		data = data & INPUT_CURRENT_LIMIT_MASK;
+
+		if (data > 0x62) {
+			pr_err("%s: Invalid current limit in register\n", __func__);
+			data = 0x62;
+		}
+		return  data * 25 + 50;
+	}
+}
+
+static void s2mu004_set_fast_charging_current(
+	struct s2mu004_charger_data *charger, int charging_current)
+{
+	u8 data;
+
+	if (factory_mode)
+		return;
+
+	if (charging_current <= 100)
+		data = 0x03;
+	else if (charging_current > 100 && charging_current <= 3150)
+		data = (charging_current / 25) - 1;
+	else
+		data = 0x7D;
+
+	s2mu004_update_reg(charger->i2c, S2MU004_CHG_CTRL9,
+		data << FAST_CHARGING_CURRENT_SHIFT, FAST_CHARGING_CURRENT_MASK);
+
+	pr_info("[DEBUG]%s: current  %d, 0x%02x\n", __func__, charging_current, data);
+
+	if (data > 0x11) 
+		data = 0x11; /* 0x11 : 450mA */
+	s2mu004_update_reg(charger->i2c, S2MU004_CHG_CTRL8,
+		data << COOL_CHARGING_CURRENT_SHIFT, COOL_CHARGING_CURRENT_MASK);
+
+#if EN_TEST_READ
+	s2mu004_test_read(charger->i2c);
+#endif
+}
+
+static int s2mu004_get_fast_charging_current(
+	struct s2mu004_charger_data *charger)
+{
+	u8 data;
+
+	s2mu004_read_reg(charger->i2c, S2MU004_CHG_CTRL9, &data);
+	if (data < 0)
+		return data;
+
+	data = data & FAST_CHARGING_CURRENT_MASK;
+
+	if (data > 0x7D) {
+		pr_err("%s: Invalid fast charging current in register\n", __func__);
+		data = 0x7D;
+	}
+	return (data + 1) * 25;
+}
+
+static void s2mu004_set_topoff_current(
+	struct s2mu004_charger_data *charger,
+	int eoc_1st_2nd, int current_limit)
+{
+	int data;
+
+	pr_info("[DEBUG]%s: current  %d \n", __func__, current_limit);
+	if (current_limit <= 100)
+		data = 0;
+	else if (current_limit > 100 && current_limit <= 475)
+		data = (current_limit - 100) / 25;
+	else
+		data = 0x0F;
+
+	switch(eoc_1st_2nd) {
+	case 1:
+		s2mu004_update_reg(charger->i2c, S2MU004_CHG_CTRL11,
+			data << FIRST_TOPOFF_CURRENT_SHIFT, FIRST_TOPOFF_CURRENT_MASK);
+		break;
+	case 2:
+		s2mu004_update_reg(charger->i2c, S2MU004_CHG_CTRL11,
+			data << SECOND_TOPOFF_CURRENT_SHIFT, SECOND_TOPOFF_CURRENT_MASK);
+		break;
+	default:
+		break;
+	}
+}
+
+static int s2mu004_get_topoff_setting(
+	struct s2mu004_charger_data *charger)
+{
+	u8 data;
+
+	s2mu004_read_reg(charger->i2c, S2MU004_CHG_CTRL11, &data);
+	if (data < 0)
+		return data;
+
+	data = data & FIRST_TOPOFF_CURRENT_MASK;
+
+	if (data > 0x0F)
+		data = 0x0F;
+	return data * 25 + 100;
+}
+
+enum {
+	S2MU004_CHG_2L_IVR_4300MV = 0,
+	S2MU004_CHG_2L_IVR_4500MV,
+	S2MU004_CHG_2L_IVR_4700MV,
+	S2MU004_CHG_2L_IVR_4900MV,
+};
+
+#if ENABLE_MIVR
+/* charger input regulation voltage setting */
+static void s2mu004_set_ivr_level(struct s2mu004_charger_data *charger)
+{
+	int chg_2l_ivr = S2MU004_CHG_2L_IVR_4500MV;
+
+	s2mu004_update_reg(charger->i2c, S2MU004_CHG_CTRL5,
+		chg_2l_ivr << SET_CHG_2L_DROP_SHIFT, SET_CHG_2L_DROP_MASK);
+}
+#endif /*ENABLE_MIVR*/
+
+static bool s2mu004_chg_init(struct s2mu004_charger_data *charger)
+{
+	u8 temp;
+	/* Read Charger IC Dev ID */
+	s2mu004_read_reg(charger->i2c, S2MU004_REG_REV_ID, &temp);
+	charger->dev_id = (temp & 0xF0) >> 4;
+
+	pr_info("%s : DEV ID : 0x%x\n", __func__, charger->dev_id);
+
+	/* Poor-Chg-INT Masking */
+	s2mu004_update_reg(charger->i2c, 0x32, 0x03, 0x03);
+
+	/*
+	 * When Self Discharge Function is activated, Charger doesn't stop charging.
+	 * If you write 0xb0[4]=1, charger will stop the charging, when self discharge
+	 * condition is satisfied.
+	 */
+	s2mu004_update_reg(charger->i2c, 0xb0, 0x0, 0x1 << 4);
+
+	s2mu004_update_reg(charger->i2c, S2MU004_REG_SC_INT1_MASK,
+			Poor_CHG_INT_MASK, Poor_CHG_INT_MASK);
+
+	s2mu004_write_reg(charger->i2c, 0x02, 0x0);
+	s2mu004_write_reg(charger->i2c, 0x03, 0x0);
+
+	/* ready for self-discharge, 0x76 */
+	s2mu004_update_reg(charger->i2c, S2MU004_REG_SELFDIS_CFG3,
+			SELF_DISCHG_MODE_MASK, SELF_DISCHG_MODE_MASK);
+
+	/* Set Top-Off timer to 30 minutes */
+	s2mu004_update_reg(charger->i2c, S2MU004_CHG_CTRL17,
+			S2MU004_TOPOFF_TIMER_30m << TOP_OFF_TIME_SHIFT,
+			TOP_OFF_TIME_MASK);
+
+	s2mu004_read_reg(charger->i2c, S2MU004_CHG_CTRL17, &temp);
+	pr_info("%s : S2MU004_CHG_CTRL17 : 0x%x\n", __func__, temp);
+
+	/* enable Watchdog timer and only Charging off */ 
+	s2mu004_update_reg(charger->i2c, S2MU004_CHG_CTRL13, 
+			ENABLE << SET_EN_WDT_SHIFT | DISABLE << SET_EN_WDT_AP_RESET_SHIFT,
+			SET_EN_WDT_MASK | SET_EN_WDT_AP_RESET_MASK);
+	s2mu004_read_reg(charger->i2c, S2MU004_CHG_CTRL13, &temp);
+	pr_info("%s : S2MU004_CHG_CTRL13 : 0x%x\n", __func__, temp);
+
+	/* set watchdog timer to 80 seconds */
+	s2mu004_update_reg(charger->i2c, S2MU004_CHG_CTRL17,
+			S2MU004_WDT_TIMER_80s << WDT_TIME_SHIFT,
+			WDT_TIME_MASK);
+
+	/* IVR Recovery enable */
+	s2mu004_update_reg(charger->i2c, S2MU004_CHG_CTRL13,
+		0x1 << SET_IVR_Recovery_SHIFT, SET_IVR_Recovery_MASK);
+
+	/* Boost OSC 1Mhz */
+	s2mu004_update_reg(charger->i2c, S2MU004_CHG_CTRL15,
+		0x02 << SET_OSC_BST_SHIFT, SET_OSC_BST_MASK);
+
+	/* QBAT switch speed config */
+	s2mu004_update_reg(charger->i2c, 0xB2, 0x0, 0xf << 4);
+
+	/* Top off debounce time set 1 sec */
+	s2mu004_update_reg(charger->i2c, 0xC0, 0x3 << 6 , 0x3 << 6);
+
+	switch (charger->pdata->chg_switching_freq) {
+	case S2MU004_OSC_BUCK_FRQ_750kHz :
+		s2mu004_update_reg(charger->i2c, S2MU004_CHG_CTRL12,
+			S2MU004_OSC_BUCK_FRQ_750kHz << SET_OSC_BUCK_SHIFT, SET_OSC_BUCK_MASK);
+		s2mu004_update_reg(charger->i2c, S2MU004_CHG_CTRL12,
+			S2MU004_OSC_BUCK_FRQ_750kHz << SET_OSC_BUCK_3L_SHIFT, SET_OSC_BUCK_3L_MASK);
+		break;
+	default :
+		/* Set OSC BUCK/BUCK 3L frequencies to default 1MHz */
+		s2mu004_update_reg(charger->i2c, S2MU004_CHG_CTRL12,
+			S2MU004_OSC_BUCK_FRQ_1MHz << SET_OSC_BUCK_SHIFT, SET_OSC_BUCK_MASK);
+		s2mu004_update_reg(charger->i2c, S2MU004_CHG_CTRL12,
+			S2MU004_OSC_BUCK_FRQ_1MHz << SET_OSC_BUCK_3L_SHIFT, SET_OSC_BUCK_3L_MASK);
+		break;
+	}
+	s2mu004_read_reg(charger->i2c, S2MU004_CHG_CTRL12, &temp);
+	pr_info("%s : S2MU004_CHG_CTRL12 : 0x%x\n", __func__, temp);
+
+	return true;
+}
+
+static int s2mu004_get_charging_status(
+	struct s2mu004_charger_data *charger)
+{
+	int status = POWER_SUPPLY_STATUS_UNKNOWN;
+	int ret;
+	u8 chg_sts0, chg_sts1;
+	union power_supply_propval value;
+
+	ret = s2mu004_read_reg(charger->i2c, S2MU004_CHG_STATUS0, &chg_sts0);
+	ret = s2mu004_read_reg(charger->i2c, S2MU004_CHG_STATUS1, &chg_sts1);
+
+	psy_do_property(charger->pdata->fuelgauge_name, get,
+		POWER_SUPPLY_PROP_CURRENT_AVG, value);
+
+	if (ret < 0)
+		return status;
+
+	if (chg_sts1 & 0x80)
+		status = POWER_SUPPLY_STATUS_DISCHARGING;
+	else if (chg_sts1 & 0x02 || chg_sts1 & 0x01) {
+		pr_info("%s: full check curr_avg(%d), topoff_curr(%d)\n",
+			__func__, value.intval, charger->topoff_current);
+		if (value.intval < charger->topoff_current)
+			status = POWER_SUPPLY_STATUS_FULL;
+		else
+			status = POWER_SUPPLY_STATUS_CHARGING;
+	} else if ((chg_sts0 & 0xE0) == 0xA0 || (chg_sts0 & 0xE0) == 0x60)
+		status = POWER_SUPPLY_STATUS_CHARGING;
+	else
+		status = POWER_SUPPLY_STATUS_NOT_CHARGING;
+
+#if EN_TEST_READ
+	s2mu004_test_read(charger->i2c);
+#endif
+	return status;
+}
+
+static int s2mu004_get_charge_type(struct s2mu004_charger_data *charger)
+{
+	int status = POWER_SUPPLY_CHARGE_TYPE_UNKNOWN;
+	u8 ret;
+
+	s2mu004_read_reg(charger->i2c, S2MU004_CHG_STATUS3, &ret);
+	if (ret < 0)
+		pr_err("%s fail\n", __func__);
+
+	switch ((ret & BAT_STATUS_MASK) >> BAT_STATUS_SHIFT) {
+	case 0x4 :
+	case 0x5 :
+		status = POWER_SUPPLY_CHARGE_TYPE_FAST;
+		break;
+	case 0x2 :
+		/* pre-charge mode */
+		status = POWER_SUPPLY_CHARGE_TYPE_TRICKLE;
+		break;
+	}
+	return status;
+}
+
+static bool s2mu004_get_batt_present(struct s2mu004_charger_data *charger)
+{
+	u8 ret;
+
+	s2mu004_read_reg(charger->i2c, S2MU004_CHG_STATUS3, &ret);
+	if (ret < 0)
+		return false;
+
+	return (ret & DET_BAT_STATUS_MASK) ? true : false;
+}
+
+static void s2mu004_wdt_clear(struct s2mu004_charger_data *charger)
+{
+	u8 reg_data, chg_fault_status, en_chg;
+
+	/* watchdog kick */
+	s2mu004_update_reg(charger->i2c, S2MU004_CHG_CTRL14,
+			0x1 << WDT_CLR_SHIFT, WDT_CLR_MASK);
+
+	s2mu004_read_reg(charger->i2c, S2MU004_CHG_STATUS1, &reg_data);
+	chg_fault_status = (reg_data & CHG_FAULT_STATUS_MASK) >> CHG_FAULT_STATUS_SHIFT;
+
+	if ((chg_fault_status == CHG_STATUS_WD_SUSPEND) ||
+		(chg_fault_status == CHG_STATUS_WD_RST)) {
+		pr_info("%s: watchdog error status(0x%02x,%d)\n",
+			__func__, reg_data, chg_fault_status);
+		if (charger->is_charging) {
+			pr_info("%s: toggle charger\n", __func__);
+			s2mu004_enable_charger_switch(charger, false);
+			s2mu004_enable_charger_switch(charger, true);
+		}
+	}
+
+	s2mu004_read_reg(charger->i2c, S2MU004_CHG_CTRL0, &en_chg);
+	if (!(en_chg & 0x80))
+		s2mu004_update_reg(charger->i2c, S2MU004_CHG_CTRL0,
+			0x1 << EN_CHG_SHIFT, EN_CHG_MASK);
+}
+
+static int s2mu004_get_charging_health(struct s2mu004_charger_data *charger)
+{
+
+	u8 ret;
+	union power_supply_propval value;
+
+	if (charger->is_charging)
+		s2mu004_wdt_clear(charger);
+
+	s2mu004_read_reg(charger->i2c, S2MU004_CHG_STATUS0, &ret);
+	pr_info("[DEBUG] %s: S2MU004_CHG_STATUS0 0x%x\n", __func__, ret);
+	if (ret < 0)
+		return POWER_SUPPLY_HEALTH_UNKNOWN;
+
+	if (is_wireless_type(charger->cable_type)) {
+		ret = (ret & (WCIN_STATUS_MASK)) >> WCIN_STATUS_SHIFT;
+	} else {
+		ret = (ret & (CHGIN_STATUS_MASK)) >> CHGIN_STATUS_SHIFT;
+	}
+
+	switch (ret) {
+	case 0x03:
+	case 0x05:
+		charger->ovp = false;
+		charger->unhealth_cnt = 0;
+		return POWER_SUPPLY_HEALTH_GOOD;
+	default:
+		break;
+	}
+
+	charger->unhealth_cnt++;
+	if (charger->unhealth_cnt < HEALTH_DEBOUNCE_CNT)
+		return POWER_SUPPLY_HEALTH_GOOD;
+
+	/* 005 need to check ovp & health count */
+	charger->unhealth_cnt = HEALTH_DEBOUNCE_CNT;
+	if (charger->ovp)
+		return POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+
+	psy_do_property("battery", get, POWER_SUPPLY_PROP_ONLINE, value);
+	if (value.intval == POWER_SUPPLY_TYPE_PDIC)
+		return POWER_SUPPLY_HEALTH_UNDERVOLTAGE;
+	else
+		return POWER_SUPPLY_HEALTH_GOOD;
+}
+
+static int s2mu004_chg_create_attrs(struct device *dev)
+{
+	unsigned long i;
+	int rc;
+
+	for (i = 0; i < ARRAY_SIZE(s2mu004_charger_attrs); i++) {
+		rc = device_create_file(dev, &s2mu004_charger_attrs[i]);
+		if (rc)
+			goto create_attrs_failed;
+	}
+	return rc;
+
+create_attrs_failed:
+	dev_err(dev, "%s: failed (%d)\n", __func__, rc);
+	while (i--)
+		device_remove_file(dev, &s2mu004_charger_attrs[i]);
+	return rc;
+}
+
+ssize_t s2mu004_chg_show_attrs(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	const ptrdiff_t offset = attr - s2mu004_charger_attrs;
+	int i = 0;
+
+	switch (offset) {
+	case CHIP_ID:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%s\n", "S2MU004");
+		break;
+	default:
+		return -EINVAL;
+	}
+	return i;
+}
+
+ssize_t s2mu004_chg_store_attrs(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	const ptrdiff_t offset = attr - s2mu004_charger_attrs;
+	int ret = 0;
+
+	switch(offset) {
+	case CHIP_ID:
+		ret = count;
+		break;
+	default:
+		ret = -EINVAL;
+	}
+	return ret;
+}
+
+static int s2mu004_chg_get_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		union power_supply_propval *val)
+{
+	int chg_curr, aicr;
+	struct s2mu004_charger_data *charger =
+		container_of(psy, struct s2mu004_charger_data, psy_chg);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = charger->charging_current ? 1 : 0;
+		break;
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = s2mu004_get_charging_status(charger);
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = s2mu004_get_charging_health(charger);
+#if EN_TEST_READ
+		s2mu004_test_read(charger->i2c);
+#endif
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		val->intval = s2mu004_get_input_current_limit(charger);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		if (charger->charging_current) {
+			aicr = s2mu004_get_input_current_limit(charger);
+			chg_curr = s2mu004_get_fast_charging_current(charger);
+			val->intval = MINVAL(aicr, chg_curr);
+		} else
+			val->intval = 0;
+		break;
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:
+		val->intval = s2mu004_get_fast_charging_current(charger);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_FULL:
+		val->intval = s2mu004_get_topoff_setting(charger);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+		val->intval = s2mu004_get_charge_type(charger);
+		break;
+#if defined(CONFIG_BATTERY_SWELLING) || defined(CONFIG_BATTERY_SWELLING_SELF_DISCHARGING)
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+		val->intval = s2mu004_get_regulation_voltage(charger);
+		break;
+#endif
+#if defined(CONFIG_AFC_CHARGER_MODE)
+	case POWER_SUPPLY_PROP_AFC_CHARGER_MODE:
+		return -ENODATA;
+#endif
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = s2mu004_get_batt_present(charger);
+		break;
+	case POWER_SUPPLY_PROP_CHARGING_ENABLED:
+		val->intval = charger->is_charging;
+		break;
+	case POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION:
+		break;
+	case POWER_SUPPLY_PROP_MAX ... POWER_SUPPLY_EXT_PROP_MAX:
+		return -ENODATA;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int s2mu004_chg_set_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		const union power_supply_propval *val)
+{
+	struct s2mu004_charger_data *charger =
+		container_of(psy, struct s2mu004_charger_data, psy_chg);
+	enum power_supply_ext_property ext_psp = psp;
+	int buck_state = ENABLE;
+	union power_supply_propval value;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		charger->status = val->intval;
+		break;
+		/* val->intval : type */
+	case POWER_SUPPLY_PROP_ONLINE:
+		charger->cable_type = val->intval;
+
+		if (charger->cable_type != POWER_SUPPLY_TYPE_OTG) {
+			if (charger->cable_type == POWER_SUPPLY_TYPE_BATTERY ||
+					charger->cable_type == POWER_SUPPLY_TYPE_UNKNOWN) {
+				value.intval = 0;
+			} else {
+#if ENABLE_MIVR
+				s2mu004_set_ivr_level(charger);
+#endif
+				value.intval = 1;
+			}
+			psy_do_property(charger->pdata->fuelgauge_name,
+					set, POWER_SUPPLY_PROP_ENERGY_AVG, value);
+		}
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		{
+			int input_current = val->intval;
+			s2mu004_set_input_current_limit(charger, input_current);
+			charger->input_current = input_current;
+		}
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		pr_info("[DEBUG] %s: is_charging %d\n", __func__, charger->is_charging);
+		charger->charging_current = val->intval;
+		/* set charging current */
+		if (charger->is_charging) {
+			/* decrease the charging current according to siop level */
+			s2mu004_set_fast_charging_current(charger, charger->charging_current);
+		}
+#if EN_TEST_READ
+		s2mu004_test_read(charger->i2c);
+#endif
+		break;
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_FULL:
+		charger->topoff_current = val->intval;
+		if (charger->pdata->chg_eoc_dualpath) {
+			s2mu004_set_topoff_current(charger, 1, val->intval);
+			s2mu004_set_topoff_current(charger, 2, 100);
+		}
+		else
+			s2mu004_set_topoff_current(charger, 1, val->intval);
+		break;
+
+#if defined(CONFIG_BATTERY_SWELLING) || defined(CONFIG_BATTERY_SWELLING_SELF_DISCHARGING)
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+		pr_info("[DEBUG]%s: float voltage(%d)\n", __func__, val->intval);
+		charger->pdata->chg_float_voltage = val->intval;
+		s2mu004_set_regulation_voltage(charger,
+				charger->pdata->chg_float_voltage);
+		break;
+#endif
+	case POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL:
+		s2mu004_charger_otg_control(charger, val->intval);
+		break;
+	case POWER_SUPPLY_PROP_CHARGING_ENABLED:
+		charger->charge_mode = val->intval;
+		psy_do_property("battery", get, POWER_SUPPLY_PROP_ONLINE, value);
+		if (value.intval != POWER_SUPPLY_TYPE_OTG) {
+			switch (charger->charge_mode) {
+			case SEC_BAT_CHG_MODE_BUCK_OFF:
+				buck_state = DISABLE;
+			case SEC_BAT_CHG_MODE_CHARGING_OFF:
+				charger->is_charging = false;
+				break;
+			case SEC_BAT_CHG_MODE_CHARGING:
+				charger->is_charging = true;
+				break;
+			}
+			value.intval = charger->is_charging;
+			psy_do_property("s2mu004-fuelgauge", set,
+				POWER_SUPPLY_PROP_CHARGING_ENABLED, value);
+
+			if (buck_state) {
+				s2mu004_enable_charger_switch(charger, charger->is_charging);
+			} else {
+				/* set buck off only if SEC_BAT_CHG_MODE_BUCK_OFF */ 
+				s2mu004_set_buck(charger, buck_state);
+			}
+		} else {
+			pr_info("[DEBUG]%s: SKIP CHARGING CONTROL while OTG(%d)\n",
+				__func__, value.intval);
+		}
+		break;
+	case POWER_SUPPLY_PROP_ENERGY_NOW:
+#if 0
+		/* Switch-off charger if JIG is connected */
+		if (val->intval && factory_mode) {
+			pr_info("%s: JIG Connection status: %d \n", __func__, val->intval);
+			s2mu004_enable_charger_switch(charger, false);
+		}
+#endif
+		break;
+	case POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION:
+		if (val->intval) {
+			pr_info("%s: Relieve VBUS2BAT\n", __func__);
+			s2mu004_write_reg(charger->i2c, 0x2F, 0xDD);
+		}
+		break;
+	case POWER_SUPPLY_PROP_AUTHENTIC:
+		if (val->intval) {
+			pr_info("%s: Bypass set\n", __func__);
+			s2mu004_update_reg(charger->i2c, 0x22 , 0xC0 , 0xC0 );
+			s2mu004_update_reg(charger->i2c, 0x29 , 0x01 << 1 , 0x01 << 1 );
+			s2mu004_update_reg(charger->i2c, 0x9F , 0x0 , 0x01 << 7 );
+			s2mu004_update_reg(charger->i2c, 0x10 , 0x01 << 5 , 0x01 << 5 );
+			/* USB LDO off */
+			s2mu004_update_reg(charger->i2c, S2MU004_PWRSEL_CTRL0,
+				0 << PWRSEL_CTRL0_SHIFT, PWRSEL_CTRL0_MASK);
+		}
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_MEASURE:
+		if (val->intval) {
+			pr_info("%s: Bypass set for current measure\n", __func__);
+			/*
+			 * Charger/muic interrupt can be occured by entering Bypass mode
+			 * Disable all interrupt mask for testing current measure.
+			 */
+			s2mu004_write_reg(charger->i2c, S2MU004_REG_SC_INT1_MASK, 0xFF);
+			s2mu004_write_reg(charger->i2c, S2MU004_REG_SC_INT2_MASK, 0xFF);
+			s2mu004_write_reg(charger->i2c, S2MU004_REG_AFC_INT_MASK, 0xFF);
+			s2mu004_write_reg(charger->i2c, S2MU004_REG_MUIC_INT1_MASK, 0xFF);
+			s2mu004_write_reg(charger->i2c, S2MU004_REG_MUIC_INT2_MASK, 0xFF);
+
+			/* Enter Bypass mode set for current measure */
+			s2mu004_update_reg(charger->i2c, 0x10 , 0x01 << 4 , 0x01 << 4 );
+			s2mu004_write_reg(charger->i2c, 0x12, 0x7f);
+			s2mu004_write_reg(charger->i2c, 0x2f, 0xdd);
+			msleep(500);
+			s2mu004_update_reg(charger->i2c, 0x22 , 0xc0 , 0xc0 );
+			s2mu004_update_reg(charger->i2c, 0x29 , 0x01 << 1 , 0x01 << 1 );
+			s2mu004_update_reg(charger->i2c, 0x9F , 0x00 , 0x80 );
+			s2mu004_update_reg(charger->i2c, 0x10 , 0x01 << 5 , 0x01 << 5 );
+			/* USB LDO off */
+			s2mu004_update_reg(charger->i2c, S2MU004_PWRSEL_CTRL0,
+				0 << PWRSEL_CTRL0_SHIFT, PWRSEL_CTRL0_MASK);
+			psy_do_property( "s2mu004-fuelgauge", set,
+				POWER_SUPPLY_PROP_FUELGAUGE_FACTORY, value);
+		} else {
+			pr_info("%s: Bypass exit for current measure\n", __func__);
+			s2mu004_update_reg(charger->i2c, 0x29 , 0x0 , 0x01 << 1 );
+			s2mu004_write_reg(charger->i2c, 0x10, 0x00);
+			/* USB LDO on */
+			s2mu004_update_reg(charger->i2c, S2MU004_PWRSEL_CTRL0,
+				1 << PWRSEL_CTRL0_SHIFT, PWRSEL_CTRL0_MASK);
+		}
+		break;
+#if defined(CONFIG_AFC_CHARGER_MODE)
+	case POWER_SUPPLY_PROP_AFC_CHARGER_MODE:
+#if defined(CONFIG_HV_MUIC_S2MU004_AFC)
+		s2mu004_hv_muic_charger_init();
+#endif
+		break;
+#endif
+	case POWER_SUPPLY_PROP_MAX ... POWER_SUPPLY_EXT_PROP_MAX:
+		switch (ext_psp) {
+		case POWER_SUPPLY_EXT_PROP_FUELGAUGE_RESET:
+			s2mu004_write_reg(charger->i2c, 0x6F, 0xC4);
+			msleep(1000);
+			s2mu004_write_reg(charger->i2c, 0x6F, 0x04);
+			msleep(50);
+			pr_info("%s: reset fuelgauge when surge occur! \n", __func__);
+			break;
+		case POWER_SUPPLY_EXT_PROP_FACTORY_VOLTAGE_REGULATION:
+			/* enable EN_JIG_AP */
+			s2mu004_update_reg(charger->i2c, S2MU004_CHG_CTRL1,
+					1 << EN_JIG_REG_AP_SHIFT, EN_JIG_REG_AP_MASK);
+			pr_info("%s: factory voltage regulation (%d)\n", __func__, val->intval);
+			s2mu004_set_regulation_vsys(charger, val->intval);
+			break;
+		case POWER_SUPPLY_EXT_PROP_ANDIG_IVR_SWITCH:
+#if !defined(CONFIG_SEC_FACTORY)
+			if (charger->dev_id < 0x3) {
+				s2mu004_analog_ivr_switch(charger, val->intval);
+			}
+#endif
+			break;
+		default:
+			return -EINVAL;
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int s2mu004_otg_get_property(struct power_supply *psy,
+				enum power_supply_property psp,
+				union power_supply_propval *val)
+{
+	struct s2mu004_charger_data *charger =
+		container_of(psy, struct s2mu004_charger_data, psy_otg);
+	u8 reg;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = charger->otg_on;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_POWERED_OTG_CONTROL:
+		s2mu004_read_reg(charger->i2c, S2MU004_CHG_STATUS2, &reg);
+		pr_info("%s: S2MU004_CHG_STATUS2 : 0x%X\n", __func__, reg);
+		if ((reg & 0xE0) == 0x60) {
+			val->intval = 1;
+		} else {
+			val->intval = 0;
+		}
+		s2mu004_read_reg(charger->i2c, S2MU004_CHG_CTRL0, &reg);
+		pr_info("%s: S2MU004_CHG_CTRL0 : 0x%X\n", __func__, reg);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int s2mu004_otg_set_property(struct power_supply *psy,
+				enum power_supply_property psp,
+				const union power_supply_propval *val)
+{
+	struct s2mu004_charger_data *charger =
+		container_of(psy, struct s2mu004_charger_data, psy_otg);
+	union power_supply_propval value;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		value.intval = val->intval;
+		pr_info("%s: OTG %s\n", __func__, value.intval > 0 ? "ON" : "OFF");
+		psy_do_property(charger->pdata->charger_name, set,
+					POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL, value);
+		power_supply_changed(&charger->psy_otg);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+#if defined(CONFIG_S2MU004_WIRELESS_CHARGER)
+static void wpc_detect_work(struct work_struct *work)
+{
+	struct s2mu004_charger_data *charger = container_of(work,
+						struct s2mu004_charger_data,
+						wpc_work.work);
+	int wc_w_state;
+	int retry_cnt;
+	union power_supply_propval value;
+	u8 reg_data;
+
+	pr_info("%s\n", __func__);
+
+	retry_cnt = 0;
+	do {
+		s2mu004_read_reg(charger->i2c,
+			S2MU004_CHG_STATUS0, &reg_data);
+		
+		reg_data = (reg_data & (WCIN_STATUS_MASK)) >> WCIN_STATUS_SHIFT;
+
+		pr_info("%s S2MU004_CHG_STATUS0: 0x%x\n", __func__, reg_data);
+
+		wc_w_state = ((reg_data == 0x05) || (reg_data == 0x03) ||
+					(reg_data == 0x07) || (reg_data == 0x01));
+
+		if (wc_w_state == 0)
+			msleep(50);
+	} while((retry_cnt++ < 2) && (wc_w_state == 0));
+
+	if ((charger->wc_w_state == 0) && (wc_w_state == 1)) {
+		value.intval = 1;
+		psy_do_property("wireless", set,
+				POWER_SUPPLY_PROP_ONLINE, value);
+		value.intval = POWER_SUPPLY_TYPE_WIRELESS;
+		pr_info("%s: wpc activated, set V_INT as PN\n",
+				__func__);
+	} else if ((charger->wc_w_state == 1) && (wc_w_state == 0)) {
+		if (!charger->is_charging)
+			s2mu004_enable_charger_switch(charger, true);
+
+		retry_cnt = 0;
+		do {
+			s2mu004_read_reg(charger->i2c,
+				S2MU004_CHG_STATUS0, &reg_data);
+			reg_data = (reg_data & (WCIN_STATUS_MASK)) >> WCIN_STATUS_SHIFT;
+			msleep(50);
+		} while((retry_cnt++ < 2) &&
+			((reg_data != 0x05) || (reg_data != 0x03)));
+		pr_info("%s: reg_data: 0x%x, charging: %d\n", __func__,
+			reg_data, charger->is_charging);
+		if (!charger->is_charging)
+			s2mu004_enable_charger_switch(charger, false);
+		/* To-Do: CHECK for reg_data value 0x01 cases */
+		if (((reg_data == 0x05) || (reg_data == 0x03) ||
+			(reg_data == 0x07) || (reg_data == 0x01)) &&
+			(is_wireless_type(charger->cable_type))) {
+			pr_info("%s: wpc uvlo, but charging\n", __func__);
+
+			if ((reg_data == 0x07) || (reg_data == 0x01)) {
+				pr_info(
+					"%s: Abnormal WPC state, maintan charging: reg_data: 0x%x\n",
+					__func__, reg_data);
+			}
+			queue_delayed_work(charger->wqueue, &charger->wpc_work,
+					   msecs_to_jiffies(500));
+			return;
+		} else {
+			value.intval = 0;
+			psy_do_property("wireless", set,
+					POWER_SUPPLY_PROP_ONLINE, value);
+
+			/* this code is for preventing reactivation of the wireless charger outside of pad*/
+			value.intval = POWER_SUPPLY_HEALTH_UNDERVOLTAGE;
+			psy_do_property(charger->pdata->wireless_charger_name, set,
+					POWER_SUPPLY_PROP_HEALTH, value);
+
+			pr_info("%s: wpc deactivated, set V_INT as PD\n",
+					__func__);
+		}
+	}
+	pr_info("%s: w(%d to %d)\n", __func__,
+		charger->wc_w_state, wc_w_state);
+
+	charger->wc_w_state = wc_w_state;
+
+	/* Do unmask again. (for frequent wcin irq problem) */
+	s2mu004_update_reg(charger->i2c, S2MU004_REG_SC_INT1_MASK,
+		0 << WCIN_M_SHIFT, WCIN_M_MASK);
+
+	wake_unlock(&charger->wpc_wake_lock);
+}
+#endif
+
+#ifndef CONFIG_SEC_FACTORY
+static void s2mu004_charger_otg_vbus_work(struct work_struct *work)
+{
+	struct s2mu004_charger_data *charger = container_of(work,
+						struct s2mu004_charger_data,
+						otg_vbus_work.work);
+
+	s2mu004_update_reg(charger->i2c, S2MU004_CHG_CTRL7, 0x2 << SET_VF_VBYP_SHIFT, SET_VF_VBYP_MASK);
+	return;
+}
+#endif
+
+#if EN_BAT_DET_IRQ
+/* s2mu004 interrupt service routine */
+static irqreturn_t s2mu004_det_bat_isr(int irq, void *data)
+{
+	struct s2mu004_charger_data *charger = data;
+	u8 val;
+
+	s2mu004_read_reg(charger->i2c, S2MU004_CHG_STATUS3, &val);
+	if ((val & DET_BAT_STATUS_MASK) == 0)
+	{
+		s2mu004_enable_charger_switch(charger, 0);
+		pr_err("charger-off if battery removed \n");
+	}
+	return IRQ_HANDLED;
+}
+#endif
+
+static irqreturn_t s2mu004_done_isr(int irq, void *data)
+{
+	struct s2mu004_charger_data *charger = data;
+	u8 val;
+
+	s2mu004_read_reg(charger->i2c, S2MU004_CHG_STATUS1, &val);
+	pr_info("%s , %02x \n " , __func__, val);
+	if ( val & (DONE_STATUS_MASK) )
+	{
+		pr_err("add self chg done \n");
+		/* add chg done code here */
+	}
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t s2mu004_chg_isr(int irq, void *data)
+{
+	struct s2mu004_charger_data *charger = data;
+	union power_supply_propval value;
+	u8 val;
+
+	s2mu004_read_reg(charger->i2c, S2MU004_CHG_STATUS0, &val);
+	pr_info("%s , %02x\n " , __func__, val);
+#if EN_OVP_IRQ
+	if ((val & CHGIN_STATUS_MASK) == (2 << CHGIN_STATUS_SHIFT))	{
+		charger->ovp = true;
+		pr_info("%s: OVP triggered\n", __func__);
+		value.intval = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+		s2mu004_update_reg(charger->i2c, 0xBE, 0x10, 0x10);
+		psy_do_property("battery", set,
+			POWER_SUPPLY_PROP_HEALTH, value);
+	} else if ((val & CHGIN_STATUS_MASK) == (3 << CHGIN_STATUS_SHIFT) ||
+			(val & CHGIN_STATUS_MASK) == (5 << CHGIN_STATUS_SHIFT)) {
+		pr_info("%s: Vbus status 0x%x \n " , __func__, val);
+		charger->unhealth_cnt = HEALTH_DEBOUNCE_CNT;
+		if (charger->ovp == true)
+			pr_info("%s: recover from OVP\n", __func__);
+		charger->ovp = false;
+		value.intval = POWER_SUPPLY_HEALTH_GOOD;
+		s2mu004_update_reg(charger->i2c, 0xBE, 0x00, 0x10);
+		psy_do_property("battery", set,
+			POWER_SUPPLY_PROP_HEALTH, value);
+
+	}
+#endif
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t s2mu004_event_isr(int irq, void *data)
+{
+	return IRQ_HANDLED;
+}
+static irqreturn_t s2mu004_ovp_isr(int irq, void *data)
+{
+	pr_info("%s ovp!\n", __func__);
+
+	return IRQ_HANDLED;
+}
+
+#if defined(CONFIG_S2MU004_WIRELESS_CHARGER)
+static irqreturn_t s2mu004_chg_wpcin_isr(int irq, void *data)
+{
+	struct s2mu004_charger_data *charger = data;
+	unsigned long delay;
+
+	/* Mask WCIN to prevent frequent WPC interrupts */
+	s2mu004_update_reg(charger->i2c, S2MU004_REG_SC_INT1_MASK,
+		1 << WCIN_M_SHIFT, WCIN_M_MASK);
+
+#ifdef CONFIG_SAMSUNG_BATTERY_FACTORY
+	delay = msecs_to_jiffies(0);
+#else
+	if (charger->wc_w_state)
+		delay = msecs_to_jiffies(500);
+	else
+		delay = msecs_to_jiffies(0);
+#endif
+	pr_info("IRQ=%d delay = %ld\n", irq, delay);
+
+	wake_lock(&charger->wpc_wake_lock);
+	queue_delayed_work(charger->wqueue, &charger->wpc_work, delay);
+
+	return IRQ_HANDLED;
+}
+#endif
+
+static int s2mu004_charger_parse_dt(struct device *dev,	
+	struct s2mu004_charger_platform_data *pdata)
+{
+	struct device_node *np = of_find_node_by_name(NULL, "s2mu004-charger");
+	int ret = 0;
+
+	if (!np) {
+		pr_err("%s np NULL(s2mu004-charger)\n", __func__);
+	} else {
+		ret = of_property_read_u32(np, "battery,chg_switching_freq",
+			&pdata->chg_switching_freq);
+		if (ret < 0) {
+			pr_info("%s: Charger switching FRQ is Empty\n", __func__);
+		}
+	}
+
+	np = of_find_node_by_name(NULL, "battery");
+	if (!np) {
+		pr_err("%s np NULL\n", __func__);
+	} else {
+		int len;
+		unsigned int i;
+		const u32 *p;
+
+		ret = of_property_read_string(np,
+			"battery,fuelgauge_name",
+			(char const **)&pdata->fuelgauge_name);
+		if (ret < 0)
+			pr_info("%s: Fuel-gauge name is Empty\n", __func__);
+
+		ret = of_property_read_u32(np, "battery,chg_float_voltage",
+					   &pdata->chg_float_voltage);
+		if (ret) {
+			pr_info("%s: battery,chg_float_voltage is Empty\n", __func__);
+			pdata->chg_float_voltage = 4200;
+		}
+		pr_info("%s: battery,chg_float_voltage is %d\n",
+			__func__, pdata->chg_float_voltage);
+
+		ret = of_property_read_u32(np, "battery,full_check_type_2nd",
+				&pdata->full_check_type_2nd);
+		if (ret)
+			pr_info("%s : Full check type 2nd is Empty\n", __func__);
+
+		pdata->chg_eoc_dualpath = of_property_read_bool(np,
+				"battery,chg_eoc_dualpath");
+
+		p = of_get_property(np, "battery,input_current_limit", &len);
+		if (!p)
+			return 1;
+
+		len = len / sizeof(u32);
+
+		pdata->charging_current = 
+			kzalloc(sizeof(sec_charging_current_t) * len,
+				GFP_KERNEL);
+
+		for (i = 0; i < len; i++) {
+			ret = of_property_read_u32_index(np,
+					"battery,input_current_limit", i,
+					&pdata->charging_current[i].input_current_limit);
+			if (ret)
+				pr_info("%s : Input_current_limit is Empty\n",
+					__func__);
+
+			ret = of_property_read_u32_index(np,
+					"battery,fast_charging_current", i,
+					&pdata->charging_current[i].fast_charging_current);
+			if (ret)
+				pr_info("%s : Fast charging current is Empty\n",
+					__func__);
+
+			ret = of_property_read_u32_index(np,
+					"battery,full_check_current_1st", i,
+					&pdata->charging_current[i].full_check_current_1st);
+			if (ret)
+				pr_info("%s : Full check current 1st is Empty\n",
+					__func__);
+
+			ret = of_property_read_u32_index(np,
+					"battery,full_check_current_2nd", i,
+					&pdata->charging_current[i].full_check_current_2nd);
+			if (ret)
+				pr_info("%s : Full check current 2nd is Empty\n",
+					__func__);
+		}
+	}
+
+	np = of_find_node_by_name(NULL, "sec-multi-charger");
+	if (!np) {
+		pr_err("%s np NULL(sec-multi-charger)\n", __func__);
+	} else {
+		ret = of_property_read_string(np,
+				"charger,main_charger",
+				(char const **)&pdata->charger_name);
+		if (ret < 0)
+			pr_info("%s: Charger name is Empty\n", __func__);
+	}
+
+	pr_info("%s DT file parsed succesfully, %d\n", __func__, ret);
+	return ret;
+}
+
+/* if need to set s2mu004 pdata */
+static struct of_device_id s2mu004_charger_match_table[] = {
+	{ .compatible = "samsung,s2mu004-charger",},
+	{},
+};
+
+static int s2mu004_charger_probe(struct platform_device *pdev)
+{
+	struct s2mu004_dev *s2mu004 = dev_get_drvdata(pdev->dev.parent);
+	struct s2mu004_platform_data *pdata = dev_get_platdata(s2mu004->dev);
+	struct s2mu004_charger_data *charger;
+	int ret = 0;
+
+	pr_info("%s:[BATT] S2MU004 Charger driver probe\n", __func__);
+	charger = kzalloc(sizeof(*charger), GFP_KERNEL);
+	if (!charger)
+		return -ENOMEM;
+
+	mutex_init(&charger->charger_mutex);
+	charger->otg_on = false;
+
+	charger->dev = &pdev->dev;
+	charger->i2c = s2mu004->i2c;
+
+	charger->pdata = devm_kzalloc(&pdev->dev, sizeof(*(charger->pdata)),
+			GFP_KERNEL);
+	if (!charger->pdata) {
+		dev_err(&pdev->dev, "Failed to allocate memory\n");
+		ret = -ENOMEM;
+		goto err_parse_dt_nomem;
+	}
+	ret = s2mu004_charger_parse_dt(&pdev->dev, charger->pdata);
+	if (ret < 0)
+		goto err_parse_dt;
+
+	platform_set_drvdata(pdev, charger);
+
+	if (charger->pdata->charger_name == NULL)
+		charger->pdata->charger_name = "s2mu004-charger";
+	if (charger->pdata->fuelgauge_name == NULL)
+		charger->pdata->fuelgauge_name = "s2mu004-fuelgauge";
+
+	charger->psy_chg.name           = "s2mu004-charger";
+	charger->psy_chg.type           = POWER_SUPPLY_TYPE_UNKNOWN;
+	charger->psy_chg.get_property   = s2mu004_chg_get_property;
+	charger->psy_chg.set_property   = s2mu004_chg_set_property;
+	charger->psy_chg.properties     = s2mu004_charger_props;
+	charger->psy_chg.num_properties = ARRAY_SIZE(s2mu004_charger_props);
+	charger->psy_otg.name			= "otg";
+	charger->psy_otg.type			= POWER_SUPPLY_TYPE_OTG;
+	charger->psy_otg.get_property	= s2mu004_otg_get_property;
+	charger->psy_otg.set_property	= s2mu004_otg_set_property;
+	charger->psy_otg.properties		= s2mu004_otg_props;
+	charger->psy_otg.num_properties	= ARRAY_SIZE(s2mu004_otg_props);
+
+	s2mu004_chg_init(charger);
+	charger->input_current = s2mu004_get_input_current_limit(charger);
+	charger->charging_current = s2mu004_get_fast_charging_current(charger);
+
+	ret = power_supply_register(&pdev->dev, &charger->psy_chg);
+	if (ret) {
+		goto err_power_supply_register;
+	}
+
+	ret = power_supply_register(&pdev->dev, &charger->psy_otg);
+	if (ret) {
+		goto err_power_supply_register_otg;
+	}
+
+	charger->charger_wqueue = create_singlethread_workqueue("charger-wq");
+	if (!charger->charger_wqueue) {
+		pr_info("%s: failed to create wq.\n", __func__);
+		ret = -ESRCH;
+		goto err_create_wq;
+	}
+
+	/*
+	 * irq request
+	 * if you need to add irq , please refer below code.
+	 */
+	charger->irq_sys = pdata->irq_base + S2MU004_CHG1_IRQ_SYS;
+	ret = request_threaded_irq(charger->irq_sys, NULL,
+			s2mu004_ovp_isr, 0 , "sys-irq", charger);
+	if (ret < 0) {
+		dev_err(s2mu004->dev, "%s: Fail to request SYS in IRQ: %d: %d\n",
+					__func__, charger->irq_sys, ret);
+		goto err_reg_irq;
+	}
+
+#if EN_BAT_DET_IRQ
+	charger->irq_det_bat = pdata->irq_base + S2MU004_CHG2_IRQ_DET_BAT;
+	ret = request_threaded_irq(charger->irq_det_bat, NULL,
+			s2mu004_det_bat_isr, 0 , "det_bat-irq", charger);
+	if (ret < 0) {
+		dev_err(s2mu004->dev, "%s: Fail to request DET_BAT in IRQ: %d: %d\n",
+					__func__, charger->irq_det_bat, ret);
+		goto err_reg_irq;
+	}
+#endif
+
+	charger->irq_chgin = pdata->irq_base + S2MU004_CHG1_IRQ_CHGIN;
+	ret = request_threaded_irq(charger->irq_chgin, NULL,
+			s2mu004_chg_isr, 0 , "chgin-irq", charger);
+	if (ret < 0) {
+		dev_err(s2mu004->dev, "%s: Fail to request CHGIN in IRQ: %d: %d\n",
+					__func__, charger->irq_chgin, ret);
+		goto err_reg_irq;
+	}
+
+	charger->irq_rst = pdata->irq_base + S2MU004_CHG1_IRQ_CHG_RSTART;
+	ret = request_threaded_irq(charger->irq_rst, NULL,
+			s2mu004_chg_isr, 0 , "restart-irq", charger);
+	if (ret < 0) {
+		dev_err(s2mu004->dev, "%s: Fail to request CHG_Restart in IRQ: %d: %d\n",
+					__func__, charger->irq_rst, ret);
+		goto err_reg_irq;
+	}
+
+	charger->irq_done = pdata->irq_base + S2MU004_CHG1_IRQ_DONE;
+	ret = request_threaded_irq(charger->irq_done, NULL,
+			s2mu004_done_isr, 0 , "done-irq", charger);
+	if (ret < 0) {
+		dev_err(s2mu004->dev, "%s: Fail to request DONE in IRQ: %d: %d\n",
+					__func__, charger->irq_done, ret);
+		goto err_reg_irq;
+	}
+
+	charger->irq_chg_fault = pdata->irq_base + S2MU004_CHG1_IRQ_CHG_Fault;
+	ret = request_threaded_irq(charger->irq_chg_fault, NULL,
+			s2mu004_event_isr, 0 , "chg_fault-irq", charger);
+	if (ret < 0) {
+		dev_err(s2mu004->dev, "%s: Fail to request CHG_Fault in IRQ: %d: %d\n",
+					__func__, charger->irq_chg_fault, ret);
+		goto err_reg_irq;
+	}
+
+	ret = s2mu004_chg_create_attrs(charger->psy_chg.dev);
+	if (ret) {
+		dev_err(charger->dev,"%s : Failed to create_attrs\n", __func__);
+		goto err_reg_irq;
+	}
+#ifndef CONFIG_SEC_FACTORY
+	INIT_DELAYED_WORK(&charger->otg_vbus_work, s2mu004_charger_otg_vbus_work);
+#endif
+#if EN_TEST_READ
+	s2mu004_test_read(charger->i2c);
+#endif
+	pr_info("%s:[BATT] S2MU004 charger driver loaded OK\n", __func__);
+
+	return 0;
+
+err_create_wq:
+	destroy_workqueue(charger->charger_wqueue);
+err_reg_irq:
+	power_supply_unregister(&charger->psy_otg);
+err_power_supply_register_otg:
+	power_supply_unregister(&charger->psy_chg);
+err_power_supply_register:
+err_parse_dt:
+err_parse_dt_nomem:
+	mutex_destroy(&charger->charger_mutex);
+	kfree(charger);
+	return ret;
+}
+
+static int s2mu004_charger_remove(struct platform_device *pdev)
+{
+	struct s2mu004_charger_data *charger =
+		platform_get_drvdata(pdev);
+
+	power_supply_unregister(&charger->psy_chg);
+	mutex_destroy(&charger->charger_mutex);
+	kfree(charger);
+	return 0;
+}
+
+#if defined CONFIG_PM
+static int s2mu004_charger_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int s2mu004_charger_resume(struct device *dev)
+{
+	return 0;
+}
+#else
+#define s2mu004_charger_suspend NULL
+#define s2mu004_charger_resume NULL
+#endif
+
+static void s2mu004_charger_shutdown(struct device *dev)
+{
+	pr_info("%s: S2MU004 Charger driver shutdown\n", __func__);
+}
+
+static SIMPLE_DEV_PM_OPS(s2mu004_charger_pm_ops, s2mu004_charger_suspend,
+		s2mu004_charger_resume);
+
+static struct platform_driver s2mu004_charger_driver = {
+	.driver         = {
+		.name	= "s2mu004-charger",
+		.owner	= THIS_MODULE,
+		.of_match_table = s2mu004_charger_match_table,
+		.pm		= &s2mu004_charger_pm_ops,
+		.shutdown	=	s2mu004_charger_shutdown,
+	},
+	.probe          = s2mu004_charger_probe,
+	.remove		= s2mu004_charger_remove,
+};
+
+static int __init s2mu004_charger_init(void)
+{
+	int ret = 0;
+
+	ret = platform_driver_register(&s2mu004_charger_driver);
+
+	return ret;
+}
+module_init(s2mu004_charger_init);
+
+static void __exit s2mu004_charger_exit(void)
+{
+	platform_driver_unregister(&s2mu004_charger_driver);
+}
+module_exit(s2mu004_charger_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Samsung Electronics");
+MODULE_DESCRIPTION("Charger driver for S2MU004");
diff -Naur linux-3.18.14/drivers/battery_v2/s2mu004_fuelgauge.c samsung/drivers/battery_v2/s2mu004_fuelgauge.c
--- linux-3.18.14/drivers/battery_v2/s2mu004_fuelgauge.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/s2mu004_fuelgauge.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,2017 @@
+/*
+ * s2mu004_fuelgauge.c - S2MU004 Fuel Gauge Driver
+ *
+ * Copyright (C) 2016 Samsung Electronics Co.Ltd
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#define DEBUG
+
+#define SINGLE_BYTE	1
+#define TABLE_SIZE	22
+
+#include "include/fuelgauge/s2mu004_fuelgauge.h"
+#include <linux/of_gpio.h>
+#include <linux/sec_batt.h>
+
+static enum power_supply_property s2mu004_fuelgauge_props[] = {
+};
+
+static int s2mu004_get_vbat(struct s2mu004_fuelgauge_data *fuelgauge);
+static int s2mu004_get_ocv(struct s2mu004_fuelgauge_data *fuelgauge);
+static int s2mu004_get_current(struct s2mu004_fuelgauge_data *fuelgauge);
+static int s2mu004_get_avgcurrent(struct s2mu004_fuelgauge_data *fuelgauge);
+static int s2mu004_get_avgvbat(struct s2mu004_fuelgauge_data *fuelgauge);
+static int s2mu004_get_monout_avgvbat(struct s2mu004_fuelgauge_data *fuelgauge);
+
+static int s2mu004_write_reg_byte(struct i2c_client *client, int reg, u8 data)
+{
+	int ret, i = 0;
+
+	ret = i2c_smbus_write_byte_data(client, reg,  data);
+	if (ret < 0) {
+		for (i = 0; i < 3; i++) {
+			ret = i2c_smbus_write_byte_data(client, reg,  data);
+			if (ret >= 0)
+				break;
+		}
+
+		if (i >= 3)
+			dev_err(&client->dev, "%s: Error(%d)\n", __func__, ret);
+	}
+
+	return ret;
+}
+
+static int s2mu004_write_reg(struct i2c_client *client, int reg, u8 *buf)
+{
+#if SINGLE_BYTE
+	int ret = 0 ;
+	s2mu004_write_reg_byte(client, reg, buf[0]);
+	s2mu004_write_reg_byte(client, reg+1, buf[1]);
+#else
+	int ret, i = 0;
+
+	ret = i2c_smbus_write_i2c_block_data(client, reg, 2, buf);
+	if (ret < 0) {
+		for (i = 0; i < 3; i++) {
+			ret = i2c_smbus_write_i2c_block_data(client, reg, 2, buf);
+			if (ret >= 0)
+				break;
+		}
+
+		if (i >= 3)
+			dev_err(&client->dev, "%s: Error(%d)\n", __func__, ret);
+	}
+#endif
+	return ret;
+}
+
+static int s2mu004_read_reg_byte(struct i2c_client *client, int reg, void *data)
+{
+	int ret = 0;
+
+	ret = i2c_smbus_read_byte_data(client, reg);
+	if (ret < 0)
+		return ret;
+	*(u8 *)data = (u8)ret;
+
+	return ret;
+}
+
+static int s2mu004_read_reg(struct i2c_client *client, int reg, u8 *buf)
+{
+
+#if SINGLE_BYTE
+	int ret =0;
+	u8 data1 = 0 , data2 = 0;
+	s2mu004_read_reg_byte(client, reg, &data1);
+	s2mu004_read_reg_byte(client, reg+1, &data2);
+	buf[0] = data1;
+	buf[1] = data2;
+#else
+	int ret = 0, i = 0;
+
+	ret = i2c_smbus_read_i2c_block_data(client, reg, 2, buf);
+	if (ret < 0) {
+		for (i = 0; i < 3; i++) {
+			ret = i2c_smbus_read_i2c_block_data(client, reg, 2, buf);
+			if (ret >= 0)
+				break;
+		}
+
+		if (i >= 3)
+			dev_err(&client->dev, "%s: Error(%d)\n", __func__, ret);
+	}
+#endif
+	return ret;
+}
+
+static void s2mu004_fg_test_read(struct i2c_client *client)
+{
+	u8 data;
+	char str[1016] = {0,};
+	int i;
+
+	/* address 0x00 ~ 0x1f */
+	for (i = 0x0; i <= 0x1F; i++) {
+		s2mu004_read_reg_byte(client, i, &data);
+		sprintf(str+strlen(str), "0x%02x:0x%02x, ", i, data);
+	}
+	
+	/* address 0x25 */
+	s2mu004_read_reg_byte(client, 0x25, &data);
+	sprintf(str+strlen(str),"0x25:0x%02x, ",data);
+
+	/* address 0x27 */
+	s2mu004_read_reg_byte(client, 0x27, &data);
+	sprintf(str+strlen(str),"0x27:0x%02x, ",data);
+
+	/* print buffer */
+	pr_info("[FG]%s: %s\n", __func__, str);
+}
+
+static void WA_0_issue_at_init(struct s2mu004_fuelgauge_data *fuelgauge)
+{
+	int a = 0;
+	u8 v_4e = 0, v_4f =0, temp1, temp2;
+	int FG_volt, UI_volt, offset;
+	u8 v_40 = 0;
+	u8 temp_REG26 = 0, temp_REG27 = 0, temp = 0;
+	u8 data[2], r_data[2];
+
+	mutex_lock(&fuelgauge->fg_lock);
+
+	s2mu004_read_reg(fuelgauge->i2c, S2MU004_REG_IRQ, data);
+	pr_info("%s: irq_reg data (%02x%02x)  \n",__func__, data[1], data[0]);
+
+	/* store data for interrupt mask */
+	r_data[0] = data[0];
+	r_data[1] = data[1];
+
+	/* disable irq for unwanted interrupt */
+	data[1] |= 0x0f;
+	s2mu004_write_reg(fuelgauge->i2c, S2MU004_REG_IRQ, data);
+
+	/* Step 1: [Surge test]  get UI voltage (0.1mV)*/
+	UI_volt = s2mu004_get_ocv(fuelgauge);
+
+	/* current fix for soc */
+	s2mu004_read_reg_byte(fuelgauge->i2c, 0x27, &temp_REG27);
+	temp=temp_REG27;
+	temp |= 0x0F;
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x27, temp);
+
+	s2mu004_read_reg_byte(fuelgauge->i2c, 0x26, &temp_REG26);
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x26, 0xFF);
+
+	/* avgvbat factor value set to 0xFF  */
+	s2mu004_read_reg_byte(fuelgauge->i2c, 0x40, &v_40);
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x40, 0xFF);
+
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x1E, 0x0F);
+	msleep(50);
+
+	/* Step 2: [Surge test] get FG voltage (0.1mV) */
+	FG_volt = s2mu004_get_vbat(fuelgauge) * 10;
+
+	/* Step 3: [Surge test] get offset */
+	offset = UI_volt - FG_volt;
+	pr_err("%s: UI_volt(%d), FG_volt(%d), offset(%d)\n",
+			__func__, UI_volt, FG_volt, offset);
+
+	/* Step 4: [Surge test] */
+	s2mu004_read_reg_byte(fuelgauge->i2c, 0x4f, &v_4f);
+	s2mu004_read_reg_byte(fuelgauge->i2c, 0x4e, &v_4e);
+	pr_err("%s: v_4f(0x%x), v_4e(0x%x)\n", __func__, v_4f, v_4e);
+
+	a = (v_4f & 0x0F) << 8;
+	a += v_4e;
+	pr_err("%s: a before add offset (0x%x)\n", __func__, a);
+
+	/* 2`s complement */
+	if (a & (0x01 << 11))
+		a = ( -10000 * ((a^0xFFF) +1)) >> 13;
+	else
+		a = ( 10000 * a ) >> 13;
+
+	a = a + offset;
+	pr_err("%s: a after add offset (0x%x)\n", __func__, a);
+
+	/* limit upper/lower offset */
+	if (a > 2490)
+		a = 2490;
+	
+	if (a < (-2490))
+		a = -2490;
+
+	a = (a << 13) / 10000;
+	if (a < 0)
+		a = -1*((a^0xFFF)+1);
+
+	pr_err("%s: a after add offset (0x%x)\n", __func__, a);
+
+	a &= 0xfff;
+	pr_err("%s: (a)&0xFFF (0x%x)\n", __func__, a);
+
+	/* modify 0x4f[3:0] */
+	temp1 = v_4f & 0xF0;
+	temp2 = (u8)((a&0xF00) >> 8);
+	temp1 |= temp2;
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x4f, temp1);
+
+	/* modify 0x4e[7:0] */
+	temp2 = (u8)(a & 0xFF);
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x4e, temp2);
+
+	/* restart and dumpdone */
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x1E, 0x0F);
+	msleep(300);
+
+	/* restore current register */
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x27, temp_REG27);
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x26, temp_REG26);
+
+	/* recovery 0x4e and 0x4f */
+	s2mu004_read_reg_byte(fuelgauge->i2c, 0x4f, &temp1);
+	temp1 &= 0xF0;
+	temp1 |= (v_4f & 0x0F);
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x4f, temp1);
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x4e, v_4e);
+
+	/* restore monout avgvbat factor value */
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x40, v_40);
+
+	/* enable irq after reset */
+	s2mu004_write_reg(fuelgauge->i2c, S2MU004_REG_IRQ, r_data);
+	pr_info("%s: re-store irq_reg data (%02x%02x) \n",__func__, r_data[1], r_data[0]);
+
+	mutex_unlock(&fuelgauge->fg_lock);
+}
+
+static int s2mu004_get_soc_from_ocv(struct s2mu004_fuelgauge_data *fuelgauge, int target_ocv)
+{
+	/* 22 values of mapping table for EVT1*/
+
+	int *soc_arr;
+	int *ocv_arr;
+	int soc = 0;
+	int ocv = target_ocv * 10;
+
+	int high_index = TABLE_SIZE - 1;
+	int low_index = 0;
+	int mid_index = 0;
+
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	soc_arr = fuelgauge->age_data_info[fuelgauge->fg_age_step].soc_arr_val;
+	ocv_arr = fuelgauge->age_data_info[fuelgauge->fg_age_step].ocv_arr_val;
+#else
+	soc_arr = fuelgauge->info.soc_arr_val;
+	ocv_arr = fuelgauge->info.ocv_arr_val;
+#endif
+
+	pr_err("%s: soc_arr(%d) ocv_arr(%d)\n", __func__,*soc_arr, *ocv_arr);
+
+	if(ocv <= ocv_arr[TABLE_SIZE - 1]) {
+		soc = soc_arr[TABLE_SIZE - 1];
+		goto soc_ocv_mapping;
+	} else if (ocv >= ocv_arr[0]) {
+		soc = soc_arr[0];
+		goto soc_ocv_mapping;
+	}
+	while (low_index <= high_index) {
+		mid_index = (low_index + high_index) >> 1;
+		if(ocv_arr[mid_index] > ocv)
+			low_index = mid_index + 1;
+		else if(ocv_arr[mid_index] < ocv)
+			high_index = mid_index - 1;
+		else {
+			soc = soc_arr[mid_index];
+			goto soc_ocv_mapping;
+		}
+	}
+	soc = soc_arr[high_index];
+	soc += ((soc_arr[low_index] - soc_arr[high_index]) *
+					(ocv - ocv_arr[high_index])) /
+					(ocv_arr[low_index] - ocv_arr[high_index]);
+
+soc_ocv_mapping:
+	dev_info(&fuelgauge->i2c->dev, "%s: ocv (%d), soc (%d)\n", __func__, ocv, soc);
+	return soc;
+}
+
+static void WA_0_issue_at_init1(struct s2mu004_fuelgauge_data *fuelgauge, int target_ocv)
+{
+	int a = 0;
+	u8 v_4e = 0, v_4f =0, temp1, temp2;
+	int FG_volt, UI_volt, offset;
+	u8 v_40 = 0;
+	u8 temp_REG26 = 0, temp_REG27 = 0, temp = 0;
+
+	mutex_lock(&fuelgauge->fg_lock);
+
+	/* Step 1: [Surge test]  get UI voltage (0.1mV)*/
+	UI_volt = target_ocv * 10;
+
+	/* avgvbat factor value set to 0xFF  */
+	s2mu004_read_reg_byte(fuelgauge->i2c, 0x40, &v_40);
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x40, 0xFF);
+
+	/* current fix for soc */
+	s2mu004_read_reg_byte(fuelgauge->i2c, 0x27, &temp_REG27);
+	temp=temp_REG27;
+	temp |= 0x0F;
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x27, temp);
+
+	s2mu004_read_reg_byte(fuelgauge->i2c, 0x26, &temp_REG26);
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x26, 0xFF);
+	
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x1E, 0x0F);
+	msleep(50);
+
+	/* Step 2: [Surge test] get FG voltage (0.1mV) */
+	FG_volt = s2mu004_get_vbat(fuelgauge) * 10;
+
+	/* Step 3: [Surge test] get offset */
+	offset = UI_volt - FG_volt;
+	pr_err("%s: UI_volt(%d), FG_volt(%d), offset(%d)\n",
+			__func__, UI_volt, FG_volt, offset);
+
+	/* Step 4: [Surge test] */
+	s2mu004_read_reg_byte(fuelgauge->i2c, 0x4f, &v_4f);
+	s2mu004_read_reg_byte(fuelgauge->i2c, 0x4e, &v_4e);
+	pr_err("%s: v_4f(0x%x), v_4e(0x%x)\n", __func__, v_4f, v_4e);
+
+	a = (v_4f & 0x0F) << 8;
+	a += v_4e;
+	pr_err("%s: a before add offset (0x%x)\n", __func__, a);
+
+	/* 2`s complement */
+	if (a & (0x01 << 11))
+		a = ( -10000 * ((a^0xFFF) +1)) >> 13;
+	else
+		a = (10000 * a) >> 13;
+
+	a = a + offset;
+	pr_err("%s: a after add offset (0x%x)\n", __func__, a);
+
+	/* limit upper/lower offset */
+	if (a > 2490)
+		a = 2490;
+	
+	if (a < (-2490))
+		a = -2490;
+
+	a = (a << 13) / 10000;
+	if (a < 0)
+		a = -1*((a^0xFFF)+1);
+
+	pr_err("%s: a after add offset (0x%x)\n", __func__, a);
+
+	a &= 0xfff;
+	pr_err("%s: (a)&0xFFF (0x%x)\n", __func__, a);
+
+	/* modify 0x4f[3:0] */
+	temp1 = v_4f & 0xF0;
+	temp2 = (u8)((a&0xF00) >> 8);
+	temp1 |= temp2;
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x4f, temp1);
+
+	/* modify 0x4e[7:0] */
+	temp2 = (u8)(a & 0xFF);
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x4e, temp2);
+
+	/* restart and dumpdone */
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x1E, 0x0F);
+	msleep(300);
+
+	/* restore current register */
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x27, temp_REG27);
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x26, temp_REG26);
+
+	pr_info("%s: S2MU004 VBAT : %d\n", __func__, s2mu004_get_vbat(fuelgauge) * 10);
+
+	/* recovery 0x4e and 0x4f */
+	s2mu004_read_reg_byte(fuelgauge->i2c, 0x4f, &temp1);
+	temp1 &= 0xF0;
+	temp1 |= (v_4f & 0x0F);
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x4f, temp1);
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x4e, v_4e);
+
+	/* restore monout avgvbat factor value */
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x40, v_40);
+
+	mutex_unlock(&fuelgauge->fg_lock);
+}
+
+
+static void s2mu004_reset_fg(struct s2mu004_fuelgauge_data *fuelgauge)
+{
+	int i;
+	u8 temp = 0;
+
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	mutex_lock(&fuelgauge->fg_lock);
+#endif
+	/* step 0: [Surge test] initialize register of FG */
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x0E, fuelgauge->age_data_info[fuelgauge->fg_age_step].batcap[0]);
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x0F, fuelgauge->age_data_info[fuelgauge->fg_age_step].batcap[1]);
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x10, fuelgauge->age_data_info[fuelgauge->fg_age_step].batcap[2]);
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x11, fuelgauge->age_data_info[fuelgauge->fg_age_step].batcap[3]);
+
+	for(i = 0x92; i <= 0xe9; i++) {
+		s2mu004_write_reg_byte(fuelgauge->i2c, i, fuelgauge->age_data_info[fuelgauge->fg_age_step].battery_table3[i - 0x92]);
+	}
+	for(i = 0xea; i <= 0xff; i++) {
+		s2mu004_write_reg_byte(fuelgauge->i2c, i, fuelgauge->age_data_info[fuelgauge->fg_age_step].battery_table4[i - 0xea]);
+	}
+#else
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x0E, fuelgauge->info.batcap[0]);
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x0F, fuelgauge->info.batcap[1]);
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x10, fuelgauge->info.batcap[2]);
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x11, fuelgauge->info.batcap[3]);
+
+	for(i = 0x92; i <= 0xe9; i++) {
+		s2mu004_write_reg_byte(fuelgauge->i2c, i, fuelgauge->info.battery_table3[i - 0x92]);
+	}
+	for(i = 0xea; i <= 0xff; i++) {
+		s2mu004_write_reg_byte(fuelgauge->i2c, i, fuelgauge->info.battery_table4[i - 0xea]);
+	}
+#endif
+
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x21, 0x13);
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x14, 0x40);
+
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	s2mu004_read_reg_byte(fuelgauge->i2c, 0x45, &temp);
+	temp &= 0xF0;
+	temp |= fuelgauge->age_data_info[fuelgauge->fg_age_step].accum[0];
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x45, temp);
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x44, fuelgauge->age_data_info[fuelgauge->fg_age_step].accum[1]);
+#else
+	s2mu004_read_reg_byte(fuelgauge->i2c, 0x45, &temp);
+	temp &= 0xF0;
+	temp |= fuelgauge->info.accum[0];
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x45, temp);
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x44, fuelgauge->info.accum[1]);
+#endif
+
+	s2mu004_read_reg_byte(fuelgauge->i2c, 0x27, &temp);
+	temp |= 0x10;
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x27, temp);
+
+	/* Interrupt source reference at mixed mode */
+	s2mu004_read_reg_byte(fuelgauge->i2c, 0x43, &temp);
+	temp &= 0xF3;
+	temp |= 0x08;
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x43, temp);
+
+	/* Charger top off current sensing method change for int. 0x49[7]=0 */
+	s2mu004_read_reg_byte(fuelgauge->i2c, 0x49, &temp);
+	temp &= 0x7F;
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x49, temp);
+
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x4B, 0x0B);
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x4A, 0x10);
+
+	s2mu004_read_reg_byte(fuelgauge->i2c, 0x03, &temp);
+	temp |= 0x10;
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x03, temp);
+
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x40, 0x08);
+
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	mutex_unlock(&fuelgauge->fg_lock);
+#endif
+
+	WA_0_issue_at_init(fuelgauge);
+
+	pr_err("%s: Reset FG completed\n", __func__);
+}
+
+static void s2mu004_restart_gauging(struct s2mu004_fuelgauge_data *fuelgauge)
+{
+	u8 temp=0, temp_REG26=0, temp_REG27=0;
+	u8 data[2], r_data[2];
+	u8 v_40;
+	pr_err("%s: Re-calculate SOC and voltage\n", __func__);
+
+	mutex_lock(&fuelgauge->fg_lock);
+
+	s2mu004_read_reg(fuelgauge->i2c, S2MU004_REG_IRQ, data);
+	pr_info("%s: irq_reg data (%02x%02x)  \n",__func__, data[1], data[0]);
+
+	/* store data for interrupt mask */
+	r_data[0] = data[0];
+	r_data[1] = data[1];
+
+	/* disable irq for unwanted interrupt */
+	data[1] |= 0x0f;
+	s2mu004_write_reg(fuelgauge->i2c, S2MU004_REG_IRQ, data);
+
+	s2mu004_read_reg_byte(fuelgauge->i2c, 0x27, &temp_REG27);
+	temp=temp_REG27;
+	temp |= 0x0F;
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x27, temp);
+
+	s2mu004_read_reg_byte(fuelgauge->i2c, 0x26, &temp_REG26);
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x26, 0xFF);
+
+	/* avgvbat factor value set to 0xFF  */
+	s2mu004_read_reg_byte(fuelgauge->i2c, 0x40, &v_40);
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x40, 0xFF);
+
+	/* restart gauge */
+	//s2mu004_write_reg_byte(fuelgauge->i2c, 0x1f, 0x01);
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x21, 0x13);
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x1E, 0x0F);
+
+	msleep(300);
+
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x27, temp_REG27);
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x26, temp_REG26);
+
+	s2mu004_read_reg_byte(fuelgauge->i2c, 0x27, &temp);
+	pr_info("%s: 0x27 : %02x \n", __func__,temp);
+	s2mu004_read_reg_byte(fuelgauge->i2c, 0x26, &temp);
+	pr_info("%s: 0x26 : %02x \n", __func__,temp);
+
+	/* restore monout avgvbat factor value */
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x40, v_40);
+
+	/* enable irq after reset */
+	s2mu004_write_reg(fuelgauge->i2c, S2MU004_REG_IRQ, r_data);
+	pr_info("%s: re-store irq_reg data (%02x%02x) \n",__func__, r_data[1], r_data[0]);
+
+	mutex_unlock(&fuelgauge->fg_lock);
+}
+
+static void s2mu004_init_regs(struct s2mu004_fuelgauge_data *fuelgauge)
+{
+	u8 temp = 0;
+	pr_err("%s: s2mu004 fuelgauge initialize\n", __func__);
+
+	/* Reduce top-off current difference between
+	 * Power on charging and Power off charging
+	 */
+	s2mu004_read_reg_byte(fuelgauge->i2c, 0x27, &temp);
+	temp |= 0x10;
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x27, temp);
+
+	/* Interrupt source reference at mixed mode */
+	s2mu004_read_reg_byte(fuelgauge->i2c, 0x43, &temp);
+	temp &= 0xF3;
+	temp |= 0x08;
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x43, temp);
+
+	/* Charger top off current sensing method change for int. 0x49[7]=0 */
+	s2mu004_read_reg_byte(fuelgauge->i2c, 0x49, &temp);
+	temp &= 0x7F;
+	s2mu004_write_reg_byte(fuelgauge->i2c, 0x49, temp);
+
+	s2mu004_read_reg_byte(fuelgauge->i2c, 0x4F, &temp);
+	fuelgauge->reg_OTP_4F = temp;
+	s2mu004_read_reg_byte(fuelgauge->i2c, 0x4E, &temp);
+	fuelgauge->reg_OTP_4E = temp;
+}
+
+static void s2mu004_alert_init(struct s2mu004_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+
+	/* VBAT Threshold setting */
+	data[0] = ((fuelgauge->pdata->fuel_alert_vol - 2800) / 50) & 0x0f;
+
+	/* SOC Threshold setting */
+	data[0] = data[0] | (fuelgauge->pdata->fuel_alert_soc << 4);
+
+	data[1] = 0x00;
+	s2mu004_write_reg(fuelgauge->i2c, S2MU004_REG_IRQ_LVL, data);
+
+	pr_info("%s: irq_lvl(vbat:0x%x, soc:0x%x)\n",__func__, data[0] & 0x0F, data[0] & 0xF0);
+}
+
+static int s2mu004_set_temperature(struct s2mu004_fuelgauge_data *fuelgauge,
+			int temperature)
+{
+	/*
+	 * s5mu005 include temperature sensor so,
+	 * do not need to set temperature value.
+	 */
+	return temperature;
+}
+
+static int s2mu004_get_temperature(struct s2mu004_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u16 compliment;
+	s32 temperature = 0;
+
+	/*
+	 *  use monitor regiser.
+	 *  monitor register default setting is temperature
+	 */
+	mutex_lock(&fuelgauge->fg_lock);
+
+	s2mu004_write_reg_byte(fuelgauge->i2c, S2MU004_REG_MONOUT_SEL, 0x10);
+	if (s2mu004_read_reg(fuelgauge->i2c, S2MU004_REG_MONOUT, data) < 0)
+		goto err;
+
+	mutex_unlock(&fuelgauge->fg_lock);
+	compliment = (data[1] << 8) | (data[0]);
+
+	/* data[] store 2's compliment format number */
+	if (compliment & (0x1 << 15)) {
+		/* Negative */
+		temperature = -1 * ((~compliment & 0xFFFF) + 1);
+	} else {
+		temperature = compliment & 0x7FFF;
+	}
+	temperature = ((temperature * 100) >> 8)/10;
+
+	dev_dbg(&fuelgauge->i2c->dev, "%s: temperature (%d)\n",
+		__func__, temperature);
+
+	return temperature;
+
+err:
+	mutex_unlock(&fuelgauge->fg_lock);
+	return -ERANGE;
+}
+
+static int s2mu004_get_rawsoc(struct s2mu004_fuelgauge_data *fuelgauge)
+{
+	u8 data[2], check_data[2];
+	u16 compliment;
+	int rsoc, i;
+	u8 por_state = 0;
+	u8 reg = S2MU004_REG_RSOC;
+	u8 reg_OTP_4E = 0, reg_OTP_4F = 0;
+	int fg_reset = 0;
+	bool charging_enabled = false;
+	union power_supply_propval value;
+	int rbat = 0;
+
+	int avg_current = 0, avg_vbat = 0, vbat = 0, curr = 0, avg_monout_vbat = 0;
+	int ocv_pwroff = 0, ocv_pwr_voltagemode =0;
+	int target_soc = 0;
+
+	/* SOC VM Monitoring For debugging SOC error */
+	u8 r_monoutsel;
+	u8 mount_data[2];
+	u32 mount_compliment;
+	int rvmsoc;
+#if !defined(CONFIG_SEC_FACTORY)	
+	int info_soc;
+#endif
+
+	s2mu004_read_reg_byte(fuelgauge->i2c, 0x1F, &por_state);
+	s2mu004_read_reg_byte(fuelgauge->i2c, 0x4F, &reg_OTP_4F);
+	s2mu004_read_reg_byte(fuelgauge->i2c, 0x4E, &reg_OTP_4E);
+
+	dev_err(&fuelgauge->i2c->dev, "%s: OTP 4E(%02x) 4F(%02x) current 4E(%02x) 4F(%02x) \n",
+			__func__, fuelgauge->reg_OTP_4E, fuelgauge->reg_OTP_4F, reg_OTP_4E, reg_OTP_4F);
+
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	if( ((por_state & 0x10) && (fuelgauge->age_reset_status == 0)) ||
+#else
+	if((por_state & 0x10) ||
+#endif
+	   (fuelgauge->probe_done == true &&
+		(fuelgauge->reg_OTP_4E != reg_OTP_4E || fuelgauge->reg_OTP_4F != reg_OTP_4F))) {
+		
+		/* check charging enable */
+		psy_do_property("s2mu004-charger", get, POWER_SUPPLY_PROP_CHARGING_ENABLED, value);
+		charging_enabled = value.intval;
+
+		value.intval = SEC_BAT_CHG_MODE_CHARGING_OFF;
+		psy_do_property("s2mu004-charger", set, POWER_SUPPLY_PROP_CHARGING_ENABLED, value);
+
+		if (fuelgauge->reg_OTP_4E != reg_OTP_4E || fuelgauge->reg_OTP_4F != reg_OTP_4F) {
+			psy_do_property("s2mu004-charger", set, POWER_SUPPLY_EXT_PROP_FUELGAUGE_RESET, value);
+
+			s2mu004_write_reg_byte(fuelgauge->i2c, 0x1F, 0x40);
+			msleep(50);
+			s2mu004_write_reg_byte(fuelgauge->i2c, 0x1F, 0x01);
+
+			s2mu004_read_reg_byte(fuelgauge->i2c, 0x4F, &reg_OTP_4F);
+			s2mu004_read_reg_byte(fuelgauge->i2c, 0x4E, &reg_OTP_4E);
+
+			dev_err(&fuelgauge->i2c->dev, "1st reset after %s: OTP 4E(%02x) 4F(%02x) current 4E(%02x) 4F(%02x) \n",
+				__func__, fuelgauge->reg_OTP_4E, fuelgauge->reg_OTP_4F, reg_OTP_4E, reg_OTP_4F);
+
+			if (fuelgauge->reg_OTP_4E != reg_OTP_4E || fuelgauge->reg_OTP_4F != reg_OTP_4F) {
+				psy_do_property("s2mu004-charger", set, POWER_SUPPLY_EXT_PROP_FUELGAUGE_RESET, value);
+
+				s2mu004_write_reg_byte(fuelgauge->i2c, 0x1F, 0x40);
+				msleep(50);
+				s2mu004_write_reg_byte(fuelgauge->i2c, 0x1F, 0x01);
+				dev_err(&fuelgauge->i2c->dev, "%s : 2st reset \n", __func__);
+			}
+		}
+
+		dev_info(&fuelgauge->i2c->dev, "%s: FG reset\n", __func__);
+		s2mu004_reset_fg(fuelgauge);
+		por_state &= ~0x10;
+		s2mu004_write_reg_byte(fuelgauge->i2c, 0x1F, por_state);
+
+		fg_reset = 1;
+	}
+
+	mutex_lock(&fuelgauge->fg_lock);
+
+	reg = S2MU004_REG_RSOC;
+
+	for (i = 0; i < 50; i++) {
+		if (s2mu004_read_reg(fuelgauge->i2c, reg, data) < 0)
+			goto err;
+		if (s2mu004_read_reg(fuelgauge->i2c, reg, check_data) < 0)
+			goto err;
+
+		dev_dbg(&fuelgauge->i2c->dev, "[DEBUG]%s: data0 (%d) data1 (%d) \n", __func__, data[0], data[1]);
+		if ((data[0] == check_data[0]) && (data[1] == check_data[1]))
+			break;
+	}
+
+	/* SOC VM Monitoring For debugging SOC error */
+	s2mu004_read_reg_byte(fuelgauge->i2c, S2MU004_REG_MONOUT_SEL, &r_monoutsel);
+	s2mu004_write_reg_byte(fuelgauge->i2c, S2MU004_REG_MONOUT_SEL, 0x02);
+	mdelay(10);
+	s2mu004_read_reg(fuelgauge->i2c, S2MU004_REG_MONOUT, mount_data);
+
+	s2mu004_write_reg_byte(fuelgauge->i2c, S2MU004_REG_MONOUT_SEL, r_monoutsel);
+	
+	mutex_unlock(&fuelgauge->fg_lock);
+
+	/* SOC VM Monitoring For debugging SOC error */
+	mount_compliment  = ((mount_data[0] + (mount_data[1] << 8)) * 10000) >> 12;
+	rvmsoc = mount_compliment;
+
+	dev_dbg(&fuelgauge->i2c->dev, "%s: vm soc raw data0 (%d) data1 (%d) \n", __func__, mount_data[0], mount_data[1]);
+	dev_info(&fuelgauge->i2c->dev, "%s: vm soc (%d) \n",__func__, rvmsoc);
+
+	if (fg_reset && charging_enabled) {
+		value.intval = SEC_BAT_CHG_MODE_CHARGING;
+		psy_do_property("s2mu004-charger", set, POWER_SUPPLY_PROP_CHARGING_ENABLED, value);
+	}
+
+	compliment = (data[1] << 8) | (data[0]);
+
+	/* data[] store 2's compliment format number */
+	if (compliment & (0x1 << 15)) {
+		/* Negative */
+		rsoc = ((~compliment) & 0xFFFF) + 1;
+		rsoc = (rsoc * (-10000)) / (0x1 << 14);
+	} else {
+		rsoc = compliment & 0x7FFF;
+		rsoc = ((rsoc * 10000) / (0x1 << 14));
+	}
+
+	if (fg_reset)
+		fuelgauge->diff_soc = fuelgauge->info.soc - rsoc;
+
+	dev_info(&fuelgauge->i2c->dev, "%s: current_soc (%d), previous soc (%d), diff (%d), FG_mode(%d)\n",
+		 __func__, rsoc, fuelgauge->info.soc, fuelgauge->diff_soc, fuelgauge->mode);
+
+	fuelgauge->info.soc = rsoc + fuelgauge->diff_soc;
+
+	avg_current = s2mu004_get_avgcurrent(fuelgauge);
+	avg_monout_vbat =  s2mu004_get_monout_avgvbat(fuelgauge);
+	ocv_pwr_voltagemode = avg_monout_vbat - avg_current*30 /100;
+
+	if(avg_current < (-500))
+		rbat = 10;
+	else
+		rbat = 30;
+
+	ocv_pwr_voltagemode = avg_monout_vbat - avg_current*rbat /100;
+
+	/* switch to voltage mocd for accuracy */
+	if ((fuelgauge->info.soc <= 300) || ((ocv_pwr_voltagemode <= 3600) && (avg_current < 10))) {
+		if(fuelgauge->mode == CURRENT_MODE) { /* switch to VOLTAGE_MODE */
+			fuelgauge->mode = LOW_SOC_VOLTAGE_MODE;
+
+			s2mu004_write_reg_byte(fuelgauge->i2c, 0x4A, 0xFF);
+
+			dev_info(&fuelgauge->i2c->dev, "%s: FG is in low soc voltage mode\n", __func__);
+		}
+	}
+	else if ((fuelgauge->info.soc > 325) && ((ocv_pwr_voltagemode > 3650) || (avg_current >= 10))) {
+		if(fuelgauge->mode == LOW_SOC_VOLTAGE_MODE) {
+			fuelgauge->mode = CURRENT_MODE;
+
+			s2mu004_write_reg_byte(fuelgauge->i2c, 0x4A, 0x10);
+
+			dev_info(&fuelgauge->i2c->dev, "%s: FG is in current mode\n", __func__);
+		}
+	}
+
+	psy_do_property("battery", get, POWER_SUPPLY_PROP_CAPACITY, value);
+	dev_info(&fuelgauge->i2c->dev, "%s: UI SOC = %d\n", __func__, value.intval);
+
+	if (value.intval >= 98) {
+		if(fuelgauge->mode == CURRENT_MODE) { /* switch to VOLTAGE_MODE */
+			fuelgauge->mode = HIGH_SOC_VOLTAGE_MODE;
+
+			s2mu004_write_reg_byte(fuelgauge->i2c, 0x4A, 0xFF);
+
+			dev_info(&fuelgauge->i2c->dev, "%s: FG is in high soc voltage mode\n", __func__);
+		}
+	}
+	else if (value.intval < 97) {
+		if(fuelgauge->mode == HIGH_SOC_VOLTAGE_MODE) {
+			fuelgauge->mode = CURRENT_MODE;
+
+			s2mu004_write_reg_byte(fuelgauge->i2c, 0x4A, 0x10);
+
+			dev_info(&fuelgauge->i2c->dev, "%s: FG is in current mode\n", __func__);
+		}
+	}
+
+	avg_vbat =  s2mu004_get_avgvbat(fuelgauge);
+	vbat = s2mu004_get_vbat(fuelgauge);
+	curr = s2mu004_get_current(fuelgauge);
+
+	if (((avg_current < (-17)) && (curr < (-17))) &&
+		((avg_monout_vbat - avg_current*rbat /100) <= 3500) && (fuelgauge->info.soc > 100)) {
+		ocv_pwroff = 3300;
+		target_soc = s2mu004_get_soc_from_ocv(fuelgauge, ocv_pwroff);
+		pr_info("%s : F/G reset Start - current flunctuation\n", __func__);
+		WA_0_issue_at_init1(fuelgauge, ocv_pwroff);
+	} else if (avg_current < (-60) && avg_vbat <= 3300) {
+		if (fuelgauge->mode == CURRENT_MODE) {
+			if (abs(avg_vbat - vbat) <= 20 && abs(avg_current - curr) <= 30) {
+				ocv_pwroff = avg_vbat - avg_current * 15 / 100;
+				target_soc = s2mu004_get_soc_from_ocv(fuelgauge, ocv_pwroff);
+				if (abs(target_soc - fuelgauge->info.soc) > 300) {
+					pr_info("%s : F/G reset Start - current mode: %d\n", __func__, target_soc);
+					WA_0_issue_at_init1(fuelgauge, ocv_pwroff);
+
+				}
+			}
+		} else {
+			if (abs(avg_vbat - vbat) <= 20) {
+				ocv_pwroff = avg_vbat;
+				target_soc = s2mu004_get_soc_from_ocv(fuelgauge, ocv_pwroff);
+				if (abs(target_soc - fuelgauge->info.soc) > 300) {
+					pr_info("%s : F/G reset Start\n", __func__);
+					WA_0_issue_at_init1(fuelgauge, ocv_pwroff);
+				}
+			}
+		}
+	}
+
+#if !defined(CONFIG_SEC_FACTORY)
+	info_soc = fuelgauge->info.soc/100;
+	if (info_soc > 93) {
+		value.intval = 0; /* digital ivr */
+		psy_do_property("s2mu004-charger", set, POWER_SUPPLY_EXT_PROP_ANDIG_IVR_SWITCH, value);
+	} else {
+		value.intval = 1; /* analog ivr */
+		psy_do_property("s2mu004-charger", set, POWER_SUPPLY_EXT_PROP_ANDIG_IVR_SWITCH, value);
+	}
+#endif
+
+	/* S2MU004 FG debug */
+	if(fuelgauge->pdata->fg_log_enable)
+		s2mu004_fg_test_read(fuelgauge->i2c);
+
+	return min(fuelgauge->info.soc, 10000);
+
+err:
+	mutex_unlock(&fuelgauge->fg_lock);
+	return -EINVAL;
+}
+
+static int s2mu004_get_current(struct s2mu004_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u16 compliment;
+	int curr = 0;
+
+	if (s2mu004_read_reg(fuelgauge->i2c, S2MU004_REG_RCUR_CC, data) < 0)
+		return -EINVAL;
+	compliment = (data[1] << 8) | (data[0]);
+	dev_dbg(&fuelgauge->i2c->dev, "%s: rCUR_CC(0x%4x)\n", __func__, compliment);
+
+	if (compliment & (0x1 << 15)) { /* Charging */
+		curr = ((~compliment) & 0xFFFF) + 1;
+		curr = (curr * 1000) >> 12;
+	} else { /* dischaging */
+		curr = compliment & 0x7FFF;
+		curr = (curr * (-1000)) >> 12;
+	}
+
+	dev_info(&fuelgauge->i2c->dev, "%s: current (%d)mA\n", __func__, curr);
+
+	return curr;
+}
+
+#define TABLE_SIZE	22
+static int s2mu004_get_ocv(struct s2mu004_fuelgauge_data *fuelgauge)
+{
+	/* 22 values of mapping table for EVT1*/
+
+	int *soc_arr;
+	int *ocv_arr;
+
+	int soc = fuelgauge->info.soc;
+	int ocv = 0;
+
+	int high_index = TABLE_SIZE - 1;
+	int low_index = 0;
+	int mid_index = 0;
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	soc_arr = fuelgauge->age_data_info[fuelgauge->fg_age_step].soc_arr_val;
+	ocv_arr = fuelgauge->age_data_info[fuelgauge->fg_age_step].ocv_arr_val;
+#else
+	soc_arr = fuelgauge->info.soc_arr_val;
+	ocv_arr = fuelgauge->info.ocv_arr_val;
+#endif
+
+	dev_err(&fuelgauge->i2c->dev,
+		"%s: soc (%d) soc_arr[TABLE_SIZE-1] (%d) ocv_arr[TABLE_SIZE-1) (%d)\n",
+		__func__, soc, soc_arr[TABLE_SIZE-1] , ocv_arr[TABLE_SIZE-1] );
+	if(soc <= soc_arr[TABLE_SIZE - 1]) {
+		ocv = ocv_arr[TABLE_SIZE - 1];
+		goto ocv_soc_mapping;
+	} else if (soc >= soc_arr[0]) {
+		ocv = ocv_arr[0];
+		goto ocv_soc_mapping;
+	}
+	while (low_index <= high_index) {
+		mid_index = (low_index + high_index) >> 1;
+		if(soc_arr[mid_index] > soc)
+			low_index = mid_index + 1;
+		else if(soc_arr[mid_index] < soc)
+			high_index = mid_index - 1;
+		else {
+			ocv = ocv_arr[mid_index];
+			goto ocv_soc_mapping;
+		}
+	}
+	ocv = ocv_arr[high_index];
+	ocv += ((ocv_arr[low_index] - ocv_arr[high_index]) *
+					(soc - soc_arr[high_index])) /
+					(soc_arr[low_index] - soc_arr[high_index]);
+
+ocv_soc_mapping:
+	dev_info(&fuelgauge->i2c->dev, "%s: soc (%d), ocv (%d)\n", __func__, soc, ocv);
+	return ocv;
+}
+
+static int s2mu004_get_avgcurrent(struct s2mu004_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u16 compliment;
+	int curr = 0;
+
+	mutex_lock(&fuelgauge->fg_lock);
+
+	s2mu004_write_reg_byte(fuelgauge->i2c, S2MU004_REG_MONOUT_SEL, 0x26);
+
+	if (s2mu004_read_reg(fuelgauge->i2c, S2MU004_REG_MONOUT, data) < 0)
+		goto err;
+	compliment = (data[1] << 8) | (data[0]);
+
+	if (compliment & (0x1 << 15)) { /* Charging */
+		curr = ((~compliment) & 0xFFFF) + 1;
+		curr = (curr * 1000) >> 12;
+	} else { /* dischaging */
+		curr = compliment & 0x7FFF;
+		curr = (curr * (-1000)) >> 12;
+	}
+	s2mu004_write_reg_byte(fuelgauge->i2c, S2MU004_REG_MONOUT_SEL, 0x10);
+
+	mutex_unlock(&fuelgauge->fg_lock);
+
+	dev_info(&fuelgauge->i2c->dev, "%s: MONOUT(0x%4x), avg current (%d)mA\n",
+		__func__, compliment, curr);
+
+	dev_info(&fuelgauge->i2c->dev, "%s: SOC(%d)%%\n", __func__, fuelgauge->info.soc);
+
+	return curr;
+
+err:
+	mutex_unlock(&fuelgauge->fg_lock);
+	return -EINVAL;
+}
+
+static int s2mu004_maintain_avgcurrent(
+	struct s2mu004_fuelgauge_data *fuelgauge)
+{
+	static int cnt;
+	int vcell = 0;
+	int curr = 0;
+
+	curr = s2mu004_get_avgcurrent(fuelgauge);
+	
+	vcell = s2mu004_get_vbat(fuelgauge);
+	if ((cnt < 10) && (curr < 0) && (fuelgauge->is_charging) &&
+		(vcell < 3500)) {
+			curr = 1;
+			cnt++;
+			dev_info(&fuelgauge->i2c->dev, "%s: vcell (%d)mV,  modified avg current (%d)mA\n",
+				 __func__, vcell, curr);
+	}
+
+	return curr;
+}
+
+static int s2mu004_get_vbat(struct s2mu004_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u8 vbat_src;
+	u32 vbat = 0;
+
+	if (s2mu004_read_reg(fuelgauge->i2c, S2MU004_REG_RVBAT, data) < 0)
+		return -EINVAL;
+
+	dev_dbg(&fuelgauge->i2c->dev, "%s: data0 (%d) data1 (%d) \n", __func__, data[0], data[1]);
+	vbat = ((data[0] + (data[1] << 8)) * 1000) >> 13;
+
+	s2mu004_read_reg_byte(fuelgauge->i2c, S2MU004_REG_CTRL0, &vbat_src);
+	dev_info(&fuelgauge->i2c->dev, "%s: vbat (%d), src (0x%02X)\n",
+		__func__, vbat, (vbat_src & 0x30) >> 4);
+
+	return vbat;
+}
+
+static int s2mu004_get_monout_avgvbat(struct s2mu004_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u16 compliment, avg_vbat;
+
+	mutex_lock(&fuelgauge->fg_lock);
+
+	s2mu004_write_reg_byte(fuelgauge->i2c, S2MU004_REG_MONOUT_SEL, 0x27);
+
+	mdelay(50);
+
+	if (s2mu004_read_reg(fuelgauge->i2c, S2MU004_REG_MONOUT, data) < 0)
+		goto err;
+	compliment = (data[1] << 8) | (data[0]);
+
+	avg_vbat = (compliment * 1000) >> 12;
+
+	s2mu004_write_reg_byte(fuelgauge->i2c, S2MU004_REG_MONOUT_SEL, 0x10);
+
+	mutex_unlock(&fuelgauge->fg_lock);
+
+	dev_info(&fuelgauge->i2c->dev, "%s: avgvbat (%d)\n", __func__, avg_vbat);
+
+	return avg_vbat;
+
+err:
+	mutex_unlock(&fuelgauge->fg_lock);
+	return -EINVAL;
+}
+
+static int s2mu004_get_avgvbat(struct s2mu004_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u32 new_vbat, old_vbat = 0;
+	int cnt;
+
+	for (cnt = 0; cnt < 5; cnt++) {
+		if (s2mu004_read_reg(fuelgauge->i2c, S2MU004_REG_RVBAT, data) < 0)
+			return -EINVAL;
+
+		new_vbat = ((data[0] + (data[1] << 8)) * 1000) >> 13;
+
+		if (cnt == 0)
+			old_vbat = new_vbat;
+		else
+			old_vbat = new_vbat / 2 + old_vbat / 2;
+	}
+
+	dev_info(&fuelgauge->i2c->dev, "%s: avgvbat (%d)\n", __func__, old_vbat);
+
+	return old_vbat;
+}
+
+/* capacity is  0.1% unit */
+static void s2mu004_fg_get_scaled_capacity(
+		struct s2mu004_fuelgauge_data *fuelgauge,
+		union power_supply_propval *val)
+{
+	int rawsoc = val->intval;
+	val->intval = (val->intval < fuelgauge->pdata->capacity_min) ?
+		0 : ((val->intval - fuelgauge->pdata->capacity_min) * 1000 /
+		(fuelgauge->capacity_max - fuelgauge->pdata->capacity_min));
+
+	dev_info(&fuelgauge->i2c->dev,
+			"%s: capacity_max(%d) scaled capacity(%d.%d), raw_soc(%d.%d)\n",
+			__func__, fuelgauge->capacity_max,
+			val->intval/10, val->intval%10, rawsoc/10, rawsoc%10);
+}
+
+/* capacity is integer */
+static void s2mu004_fg_get_atomic_capacity(
+		struct s2mu004_fuelgauge_data *fuelgauge,
+		union power_supply_propval *val)
+{
+	if (fuelgauge->pdata->capacity_calculation_type &
+			SEC_FUELGAUGE_CAPACITY_TYPE_ATOMIC) {
+		if (fuelgauge->capacity_old < val->intval)
+			val->intval = fuelgauge->capacity_old + 1;
+		else if (fuelgauge->capacity_old > val->intval)
+			val->intval = fuelgauge->capacity_old - 1;
+	}
+
+	/* keep SOC stable in abnormal status */
+	if (fuelgauge->pdata->capacity_calculation_type &
+			SEC_FUELGAUGE_CAPACITY_TYPE_SKIP_ABNORMAL) {
+		if (!fuelgauge->is_charging &&
+				fuelgauge->capacity_old < val->intval) {
+			dev_err(&fuelgauge->i2c->dev,
+					"%s: capacity (old %d : new %d)\n",
+					__func__, fuelgauge->capacity_old, val->intval);
+			val->intval = fuelgauge->capacity_old;
+		}
+	}
+
+	/* updated old capacity */
+	fuelgauge->capacity_old = val->intval;
+}
+
+static int s2mu004_fg_check_capacity_max(
+		struct s2mu004_fuelgauge_data *fuelgauge, int capacity_max)
+{
+	int new_capacity_max = capacity_max;
+
+	if (new_capacity_max < (fuelgauge->pdata->capacity_max -
+				fuelgauge->pdata->capacity_max_margin - 10)) {
+		new_capacity_max =
+			(fuelgauge->pdata->capacity_max -
+			 fuelgauge->pdata->capacity_max_margin);
+
+		dev_info(&fuelgauge->i2c->dev, "%s: set capacity max(%d --> %d)\n",
+				__func__, capacity_max, new_capacity_max);
+	} else if (new_capacity_max > (fuelgauge->pdata->capacity_max +
+				fuelgauge->pdata->capacity_max_margin)) {
+		new_capacity_max =
+			(fuelgauge->pdata->capacity_max +
+			 fuelgauge->pdata->capacity_max_margin);
+
+		dev_info(&fuelgauge->i2c->dev, "%s: set capacity max(%d --> %d)\n",
+				__func__, capacity_max, new_capacity_max);
+	}
+
+	return new_capacity_max;
+}
+
+static int s2mu004_fg_calculate_dynamic_scale(
+		struct s2mu004_fuelgauge_data *fuelgauge, int capacity)
+{
+	union power_supply_propval raw_soc_val;
+	raw_soc_val.intval = s2mu004_get_rawsoc(fuelgauge) / 10;
+
+	if (raw_soc_val.intval <
+			fuelgauge->pdata->capacity_max -
+			fuelgauge->pdata->capacity_max_margin) {
+		fuelgauge->capacity_max =
+			fuelgauge->pdata->capacity_max -
+			fuelgauge->pdata->capacity_max_margin;
+		dev_dbg(&fuelgauge->i2c->dev, "%s: capacity_max (%d)",
+				__func__, fuelgauge->capacity_max);
+	} else {
+		fuelgauge->capacity_max =
+			(raw_soc_val.intval >
+			 fuelgauge->pdata->capacity_max +
+			 fuelgauge->pdata->capacity_max_margin) ?
+			(fuelgauge->pdata->capacity_max +
+			 fuelgauge->pdata->capacity_max_margin) :
+			raw_soc_val.intval;
+		dev_dbg(&fuelgauge->i2c->dev, "%s: raw soc (%d)",
+				__func__, fuelgauge->capacity_max);
+	}
+
+	if (capacity != 100) {
+		fuelgauge->capacity_max = s2mu004_fg_check_capacity_max(
+			fuelgauge, (fuelgauge->capacity_max * 100 / (capacity + 1)));
+	} else  {
+		fuelgauge->capacity_max =
+			(fuelgauge->capacity_max * 99 / 100);
+	}
+
+	/* update capacity_old for sec_fg_get_atomic_capacity algorithm */
+	fuelgauge->capacity_old = capacity;
+
+	dev_info(&fuelgauge->i2c->dev, "%s: %d is used for capacity_max\n",
+			__func__, fuelgauge->capacity_max);
+
+	return fuelgauge->capacity_max;
+}
+
+bool s2mu004_fuelgauge_fuelalert_init(struct i2c_client *client, int soc)
+{
+	struct s2mu004_fuelgauge_data *fuelgauge = i2c_get_clientdata(client);
+	u8 data[2];
+
+	fuelgauge->is_fuel_alerted = false;
+
+	/* 1. Set s2mu004 alert configuration. */
+	s2mu004_alert_init(fuelgauge);
+
+	if (s2mu004_read_reg(client, S2MU004_REG_IRQ, data) < 0)
+		return -1;
+
+	/*Enable VBAT, SOC */
+	data[1] &= 0xfc;
+
+	/*Disable IDLE_ST, INIT)ST */
+	data[1] |= 0x0c;
+
+	s2mu004_write_reg(client, S2MU004_REG_IRQ, data);
+
+	dev_dbg(&client->dev, "%s: irq_reg(%02x%02x) irq(%d)\n",
+			__func__, data[1], data[0], fuelgauge->pdata->fg_irq);
+
+	return true;
+}
+
+static void s2mu004_fg_reset_capacity_by_jig_connection(struct s2mu004_fuelgauge_data *fuelgauge)
+{
+	u8 data = 0;
+
+	s2mu004_read_reg_byte(fuelgauge->i2c, S2MU004_REG_FG_ID, &data);
+	data &= 0xF0;
+	data |= 0x0F; //set model data version 0xF for next boot up initializing fuelgague	
+	s2mu004_write_reg_byte(fuelgauge->i2c, S2MU004_REG_FG_ID, data);
+
+	pr_info("%s: set Model data version (0x%x)\n", __func__, data & 0x0F);
+}
+
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+static int s2mu004_fg_aging_check(
+		struct s2mu004_fuelgauge_data *fuelgauge, int step)
+{
+	u8 batcap0, batcap1, batcap2, batcap3;
+	u8 por_state = 0;
+	union power_supply_propval value;
+	int charging_enabled = false;
+
+	fuelgauge->fg_age_step = step;
+
+	s2mu004_read_reg_byte(fuelgauge->i2c, 0x0E, &batcap0);
+	s2mu004_read_reg_byte(fuelgauge->i2c, 0x0F, &batcap1);
+	s2mu004_read_reg_byte(fuelgauge->i2c, 0x10, &batcap2);
+	s2mu004_read_reg_byte(fuelgauge->i2c, 0x11, &batcap3);
+
+	pr_info("%s: [Long life] orig. batcap : %02x, %02x, %02x, %02x , fg_age_step data : %02x, %02x, %02x, %02x \n",
+		__func__, batcap0, batcap1, batcap2, batcap3,
+		fuelgauge->age_data_info[fuelgauge->fg_age_step].batcap[0],
+		fuelgauge->age_data_info[fuelgauge->fg_age_step].batcap[1],
+		fuelgauge->age_data_info[fuelgauge->fg_age_step].batcap[2],
+		fuelgauge->age_data_info[fuelgauge->fg_age_step].batcap[3] );
+
+	if ( (batcap0 != fuelgauge->age_data_info[fuelgauge->fg_age_step].batcap[0]) ||
+	     (batcap1 != fuelgauge->age_data_info[fuelgauge->fg_age_step].batcap[1]) ||
+	     (batcap2 != fuelgauge->age_data_info[fuelgauge->fg_age_step].batcap[2]) ||
+	     (batcap3 != fuelgauge->age_data_info[fuelgauge->fg_age_step].batcap[3]) ) {
+
+		pr_info("%s: [Long life] reset gauge for age forecast , step[%d] \n", __func__, fuelgauge->fg_age_step);
+
+		fuelgauge->age_reset_status = 1;
+		por_state |= 0x10;
+		s2mu004_write_reg_byte(fuelgauge->i2c, 0x1F, por_state);
+
+		/* check charging enable */
+		psy_do_property("s2mu004-charger", get, POWER_SUPPLY_PROP_CHARGING_ENABLED, value);
+		charging_enabled = value.intval;
+
+		if(charging_enabled == true) {
+			pr_info("%s: [Long life] disable charger for reset gauge age forecast \n", __func__);
+			value.intval = SEC_BAT_CHG_MODE_CHARGING_OFF;
+			psy_do_property("s2mu004-charger", set, POWER_SUPPLY_PROP_CHARGING_ENABLED, value);
+		}
+
+		s2mu004_reset_fg(fuelgauge);
+
+		if(charging_enabled == true ) {
+			psy_do_property("battery", get, POWER_SUPPLY_PROP_STATUS, value);
+			charging_enabled = value.intval;
+		
+			if(charging_enabled == 1 ) { /* POWER_SUPPLY_STATUS_CHARGING 1 */
+				pr_info("%s: [Long life] enable charger for reset gauge age forecast \n", __func__);
+				value.intval = SEC_BAT_CHG_MODE_CHARGING;
+				psy_do_property("s2mu004-charger", set, POWER_SUPPLY_PROP_CHARGING_ENABLED, value);
+			}
+		}
+
+		por_state &= ~0x10;
+		s2mu004_write_reg_byte(fuelgauge->i2c, 0x1F, por_state);
+		fuelgauge->age_reset_status = 0;
+
+		return 1;
+	}
+	return 0;
+}
+#endif
+
+static int s2mu004_fg_get_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		union power_supply_propval *val)
+{
+	struct s2mu004_fuelgauge_data *fuelgauge =
+		container_of(psy, struct s2mu004_fuelgauge_data, psy_fg);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+		return -ENODATA;
+	case POWER_SUPPLY_PROP_ENERGY_NOW:
+		switch (val->intval) {
+		case SEC_BATTERY_CAPACITY_DESIGNED:
+			val->intval = fuelgauge->pdata->capacity_full;
+			break;
+		case SEC_BATTERY_CAPACITY_ABSOLUTE:
+			val->intval = 0;
+			break;
+		case SEC_BATTERY_CAPACITY_TEMPERARY:
+			val->intval = 0;
+			break;
+		case SEC_BATTERY_CAPACITY_CURRENT:
+			val->intval = 0;
+			break;
+		case SEC_BATTERY_CAPACITY_AGEDCELL:
+			val->intval = 0;
+			break;
+		case SEC_BATTERY_CAPACITY_CYCLE:
+			val->intval = 0;
+			break;
+		case SEC_BATTERY_CAPACITY_FULL:
+			val->intval = fuelgauge->pdata->capacity_full;
+			break;
+		}
+		break;
+		/* Cell voltage (VCELL, mV) */
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = s2mu004_get_vbat(fuelgauge);
+		break;
+		/* Additional Voltage Information (mV) */
+	case POWER_SUPPLY_PROP_VOLTAGE_AVG:
+		switch (val->intval) {
+			case SEC_BATTERY_VOLTAGE_AVERAGE:
+				val->intval = s2mu004_get_avgvbat(fuelgauge);
+				break;
+			case SEC_BATTERY_VOLTAGE_OCV:
+				val->intval = s2mu004_get_ocv(fuelgauge);
+				break;
+		}
+		break;
+		/* Current (mA) */
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		if (val->intval == SEC_BATTERY_CURRENT_UA)
+			val->intval = s2mu004_get_current(fuelgauge) * 1000;
+		else
+			val->intval = s2mu004_get_current(fuelgauge);
+		break;
+		/* Average Current (mA) */
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+		if (val->intval == SEC_BATTERY_CURRENT_UA)
+			val->intval = s2mu004_maintain_avgcurrent(fuelgauge) * 1000;
+		else
+			val->intval = s2mu004_maintain_avgcurrent(fuelgauge);
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		if (val->intval == SEC_FUELGAUGE_CAPACITY_TYPE_RAW) {
+			val->intval = s2mu004_get_rawsoc(fuelgauge);
+		} else {
+			val->intval = s2mu004_get_rawsoc(fuelgauge) / 10;
+
+			if (fuelgauge->pdata->capacity_calculation_type &
+				(SEC_FUELGAUGE_CAPACITY_TYPE_SCALE |
+					SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE))
+				s2mu004_fg_get_scaled_capacity(fuelgauge, val);
+
+			/* capacity should be between 0% and 100%
+			 * (0.1% degree)
+			 */
+			if (val->intval > 1000)
+				val->intval = 1000;
+			if (val->intval < 0)
+				val->intval = 0;
+
+			/* get only integer part */
+			val->intval /= 10;
+
+			/* check whether doing the wake_unlock */
+			if ((val->intval > fuelgauge->pdata->fuel_alert_soc) &&
+					fuelgauge->is_fuel_alerted) {
+				wake_unlock(&fuelgauge->fuel_alert_wake_lock);
+				s2mu004_fuelgauge_fuelalert_init(fuelgauge->i2c,
+						fuelgauge->pdata->fuel_alert_soc);
+			}
+
+			/* (Only for atomic capacity)
+			 * In initial time, capacity_old is 0.
+			 * and in resume from sleep,
+			 * capacity_old is too different from actual soc.
+			 * should update capacity_old
+			 * by val->intval in booting or resume.
+			 */
+			if (fuelgauge->initial_update_of_soc) {
+				/* updated old capacity */
+				fuelgauge->capacity_old = val->intval;
+				fuelgauge->initial_update_of_soc = false;
+				break;
+			}
+
+			if (fuelgauge->sleep_initial_update_of_soc) {
+				/* updated old capacity in case of resume */
+				if(fuelgauge->is_charging ||
+					((!fuelgauge->is_charging) && (fuelgauge->capacity_old >= val->intval))) {
+					fuelgauge->capacity_old = val->intval;
+					fuelgauge->sleep_initial_update_of_soc = false;
+					break;
+				}
+			}
+
+			if (fuelgauge->pdata->capacity_calculation_type &
+				(SEC_FUELGAUGE_CAPACITY_TYPE_ATOMIC |
+					 SEC_FUELGAUGE_CAPACITY_TYPE_SKIP_ABNORMAL))
+				s2mu004_fg_get_atomic_capacity(fuelgauge, val);
+		}
+		break;
+	/* IFPMIC Temperature */
+	case POWER_SUPPLY_PROP_TEMP:
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		val->intval = s2mu004_get_temperature(fuelgauge);
+		break;
+	case POWER_SUPPLY_PROP_ENERGY_FULL:
+#if defined(CONFIG_FUELGAUGE_ASOC_FROM_CYCLES)
+		{
+			int calc_step = 0;
+
+			if (!(fuelgauge->pdata->fixed_asoc_levels <= 0 || val->intval < 0)) {
+				for (calc_step = fuelgauge->pdata->fixed_asoc_levels - 1; calc_step >= 0; calc_step--) {
+					if (fuelgauge->pdata->cycles_to_asoc[calc_step].cycle <= val->intval)
+						break;
+				}
+
+				dev_info(fuelgauge->dev, "%s: Battery Cycles = %d, ASOC step = %d\n",
+					__func__, val->intval, calc_step);
+
+				val->intval = fuelgauge->pdata->cycles_to_asoc[calc_step].asoc;
+			}
+		}
+#else
+		return -1;
+#endif
+		break;
+	case POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:
+		val->intval = fuelgauge->capacity_max;
+		break;
+	case POWER_SUPPLY_PROP_SCOPE:
+		val->intval = fuelgauge->mode;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int s2mu004_fg_set_property(struct power_supply *psy,
+                            enum power_supply_property psp,
+                            const union power_supply_propval *val)
+{
+	struct s2mu004_fuelgauge_data *fuelgauge =
+		container_of(psy, struct s2mu004_fuelgauge_data, psy_fg);
+	enum power_supply_ext_property ext_psp = psp;
+	u8 temp = 0;
+
+	switch (psp) {
+		case POWER_SUPPLY_PROP_STATUS:
+			break;
+		case POWER_SUPPLY_PROP_CHARGE_FULL:
+			if (fuelgauge->pdata->capacity_calculation_type &
+					SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE) {
+				s2mu004_fg_calculate_dynamic_scale(fuelgauge, val->intval);
+			}
+			break;
+		case POWER_SUPPLY_PROP_ONLINE:
+			fuelgauge->cable_type = val->intval;
+			break;
+		case POWER_SUPPLY_PROP_CHARGING_ENABLED:
+			if (val->intval)
+				fuelgauge->is_charging = true;
+			else
+				fuelgauge->is_charging = false;
+			break;
+		case POWER_SUPPLY_PROP_CAPACITY:
+			if (val->intval == SEC_FUELGAUGE_CAPACITY_TYPE_RESET) {
+				fuelgauge->initial_update_of_soc = true;
+				s2mu004_restart_gauging(fuelgauge);
+			}
+			break;
+		case POWER_SUPPLY_PROP_TEMP:
+		case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+			s2mu004_set_temperature(fuelgauge, val->intval);
+			break;
+		case POWER_SUPPLY_PROP_ENERGY_NOW:
+			s2mu004_fg_reset_capacity_by_jig_connection(fuelgauge);
+			break;
+		case POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:
+			dev_info(&fuelgauge->i2c->dev,
+				"%s: capacity_max changed, %d -> %d\n",
+				__func__, fuelgauge->capacity_max, val->intval);
+			fuelgauge->capacity_max = s2mu004_fg_check_capacity_max(fuelgauge, val->intval);
+			fuelgauge->initial_update_of_soc = true;
+			break;
+		case POWER_SUPPLY_PROP_CHARGE_EMPTY:
+			pr_info("%s: WA for battery 0 percent\n", __func__);
+			s2mu004_write_reg_byte(fuelgauge->i2c, 0x1F, 0x01);
+			break;
+		case POWER_SUPPLY_PROP_ENERGY_AVG:
+			pr_info("%s: WA for power off issue: val(%d)\n", __func__, val->intval);
+			if(val->intval)
+				s2mu004_write_reg_byte(fuelgauge->i2c, 0x41, 0x10); /* charger start */
+			else
+				s2mu004_write_reg_byte(fuelgauge->i2c, 0x41, 0x04); /* charger end */
+			break;
+		case POWER_SUPPLY_PROP_FUELGAUGE_FACTORY:
+			pr_info("%s:[DEBUG_FAC]  fuelgauge \n", __func__);
+			s2mu004_read_reg_byte(fuelgauge->i2c, S2MU004_REG_CTRL0, &temp);
+			temp &= 0xCF;
+			temp |= 0x30;
+			s2mu004_write_reg_byte(fuelgauge->i2c, S2MU004_REG_CTRL0, temp);
+			s2mu004_fg_reset_capacity_by_jig_connection(fuelgauge);
+			break;
+		case POWER_SUPPLY_PROP_MAX ... POWER_SUPPLY_EXT_PROP_MAX:
+			switch (ext_psp) {
+			case POWER_SUPPLY_EXT_PROP_INBAT_VOLTAGE_FGSRC_SWITCHING:
+				if (val->intval == SEC_BAT_INBAT_FGSRC_SWITCHING_ON) {
+					/* Get Battery voltage (by I2C control) */
+					s2mu004_read_reg_byte(fuelgauge->i2c, S2MU004_REG_CTRL0, &temp);
+					temp &= 0xCF;
+					temp |= 0x10;
+					s2mu004_write_reg_byte(fuelgauge->i2c, S2MU004_REG_CTRL0, temp);
+					mdelay(1000);
+					s2mu004_restart_gauging(fuelgauge);
+					s2mu004_fg_reset_capacity_by_jig_connection(fuelgauge);
+				} else if (val->intval == SEC_BAT_INBAT_FGSRC_SWITCHING_OFF) {
+					s2mu004_read_reg_byte(fuelgauge->i2c, S2MU004_REG_CTRL0, &temp);
+					temp &= 0xCF;
+					temp |= 0x30;
+					s2mu004_write_reg_byte(fuelgauge->i2c, S2MU004_REG_CTRL0, temp);
+					mdelay(1000);
+					s2mu004_restart_gauging(fuelgauge);
+				}
+				s2mu004_read_reg_byte(fuelgauge->i2c, S2MU004_REG_CTRL0, &temp);
+				pr_info("%s: [%d] Internal switch 0x%X\n", __func__, val->intval, (temp & 0x30) >> 4);
+				break;
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+			case POWER_SUPPLY_EXT_PROP_UPDATE_BATTERY_DATA:
+				s2mu004_fg_aging_check(fuelgauge, val->intval);
+				break;
+#endif
+			default:
+				return -EINVAL;
+			}
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void s2mu004_fg_isr_work(struct work_struct *work)
+{
+	struct s2mu004_fuelgauge_data *fuelgauge =
+		container_of(work, struct s2mu004_fuelgauge_data, isr_work.work);
+	u8 fg_alert_status = 0;
+
+	s2mu004_read_reg_byte(fuelgauge->i2c, S2MU004_REG_STATUS, &fg_alert_status);
+	dev_info(&fuelgauge->i2c->dev, "%s : fg_alert_status(0x%x)\n",
+		__func__, fg_alert_status);
+
+	fg_alert_status &= 0x03;
+	if (fg_alert_status & 0x01) {
+		pr_info("%s : Battery Level is very Low!\n", __func__);
+	}
+
+	if (fg_alert_status & 0x02) {
+		int voltage = s2mu004_get_vbat(fuelgauge);
+		pr_info("%s : Battery Votage is very Low! (%dmV)\n",
+			__func__, voltage);
+	}
+
+	if (!fg_alert_status) {
+		fuelgauge->is_fuel_alerted = false;
+		pr_debug("%s : Battery Health is good!\n", __func__);
+		wake_unlock(&fuelgauge->fuel_alert_wake_lock);
+	}
+}
+
+static irqreturn_t s2mu004_fg_irq_thread(int irq, void *irq_data)
+{
+	struct s2mu004_fuelgauge_data *fuelgauge = irq_data;
+	u8 fg_irq = 0;
+
+	s2mu004_read_reg_byte(fuelgauge->i2c, S2MU004_REG_IRQ, &fg_irq);
+	dev_info(&fuelgauge->i2c->dev, "%s: fg_irq(0x%x)\n",
+		__func__, fg_irq);
+
+	if (fuelgauge->is_fuel_alerted) {
+		return IRQ_HANDLED;
+	} else {
+		wake_lock(&fuelgauge->fuel_alert_wake_lock);
+		fuelgauge->is_fuel_alerted = true;
+		schedule_delayed_work(&fuelgauge->isr_work, 0);
+	}
+
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_OF
+static int s2mu004_fuelgauge_parse_dt(struct s2mu004_fuelgauge_data *fuelgauge)
+{
+	struct device_node *np = of_find_node_by_name(NULL, "s2mu004-fuelgauge");
+	int ret;
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	int len, i;
+#if defined(CONFIG_FUELGAUGE_ASOC_FROM_CYCLES)
+	const u32 *p;
+#endif
+#endif
+
+	/* reset, irq gpio info */
+	if (np == NULL) {
+		pr_err("%s np NULL\n", __func__);
+	} else {
+		fuelgauge->pdata->fg_irq = of_get_named_gpio(np, "fuelgauge,fuel_int", 0);
+		if (fuelgauge->pdata->fg_irq < 0)
+			pr_err("%s error reading fg_irq = %d\n",
+				__func__, fuelgauge->pdata->fg_irq);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_max",
+				&fuelgauge->pdata->capacity_max);
+		if (ret < 0)
+			pr_err("%s error reading capacity_max %d\n", __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_max_margin",
+				&fuelgauge->pdata->capacity_max_margin);
+		if (ret < 0)
+			pr_err("%s error reading capacity_max_margin %d\n", __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_min",
+				&fuelgauge->pdata->capacity_min);
+		if (ret < 0)
+			pr_err("%s error reading capacity_min %d\n", __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_calculation_type",
+				&fuelgauge->pdata->capacity_calculation_type);
+		if (ret < 0)
+			pr_err("%s error reading capacity_calculation_type %d\n",
+					__func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,fg_log_enable",
+				&fuelgauge->pdata->fg_log_enable);
+		if (ret < 0)
+			pr_err("%s fg_log_disabled %d\n", __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,fuel_alert_soc",
+				&fuelgauge->pdata->fuel_alert_soc);
+		if (ret < 0)
+			pr_err("%s error reading pdata->fuel_alert_soc %d\n",
+					__func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_full",
+				&fuelgauge->pdata->capacity_full);
+		if (ret < 0)
+			pr_err("%s error reading pdata->capacity_full %d\n",
+					__func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,fuel_alert_vol",
+				&fuelgauge->pdata->fuel_alert_vol);
+		if (ret < 0)
+			pr_err("%s error reading pdata->fuel_alert_vol %d\n",
+					__func__, ret);
+		
+		fuelgauge->pdata->repeated_fuelalert = of_property_read_bool(np,
+				"fuelgauge,repeated_fuelalert");
+
+		/* get battery_params node */
+		np = of_find_node_by_name(NULL, "battery_params");
+		if (!np) {
+			pr_err("%s battery_params node NULL\n", __func__);
+		} else {
+#if !defined(CONFIG_BATTERY_AGE_FORECAST)
+			/* get battery_table */
+			ret = of_property_read_u32_array(np, "battery,battery_table3", fuelgauge->info.battery_table3, 88);
+			if (ret < 0) {
+				pr_err("%s error reading battery,battery_table3\n", __func__);
+			}
+
+			ret = of_property_read_u32_array(np, "battery,battery_table4", fuelgauge->info.battery_table4, 22);
+			if (ret < 0) {
+				pr_err("%s error reading battery,battery_table4\n", __func__);
+			}
+
+			ret = of_property_read_u32_array(np, "battery,batcap", fuelgauge->info.batcap, 4);
+			if (ret < 0) {
+				pr_err("%s error reading battery,batcap\n", __func__);
+			}
+
+			ret = of_property_read_u32_array(np, "battery,accum", fuelgauge->info.accum, 2);
+			if (ret < 0) {
+				pr_err("%s error reading battery,accum\n", __func__);
+			}
+
+			ret = of_property_read_u32_array(np, "battery,soc_arr_val", fuelgauge->info.soc_arr_val, 22);
+			if (ret < 0) {
+				pr_err("%s error reading battery,soc_arr_val\n", __func__);
+			}
+
+			ret = of_property_read_u32_array(np, "battery,ocv_arr_val", fuelgauge->info.ocv_arr_val, 22);
+			if (ret < 0) {
+				pr_err("%s error reading battery,ocv_arr_val\n", __func__);
+			}
+#else
+			of_get_property(np, "battery,battery_data", &len);
+			fuelgauge->fg_num_age_step = len / sizeof(fg_age_data_info_t);
+			fuelgauge->age_data_info = kzalloc(len, GFP_KERNEL);
+			ret = of_property_read_u32_array(np, "battery,battery_data",
+					(int *)fuelgauge->age_data_info, len/sizeof(int));
+
+			pr_err("%s: [Long life] fuelgauge->fg_num_age_step %d \n", __func__,fuelgauge->fg_num_age_step);
+
+			for(i=0 ; i < fuelgauge->fg_num_age_step ; i++){
+				pr_err("%s: [Long life] age_step = %d, table3[0] %d, table4[0] %d, batcap[0] %02x, accum[0] %02x, soc_arr[0] %d, ocv_arr[0] %d \n",
+					__func__, i,
+					fuelgauge->age_data_info[i].battery_table3[0],
+					fuelgauge->age_data_info[i].battery_table4[0],
+					fuelgauge->age_data_info[i].batcap[0],
+					fuelgauge->age_data_info[i].accum[0],
+					fuelgauge->age_data_info[i].soc_arr_val[0],
+					fuelgauge->age_data_info[i].ocv_arr_val[0]);
+			}
+#if defined(CONFIG_FUELGAUGE_ASOC_FROM_CYCLES)
+			p = of_get_property(np, "battery,cycles_to_asoc_mapping", &len);
+			if (p) {
+				fuelgauge->pdata->fixed_asoc_levels = len / sizeof(sec_cycles_to_asoc_t);
+				fuelgauge->pdata->cycles_to_asoc = kzalloc(len, GFP_KERNEL);
+				ret = of_property_read_u32_array(np, "battery,cycles_to_asoc_mapping",
+						 (u32 *)fuelgauge->pdata->cycles_to_asoc, len/sizeof(u32));
+				if (ret) {
+					pr_err("%s: failed to read fuelgauge->pdata->cycles_to_asoc: %d\n",
+							__func__, ret);
+					kfree(fuelgauge->pdata->cycles_to_asoc);
+					fuelgauge->pdata->cycles_to_asoc = NULL;
+					fuelgauge->pdata->fixed_asoc_levels = 0;
+				}
+				pr_err("%s: fixed_asoc_levels : %d\n", __func__, fuelgauge->pdata->fixed_asoc_levels);
+				for (len = 0; len < fuelgauge->pdata->fixed_asoc_levels; ++len) {
+					pr_err("[%d/%d]cycle:%d, asoc:%d\n",
+						len, fuelgauge->pdata->fixed_asoc_levels-1,
+						fuelgauge->pdata->cycles_to_asoc[len].cycle,
+						fuelgauge->pdata->cycles_to_asoc[len].asoc);
+				}
+
+			} else {
+				fuelgauge->pdata->fixed_asoc_levels = 0;
+				pr_err("%s: Cycles to ASOC mapping not defined\n", __func__);
+			}
+#endif
+#endif
+		}
+	}
+
+	return 0;
+}
+
+static struct of_device_id s2mu004_fuelgauge_match_table[] = {
+        { .compatible = "samsung,s2mu004-fuelgauge",},
+        {},
+};
+#else
+static int s2mu004_fuelgauge_parse_dt(struct s2mu004_fuelgauge_data *fuelgauge)
+{
+    return -ENOSYS;
+}
+
+#define s2mu004_fuelgauge_match_table NULL
+#endif /* CONFIG_OF */
+
+static int s2mu004_fuelgauge_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+	struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
+	struct s2mu004_fuelgauge_data *fuelgauge;
+	union power_supply_propval raw_soc_val;
+	int ret = 0;
+	u8 temp = 0;
+
+	pr_info("%s: S2MU004 Fuelgauge Driver Loading\n", __func__);
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE))
+		return -EIO;
+
+	fuelgauge = kzalloc(sizeof(*fuelgauge), GFP_KERNEL);
+	if (!fuelgauge)
+		return -ENOMEM;
+
+	mutex_init(&fuelgauge->fg_lock);
+
+	fuelgauge->i2c = client;
+
+	if (client->dev.of_node) {
+		fuelgauge->pdata = devm_kzalloc(&client->dev, sizeof(*(fuelgauge->pdata)),
+				GFP_KERNEL);
+		if (!fuelgauge->pdata) {
+			dev_err(&client->dev, "Failed to allocate memory\n");
+			ret = -ENOMEM;
+			goto err_parse_dt_nomem;
+		}
+		ret = s2mu004_fuelgauge_parse_dt(fuelgauge);
+		if (ret < 0)
+			goto err_parse_dt;
+	} else {
+		fuelgauge->pdata = client->dev.platform_data;
+	}
+
+	i2c_set_clientdata(client, fuelgauge);
+
+	fuelgauge->psy_fg.name          = "s2mu004-fuelgauge";
+	fuelgauge->psy_fg.type          = POWER_SUPPLY_TYPE_UNKNOWN;
+	fuelgauge->psy_fg.get_property  = s2mu004_fg_get_property;
+	fuelgauge->psy_fg.set_property  = s2mu004_fg_set_property;
+	fuelgauge->psy_fg.properties    = s2mu004_fuelgauge_props;
+	fuelgauge->psy_fg.num_properties =
+			ARRAY_SIZE(s2mu004_fuelgauge_props);
+
+	/* 0x48[7:4]=0010 : EVT2 */
+	fuelgauge->revision = 0;
+	s2mu004_read_reg_byte(fuelgauge->i2c, 0x48, &temp);
+	fuelgauge->revision = (temp & 0xF0) >> 4;
+
+	pr_info("%s: S2MU004 Fuelgauge revision: %d, reg 0x48 = 0x%x\n", __func__, fuelgauge->revision, temp);
+
+	fuelgauge->capacity_max = fuelgauge->pdata->capacity_max;
+	fuelgauge->info.soc = 0;
+	fuelgauge->mode = CURRENT_MODE;
+
+	raw_soc_val.intval = s2mu004_get_rawsoc(fuelgauge);
+	raw_soc_val.intval = raw_soc_val.intval / 10;
+
+	if (raw_soc_val.intval > fuelgauge->capacity_max)
+		s2mu004_fg_calculate_dynamic_scale(fuelgauge, 100);
+
+	s2mu004_init_regs(fuelgauge);
+
+	ret = power_supply_register(&client->dev, &fuelgauge->psy_fg);
+	if (ret) {
+		pr_err("%s: Failed to Register psy_fg\n", __func__);
+		goto err_data_free;
+	}
+
+	fuelgauge->is_fuel_alerted = false;
+	if (fuelgauge->pdata->fuel_alert_soc >= 0) {
+		s2mu004_fuelgauge_fuelalert_init(fuelgauge->i2c,
+					fuelgauge->pdata->fuel_alert_soc);
+		wake_lock_init(&fuelgauge->fuel_alert_wake_lock,
+					WAKE_LOCK_SUSPEND, "fuel_alerted");
+
+		if (fuelgauge->pdata->fg_irq > 0) {
+			INIT_DELAYED_WORK(
+					&fuelgauge->isr_work, s2mu004_fg_isr_work);
+
+			fuelgauge->fg_irq = gpio_to_irq(fuelgauge->pdata->fg_irq);
+			dev_info(&client->dev,
+					"%s : fg_irq = %d\n", __func__, fuelgauge->fg_irq);
+			if (fuelgauge->fg_irq > 0) {
+				ret = request_threaded_irq(fuelgauge->fg_irq,
+						NULL, s2mu004_fg_irq_thread,
+						IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+						"fuelgauge-irq", fuelgauge);
+				if (ret) {
+					dev_err(&client->dev,
+							"%s: Failed to Request IRQ\n", __func__);
+					goto err_supply_unreg;
+				}
+
+				ret = enable_irq_wake(fuelgauge->fg_irq);
+				if (ret < 0)
+					dev_err(&client->dev,
+							"%s: Failed to Enable Wakeup Source(%d)\n",
+							__func__, ret);
+			} else {
+				dev_err(&client->dev, "%s: Failed gpio_to_irq(%d)\n",
+						__func__, fuelgauge->fg_irq);
+				goto err_supply_unreg;
+			}
+		}
+	}
+
+	fuelgauge->sleep_initial_update_of_soc = false;
+	fuelgauge->initial_update_of_soc = true;
+
+	fuelgauge->cc_on = true;
+	fuelgauge->probe_done = true;
+
+	pr_info("%s: S2MU004 Fuelgauge Driver Loaded\n", __func__);
+	return 0;
+
+err_supply_unreg:
+	power_supply_unregister(&fuelgauge->psy_fg);
+err_data_free:
+	if (client->dev.of_node)
+		kfree(fuelgauge->pdata);
+
+err_parse_dt:
+err_parse_dt_nomem:
+	mutex_destroy(&fuelgauge->fg_lock);
+	kfree(fuelgauge);
+
+	return ret;
+}
+
+static const struct i2c_device_id s2mu004_fuelgauge_id[] = {
+	{"s2mu004-fuelgauge", 0},
+	{}
+};
+
+static void s2mu004_fuelgauge_shutdown(struct i2c_client *client)
+{
+
+}
+
+static int s2mu004_fuelgauge_remove(struct i2c_client *client)
+{
+	struct s2mu004_fuelgauge_data *fuelgauge = i2c_get_clientdata(client);
+
+	if (fuelgauge->pdata->fuel_alert_soc >= 0)
+		wake_lock_destroy(&fuelgauge->fuel_alert_wake_lock);
+
+	return 0;
+}
+
+#if defined CONFIG_PM
+static int s2mu004_fuelgauge_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int s2mu004_fuelgauge_resume(struct device *dev)
+{
+	struct s2mu004_fuelgauge_data *fuelgauge = dev_get_drvdata(dev);
+
+	fuelgauge->sleep_initial_update_of_soc = true;
+
+	return 0;
+}
+#else
+#define s2mu004_fuelgauge_suspend NULL
+#define s2mu004_fuelgauge_resume NULL
+#endif
+
+static SIMPLE_DEV_PM_OPS(s2mu004_fuelgauge_pm_ops, s2mu004_fuelgauge_suspend,
+		s2mu004_fuelgauge_resume);
+
+static struct i2c_driver s2mu004_fuelgauge_driver = {
+	.driver = {
+		.name = "s2mu004-fuelgauge",
+		.owner = THIS_MODULE,
+		.pm = &s2mu004_fuelgauge_pm_ops,
+		.of_match_table = s2mu004_fuelgauge_match_table,
+	},
+	.probe  = s2mu004_fuelgauge_probe,
+	.remove = s2mu004_fuelgauge_remove,
+	.shutdown   = s2mu004_fuelgauge_shutdown,
+	.id_table   = s2mu004_fuelgauge_id,
+};
+
+static int __init s2mu004_fuelgauge_init(void)
+{
+	pr_info("%s: S2MU004 Fuelgauge Init\n", __func__);
+	return i2c_add_driver(&s2mu004_fuelgauge_driver);
+}
+
+static void __exit s2mu004_fuelgauge_exit(void)
+{
+	i2c_del_driver(&s2mu004_fuelgauge_driver);
+}
+module_init(s2mu004_fuelgauge_init);
+module_exit(s2mu004_fuelgauge_exit);
+
+MODULE_DESCRIPTION("Samsung S2MU004 Fuel Gauge Driver");
+MODULE_AUTHOR("Samsung Electronics");
+MODULE_LICENSE("GPL");
diff -Naur linux-3.18.14/drivers/battery_v2/s2mu005_charger.c samsung/drivers/battery_v2/s2mu005_charger.c
--- linux-3.18.14/drivers/battery_v2/s2mu005_charger.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/s2mu005_charger.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,1716 @@
+/* drivers/battery/s2mu005_charger.c
+ * S2MU005 Charger Driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ */
+#include <linux/mfd/samsung/s2mu005.h>
+#include "include/charger/s2mu005_charger.h"
+#include <linux/version.h>
+#include <linux/sec_batt.h>
+
+#define ENABLE_MIVR 1
+
+#define EN_OVP_IRQ 1
+#define EN_IEOC_IRQ 1
+#define EN_TOPOFF_IRQ 1
+#define EN_RECHG_REQ_IRQ 0
+#define EN_TR_IRQ 0
+#define EN_MIVR_SW_REGULATION 0
+#define EN_BST_IRQ 0
+#define MINVAL(a, b) ((a <= b) ? a : b)
+
+#define EOC_DEBOUNCE_CNT 2
+#define HEALTH_DEBOUNCE_CNT 3
+#define DEFAULT_CHARGING_CURRENT 500
+
+#define EOC_SLEEP 200
+#define EOC_TIMEOUT (EOC_SLEEP * 6)
+#ifndef EN_TEST_READ
+#define EN_TEST_READ 1
+#endif
+
+#define ENABLE 1
+#define DISABLE 0
+
+struct s2mu005_charger_data {
+	struct i2c_client       *client;
+	struct device *dev;
+	struct s2mu005_platform_data *s2mu005_pdata;
+	struct delayed_work	charger_work;
+	struct delayed_work	det_bat_work;
+	struct workqueue_struct *charger_wqueue;
+	struct power_supply	psy_chg;
+	struct power_supply	psy_otg;
+	s2mu005_charger_platform_data_t *pdata;
+	int dev_id;
+	int input_current;
+	int charging_current;
+	int topoff_current;
+	int cable_type;
+	bool is_charging;
+	int charge_mode;
+	struct mutex io_lock;
+
+	/* register programming */
+	int reg_addr;
+	int reg_data;
+
+	bool ovp;
+	int unhealth_cnt;
+	int status;
+
+	/* s2mu005 */
+	int irq_det_bat;
+	int irq_chg;
+	u8 fg_clock;
+	int fg_mode;
+
+	bool	suspended;
+	bool	pending_chg_work;	
+};
+
+static enum power_supply_property sec_charger_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_CHARGE_TYPE,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_CURRENT_MAX,
+	POWER_SUPPLY_PROP_CURRENT_AVG,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL,
+	POWER_SUPPLY_PROP_CHARGING_ENABLED,
+	POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION,
+	POWER_SUPPLY_PROP_AUTHENTIC,
+};
+
+static enum power_supply_property s2mu005_otg_props[] = {
+	POWER_SUPPLY_PROP_ONLINE,
+};
+
+int otg_enable_flag;
+
+static void s2mu005_set_fast_charging_current(struct i2c_client *i2c,
+		int charging_current);
+static int s2mu005_get_charging_health(struct s2mu005_charger_data *charger);
+
+static void s2mu005_test_read(struct i2c_client *i2c)
+{
+	u8 data;
+	char str[1016] = {0,};
+	int i;
+
+	for (i = 0x8; i <= 0x1A; i++) {
+		s2mu005_read_reg(i2c, i, &data);
+
+		sprintf(str+strlen(str), "0x%02x:0x%02x, ", i, data);
+	}
+
+	pr_info("[DEBUG]%s: %s\n", __func__, str);
+}
+static BLOCKING_NOTIFIER_HEAD(s2m_acok_notifier_list);
+
+static int s2m_acok_register_notifier(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_register(&s2m_acok_notifier_list, nb);
+}
+
+static int s2m_acok_unregister_notifier(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_unregister(&s2m_acok_notifier_list, nb);
+}
+
+int s2m_acok_notify_call_chain(void)
+{
+	int ret = blocking_notifier_call_chain(&s2m_acok_notifier_list, 0, NULL);
+	return notifier_to_errno(ret);
+}
+EXPORT_SYMBOL(s2m_acok_notify_call_chain);
+
+static int s2m_acok_notifier_call(
+				struct notifier_block *notifer,
+				unsigned long event, void *v)
+{
+	struct power_supply *psy = get_power_supply_by_name("s2mu005-charger");
+	struct s2mu005_charger_data *charger =
+		container_of(psy, struct s2mu005_charger_data, psy_chg);
+	pr_info("s2m acok noti!!\n");
+	/* Delay 100ms for debounce */
+	queue_delayed_work(charger->charger_wqueue, &charger->charger_work, msecs_to_jiffies(100));
+	return true;
+}
+
+struct notifier_block s2m_acok_notifier = {
+	.notifier_call = s2m_acok_notifier_call,
+};
+
+static void s2mu005_charger_otg_control(struct s2mu005_charger_data *charger,
+		bool enable)
+{
+	otg_enable_flag = enable;
+
+	if (!enable) {
+		/* set mode to Charger mode */
+		s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL0,
+			2 << REG_MODE_SHIFT, REG_MODE_MASK);
+
+		/* OTG OCP debounce time 100usec->1msec, 0x88[3:2]=11 --> 10 */
+		s2mu005_update_reg(charger->client, 0x88,
+			0x8, 0xC);
+
+#ifdef CONFIG_SEC_FACTORY
+		if(charger->dev_id >= 4) {
+			   /* set mode to Tx mode */
+			s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL0,
+				5 << REG_MODE_SHIFT, REG_MODE_MASK);
+
+			mdelay(150);
+			pr_info("%s: EVT4 OTG Control for factory mode\n", __func__);
+
+			   /* set mode to Charger mode */
+			s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL0,
+				2 << REG_MODE_SHIFT, REG_MODE_MASK);
+		}
+#endif		
+
+		/* mask VMID_INT */
+		s2mu005_update_reg(charger->client, S2MU005_REG_SC_INT_MASK,
+			1 << VMID_M_SHIFT, VMID_M_MASK);
+
+		pr_info("%s : Turn off OTG\n",	__func__);
+	} else {
+		/* unmask VMID_INT */
+		s2mu005_update_reg(charger->client, S2MU005_REG_SC_INT_MASK,
+			0 << VMID_M_SHIFT, VMID_M_MASK);
+
+#ifndef CONFIG_SEC_FACTORY
+		/* EN_OTG OFF */
+		s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL15,
+			0 << T_EN_OTG_SHIFT, T_EN_OTG_MASK);
+		/* OTG SCP disable */
+		s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL4,
+			1 << OTG_OCP_SW_ON_SHIFT, OTG_OCP_SW_ON_MASK);
+#endif
+
+		/* set mode to OTG */
+		s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL0,
+			4 << REG_MODE_SHIFT, REG_MODE_MASK);
+
+		/* OTG OCP debounce time 100usec->1msec, 0x88[3:2]=10 --> 11 */
+		s2mu005_update_reg(charger->client, 0x88,
+			0xC, 0xC);
+
+#ifndef CONFIG_SEC_FACTORY
+		msleep(5);
+
+		/* EN_OTG ON */
+		s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL15,
+			1 << T_EN_OTG_SHIFT, T_EN_OTG_MASK);
+		/* OTG SCP enable */
+		s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL4,
+			0 << OTG_OCP_SW_ON_SHIFT, OTG_OCP_SW_ON_MASK);
+#endif
+
+		/* set boost frequency to 1MHz */
+		s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL11,
+			2 << SET_OSC_BST_SHIFT, SET_OSC_BST_MASK);
+
+		/* set OTG current limit to 1.5 A */
+		s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL4,
+			3 << SET_OTG_OCP_SHIFT, SET_OTG_OCP_MASK);
+
+		/* VBUS switches are OFF when OTG over-current happen */
+		s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL4,
+			1 << OTG_OCP_SW_OFF_SHIFT, OTG_OCP_SW_OFF_MASK);
+
+		/* set OTG voltage to 5.1 V */
+		s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL5,
+			0x16 << SET_VF_VMID_BST_SHIFT, SET_VF_VMID_BST_MASK);
+
+		pr_info("%s : Turn on OTG\n",	__func__);
+	}
+#if EN_TEST_READ
+	s2mu005_test_read(charger->client);
+#endif
+}
+
+static void s2mu005_wdt_control(struct s2mu005_charger_data *charger,
+		int onoff)
+{
+	u8 temp;
+	
+	if (onoff > 0) {
+		s2mu005_read_reg(charger->client, 0x1A, &temp);
+		temp &= ~0x3;
+		temp |= 0x2;
+		s2mu005_write_reg(charger->client, 0x1A, temp);
+		pr_info("%s : Watchdog Timer Enabled,\n",	__func__);
+	} else {
+		s2mu005_read_reg(charger->client, 0x1A, &temp);
+		temp &= ~0x3;
+		temp |= 0x1;
+		s2mu005_write_reg(charger->client, 0x1A, temp);
+		pr_info("%s : Watchdog Timer Disabled,\n",	__func__);
+	}
+}
+
+static void s2mu005_enable_charger_switch(struct s2mu005_charger_data *charger,
+		int onoff)
+{
+	int buck_mode = 0;
+	u8 data = 0;
+	u8 ctrl13 = 0;
+
+	if (factory_mode) {
+		pr_info("%s: Factory Mode Skip CHG_EN Control\n", __func__);
+		return;
+	}
+
+	/* prevent vsys drip, set full current at QBAT */
+	if(charger->dev_id <= 2) {
+		s2mu005_set_fast_charging_current(charger->client, 1700);
+		msleep(20);
+	}
+
+	if(charger->dev_id >= 4)
+		/* 0: all-off mode, 1: buck mode */
+#if defined(CONFIG_S2MU005_EVT4_DISABLE_BUCK_MODE)
+		buck_mode = 0;  // do not support buck only mode
+#else
+		buck_mode = 1;
+#endif
+	else
+		buck_mode = 0;  // do not support buck only mode
+
+	if (onoff > 0) {
+		pr_info("[DEBUG]%s: turn on charger\n", __func__);
+		/* buck 0 -> all off, buck 1 -> buck on, charger off */
+		s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL0,
+			buck_mode << REG_MODE_SHIFT, REG_MODE_MASK);
+		if(charger->dev_id <= 2) {
+			msleep(50);
+			s2mu005_update_reg(charger->client, 0x2A, 0 << 3, 0x08); /* set async time 150msec */
+		}
+		/* buck on, charger on */
+		s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL0,
+			2 << REG_MODE_SHIFT, REG_MODE_MASK);
+		if(charger->dev_id <= 2) {
+			msleep(150);
+			s2mu005_update_reg(charger->client, 0x2A, 1 << 3, 0x08); /* set async time 20msec recover */
+		}
+
+		/* To prevent entering watchdog issue case we set WDT_CLR to not clear before enabling WDT */
+		s2mu005_read_reg(charger->client, S2MU005_CHG_CTRL13, &ctrl13);
+		ctrl13 &= ~0x1;
+		s2mu005_write_reg(charger->client, S2MU005_CHG_CTRL13, ctrl13); /* wdt not clear, CTRL13 REG bit[0]*/
+
+		s2mu005_wdt_control(charger, 1); /* watchdog timer enable */
+	} else {
+		pr_info("[DEBUG] %s: turn off charger\n", __func__);
+		/* buck 0 -> all off, buck 1 -> buck on, charger off */
+		s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL0,
+			buck_mode << REG_MODE_SHIFT, REG_MODE_MASK);
+		s2mu005_wdt_control(charger, 0); /* watchdog timer disable */
+	}
+
+	s2mu005_read_reg(charger->client, S2MU005_CHG_CTRL0, &data);
+	pr_info("%s: CHG_CTRL0(0x%x)\n", __func__, data);
+}
+
+static void s2mu005_set_buck(struct s2mu005_charger_data *charger, int enable)
+{
+	if (enable) {
+		pr_info("[DEBUG]%s: set buck on\n", __func__);
+		s2mu005_enable_charger_switch(charger, charger->is_charging);
+	} else {
+		pr_info("[DEBUG]%s: set buck off (charger off mode)\n", __func__);
+		s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL0, 0 << REG_MODE_SHIFT, REG_MODE_MASK);
+	}
+}
+
+static void s2mu005_set_regulation_voltage(struct s2mu005_charger_data *charger,
+		int float_voltage)
+{
+	int data;
+
+	if (factory_mode)
+		return;
+
+	pr_info("[DEBUG]%s: float_voltage %d \n", __func__, float_voltage);
+	if (float_voltage <= 3900)
+		data = 0;
+	else if (float_voltage > 3900 && float_voltage <= 4400)
+		data = (float_voltage - 3900) / 10;
+	else
+		data = 0x32;
+
+	s2mu005_update_reg(charger->client,
+		S2MU005_CHG_CTRL8, data << SET_VF_VBAT_SHIFT, SET_VF_VBAT_MASK);
+}
+
+static void s2mu005_set_input_current_limit(struct s2mu005_charger_data *charger,
+		int charging_current)
+{
+	int data;
+
+	if (factory_mode)
+		return;
+
+	pr_info("[DEBUG]%s: current  %d \n", __func__, charging_current);
+	if (charging_current <= 100)
+		data = 0;
+	else if (charging_current >= 100 && charging_current <= 2600)
+		data = (charging_current - 100) / 50;
+	else
+		data = 0x3F;
+
+	s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL2, data << INPUT_CURRENT_LIMIT_SHIFT,
+			INPUT_CURRENT_LIMIT_MASK);
+#if EN_TEST_READ
+	s2mu005_test_read(charger->client);
+#endif
+}
+
+static int s2mu005_get_input_current_limit(struct i2c_client *i2c)
+{
+	u8 data;
+	int ret;
+
+	ret = s2mu005_read_reg(i2c, S2MU005_CHG_CTRL2, &data);
+	if (ret < 0)
+		return ret;
+
+	data = data & INPUT_CURRENT_LIMIT_MASK;
+
+	if (data >= 0x3F)
+		data = 0x3F;
+	return  data * 50 + 100;
+
+}
+
+static void s2mu005_set_fast_charging_current(struct i2c_client *i2c,
+		int charging_current)
+{
+	int data;
+
+	if (factory_mode)
+		return;
+
+	pr_info("[DEBUG]%s: current  %d \n", __func__, charging_current);
+	if (charging_current <= 100)
+		data = 0;
+	else if (charging_current >= 100 && charging_current <= 2600)
+		data = ((charging_current - 100) / 50) + 1;
+	else
+		data = 0x33;
+
+	s2mu005_update_reg(i2c, S2MU005_CHG_CTRL7, data << FAST_CHARGING_CURRENT_SHIFT,
+			FAST_CHARGING_CURRENT_MASK);
+
+	/* work-around for unstable booting */
+	if (data > 0x13) data = 0x13; /* 0x13 : 1A */
+	s2mu005_update_reg(i2c, S2MU005_CHG_CTRL6, data << COOL_CHARGING_CURRENT_SHIFT,
+	COOL_CHARGING_CURRENT_MASK); /* set cool charging current with max limit 1A */
+
+#if EN_TEST_READ
+	s2mu005_test_read(i2c);
+#endif
+}
+
+static int s2mu005_get_fast_charging_current(struct i2c_client *i2c)
+{
+	u8 data;
+	int ret;
+
+	ret = s2mu005_read_reg(i2c, S2MU005_CHG_CTRL7, &data);
+	if (ret < 0)
+		return ret;
+
+	data = data & FAST_CHARGING_CURRENT_MASK;
+
+	if (data > 0x33)
+		data = 0x33;
+	return (data - 1 )* 50 + 100;
+}
+
+static int s2mu005_get_topoff_current(struct s2mu005_charger_data *charger)
+{
+	u8 data;
+	int ret;
+
+	ret = s2mu005_read_reg(charger->client, S2MU005_CHG_CTRL10, &data);
+	if (ret < 0)
+		return ret;
+
+	data = data & FIRST_TOPOFF_CURRENT_MASK;
+
+	if (data >= 0x0F)
+		data = 0x0F;
+	return data * 25 + 100;
+}
+
+static void s2mu005_set_topoff_current(struct i2c_client *i2c,
+		int eoc_1st_2nd, int current_limit)
+{
+	int data;
+
+	pr_info("[DEBUG]%s: current  %d \n", __func__, current_limit);
+	if (current_limit <= 100)
+		data = 0;
+	else if (current_limit > 100 && current_limit <= 475)
+		data = (current_limit - 100) / 25;
+	else
+		data = 0x0F;
+
+	switch(eoc_1st_2nd) {
+	case 1:
+		s2mu005_update_reg(i2c, S2MU005_CHG_CTRL10, data << FIRST_TOPOFF_CURRENT_SHIFT,
+			FIRST_TOPOFF_CURRENT_MASK);
+		break;
+	case 2:
+		s2mu005_update_reg(i2c, S2MU005_CHG_CTRL10, data << SECOND_TOPOFF_CURRENT_SHIFT,
+			SECOND_TOPOFF_CURRENT_MASK);
+		break;
+	default:
+		break;
+	}
+}
+
+enum {
+	S2MU005_MIVR_4200MV = 0,
+	S2MU005_MIVR_4300MV,
+	S2MU005_MIVR_4400MV,
+	S2MU005_MIVR_4500MV,
+	S2MU005_MIVR_4600MV,
+	S2MU005_MIVR_4700MV,
+	S2MU005_MIVR_4800MV,
+	S2MU005_MIVR_4900MV,
+};
+
+#if ENABLE_MIVR
+/* charger input regulation voltage setting */
+static void s2mu005_set_mivr_level(struct s2mu005_charger_data *charger)
+{
+	int mivr = S2MU005_MIVR_4500MV;
+	u8 temp = 0;
+
+	s2mu005_read_reg(charger->client, 0x1A, &temp);
+	temp |= 0x80;
+	s2mu005_write_reg(charger->client, 0x1A, temp);
+
+	s2mu005_update_reg(charger->client,
+			S2MU005_CHG_CTRL1, mivr << SET_VIN_DROP_SHIFT, SET_VIN_DROP_MASK);
+}
+#endif /*ENABLE_MIVR*/
+
+/* here is set init charger data */
+#define S2MU003_MRSTB_CTRL 0X47
+static bool s2mu005_chg_init(struct s2mu005_charger_data *charger)
+{
+	u8 temp;
+	/* Read Charger IC Dev ID */
+	s2mu005_read_reg(charger->client, S2MU005_REG_REV_ID, &temp);
+	charger->dev_id = temp & 0x0F;
+
+	dev_info(charger->dev, "%s : DEV ID : 0x%x\n", __func__,
+			charger->dev_id);
+
+/* s2mu005 : CHG 0xAF[7]=1 for SMPL issue, 0xAF[7]=0 for JIG case */
+#if !defined(CONFIG_SEC_FACTORY)
+	if (charger->dev_id == 3) {
+		s2mu005_update_reg(charger->client, 0xAF, 1 << 7, 1 << 7);
+		s2mu005_read_reg(charger->client, 0xAF, &temp);
+		dev_info(charger->dev, "[DEBUG]%s : 0xAF(0x%x)\n", __func__, temp);
+	}
+#endif
+
+	/* ready for self-discharge */
+	s2mu005_update_reg(charger->client, S2MU005_REG_SELFDIS_CFG3,
+			SELF_DISCHG_MODE_MASK, SELF_DISCHG_MODE_MASK);
+
+	/* Buck switching mode frequency setting */
+
+	/* Disable Timer function (Charging timeout fault) */
+	// to be
+
+	/* Disable TE */
+	// to be
+
+	/* MUST set correct regulation voltage first
+	 * Before MUIC pass cable type information to charger
+	 * charger would be already enabled (default setting)
+	 * it might cause EOC event by incorrect regulation voltage */
+	// to be
+
+#if !(ENABLE_MIVR)
+	/* voltage regulatio disable does not exist mu005 */
+#endif
+	/* TOP-OFF debounce time set 256us */
+	// only 003 ? need to check
+
+	/* Disable (set 0min TOP OFF Timer) */
+	// to be
+
+	s2mu005_read_reg(charger->client, 0x7B, &temp);
+
+	if(charger->dev_id <= 2) {
+		s2mu005_update_reg(charger->client, 0x2A, 1 << 3, 0x08); // set async time 20msec recover
+	}
+
+	charger->fg_clock = temp;
+
+	s2mu005_read_reg(charger->client, 0x20, &temp); //topoff timer 90min, watchdog timer 80sec
+	temp &= ~0x3F;
+	temp |= 0x35;
+	s2mu005_write_reg(charger->client, 0x20, temp);
+
+	s2mu005_read_reg(charger->client, S2MU005_CHG_CTRL0, &temp); //Always CHG_EN is ENABLED
+	if( !(temp & 0x10) )
+	{
+		temp |= 0x10;
+		s2mu005_write_reg(charger->client, S2MU005_CHG_CTRL0, temp);
+		dev_info(charger->dev, "%s: CHG CTRL0 CHG EN : 0x%02x\n", __func__,temp);
+	}
+	
+	/* float voltage */
+	s2mu005_set_regulation_voltage(charger,
+			charger->pdata->chg_float_voltage);
+	
+	dev_info(charger->dev, "%s: set float voltage : %d\n", __func__,charger->pdata->chg_float_voltage);
+
+	return true;
+}
+
+static void s2mu005_charger_initialize(struct s2mu005_charger_data *charger)
+{
+	u8 temp = 0;
+
+	s2mu005_read_reg(charger->client, 0x5A, &temp);
+	temp |= 0x80;
+	s2mu005_write_reg(charger->client, 0x5A, temp);
+
+	if(charger->dev_id == 0) {
+		s2mu005_write_reg(charger->client, 0x87, 0x00);
+		s2mu005_write_reg(charger->client, 0x92, 0xE5);
+		s2mu005_write_reg(charger->client, 0x97, 0x85);
+		s2mu005_write_reg(charger->client, 0x9A, 0x67);
+		s2mu005_write_reg(charger->client, 0x9C, 0xEA);
+		s2mu005_write_reg(charger->client, 0x9E, 0x6E);
+		s2mu005_write_reg(charger->client, 0xA1, 0x20);
+		s2mu005_write_reg(charger->client, 0xA4, 0x0A);
+		s2mu005_write_reg(charger->client, 0xA5, 0x45);
+
+		s2mu005_read_reg(charger->client, 0x51, &temp);
+		if(temp & 0x02) {
+			s2mu005_read_reg(charger->client, 0x49, &temp);
+			switch(temp & 0x1F) {
+				case 0x18:
+				case 0x19:
+				case 0x1C:
+				case 0x1D:
+					break;
+				default:
+					s2mu005_read_reg(charger->client, 0x89, &temp);
+					temp &= 0xFC;
+					temp |= 0x01;
+					s2mu005_write_reg(charger->client, 0x89, temp);
+					break;
+			}
+		}
+	}
+	/* set fastest speed for QBAT switch */
+	s2mu005_read_reg(charger->client, 0x87, &temp);
+	temp &= ~0xF0;
+	s2mu005_write_reg(charger->client, 0x87, temp);
+
+	s2mu005_write_reg(charger->client, 0x27, 0x51);
+	
+	s2mu005_read_reg(charger->client, 0x20, &temp); //topoff timer 90min, watchdog timer 80sec
+	temp &= ~0x3F;
+	temp |= 0x35;
+	s2mu005_write_reg(charger->client, 0x20, temp);
+	
+	s2mu005_write_reg(charger->client, 0x1A, 0x91);
+
+	s2mu005_read_reg(charger->client, 0x13, &temp);
+	temp &= ~0x60;
+	s2mu005_write_reg(charger->client, 0x13, temp);
+
+	s2mu005_read_reg(charger->client, 0xA8, &temp);
+	temp &= 0x7F;
+	temp |= 0x80;
+	s2mu005_write_reg(charger->client, 0xA8, temp);
+
+	s2mu005_write_reg(charger->client, 0x0F, 0x50);
+
+	s2mu005_read_reg(charger->client, 0x89, &temp);
+	temp &= ~0x80;
+	s2mu005_write_reg(charger->client, 0x89, temp);
+
+	s2mu005_read_reg(charger->client, 0xA5, &temp);
+	temp &= ~0x04;
+	s2mu005_write_reg(charger->client, 0xA5, temp);
+
+	s2mu005_read_reg(charger->client, 0x20, &temp); //topoff timer 90min
+	temp &= ~0x38;
+	temp |= 0x30;
+	s2mu005_write_reg(charger->client, 0x20, temp);
+
+#if ENABLE_MIVR
+	s2mu005_set_mivr_level(charger);
+#endif /*DISABLE_MIVR*/
+	/* float voltage */
+	s2mu005_set_regulation_voltage(charger,
+			charger->pdata->chg_float_voltage);
+	/* topoff current */
+	charger->topoff_current = 100;
+	s2mu005_set_topoff_current(charger->client, 1, charger->topoff_current);
+	if (charger->pdata->chg_eoc_dualpath) {
+		s2mu005_set_topoff_current(charger->client, 2, charger->topoff_current);
+	}
+
+	dev_info(charger->dev, "%s: Re-initialize Charger completely\n", __func__);
+}
+
+static int s2mu005_get_charging_status(struct s2mu005_charger_data *charger)
+{
+	int status = POWER_SUPPLY_STATUS_UNKNOWN;
+	int ret;
+	u8 chg_sts;
+	union power_supply_propval chg_mode;
+	union power_supply_propval value;
+
+	ret = s2mu005_read_reg(charger->client, S2MU005_CHG_STATUS0, &chg_sts);
+	psy_do_property("battery", get, POWER_SUPPLY_PROP_CHARGE_NOW, chg_mode);
+	psy_do_property("s2mu005-fuelgauge", get, POWER_SUPPLY_PROP_CURRENT_AVG, value);
+
+	if (ret < 0)
+		return status;
+
+	switch (chg_sts & 0x0F) {
+	case 0x00:	//charger is off
+		status = POWER_SUPPLY_STATUS_DISCHARGING;
+		break;
+	case 0x02:	//Pre-charge state
+	case 0x03:	//Cool-charge state
+	case 0x04:	//CC state
+	case 0x05:	//CV state
+		status = POWER_SUPPLY_STATUS_CHARGING;
+		break;
+	case 0x07:	//Top-off state
+	case 0x06:	//Done Flag
+	case 0x08:	//Done state
+		dev_info(charger->dev, "%s: full check curr_avg(%d), topoff_curr(%d)\n",
+			__func__, value.intval, charger->topoff_current);
+		if (value.intval < charger->topoff_current)
+			status = POWER_SUPPLY_STATUS_FULL;
+		else
+			status = POWER_SUPPLY_STATUS_CHARGING;
+		break;
+	case 0x0F:	//Input is invalid
+		status = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		break;
+	default:
+		break;
+	}
+
+#if EN_TEST_READ
+	s2mu005_test_read(charger->client);
+#endif
+	return status;
+}
+
+static int s2mu005_get_charge_type(struct i2c_client *iic)
+{
+	int status = POWER_SUPPLY_CHARGE_TYPE_UNKNOWN;
+	u8 data;
+	int ret;
+
+	ret = s2mu005_read_reg(iic, S2MU005_CHG_STATUS0, &data);
+	if (ret < 0)
+		dev_err(&iic->dev, "%s fail\n", __func__);
+
+	switch (data & CHG_OK_MASK ) {
+	case CHG_OK_MASK:
+		status = POWER_SUPPLY_CHARGE_TYPE_FAST;
+		break;
+	default:
+		/* 005 does not need to do this */
+		/* pre-charge mode */
+		status = POWER_SUPPLY_CHARGE_TYPE_TRICKLE;
+		break;
+	}
+
+	return status;
+}
+
+static bool s2mu005_get_batt_present(struct i2c_client *iic)
+{
+	u8 data;
+	int ret;
+
+	ret = s2mu005_read_reg(iic, S2MU005_CHG_STATUS1, &data);
+	if (ret < 0)
+		return false;
+
+	return (data & DET_BAT_STATUS_MASK) ? true : false;
+}
+
+static void s2mu005_wdt_clear(struct s2mu005_charger_data *charger)
+{
+	u8 status3;
+	u8 ctrl13;
+	
+	s2mu005_read_reg(charger->client, S2MU005_CHG_STATUS3, &status3);
+
+	s2mu005_read_reg(charger->client, S2MU005_CHG_CTRL13, &ctrl13);
+	ctrl13 &= ~0x1;
+	ctrl13 |= 0x1;
+	s2mu005_write_reg(charger->client, S2MU005_CHG_CTRL13, ctrl13); /* wdt clear */
+	
+	status3 &= 0x0f;
+
+	if (status3 == 0x05) {
+		dev_info(&charger->client->dev,
+			"%s: watchdog error status, enable charger\n", __func__);
+		s2mu005_enable_charger_switch(charger, charger->is_charging);
+	}
+}
+
+static void s2mu005_get_vsys_charging_health(struct s2mu005_charger_data *charger)
+{
+	u8 data;
+	int ret;
+	union power_supply_propval value;
+
+	/* add VSYS OVP handling codes for ACT test */
+	ret = s2mu005_read_reg(charger->client, S2MU005_CHG_STATUS3, &data);
+	data = data & 0xf;
+	pr_info("%s: CHG_STASTUS3(0x%x)\n", __func__, data);
+	switch(data) {
+	case 0x3:
+		pr_info("%s: VSYS OVP\n", __func__);
+		psy_do_property("battery", set, POWER_SUPPLY_EXT_PROP_SYSOVLO, value);
+		break;
+	case 0x4:
+		pr_info("%s: VSYS UVLO\n", __func__);
+		break;
+	default:
+		break;
+	}
+}
+
+static int s2mu005_get_charging_health(struct s2mu005_charger_data *charger)
+{
+	u8 data;
+	int ret;
+
+	s2mu005_get_vsys_charging_health(charger);
+
+	ret = s2mu005_read_reg(charger->client, S2MU005_CHG_STATUS1, &data);
+	
+	if(charger->is_charging) {
+		s2mu005_wdt_clear(charger);
+	}
+
+	if (ret < 0)
+		return POWER_SUPPLY_HEALTH_UNKNOWN;
+
+	data = (data & 0x70) >> 4;
+	switch (data) {
+	case 0x03:
+	case 0x05:
+		charger->ovp = false;
+		charger->unhealth_cnt = 0;
+		return POWER_SUPPLY_HEALTH_GOOD;
+	default:
+		break;
+	}
+
+	charger->unhealth_cnt++;
+	if (charger->unhealth_cnt < HEALTH_DEBOUNCE_CNT)
+		return POWER_SUPPLY_HEALTH_GOOD;
+
+	/* 005 need to check ovp & health count */
+	charger->unhealth_cnt = HEALTH_DEBOUNCE_CNT;
+	if (charger->ovp)
+		return POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+	return POWER_SUPPLY_HEALTH_UNDERVOLTAGE;
+}
+
+static int sec_chg_get_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		union power_supply_propval *val)
+{
+	int chg_curr, aicr;
+	struct s2mu005_charger_data *charger =
+		container_of(psy, struct s2mu005_charger_data, psy_chg);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = charger->charging_current ? 1 : 0;
+		break;
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = s2mu005_get_charging_status(charger);
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = s2mu005_get_charging_health(charger);
+#if EN_TEST_READ
+		s2mu005_test_read(charger->client);
+#endif
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		val->intval = s2mu005_get_input_current_limit(charger->client);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		if (charger->charging_current) {
+			aicr = s2mu005_get_input_current_limit(charger->client);
+			chg_curr = s2mu005_get_fast_charging_current(charger->client);
+			val->intval = MINVAL(aicr, chg_curr);
+		} else
+			val->intval = 0;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_FULL:
+		val->intval = s2mu005_get_topoff_current(charger);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+		val->intval = s2mu005_get_charge_type(charger->client);
+		break;
+#if defined(CONFIG_BATTERY_SWELLING) || defined(CONFIG_BATTERY_SWELLING_SELF_DISCHARGING)
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+		val->intval = charger->pdata->chg_float_voltage;
+		break;
+#endif
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = s2mu005_get_batt_present(charger->client);
+		break;
+	case POWER_SUPPLY_PROP_CHARGING_ENABLED:
+		val->intval = charger->is_charging;
+		break;
+	case POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sec_chg_set_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		const union power_supply_propval *val)
+{
+	struct s2mu005_charger_data *charger =
+		container_of(psy, struct s2mu005_charger_data, psy_chg);
+	enum power_supply_ext_property ext_psp = psp;
+	int buck_state = ENABLE;
+	union power_supply_propval value;
+	u8 temp;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		charger->status = val->intval;
+		break;
+		/* val->intval : type */
+	case POWER_SUPPLY_PROP_ONLINE:
+		charger->cable_type = val->intval;
+
+		if (charger->cable_type != POWER_SUPPLY_TYPE_OTG) {
+			if (charger->cable_type == POWER_SUPPLY_TYPE_BATTERY ||
+					charger->cable_type == POWER_SUPPLY_TYPE_UNKNOWN) {
+				value.intval = 0;
+			} else {
+#if ENABLE_MIVR
+				s2mu005_set_mivr_level(charger);
+#endif 			/*DISABLE_MIVR*/
+				value.intval = 1;
+			}
+			psy_do_property("s2mu005-fuelgauge", set, POWER_SUPPLY_PROP_ENERGY_AVG, value);
+		}
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		{
+			int input_current = val->intval;
+			if (charger->input_current == 
+				charger->pdata->charging_current[POWER_SUPPLY_TYPE_BATTERY].input_current_limit)
+				msleep(50);
+			s2mu005_set_input_current_limit(charger, input_current);
+			charger->input_current = input_current;
+			pr_info("[DEBUG]%s:[BATT] cable_type(%d), input_current(%d)mA\n",
+			__func__, charger->cable_type, charger->input_current);
+		}
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		pr_info("[DEBUG] %s: is_charging %d\n", __func__, charger->is_charging);
+		charger->charging_current = val->intval;
+		/* set charging current */
+			s2mu005_set_fast_charging_current(charger->client, charger->charging_current);
+#if EN_TEST_READ
+		s2mu005_test_read(charger->client);
+#endif
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_FULL:
+		charger->topoff_current = val->intval;
+		if (charger->pdata->chg_eoc_dualpath) {
+			s2mu005_set_topoff_current(charger->client, 1, val->intval);
+			s2mu005_set_topoff_current(charger->client, 2, 100);
+		}
+		else
+			s2mu005_set_topoff_current(charger->client, 1, val->intval);
+		break;
+#if defined(CONFIG_BATTERY_SWELLING) || defined(CONFIG_BATTERY_SWELLING_SELF_DISCHARGING)
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+		pr_info("[DEBUG]%s: float voltage(%d)\n", __func__, val->intval);
+		charger->pdata->chg_float_voltage = val->intval;
+		s2mu005_set_regulation_voltage(charger,
+				charger->pdata->chg_float_voltage);
+		break;
+#endif
+	case POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL:
+		s2mu005_charger_otg_control(charger, val->intval);
+		break;
+	case POWER_SUPPLY_PROP_CHARGING_ENABLED:
+		charger->charge_mode = val->intval;
+		psy_do_property("battery", get, POWER_SUPPLY_PROP_ONLINE, value);
+		if (value.intval != POWER_SUPPLY_TYPE_OTG) {
+			pr_info("[DEBUG]%s: CHARGING_ENABLE(%d)\n", __func__,charger->charge_mode);
+			switch (charger->charge_mode) {
+			case SEC_BAT_CHG_MODE_BUCK_OFF:
+				buck_state = DISABLE;
+			case SEC_BAT_CHG_MODE_CHARGING_OFF:
+				charger->is_charging = false;
+				break;
+			case SEC_BAT_CHG_MODE_CHARGING:
+				charger->is_charging = true;
+				break;
+			}
+			if(charger->dev_id >= 4) {
+				if (buck_state) {
+					s2mu005_enable_charger_switch(charger, charger->is_charging);
+				} else {
+					/* set buck off only if SEC_BAT_CHG_MODE_BUCK_OFF */
+					s2mu005_set_buck(charger, buck_state);
+				}
+			} else {
+				s2mu005_enable_charger_switch(charger, charger->is_charging);
+			}
+		} else {
+			pr_info("[DEBUG]%s: SKIP CHARGING CONTROL(%d)\n", __func__, value.intval);
+		}
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_ENABLED:
+		s2mu005_charger_initialize(charger);
+		break;
+	case POWER_SUPPLY_PROP_ENERGY_NOW:
+#if !defined(CONFIG_SEC_FACTORY)
+		if (charger->dev_id == 3) {
+			if (val->intval) {
+				s2mu005_update_reg(charger->client, 0xAF, 0 << 7, 1 << 7);
+				s2mu005_read_reg(charger->client, 0xAF, &temp);
+				pr_info("[DEBUG]%s: 0xAF(0x%x) (%d)\n", __func__, temp, val->intval);
+			}
+		}
+#endif
+		/* Switch-off charger if JIG is connected */
+		if (val->intval && factory_mode) {
+			pr_info("%s: JIG Connection status: %d \n", __func__, val->intval);
+			s2mu005_enable_charger_switch(charger, false);
+		}
+		break;
+	case POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION:
+		if (val->intval) {
+			pr_info("%s: Relieve VBUS2BAT\n", __func__);
+			s2mu005_write_reg(charger->client, 0x26, 0x5D);
+		}
+		break;
+	case POWER_SUPPLY_PROP_AUTHENTIC:
+		if (val->intval) {
+			pr_info("%s: Bypass set\n", __func__);
+			s2mu005_write_reg(charger->client, 0x2A, 0x10);
+			s2mu005_write_reg(charger->client, 0x23, 0x15);
+			s2mu005_write_reg(charger->client, 0x24, 0x44);
+
+			pr_info("%s: Do additional setting!!!!!\n", __func__);
+			s2mu005_update_reg(charger->client, 0x0E, 0x01 << 6, 0x01 << 6);
+			s2mu005_write_reg(charger->client, 0x96, 0xD5);
+			s2mu005_update_reg(charger->client, 0xA1, 0x01 << 7, 0x01 << 7);
+			s2mu005_write_reg(charger->client, 0x7C, 0x00);
+			s2mu005_write_reg(charger->client, 0x59, 0x0F);
+			s2mu005_update_reg(charger->client, 0xAF, 0x00 << 7, 0x01 << 7);
+			s2mu005_write_reg(charger->client, 0x1C, 0x5D);
+			s2mu005_write_reg(charger->client, 0x26, 0x51);
+
+			/* ULDO off */
+			s2mu005_update_reg(charger->client, 0x5A, 0x00 << 7, 0x01 << 7);
+
+			s2mu005_read_reg(charger->client, 0x0E, &temp);
+			pr_info("[DEBUG]%s: 0x96(0x%x) (%d)\n", __func__, temp, val->intval);
+			s2mu005_read_reg(charger->client, 0x96, &temp);
+			pr_info("[DEBUG]%s: 0x96(0x%x) (%d)\n", __func__, temp, val->intval);
+			s2mu005_read_reg(charger->client, 0xA1, &temp);
+			pr_info("[DEBUG]%s: 0xA1(0x%x) (%d)\n", __func__, temp, val->intval);
+			s2mu005_read_reg(charger->client, 0x7C, &temp);
+			pr_info("[DEBUG]%s: 0x7C(0x%x) (%d)\n", __func__, temp, val->intval);
+			s2mu005_read_reg(charger->client, 0x59, &temp);
+			pr_info("[DEBUG]%s: 0x59(0x%x) (%d)\n", __func__, temp, val->intval);
+			s2mu005_read_reg(charger->client, 0xAF, &temp);
+			pr_info("[DEBUG]%s: 0xAF(0x%x) (%d)\n", __func__, temp, val->intval);
+			s2mu005_read_reg(charger->client, 0x1C, &temp);
+			pr_info("[DEBUG]%s: 0x1C(0x%x) (%d)\n", __func__, temp, val->intval);
+			s2mu005_read_reg(charger->client, 0x26, &temp);
+			pr_info("[DEBUG]%s: 0x26(0x%x) (%d)\n", __func__, temp, val->intval);
+			s2mu005_read_reg(charger->client, 0x5A, &temp);
+			pr_info("[DEBUG]%s: 0x5A(0x%x) (%d)\n", __func__, temp, val->intval);
+		}
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_MEASURE:
+		if (val->intval) {
+			pr_info("%s: Bypass set for current measure\n", __func__);
+			/*
+			 * Charger/muic interrupt can be occured by entering Bypass mode
+			 * Disable all interrupt mask for testing current measure.
+			 */
+			s2mu005_write_reg(charger->client, S2MU005_REG_SC_INT_MASK, 0xFF);
+			s2mu005_write_reg(charger->client, S2MU005_REG_MUIC_INT1_MASK, 0xFF);
+			s2mu005_write_reg(charger->client, S2MU005_REG_MUIC_INT2_MASK, 0xFF);
+
+			/* Enter Bypass mode set for current measure */
+			s2mu005_update_reg(charger->client, 0xA2, 0x01 << 6, 0x01 << 6);	/* FAST JIG enable */
+			s2mu005_update_reg(charger->client, 0xA7, 0x80, 0x80);				/* 0xA7 and 0x23 is for JIG QBAT On */
+			s2mu005_update_reg(charger->client, 0x23, 0x0C, 0x0C);
+			s2mu005_update_reg(charger->client, 0x96, 0x00, 0xC0); 				/* VBUS UVLO Low set */
+			s2mu005_update_reg(charger->client, 0x0E, 0x01 << 5, 0x01 << 5); 	/* JIG_ON_AP enable (enter factory mode) */
+			s2mu005_write_reg(charger->client, 0x26, 0xdd); 					/* UVLO and IN2BAT Off */
+			s2mu005_update_reg(charger->client, 0xAF, 0x00, 0x80);				/* BAT to SYS diode off */
+			s2mu005_update_reg(charger->client, 0x0E, 0x01 << 6, 0x01 << 6);	/* EN_JIG_BYPASS_MODE enable */
+			/* USB LDO off */
+			s2mu005_update_reg(charger->client, S2MU005_REG_PWRSEL_CTRL0,
+				0 << 7, 1 << 7);
+			msleep(50);
+			s2mu005_update_reg(charger->client, 0xA7, 0x00, 0x80);				/* set JIG_QBAT_OFF */
+			psy_do_property( "s2mu005-fuelgauge", set,
+				POWER_SUPPLY_PROP_FUELGAUGE_FACTORY, value);
+		} else {
+			pr_info("%s: Bypass exit for current measure\n", __func__);
+			s2mu005_update_reg(charger->client, 0x1C, 0xC0, 0xC0);				/* QBAT Off */
+			s2mu005_write_reg(charger->client, 0x0E, 0x00);						/* Charger off */
+		}
+		break;
+	case POWER_SUPPLY_PROP_RESISTANCE:
+		if(val->intval) {
+			s2mu005_update_reg(charger->client, S2MU005_REG_SELFDIS_CFG2,
+			FC_SELF_DISCHG_MASK, FC_SELF_DISCHG_MASK);
+		} else {
+			s2mu005_update_reg(charger->client, S2MU005_REG_SELFDIS_CFG2,
+			0, FC_SELF_DISCHG_MASK);
+		}
+		break;
+	case POWER_SUPPLY_PROP_SCOPE:
+		charger->fg_mode = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_MAX ... POWER_SUPPLY_EXT_PROP_MAX:
+		switch (ext_psp) {
+		case POWER_SUPPLY_EXT_PROP_FACTORY_VOLTAGE_REGULATION:
+			/* S2MU005 set up Vsys 4.0V by 0x0E[7] = 0 */
+			s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL0, 0 << 7, 1 << 7);
+			pr_info("%s: factory voltage regulation 4.0V\n", __func__);
+			break;
+		case POWER_SUPPLY_EXT_PROP_DISABLE_FACTORY_MODE:
+			{
+				u8 temp;
+				if (val->intval) {
+					/* Disable Factory Mode */
+					pr_info("%s: Disable Factory Mode\n", __func__);
+
+					/* Buck regulation voltage applied */
+					s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL0, 1 << 7, 1 << 7);
+					/* Bat to Sys Diode On */
+					s2mu005_update_reg(charger->client, 0xAF, 1 << 7, 1 << 7);
+					/* Disable JIGON, Charger mode */
+					s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL0, 0x00, 0x20);
+					/* Set Float voltage to 4.35V */
+					s2mu005_write_reg(charger->client, S2MU005_CHG_CTRL8, 0x5A);
+					/* JIG QBAT On */
+					s2mu005_update_reg(charger->client, 0xA7, 1 << 7, 1 << 7);
+					/* SYS OVP enable */
+					s2mu005_update_reg(charger->client, 0x9E, 1 << 5, 1 << 5);
+					/* IN to BAT function On */
+					s2mu005_update_reg(charger->client, 0x26, 0x04, 0x0C);
+					/* BUCK OSC 750KHz */
+					s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL11, 0x08, 0x18);
+					/* Disable FAST JIG */
+					s2mu005_update_reg(charger->client, 0xA2, 0 << 6, 1 << 6);
+					/* VMID Switch Off Enable */
+					s2mu005_update_reg(charger->client, 0xA1, 0 << 6, 1 << 6);
+					/* OVP Level Recover */
+					s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL1, 1 << 2, 1 << 2);
+
+					s2mu005_read_reg(charger->client, S2MU005_CHG_CTRL0, &temp);
+					pr_info("[DEBUG]%s: 0x0E : 0x%x\n", __func__, temp);
+					s2mu005_read_reg(charger->client, 0xAF, &temp);
+					pr_info("[DEBUG]%s: 0xAF : 0x%x\n", __func__, temp);
+					s2mu005_read_reg(charger->client, S2MU005_CHG_CTRL8, &temp);
+					pr_info("[DEBUG]%s: 0x16 : 0x%x\n", __func__, temp);
+					s2mu005_read_reg(charger->client, 0xA7, &temp);
+					pr_info("[DEBUG]%s: 0xA7 : 0x%x\n", __func__, temp);
+					s2mu005_read_reg(charger->client, 0x9E, &temp);
+					pr_info("[DEBUG]%s: 0x9E : 0x%x\n", __func__, temp);
+					s2mu005_read_reg(charger->client, 0x26, &temp);
+					pr_info("[DEBUG]%s: 0x26 : 0x%x\n", __func__, temp);
+					s2mu005_read_reg(charger->client, 0x19, &temp);
+					pr_info("[DEBUG]%s: 0x19 : 0x%x\n", __func__, temp);
+					s2mu005_read_reg(charger->client, 0xA2, &temp);
+					pr_info("[DEBUG]%s: 0xA2 : 0x%x\n", __func__, temp);
+					s2mu005_read_reg(charger->client, 0xA1, &temp);
+					pr_info("[DEBUG]%s: 0xA1 : 0x%x\n", __func__, temp);
+					s2mu005_read_reg(charger->client, 0x0F, &temp);
+					pr_info("[DEBUG]%s: 0x0F : 0x%x\n", __func__, temp);
+				}
+			}
+			break;
+		default:
+			return -EINVAL;
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int s2mu005_otg_get_property(struct power_supply *psy,
+				enum power_supply_property psp,
+				union power_supply_propval *val)
+{
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = otg_enable_flag;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int s2mu005_otg_set_property(struct power_supply *psy,
+				enum power_supply_property psp,
+				const union power_supply_propval *val)
+{
+	struct s2mu005_charger_data *charger =
+		container_of(psy, struct s2mu005_charger_data, psy_otg);
+	union power_supply_propval value;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		value.intval = val->intval;
+		pr_info("%s: OTG %s\n", __func__, value.intval > 0 ? "on" : "off");
+		psy_do_property(charger->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL, value);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/*
+ssize_t s2mu003_chg_show_attrs(struct device *dev,
+		const ptrdiff_t offset, char *buf)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct s2mu003_charger_data *charger =
+		container_of(psy, struct s2mu003_charger_data, psy_chg);
+	int i = 0;
+	char *str = NULL;
+
+	switch (offset) {
+	case CHG_REG:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%x\n",
+				charger->reg_addr);
+		break;
+	case CHG_DATA:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%x\n",
+				charger->reg_data);
+		break;
+	case CHG_REGS:
+		str = kzalloc(sizeof(char) * 256, GFP_KERNEL);
+		if (!str)
+			return -ENOMEM;
+
+	//	s2mu005_read_regs(charger->client, str);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%s\n",
+				str);
+
+		kfree(str);
+		break;
+	default:
+		i = -EINVAL;
+		break;
+	}
+
+	return i;
+}
+
+ssize_t s2mu003_chg_store_attrs(struct device *dev,
+		const ptrdiff_t offset,
+		const char *buf, size_t count)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct s2mu003_charger_data *charger =
+		container_of(psy, struct s2mu003_charger_data, psy_chg);
+
+	int ret = 0;
+	int x = 0;
+	uint8_t data = 0;
+
+	switch (offset) {
+	case CHG_REG:
+		if (sscanf(buf, "%x\n", &x) == 1) {
+			charger->reg_addr = x;
+			data = s2mu003_reg_read(charger->client,
+					charger->reg_addr);
+			charger->reg_data = data;
+			dev_dbg(dev, "%s: (read) addr = 0x%x, data = 0x%x\n",
+					__func__, charger->reg_addr, charger->reg_data);
+			ret = count;
+		}
+		break;
+	case CHG_DATA:
+		if (sscanf(buf, "%x\n", &x) == 1) {
+			data = (u8)x;
+
+			dev_dbg(dev, "%s: (write) addr = 0x%x, data = 0x%x\n",
+					__func__, charger->reg_addr, data);
+			ret = s2mu003_reg_write(charger->client,
+					charger->reg_addr, data);
+			if (ret < 0) {
+				dev_dbg(dev, "I2C write fail Reg0x%x = 0x%x\n",
+						(int)charger->reg_addr, (int)data);
+			}
+			ret = count;
+		}
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+*/
+
+static void s2mu005_det_bat_work(struct work_struct *work)
+{
+	struct s2mu005_charger_data *charger =
+		container_of(work, struct s2mu005_charger_data, det_bat_work.work);
+	u8 val;
+	union power_supply_propval value;
+
+	s2mu005_read_reg(charger->client, S2MU005_CHG_STATUS1, &val);
+	if ((val & DET_BAT_STATUS_MASK) == 0)
+	{
+		//value.intval = 0;
+		psy_do_property("s2mu005-fuelgauge", set, POWER_SUPPLY_PROP_CHARGE_EMPTY, value);
+		s2mu005_enable_charger_switch(charger, 0);
+		pr_info("charger-off if battery removed \n");
+	}
+}
+
+/* s2mu005 interrupt service routine */
+static irqreturn_t s2mu005_det_bat_isr(int irq, void *data)
+{
+	struct s2mu005_charger_data *charger = data;
+
+	queue_delayed_work(charger->charger_wqueue, &charger->det_bat_work, 0);
+
+	return IRQ_HANDLED;
+}
+static irqreturn_t s2mu005_chg_isr(int irq, void *data)
+{
+	struct s2mu005_charger_data *charger = data;
+	u8 val;
+
+	s2mu005_read_reg(charger->client, S2MU005_CHG_STATUS0, &val);
+	pr_info("[DEBUG] %s , %02x \n " , __func__, val);
+	if ( val & (CHG_STATUS_DONE << CHG_STATUS_SHIFT) )
+	{
+		pr_info("add self chg done \n");
+		/* add chg done code here */
+	}
+	return IRQ_HANDLED;
+}
+
+#if EN_OVP_IRQ
+
+
+static void s2mu005_get_ovp_status(struct s2mu005_charger_data *charger)
+{
+	u8 val;
+	union power_supply_propval value;
+
+	s2mu005_read_reg(charger->client, S2MU005_CHG_STATUS1, &val);
+	val = (val & VBUS_OVP_MASK) >> VBUS_OVP_SHIFT;
+	if (val == 0x02) {
+		charger->ovp = true;
+		dev_info(charger->dev, "%s: OVP triggered, Vbus status: 0x%x\n", __func__, val);
+		charger->unhealth_cnt = HEALTH_DEBOUNCE_CNT;
+		value.intval = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+		psy_do_property("battery", set,
+			POWER_SUPPLY_PROP_HEALTH, value);
+	} else if(val == 0x03 || val == 0x05) {
+		if(charger->ovp) {
+			dev_info(charger->dev, "%s: Recover from OVP, Vbus status 0x%x \n " , __func__, val);
+			charger->unhealth_cnt = 0;
+			charger->ovp = false;
+			value.intval = POWER_SUPPLY_HEALTH_GOOD;
+			psy_do_property("battery", set,
+				POWER_SUPPLY_PROP_HEALTH, value);
+		}
+  	}
+	charger->pending_chg_work = false;
+}
+
+
+static void s2mu005_ovp_work(struct work_struct *work)
+{
+	struct s2mu005_charger_data *charger =
+		container_of(work, struct s2mu005_charger_data, charger_work.work);
+
+	if (!charger->suspended) {
+		s2mu005_get_ovp_status(charger);
+	} else {
+		charger->pending_chg_work = true;
+	}
+}
+#endif
+
+static int s2mu005_charger_parse_dt(struct device *dev,
+		struct s2mu005_charger_platform_data *pdata)
+{
+	struct device_node *np = of_find_node_by_name(NULL, "s2mu005-charger");
+	const u32 *p;
+	int ret, i, len;
+
+	/* SC_CTRL11 , SET_OSC_BUCK , Buck switching frequency setting
+		 * 0 : 500kHz
+         * 1 : 750kHz
+         * 2 : 1MHz
+         * 3 : 2MHz
+         */
+/*	ret = of_property_read_u32(np,
+		"battery,switching_frequency_mode", pdata->switching_frequency_mode);
+	if (!ret)
+		pdata->switching_frequency_mode = 1;
+	pr_info("%s : switching_frequency_mode = %d\n", __func__,
+			pdata->switching_frequency_mode);
+*/
+	/* SC_CTRL8 , SET_VF_VBAT , Battery regulation voltage setting */
+	ret = of_property_read_u32(np, "battery,chg_float_voltage",
+				&pdata->chg_float_voltage);
+
+	np = of_find_node_by_name(NULL, "battery");
+	if (!np) {
+		pr_err("%s np NULL\n", __func__);
+	} else {
+		ret = of_property_read_string(np,
+			"battery,charger_name", (char const **)&pdata->charger_name);
+
+		ret = of_property_read_u32(np, "battery,full_check_type_2nd",
+				&pdata->full_check_type_2nd);
+		if (ret)
+			pr_info("%s : Full check type 2nd is Empty\n", __func__);
+
+		pdata->chg_eoc_dualpath = of_property_read_bool(np,
+				"battery,chg_eoc_dualpath");
+
+		pdata->always_enable = of_property_read_bool(np,
+					"battery,always_enable");
+
+		p = of_get_property(np, "battery,input_current_limit", &len);
+		if (!p)
+			return 1;
+
+		len = len / sizeof(u32);
+
+		pdata->charging_current =
+			kzalloc(sizeof(sec_charging_current_t) * len,
+				GFP_KERNEL);
+
+		for(i = 0; i < len; i++) {
+			ret = of_property_read_u32_index(np,
+					"battery,input_current_limit", i,
+					&pdata->charging_current[i].input_current_limit);
+			if (ret)
+				pr_info("%s : Input_current_limit is Empty\n", __func__);
+		}
+	}
+
+	dev_info(dev, "s2mu005 charger parse dt retval = %d\n", ret);
+	return ret;
+}
+
+/* if need to set s2mu005 pdata */
+static struct of_device_id s2mu005_charger_match_table[] = {
+	{ .compatible = "samsung,s2mu005-charger",},
+	{},
+};
+
+static int s2mu005_charger_probe(struct platform_device *pdev)
+{
+	struct s2mu005_dev *s2mu005 = dev_get_drvdata(pdev->dev.parent);
+	struct s2mu005_platform_data *pdata = dev_get_platdata(s2mu005->dev);
+	struct s2mu005_charger_data *charger;
+	int ret = 0;
+
+	union power_supply_propval val;
+
+	otg_enable_flag = 0;
+	pr_info("%s:[BATT] S2MU005 Charger driver probe\n", __func__);
+	charger = kzalloc(sizeof(*charger), GFP_KERNEL);
+	if (!charger)
+		return -ENOMEM;
+
+	mutex_init(&charger->io_lock);
+
+	charger->dev = &pdev->dev;
+	charger->client = s2mu005->i2c;
+
+	charger->pdata = devm_kzalloc(&pdev->dev, sizeof(*(charger->pdata)),
+			GFP_KERNEL);
+	if (!charger->pdata) {
+		dev_err(&pdev->dev, "Failed to allocate memory\n");
+		ret = -ENOMEM;
+		goto err_parse_dt_nomem;
+	}
+	ret = s2mu005_charger_parse_dt(&pdev->dev, charger->pdata);
+	if (ret < 0)
+		goto err_parse_dt;
+
+	platform_set_drvdata(pdev, charger);
+
+	if (charger->pdata->charger_name == NULL)
+		charger->pdata->charger_name = "sec-charger";
+
+	charger->psy_chg.name           = charger->pdata->charger_name;
+	charger->psy_chg.type           = POWER_SUPPLY_TYPE_UNKNOWN;
+	charger->psy_chg.get_property   = sec_chg_get_property;
+	charger->psy_chg.set_property   = sec_chg_set_property;
+	charger->psy_chg.properties     = sec_charger_props;
+	charger->psy_chg.num_properties = ARRAY_SIZE(sec_charger_props);
+	charger->psy_otg.name		= "otg";
+	charger->psy_otg.type		= POWER_SUPPLY_TYPE_OTG;
+	charger->psy_otg.get_property	= s2mu005_otg_get_property;
+	charger->psy_otg.set_property	= s2mu005_otg_set_property;
+	charger->psy_otg.properties	= s2mu005_otg_props;
+	charger->psy_otg.num_properties	= ARRAY_SIZE(s2mu005_otg_props);
+
+	s2mu005_chg_init(charger);
+
+	ret = power_supply_register(&pdev->dev, &charger->psy_chg);
+	if (ret) {
+		pr_err("%s: Failed to Register psy_chg\n", __func__);
+		goto err_power_supply_register;
+	}
+
+	ret = power_supply_register(&pdev->dev, &charger->psy_otg);
+	if (ret) {
+		pr_err("%s: Failed to Register otg_chg\n", __func__);
+		goto err_power_supply_register_otg;
+	}
+
+	charger->charger_wqueue = create_singlethread_workqueue("charger-wq");
+	if (!charger->charger_wqueue) {
+		dev_info(charger->dev, "%s: failed to create wq.\n", __func__);
+		ret = -ESRCH;
+		goto err_create_wq;
+	}
+	INIT_DELAYED_WORK(&charger->charger_work, s2mu005_ovp_work);
+	INIT_DELAYED_WORK(&charger->det_bat_work, s2mu005_det_bat_work);
+
+	/*
+	 * irq request
+	 * if you need to add irq , please refer below code.
+	 */
+	charger->irq_det_bat = pdata->irq_base + S2MU005_CHG_IRQ_DET_BAT;
+	ret = request_threaded_irq(charger->irq_det_bat, NULL,
+			s2mu005_det_bat_isr, 0 , "det-bat-in-irq", charger);
+	if(ret < 0) {
+		dev_err(s2mu005->dev, "%s: Fail to request det bat in IRQ: %d: %d\n",
+					__func__, charger->irq_det_bat, ret);
+		goto err_reg_irq;
+	}
+	charger->irq_chg = pdata->irq_base + S2MU005_CHG_IRQ_CHG;
+	ret = request_threaded_irq(charger->irq_chg, NULL,
+			s2mu005_chg_isr, 0 , "chg-irq", charger);
+	if(ret < 0) {
+		dev_err(s2mu005->dev, "%s: Fail to request det bat in IRQ: %d: %d\n",
+					__func__, charger->irq_chg, ret);
+		goto err_reg_irq;
+	}
+
+	psy_do_property("s2mu005-fuelgauge", get, POWER_SUPPLY_PROP_SCOPE, val);
+	charger->fg_mode = val.intval;
+
+#if EN_TEST_READ
+	s2mu005_test_read(charger->client);
+#endif
+
+	charger->suspended = false;
+	charger->pending_chg_work = false;
+	
+	s2m_acok_register_notifier(&s2m_acok_notifier);
+
+	pr_info("%s:[BATT] S2MU005 charger driver loaded OK\n", __func__);
+
+	return 0;
+
+err_create_wq:
+	destroy_workqueue(charger->charger_wqueue);
+err_reg_irq:
+	power_supply_unregister(&charger->psy_otg);
+err_power_supply_register_otg:
+	power_supply_unregister(&charger->psy_chg);
+err_power_supply_register:
+err_parse_dt:
+err_parse_dt_nomem:
+	mutex_destroy(&charger->io_lock);
+	kfree(charger);
+	return ret;
+}
+
+static int s2mu005_charger_remove(struct platform_device *pdev)
+{
+	struct s2mu005_charger_data *charger =
+		platform_get_drvdata(pdev);
+
+	power_supply_unregister(&charger->psy_chg);
+	s2m_acok_unregister_notifier(&s2m_acok_notifier);
+	mutex_destroy(&charger->io_lock);
+	kfree(charger);
+	return 0;
+}
+
+#if defined CONFIG_PM
+static int s2mu005_charger_suspend(struct device *dev)
+{
+	struct s2mu005_charger_data *charger = dev_get_drvdata(dev);
+	u8 data = 0;
+
+	cancel_delayed_work_sync(&charger->charger_work);
+
+	if (charger->dev_id < 2) {
+		if (!charger->is_charging && !charger->fg_mode) {
+			s2mu005_read_reg(charger->client, 0x72, &data);
+			data |= 0x80;
+			s2mu005_write_reg(charger->client, 0x72, data);
+
+			data = charger->fg_clock + 64 > 0xFF ? 0xFF : charger->fg_clock + 64;
+			s2mu005_write_reg(charger->client, 0x7B, data);
+		}
+
+		s2mu005_read_reg(charger->client, 0x7B, &data);
+		pr_info("%s: 0x7B : 0x%x\n", __func__, data);
+	}
+	charger->suspended = true;
+	return 0;
+}
+
+static int s2mu005_charger_resume(struct device *dev)
+{
+	struct s2mu005_charger_data *charger = dev_get_drvdata(dev);
+	u8 data;
+
+	if (charger->dev_id < 2) {
+		if (!charger->is_charging && !charger->fg_mode) {
+			s2mu005_read_reg(charger->client, 0x72, &data);
+			data &= ~0x80;
+			s2mu005_write_reg(charger->client, 0x72, data);
+
+			s2mu005_write_reg(charger->client, 0x7B, charger->fg_clock);
+		}
+		s2mu005_read_reg(charger->client, 0x7B, &data);
+		pr_info("%s: 0x7B : 0x%x\n", __func__, data);
+	}
+
+	if (charger->pending_chg_work) {
+		s2mu005_get_ovp_status(charger);
+	}
+	
+	charger->suspended = false;
+	return 0;
+}
+#else
+#define s2mu005_charger_suspend NULL
+#define s2mu005_charger_resume NULL
+#endif
+
+static void s2mu005_charger_shutdown(struct device *dev)
+{
+	struct s2mu005_charger_data *charger = dev_get_drvdata(dev);
+#if !defined(CONFIG_SEC_FACTORY)
+#if !defined(CONFIG_S2MU005_INNER_BATTERY)
+	/*
+	 * In case plug TA --> remove battery --> re-insert battery,
+	 * we need to reset FG if SC_INT[0] = 1. However, it can make
+	 * FG reset if plug TA --> power off --> LPM charging.
+	 * To avoid the problem, when power-off sequence by power-key,
+	 *    0x59[3]=0, 0x7C[0]=0 should be set in kernel.
+	 *    0x59[3]=1, 0x7C[0]=1 should be set in bootloader.
+	 */
+	s2mu005_update_reg(charger->client, 0x59, 0, 0x01 << 3); /* manual reset disable */
+	s2mu005_update_reg(charger->client, 0x7C, 0, 0x01 << 0); /* i2c port reset disable */
+#endif
+
+	 /* defualt value for Bypass mode of factory mode */
+	s2mu005_write_reg(charger->client, 0x2A, 0x08);
+	s2mu005_write_reg(charger->client, 0x23, 0x55);
+	s2mu005_write_reg(charger->client, 0x24, 0x55);
+#endif
+	pr_info("%s: S2MU005 Charger driver shutdown\n", __func__);
+
+	if (!(charger->pdata->always_enable)) {
+		pr_info("%s: turn on charger\n", __func__);
+		s2mu005_enable_charger_switch(charger, true);
+	}
+}
+
+static SIMPLE_DEV_PM_OPS(s2mu005_charger_pm_ops, s2mu005_charger_suspend,
+		s2mu005_charger_resume);
+
+static struct platform_driver s2mu005_charger_driver = {
+	.driver         = {
+		.name   = "s2mu005-charger",
+		.owner  = THIS_MODULE,
+		.of_match_table = s2mu005_charger_match_table,
+		.pm     = &s2mu005_charger_pm_ops,
+		.shutdown = s2mu005_charger_shutdown,
+	},
+	.probe          = s2mu005_charger_probe,
+	.remove		= s2mu005_charger_remove,
+};
+
+static int __init s2mu005_charger_init(void)
+{
+	int ret = 0;
+
+	ret = platform_driver_register(&s2mu005_charger_driver);
+
+	return ret;
+}
+module_init(s2mu005_charger_init);
+
+static void __exit s2mu005_charger_exit(void)
+{
+	platform_driver_unregister(&s2mu005_charger_driver);
+}
+module_exit(s2mu005_charger_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Samsung Electronics");
+MODULE_DESCRIPTION("Charger driver for S2MU005");
diff -Naur linux-3.18.14/drivers/battery_v2/s2mu005_fuelgauge.c samsung/drivers/battery_v2/s2mu005_fuelgauge.c
--- linux-3.18.14/drivers/battery_v2/s2mu005_fuelgauge.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/s2mu005_fuelgauge.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,2569 @@
+/*
+ *  s2mu005_fuelgauge.c
+ *  Samsung S2MU005 Fuel Gauge Driver
+ *
+ *  Copyright (C) 2015 Samsung Electronics
+ *  Developed by Nguyen Tien Dat (tiendat.nt@samsung.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#define DEBUG
+
+#define SINGLE_BYTE	1
+#define TABLE_SIZE	22
+
+#include "include/fuelgauge/s2mu005_fuelgauge.h"
+#include <linux/of_gpio.h>
+#include <linux/sec_batt.h>
+
+static enum power_supply_property s2mu005_fuelgauge_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_VOLTAGE_AVG,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CURRENT_AVG,
+	POWER_SUPPLY_PROP_CHARGE_FULL,
+	POWER_SUPPLY_PROP_ENERGY_NOW,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_TEMP_AMBIENT,
+	POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN,
+	POWER_SUPPLY_PROP_CHARGE_TYPE,
+};
+
+static int s2mu005_get_vbat(struct s2mu005_fuelgauge_data *fuelgauge);
+static int s2mu005_get_ocv(struct s2mu005_fuelgauge_data *fuelgauge);
+static int s2mu005_get_current(struct s2mu005_fuelgauge_data *fuelgauge);
+static int s2mu005_get_avgcurrent(struct s2mu005_fuelgauge_data *fuelgauge);
+static int s2mu005_get_avgvbat(struct s2mu005_fuelgauge_data *fuelgauge);
+static int s2mu005_get_monout_avgvbat(struct s2mu005_fuelgauge_data *fuelgauge);
+
+static int s2mu005_read_reg_byte(struct i2c_client *client, int reg, void *data)
+{
+	int ret = 0;
+	int cnt = 0;
+
+	ret = i2c_smbus_read_byte_data(client, reg);
+	if (ret < 0) {
+		while(ret < 0 && cnt < 5) {
+			ret = i2c_smbus_read_byte_data(client, reg);
+			cnt++;
+			dev_err(&client->dev,
+					"%s: I2C read Incorrect! reg:0x%x, data:0x%x, cnt:%d\n",
+					__func__, reg, *(u8 *)data, cnt);
+		}
+		if (cnt == 5)
+			dev_err(&client->dev,
+				"%s: I2C read Failed reg:0x%x, data:0x%x\n",
+				__func__, reg, *(u8 *)data);
+	}
+	*(u8 *)data = (u8)ret;
+
+	return ret;
+}
+
+static int s2mu005_write_and_verify_reg_byte(struct i2c_client *client, int reg, u8 data)
+{
+	int ret, i = 0;
+	int i2c_corrupted_cnt = 0;
+	u8 temp = 0;
+
+	/* pr_info("[SKB]%s: write addr:0x%x, data:0x%x\n", __func__, reg, data); */
+	ret = i2c_smbus_write_byte_data(client, reg, data);
+
+	/* skip the error in case Fuelgauge IC reset */
+	if (reg == 0x1F && (data == 0x40 || data == 0x01))
+		return ret;
+
+	if (ret < 0) {
+		for (i = 0; i < 3; i++) {
+			ret = i2c_smbus_write_byte_data(client, reg, data);
+			if (ret >= 0)
+				break;
+		}
+
+		if (i >= 3)
+			dev_err(&client->dev, "%s: Error(%d)\n", __func__, ret);
+	}
+
+	/* Skip non-writable registers */
+	if ((reg == 0xee) || (reg == 0xef) || (reg == 0xf2) || (reg == 0xf3) ||
+		(reg == 0x1e) || (reg == 0x44) || (reg == 0x45) ||
+		(reg == 0x54) || (reg == 0x55) || (reg == 0x56) || (reg == 0x57)) {
+		return ret;
+	}
+
+	s2mu005_read_reg_byte(client, reg, &temp);
+	while ((temp != data) && (i2c_corrupted_cnt < 5)) {
+		dev_err(&client->dev,
+			"%s: I2C write Incorrect! REG: 0x%x Expected: 0x%x Real-Value: 0x%x\n",
+			__func__, reg, data, temp);
+		ret = i2c_smbus_write_byte_data(client, reg, data);
+		s2mu005_read_reg_byte(client, reg, &temp);
+		i2c_corrupted_cnt++;
+	}
+
+	if (i2c_corrupted_cnt == 5)
+		dev_err(&client->dev,
+			"%s: I2C write failed REG: 0x%x Expected: 0x%x\n",
+			__func__, reg, data);
+
+	return ret;
+}
+
+static int s2mu005_write_reg(struct i2c_client *client, int reg, u8 *buf)
+{
+#if SINGLE_BYTE
+	int ret = 0 ;
+	s2mu005_write_and_verify_reg_byte(client, reg, buf[0]);
+	s2mu005_write_and_verify_reg_byte(client, reg+1, buf[1]);
+#else
+	int ret, i = 0;
+
+	ret = i2c_smbus_write_i2c_block_data(client, reg, 2, buf);
+	if (ret < 0) {
+		for (i = 0; i < 3; i++) {
+			ret = i2c_smbus_write_i2c_block_data(client, reg, 2, buf);
+			if (ret >= 0)
+				break;
+		}
+
+		if (i >= 3)
+			dev_err(&client->dev, "%s: Error(%d)\n", __func__, ret);
+	}
+#endif
+	return ret;
+}
+
+static int s2mu005_read_reg(struct i2c_client *client, int reg, u8 *buf)
+{
+
+#if SINGLE_BYTE
+	int ret =0;
+	u8 data1 = 0 , data2 = 0;
+	s2mu005_read_reg_byte(client, reg, &data1);
+	s2mu005_read_reg_byte(client, reg+1, &data2);
+	buf[0] = data1;
+	buf[1] = data2;
+#else
+	int ret = 0, i = 0;
+
+	ret = i2c_smbus_read_i2c_block_data(client, reg, 2, buf);
+	if (ret < 0) {
+		for (i = 0; i < 3; i++) {
+			ret = i2c_smbus_read_i2c_block_data(client, reg, 2, buf);
+			if (ret >= 0)
+				break;
+		}
+
+		if (i >= 3)
+			dev_err(&client->dev, "%s: Error(%d)\n", __func__, ret);
+	}
+#endif
+	return ret;
+}
+
+static void s2mu005_fg_test_read(struct i2c_client *client)
+{
+	u8 data = 0;
+	char str[1016] = {0,};
+	int i = 0;
+
+	/* address 0x00 ~ 0x5B */
+	for (i = 0x0; i <= 0x5B; i++) {
+		s2mu005_read_reg_byte(client, i, &data);
+		sprintf(str+strlen(str), "%02x:%02x, ", i, data);
+	}
+
+	/* address 0x27 */
+	s2mu005_read_reg_byte(client, 0x27, &data);
+	sprintf(str+strlen(str),"27:%02x, ",data);
+
+	/* print buffer */
+	pr_info("[FG]%s: %s\n", __func__, str);
+
+	memset(str,0,strlen(str));
+
+	/* address 0x92 ~ 0xff */
+	for (i = 0x92; i <= 0xff; i++) {
+		s2mu005_read_reg_byte(client, i, &data);
+		sprintf(str+strlen(str), "%02x:%02x, ", i, data);
+	}
+
+	/* print buffer */
+	pr_info("[FG]%s: %s\n", __func__, str);
+}
+
+static void WA_0_issue_at_init(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	int a = 0;
+	u8 v_52 = 0, v_53 =0, temp1, temp2;
+	int FG_volt, UI_volt, offset;
+	u8 v_40 = 0;
+	u8 temp_REG26 = 0, temp_REG27 = 0, temp = 0;
+
+	/* Step 1: [Surge test]  get UI voltage (0.1mV)*/
+	UI_volt = s2mu005_get_ocv(fuelgauge);
+
+	/* current fix for soc */
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x27, &temp_REG27);
+	temp=temp_REG27;
+	temp |= 0x0F;
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x27, temp);
+
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x26, &temp_REG26);
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x26, 0xF7);
+
+	/* avgvbat factor value set to 0xFF  */
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x40, &v_40);
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x40, 0xFF);
+
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x1E, 0x0F);
+	msleep(50);
+
+	/* Step 2: [Surge test] get FG voltage (0.1mV) */
+	FG_volt = s2mu005_get_vbat(fuelgauge) * 10;
+
+	/* Step 3: [Surge test] get offset */
+	offset = UI_volt - FG_volt;
+	pr_info("%s: UI_volt(%d), FG_volt(%d), offset(%d)\n",
+			__func__, UI_volt, FG_volt, offset);
+
+	/* Step 4: [Surge test] */
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x53, &v_53);
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x52, &v_52);
+	pr_info("%s: v_53(0x%x), v_52(0x%x)\n", __func__, v_53, v_52);
+
+	a = (v_53 & 0x0F) << 8;
+	a += v_52;
+	pr_info("%s: a before add offset (0x%x)\n", __func__, a);
+
+	/* 2`s complement */
+	if (a & (0x01 << 11))
+		a = ( -10000 * ((a^0xFFF) +1)) >> 13;
+	else
+		a = ( 10000 * a ) >> 13;
+
+	a = a + offset;
+	pr_err("%s: a after add offset (0x%x)\n", __func__, a);
+
+	/* limit upper/lower offset */
+	if (a > 2490)
+		a = 2490;
+	
+	if (a < (-2490))
+		a = -2490;
+
+	a = (a << 13) / 10000;
+	if (a < 0)
+		a = -1*((a^0xFFF)+1);
+
+	pr_info("%s: a after add offset (0x%x)\n", __func__, a);
+
+	a &= 0xfff;
+	pr_info("%s: (a)&0xFFF (0x%x)\n", __func__, a);
+
+	/* modify 0x53[3:0] */
+	temp1 = v_53 & 0xF0;
+	temp2 = (u8)((a&0xF00) >> 8);
+	temp1 |= temp2;
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x53, temp1);
+
+	/* modify 0x52[7:0] */
+	temp2 = (u8)(a & 0xFF);
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x52, temp2);
+
+	/* restart and dumpdone */
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x1E, 0x0F);
+	msleep(300);
+
+	/* restore current register */
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x27, temp_REG27);
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x26, 0xF6);
+
+	/* recovery 0x52 and 0x53 */
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x53, &temp1);
+	temp1 &= 0xF0;
+	temp1 |= (v_53 & 0x0F);
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x53, temp1);
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x52, v_52);
+
+	/* restore monout avgvbat factor value */
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x40, v_40);
+}
+
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+static void WA_force_rawsoc_100(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	u8 temp1, v_40;
+
+	/* Set average current coefficient ( addr 0x41 = 0x04 ) */
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x41, 0x04);
+
+	/* Set discharging current*/
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x26, 0xF6);
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x27, &temp1);
+	temp1 |= 0x0F;
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x27, temp1);
+
+	/* Set average voltage coefficient ( addr 0x40 = 0xFF ) */
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x40, &v_40);
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x40, 0xFF);
+
+	/* Fix discharging current ( addr 0x26[0] = 0x1 ) */
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x26, &temp1);
+	temp1 |= 0x01;
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x26, temp1);
+
+	/* Set voltage fix for 100% rawsoc & enable */
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x25, &temp1);
+	temp1 &= 0xF0;
+	temp1 |= 0x05;
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x25, temp1);
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x24, 0xB7);
+
+	/* restart and dumpdone */
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x1E, 0x0F);
+	msleep(300);
+
+	/*Disable voltage fix*/
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x24, &temp1);
+	temp1 &= 0xFE;
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x24, temp1);
+
+	/* Disable discharging current fix */
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x26, &temp1);
+	temp1 &= 0xFE;
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x26, temp1);
+
+	/* Recover Reg 0x40 */
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x40, v_40);
+}
+#endif
+
+static int s2mu005_get_soc_from_ocv(struct s2mu005_fuelgauge_data *fuelgauge, int target_ocv)
+{
+	/* 22 values of mapping table for EVT1*/
+
+	int *soc_arr;
+	int *ocv_arr;
+	int soc = 0;
+	int ocv = target_ocv * 10;
+
+	int high_index = TABLE_SIZE - 1;
+	int low_index = 0;
+	int mid_index = 0;
+
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	soc_arr = fuelgauge->age_data_info[fuelgauge->fg_age_step].soc_arr_val;
+	ocv_arr = fuelgauge->age_data_info[fuelgauge->fg_age_step].ocv_arr_val;
+#else
+	if(fuelgauge->revision >= 2) {
+		soc_arr = fuelgauge->info.soc_arr_evt2;
+		ocv_arr = fuelgauge->info.ocv_arr_evt2;
+	} else {
+		soc_arr = fuelgauge->info.soc_arr_evt1;
+		ocv_arr = fuelgauge->info.ocv_arr_evt1;
+	}
+#endif
+
+	pr_err("%s: soc_arr(%d) ocv_arr(%d)\n", __func__, (*soc_arr), (*ocv_arr));
+
+	if(ocv <= ocv_arr[TABLE_SIZE - 1]) {
+		soc = soc_arr[TABLE_SIZE - 1];
+		goto soc_ocv_mapping;
+	} else if (ocv >= ocv_arr[0]) {
+		soc = soc_arr[0];
+		goto soc_ocv_mapping;
+	}
+	while (low_index <= high_index) {
+		mid_index = (low_index + high_index) >> 1;
+		if(ocv_arr[mid_index] > ocv)
+			low_index = mid_index + 1;
+		else if(ocv_arr[mid_index] < ocv)
+			high_index = mid_index - 1;
+		else {
+			soc = soc_arr[mid_index];
+			goto soc_ocv_mapping;
+		}
+	}
+	soc = soc_arr[high_index];
+	soc += ((soc_arr[low_index] - soc_arr[high_index]) *
+					(ocv - ocv_arr[high_index])) /
+					(ocv_arr[low_index] - ocv_arr[high_index]);
+
+soc_ocv_mapping:
+	dev_info(&fuelgauge->i2c->dev, "%s: ocv (%d), soc (%d)\n", __func__, ocv, soc);
+	return soc;
+}
+
+static void WA_0_issue_at_init1(struct s2mu005_fuelgauge_data *fuelgauge, int target_ocv)
+{
+	int a = 0;
+	u8 v_52 = 0, v_53 =0, temp1, temp2;
+	int FG_volt, UI_volt, offset;
+	u8 v_40 = 0;
+	u8 temp_REG26 = 0, temp_REG27 = 0, temp = 0;
+
+	if ((fuelgauge->temperature <= (int)fuelgauge->low_temp_limit) && (!(fuelgauge->info.soc <= 500))) {
+		pr_info("%s : Skip F/G reset in low temperatures\n", __func__);
+		fuelgauge->vbatl_mode = VBATL_MODE_SW_VALERT;
+		return;
+	}
+
+	mutex_lock(&fuelgauge->fg_lock);
+
+	/* Step 1: [Surge test]  get UI voltage (0.1mV)*/
+	UI_volt = target_ocv * 10;
+
+	if(fuelgauge->wa_flag == true)
+	{
+		pr_info("%s: %s is overlapped\n", __func__, __func__);
+		return;
+	}
+	fuelgauge->wa_flag = true;
+
+	/* avgvbat factor value set to 0xFF  */
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x40, &v_40);
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x40, 0xFF);
+
+	/* current fix for soc */
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x27, &temp_REG27);
+	temp=temp_REG27;
+	temp |= 0x0F;
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x27, temp);
+
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x26, &temp_REG26);
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x26, 0xF7);
+
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x1E, 0x0F);
+	msleep(50);
+
+	/* Step 2: [Surge test] get FG voltage (0.1mV) */
+	FG_volt = s2mu005_get_vbat(fuelgauge) * 10;
+
+	/* Step 3: [Surge test] get offset */
+	offset = UI_volt - FG_volt;
+	pr_info("%s: UI_volt(%d), FG_volt(%d), offset(%d)\n",
+			__func__, UI_volt, FG_volt, offset);
+
+	/* Step 4: [Surge test] */
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x53, &v_53);
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x52, &v_52);
+	pr_info("%s: Read v_53(0x%x), v_52(0x%x)\n", __func__, v_53, v_52);
+
+	a = (v_53 & 0x0F) << 8;
+	a += v_52;
+	pr_info("%s: a before add offset (0x%x)\n", __func__, a);
+
+
+	/* 2`s complement */
+	if (a & (0x01 << 11))
+		a = ( -10000 * ((a^0xFFF) +1)) >> 13;
+	else
+		a = (10000 * a) >> 13;
+
+	a = a + offset;
+	pr_err("%s: a after add offset (0x%x)\n", __func__, a);
+
+	/* limit upper/lower offset */
+	if (a > 2490)
+		a = 2490;
+	
+	if (a < (-2490))
+		a = -2490;
+
+	a = (a << 13) / 10000;
+	if (a < 0)
+		a = -1*((a^0xFFF)+1);
+
+	pr_info("%s: a after add offset (0x%x)\n", __func__, a);
+
+	a &= 0xfff;
+	pr_info("%s: (a)&0xFFF (0x%x)\n", __func__, a);
+
+	/* modify 0x53[3:0] */
+	temp1 = v_53 & 0xF0;
+	temp2 = (u8)((a&0xF00) >> 8);
+	temp1 |= temp2;
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x53, temp1);
+
+	/* modify 0x52[7:0] */
+	temp2 = (u8)(a & 0xFF);
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x52, temp2);
+
+	/* restart and dumpdone */
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x1E, 0x0F);
+	msleep(300);
+
+	/* restore current register */
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x27, temp_REG27);
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x26, 0xF6);
+
+	pr_info("%s: S2MU005 VBAT : %d\n", __func__, s2mu005_get_vbat(fuelgauge) * 10);
+
+	/* recovery 0x52 and 0x53 */
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x53, &temp1);
+	temp1 &= 0xF0;
+	temp1 |= (v_53 & 0x0F);
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x53, temp1);
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x52, v_52);
+
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x53, &v_53);
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x52, &v_52);
+	pr_info("%s: Restored v_53(0x%x), v_52(0x%x)\n", __func__, v_53, v_52);
+
+	/* restore monout avgvbat factor value */
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x40, v_40);
+	s2mu005_fg_test_read(fuelgauge->i2c);
+
+	fuelgauge->wa_flag = false;
+	mutex_unlock(&fuelgauge->fg_lock);
+}
+
+
+static void s2mu005_reset_fg(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	int i;
+	u8 temp = 0;
+
+	mutex_lock(&fuelgauge->fg_lock);
+
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	/* Reset IC */
+	if (fuelgauge->age_reset_status == 1) {
+		s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x1F, 0x40);
+		msleep(50);
+		s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x1F, 0x01);
+		msleep(50);
+	}
+
+	/* step 0: [Surge test] initialize register of FG */
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x0F, fuelgauge->age_data_info[fuelgauge->fg_age_step].batcap[0]);
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x0E, fuelgauge->age_data_info[fuelgauge->fg_age_step].batcap[1]);
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x11, fuelgauge->age_data_info[fuelgauge->fg_age_step].batcap[2]);
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x10, fuelgauge->age_data_info[fuelgauge->fg_age_step].batcap[3]);
+#else
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x0F, fuelgauge->info.batcap[0]);
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x0E, fuelgauge->info.batcap[1]);
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x11, fuelgauge->info.batcap[2]);
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x10, fuelgauge->info.batcap[3]);
+#endif
+
+	/*After battery capacity update, set 0x0C[6]*/
+	if(fuelgauge->revision >= 0x0A)	{
+		s2mu005_read_reg_byte(fuelgauge->i2c, 0x0C, &temp);
+		temp |= 0x40;
+		s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x0C, temp);
+	}
+
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	for (i = 0x92; i <= 0xe9; i++) {
+		s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, i, fuelgauge->age_data_info[fuelgauge->fg_age_step].battery_table3[i - 0x92]);
+	}
+	for (i = 0xea; i <= 0xff; i++) {
+		s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, i, fuelgauge->age_data_info[fuelgauge->fg_age_step].battery_table4[i - 0xea]);
+	}
+#else
+	if(fuelgauge->revision >= 2) {
+		for(i = 0x92; i <= 0xe9; i++) {
+			s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, i, fuelgauge->info.battery_table3[i - 0x92]);
+		}
+		for(i = 0xea; i <= 0xff; i++) {
+			s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, i, fuelgauge->info.battery_table4[i - 0xea]);
+		}
+ 	} else {
+		for(i = 0x92; i <= 0xe9; i++) {
+			s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, i, fuelgauge->info.battery_table1[i - 0x92]);
+		}
+		for(i = 0xea; i <= 0xff; i++) {
+			s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, i, fuelgauge->info.battery_table2[i - 0xea]);
+		}
+ 	}
+#endif
+
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x21, 0x13);
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x14, 0x40);
+
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x45, &temp);
+	temp &= 0xF0;
+	temp |= fuelgauge->age_data_info[fuelgauge->fg_age_step].accum[1];
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x45, temp);
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x44,  fuelgauge->age_data_info[fuelgauge->fg_age_step].accum[0]);
+#else
+	if(fuelgauge->revision >= 2) {
+		s2mu005_read_reg_byte(fuelgauge->i2c, 0x45, &temp);
+		temp &= 0xF0;
+		temp |= fuelgauge->pdata->evt2_val;
+		temp |=  fuelgauge->info.fg_accumulative_rate_evt2[1];
+		s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x45, temp);
+		s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x44,  fuelgauge->info.fg_accumulative_rate_evt2[0]);
+	} else {
+		s2mu005_read_reg_byte(fuelgauge->i2c, 0x45, &temp);
+		temp &= 0xF0;
+		temp |= 0x07;
+		s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x45, temp);
+		s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x44, 0xCC);
+	}
+#endif
+
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x27, &temp);
+	temp |= 0x10;
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x27, temp);
+
+	if(fuelgauge->revision >= 2) {
+		s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x4B, 0x0B);
+		s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x4A, 0x10);
+
+		s2mu005_read_reg_byte(fuelgauge->i2c, 0x03, &temp);
+		temp |= 0x40;
+		s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x03, temp);
+	}
+	else {
+		s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x4B, 0x09);
+
+		s2mu005_read_reg_byte(fuelgauge->i2c, 0x27, &temp);
+		temp |= 0x0F;
+		s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x27, temp);
+
+		s2mu005_read_reg_byte(fuelgauge->i2c, 0x26, &temp);
+		temp |= 0xFE;
+		s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x26, temp);
+
+		s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x4A, 0xFF);
+
+		s2mu005_read_reg_byte(fuelgauge->i2c, 0x26, &temp);
+		temp &= 0xFE;
+		s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x26, temp);
+	}
+
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x40, 0x08);
+
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	if (fuelgauge->age_reset_status == 1)
+		WA_force_rawsoc_100(fuelgauge);
+	else
+		WA_0_issue_at_init(fuelgauge);
+#else
+	WA_0_issue_at_init(fuelgauge);
+#endif
+
+	/* If it was voltage mode, recover it */
+	if ((fuelgauge->revision >= 2) && (fuelgauge->mode == HIGH_SOC_VOLTAGE_MODE))
+		s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x4A, 0xFF);
+
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x1F, 0x0);
+
+	mutex_unlock(&fuelgauge->fg_lock);
+	pr_info("%s: Reset FG completed\n", __func__);
+}
+
+static void s2mu005_restart_gauging(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	u8 temp=0, temp_REG26=0, temp_REG27=0;
+	u8 v_40;
+	u8 data[2], r_data[2];
+	pr_info("%s: Re-calculate SOC and voltage\n", __func__);
+
+	mutex_lock(&fuelgauge->fg_lock);
+
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x27, &temp_REG27);
+	temp=temp_REG27;
+	temp |= 0x0F;
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x27, temp);
+
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x26, &temp_REG26);
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x26, 0xF7);
+
+	/* avgvbat factor value set to 0xFF  */
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x40, &v_40);
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x40, 0xFF);
+
+	s2mu005_read_reg(fuelgauge->i2c, S2MU005_REG_IRQ, data);
+	pr_info("%s: irq_reg data (%02x%02x)  \n",__func__, data[1], data[0]);
+
+	/* store data for interrupt mask */
+	r_data[0] = data[0];
+	r_data[1] = data[1];
+	/* disable irq for unwanted interrupt */
+	data[1] |= 0x0f;
+	s2mu005_write_reg(fuelgauge->i2c, S2MU005_REG_IRQ, data);
+
+	/* restart gauge */
+	//s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x1f, 0x01);
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x21, 0x13);
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x1E, 0x0F);
+
+	msleep(300);
+
+	/* enable irq after reset */
+	s2mu005_write_reg(fuelgauge->i2c, S2MU005_REG_IRQ, r_data);
+	pr_info("%s: re-store irq_reg data (%02x%02x) \n",__func__, r_data[1], r_data[0]);
+
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x27, temp_REG27);
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x26, 0xF6);
+
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x27, &temp);
+	pr_info("%s: 0x27 : %02x \n", __func__,temp);
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x26, &temp);
+	pr_info("%s: 0x26 : %02x \n", __func__,temp);
+
+	/* restore monout avgvbat factor value */
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x40, v_40);
+
+	mutex_unlock(&fuelgauge->fg_lock);
+}
+
+static void s2mu005_init_regs(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	u8 temp = 0;
+	pr_info("%s: s2mu005 fuelgauge initialize\n", __func__);
+
+	/* Reduce top-off current difference between
+	 * Power on charging and Power off charging
+	 */
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x27, &temp);
+	temp |= 0x10;
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x27, temp);
+
+	if(fuelgauge->revision < 2) {
+	/* Sampling time set 500ms */
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x45, &temp);
+	temp &= 0x3F;
+	temp |= 0x0;
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x45, temp);
+	}
+}
+
+static void s2mu005_alert_init(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+
+	/* VBAT Threshold setting: 3.55V */
+	data[0] = 0x00 & 0x0f;
+
+	/* SOC Threshold setting */
+	data[0] = data[0] | (fuelgauge->pdata->fuel_alert_soc << 4);
+
+	data[1] = 0x00;
+	s2mu005_write_reg(fuelgauge->i2c, S2MU005_REG_IRQ_LVL, data);
+}
+
+static bool s2mu005_check_status(struct i2c_client *client)
+{
+	u8 data[2];
+	bool ret = false;
+
+	/* check if Smn was generated */
+	if (s2mu005_read_reg(client, S2MU005_REG_STATUS, data) < 0)
+		return ret;
+
+	dev_dbg(&client->dev, "%s: status to (%02x%02x)\n",
+		__func__, data[1], data[0]);
+
+	if (data[1] & (0x1 << 1))
+		return true;
+	else
+		return false;
+}
+
+static int s2mu005_set_temperature(struct s2mu005_fuelgauge_data *fuelgauge,
+			int temperature)
+{
+	/*
+	 * s5mu005 include temperature sensor so,
+	 * do not need to set temperature value.
+	 */
+	return temperature;
+}
+
+static int s2mu005_get_temperature(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	s32 temperature = 0;
+
+	/*
+	 *  use monitor regiser.
+	 *  monitor register default setting is temperature
+	 */
+	mutex_lock(&fuelgauge->fg_lock);
+
+	if (s2mu005_read_reg(fuelgauge->i2c, S2MU005_REG_MONOUT, data) < 0)
+		goto err;
+
+	mutex_unlock(&fuelgauge->fg_lock);
+
+	/* data[] store 2's compliment format number */
+	if (data[0] & (0x1 << 7)) {
+		/* Negative */
+		temperature = ((~(data[0])) & 0xFF) + 1;
+		temperature *= -10;
+	} else {
+		temperature = data[0] & 0x7F;
+		temperature *= 10;
+	}
+
+	dev_dbg(&fuelgauge->i2c->dev, "%s: temperature (%d)\n",
+		__func__, temperature);
+
+	return temperature;
+
+err:
+	mutex_unlock(&fuelgauge->fg_lock);
+	return -ERANGE;
+}
+
+static int s2mu005_get_rawsoc(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	u8 data[2], check_data[2];
+	u16 compliment;
+	int rsoc, i;
+	u8 por_state = 0;
+	u8 temp = 0;
+	u8 reg = S2MU005_REG_RSOC;
+	int fg_reset = 0;
+	bool charging_enabled = false;
+	union power_supply_propval value;
+	int float_voltage = 0;
+	int force_power_off_voltage = 0;
+	int rbat = 0;
+
+	int avg_current = 0, avg_vbat = 0, vbat = 0, curr = 0, avg_monout_vbat = 0;
+	int ocv_pwroff = 0, ocv_100 = 0, ocv_pwr_voltagemode =0;
+	int target_soc = 0, soc_100 = 0;
+	//bkj - rempcap logging
+	int rsoc1;
+	u8 fg_mode_reg = 0;
+
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x1F, &por_state);
+	dev_info(&fuelgauge->i2c->dev, "%s:reg 0x1F value (%02x)\n", __func__, por_state);
+	if (por_state & 0x80) {
+		dev_err(&fuelgauge->i2c->dev, "%s: Invalid regster value clear !!!\n", __func__);
+		por_state &= 0x7F;
+		s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x1F, por_state);
+	}
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	if ((por_state & 0x10) && (fuelgauge->age_reset_status == 0))
+#else
+	if (por_state & 0x10)
+#endif
+	{
+		psy_do_property("s2mu005-charger", get, POWER_SUPPLY_PROP_CHARGING_ENABLED, value);
+		charging_enabled = value.intval;
+		value.intval = SEC_BAT_CHG_MODE_CHARGING_OFF;
+		psy_do_property("s2mu005-charger", set, POWER_SUPPLY_PROP_CHARGING_ENABLED, value);
+
+		dev_info(&fuelgauge->i2c->dev, "%s: FG reset\n", __func__);
+		s2mu005_reset_fg(fuelgauge);
+
+		fg_reset = 1;
+	}
+
+	mutex_lock(&fuelgauge->fg_lock);
+
+	if(fuelgauge->revision >= 2)
+		reg = S2MU005_REG_RSOC;
+	else {
+		if(fuelgauge->mode == CURRENT_MODE)
+			reg = S2MU005_REG_RSOC;
+		else {
+			s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x0C, 0x03);
+			reg = S2MU005_REG_MONOUT;
+		}
+	}
+
+	for (i = 0; i < 50; i++) {
+		if (s2mu005_read_reg(fuelgauge->i2c, reg, data) < 0)
+			goto err;
+		if (s2mu005_read_reg(fuelgauge->i2c, reg, check_data) < 0)
+			goto err;
+
+		dev_dbg(&fuelgauge->i2c->dev, "[DEBUG]%s: data0 (%d) data1 (%d) \n", __func__, data[0], data[1]);
+		if ((data[0] == check_data[0]) && (data[1] == check_data[1]))
+			break;
+	}
+
+	mutex_unlock(&fuelgauge->fg_lock);
+
+	if (fg_reset) {
+		psy_do_property("s2mu005-charger", set, POWER_SUPPLY_PROP_CHARGE_ENABLED, value);
+		if (charging_enabled) {
+			value.intval = SEC_BAT_CHG_MODE_CHARGING;
+			psy_do_property("s2mu005-charger", set, POWER_SUPPLY_PROP_CHARGING_ENABLED, value);
+		}
+	}
+
+	compliment = (data[1] << 8) | (data[0]);
+
+	/* data[] store 2's compliment format number */
+	if (compliment & (0x1 << 15)) {
+		/* Negative */
+		rsoc = ((~compliment) & 0xFFFF) + 1;
+		rsoc = (rsoc * (-10000)) / (0x1 << 14);
+	} else {
+		rsoc = compliment & 0x7FFF;
+		rsoc = ((rsoc * 10000) / (0x1 << 14));
+	}
+
+	if (fg_reset)
+		fuelgauge->diff_soc = fuelgauge->info.soc - rsoc;
+
+	dev_info(&fuelgauge->i2c->dev, "%s: current_soc (%d), previous soc (%d), diff (%d), FG_mode(%d)\n",
+		 __func__, rsoc, fuelgauge->info.soc, fuelgauge->diff_soc, fuelgauge->mode);
+
+	fuelgauge->info.soc = rsoc + fuelgauge->diff_soc;
+
+	avg_current = s2mu005_get_avgcurrent(fuelgauge);
+	avg_vbat =  s2mu005_get_avgvbat(fuelgauge);
+	vbat = s2mu005_get_vbat(fuelgauge);
+	curr = s2mu005_get_current(fuelgauge);
+	avg_monout_vbat =  s2mu005_get_monout_avgvbat(fuelgauge);
+	ocv_pwr_voltagemode = avg_monout_vbat - avg_current * 30 / 100;
+
+	if(avg_current < (-500))
+		rbat = 10;
+	else
+		rbat = 30;
+
+	ocv_pwr_voltagemode = avg_monout_vbat - avg_current * rbat / 100;
+
+	if(fuelgauge->revision >= 2) {
+	if ((fuelgauge->info.soc <= 300) || ((ocv_pwr_voltagemode <= 3600) && (avg_current < 10))) {
+			if(fuelgauge->mode == CURRENT_MODE) { /* switch to VOLTAGE_MODE */
+				fuelgauge->mode = LOW_SOC_VOLTAGE_MODE;
+
+				s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x4A, 0xFF);
+
+				dev_info(&fuelgauge->i2c->dev, "%s: FG is in low soc voltage mode\n", __func__);
+			}
+		}
+	else if ((fuelgauge->info.soc > 325) && ((ocv_pwr_voltagemode > 3650) || (avg_current >= 10))) {
+			if(fuelgauge->mode == LOW_SOC_VOLTAGE_MODE) {
+				fuelgauge->mode = CURRENT_MODE;
+
+				s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x4A, 0x10);
+
+				dev_info(&fuelgauge->i2c->dev, "%s: FG is in current mode\n", __func__);
+			}
+		}
+
+		psy_do_property("s2mu005-charger", get, POWER_SUPPLY_PROP_VOLTAGE_MAX, value);
+		float_voltage = value.intval;
+		float_voltage = (float_voltage * 996) / 1000;
+
+		psy_do_property("battery", get, POWER_SUPPLY_PROP_CAPACITY, value);
+		dev_info(&fuelgauge->i2c->dev, "%s: UI SOC = %d\n", __func__, value.intval);
+
+		s2mu005_read_reg_byte(fuelgauge->i2c, 0x4A, &fg_mode_reg);
+
+		dev_info(&fuelgauge->i2c->dev, "%s: fuelgauge->is_charging = %d, avg_vbat = %d, float_voltage = %d, avg_current = %d, 0x4A = 0x%02x\n",
+			__func__, fuelgauge->is_charging, avg_vbat, float_voltage, avg_current, fg_mode_reg);
+
+		if ((value.intval >= 98) ||
+			((fuelgauge->is_charging == true) &&
+			(avg_vbat > float_voltage) && (avg_current < 500))) {
+			if(fuelgauge->mode == CURRENT_MODE) { /* switch to VOLTAGE_MODE */
+				fuelgauge->mode = HIGH_SOC_VOLTAGE_MODE;
+
+				s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x4A, 0xFF);
+
+				dev_info(&fuelgauge->i2c->dev, "%s: FG is in high soc voltage mode\n", __func__);
+			}
+		}
+		else if (((avg_current > 550) && (value.intval < 97)) ||
+					((avg_current < 10) && (value.intval < 97))) {
+			if(fuelgauge->mode == HIGH_SOC_VOLTAGE_MODE) {
+				fuelgauge->mode = CURRENT_MODE;
+
+				s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x4A, 0x10);
+
+				dev_info(&fuelgauge->i2c->dev, "%s: FG is in current mode\n", __func__);
+			}
+		}
+	}
+	else {
+		if(!fuelgauge->is_charging && fuelgauge->info.soc <= 300) {
+			if(fuelgauge->mode == CURRENT_MODE) { /* switch to VOLTAGE_MODE */
+
+				fuelgauge->mode = LOW_SOC_VOLTAGE_MODE;
+				value.intval = fuelgauge->mode;
+				psy_do_property("s2mu005-charger", set, POWER_SUPPLY_PROP_SCOPE, value);
+
+				s2mu005_read_reg_byte(fuelgauge->i2c, 0x26, &temp);
+				temp |= 0x01;
+				s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x26, temp);
+
+				s2mu005_read_reg_byte(fuelgauge->i2c, 0x4B, &temp);
+				temp |= 0x02;
+				s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x4B, temp);
+
+				s2mu005_read_reg_byte(fuelgauge->i2c, 0x45, &temp);
+				temp &= 0xF0;
+				s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x45, temp);
+
+				s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x44, 0x00);
+				fuelgauge->vm_soc = fuelgauge->info.soc;
+
+				dev_info(&fuelgauge->i2c->dev, "%s: FG is in low soc voltage mode: %d\n",
+					__func__, fuelgauge->vm_soc);
+			}
+		} else if (fuelgauge->is_charging && fuelgauge->info.soc >= fuelgauge->vm_soc) {
+			if(fuelgauge->mode == LOW_SOC_VOLTAGE_MODE) {
+
+				fuelgauge->mode = CURRENT_MODE;
+				value.intval = fuelgauge->mode;
+				psy_do_property("s2mu005-charger", set, POWER_SUPPLY_PROP_SCOPE, value);
+
+				s2mu005_read_reg_byte(fuelgauge->i2c, 0x4B, &temp);
+				temp &= ~0x02;
+				s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x4B, temp);
+
+				s2mu005_read_reg_byte(fuelgauge->i2c, 0x26, &temp);
+				temp &= ~0x01;
+				s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x26, temp);
+
+				s2mu005_read_reg_byte(fuelgauge->i2c, 0x45, &temp);
+				temp &= 0xF0;
+				temp |= 0x07;
+				s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x45, temp);
+
+				s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x44, 0xCC);
+				dev_info(&fuelgauge->i2c->dev, "%s: FG is in current mode\n", __func__);
+			}
+		}
+	}
+
+	psy_do_property("battery", get, POWER_SUPPLY_PROP_TEMP, value);
+	fuelgauge->temperature = value.intval;
+	psy_do_property("battery", get, POWER_SUPPLY_PROP_TEMP, value);
+
+	if(fuelgauge->temperature <= (-150))
+		force_power_off_voltage = 3550;
+	else
+		force_power_off_voltage = 3300;
+
+	dev_info(&fuelgauge->i2c->dev,
+		"%s: Fuelgauge Mode: %d, Force power-off voltage: %d\n",
+		__func__, fuelgauge->mode, force_power_off_voltage);
+
+	if (((avg_current < (-17)) && (curr < (-17))) &&
+		((avg_monout_vbat - avg_current * rbat / 100) <= 3500) && (fuelgauge->info.soc > 100)) {
+		ocv_pwroff = 3300;
+		target_soc = s2mu005_get_soc_from_ocv(fuelgauge, ocv_pwroff);
+		pr_info("%s : F/G reset Start - current flunctuation\n", __func__);
+		WA_0_issue_at_init1(fuelgauge, ocv_pwroff);
+	} else if (avg_current < (-60) && avg_vbat <= force_power_off_voltage) {
+		if (fuelgauge->mode == CURRENT_MODE) {
+			if (abs(avg_vbat - vbat) <= 20 && abs(avg_current - curr) <= 30) {
+				ocv_pwroff = avg_vbat - avg_current * 15 / 100;
+				target_soc = s2mu005_get_soc_from_ocv(fuelgauge, ocv_pwroff);
+				if (abs(target_soc - fuelgauge->info.soc) > 300) {
+					pr_info("%s : F/G reset Start - current mode: %d\n",
+						__func__, target_soc);
+					WA_0_issue_at_init1(fuelgauge, ocv_pwroff);
+				}
+			}
+		} else {
+			if (abs(avg_vbat - vbat) <= 20) {
+				ocv_pwroff = avg_vbat;
+				target_soc = s2mu005_get_soc_from_ocv(fuelgauge, ocv_pwroff);
+				if (abs(target_soc - fuelgauge->info.soc) > 300) {
+					pr_info("%s : F/G reset Start\n", __func__);
+					WA_0_issue_at_init1(fuelgauge, ocv_pwroff);
+				}
+			}
+		}
+	}
+
+	if(fuelgauge->revision < 2) {
+		/* -------------- for enable/disable Current Sensing -------------- */
+		if(fuelgauge->mode == CURRENT_MODE) {
+			ocv_100 = avg_vbat - avg_current * 15 / 100;
+			soc_100 = s2mu005_get_soc_from_ocv(fuelgauge, ocv_100);
+
+			if (fuelgauge->is_charging && avg_current > 0 && fuelgauge->info.soc >= 10000 && fuelgauge->cc_on == true) {
+				fuelgauge->cc_on = false;
+				s2mu005_read_reg_byte(fuelgauge->i2c, 0x45, &temp);
+				temp &= 0xF0;
+				s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x45, temp);
+
+				s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x44, 0x00);
+				dev_dbg(&fuelgauge->i2c->dev, "[DEBUG]%s: stop CC, ocv_100: (%d), soc_100: (%d)\n", __func__, ocv_100, soc_100);
+			} else if((!fuelgauge->is_charging || (fuelgauge->is_charging && avg_current < 0))
+				&& (soc_100 < 10000) && fuelgauge->cc_on == false) {
+				fuelgauge->cc_on = true;
+				s2mu005_read_reg_byte(fuelgauge->i2c, 0x45, &temp);
+				temp &= 0xF0;
+				temp |= 0x07;
+				s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x45, temp);
+
+				s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x44, 0xCC);
+				dev_dbg(&fuelgauge->i2c->dev, "[DEBUG]%s: start CC, ocv_100: (%d), soc_100: (%d)\n", __func__, ocv_100, soc_100);
+			}
+		}
+
+		/* -------------- for enable/disable Current Sensing -------------- */
+
+		/* For debugging */
+		s2mu005_read_reg_byte(fuelgauge->i2c, 0x44, &temp);
+		pr_info("%s: Reg 0x44 : 0x%x\n", __func__, temp);
+		s2mu005_read_reg_byte(fuelgauge->i2c, 0x45, &temp);
+		pr_info("%s: Reg 0x45 : 0x%x\n", __func__, temp);
+
+		s2mu005_read_reg_byte(fuelgauge->i2c, 0x26, &temp);
+		pr_info("%s: Reg 0x26 : 0x%x\n", __func__, temp);
+
+		s2mu005_read_reg_byte(fuelgauge->i2c, 0x4B, &temp);
+		pr_info("%s: Reg 0x4B : 0x%x\n", __func__, temp);
+
+		//bkj - rempcap logging
+		/* ------ read remaining capacity -------- */
+		if (fuelgauge->mode == CURRENT_MODE)
+		{
+			mutex_lock(&fuelgauge->fg_lock);
+
+			s2mu005_read_reg_byte(fuelgauge->i2c, 0x0C, &temp);
+			s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x0C, 0x2A);
+
+			for (i = 0; i < 50; i++) {
+				if (s2mu005_read_reg(fuelgauge->i2c, S2MU005_REG_MONOUT, data) < 0)
+					goto err;
+				if (s2mu005_read_reg(fuelgauge->i2c, S2MU005_REG_MONOUT, check_data) < 0)
+					goto err;
+
+				dev_dbg(&fuelgauge->i2c->dev, "[DEBUG]%s: remaining capacity data0 (%d) data1 (%d)\n", __func__, data[0], data[1]);
+				if ((data[0] == check_data[0]) && (data[1] == check_data[1]))
+					break;
+			}
+			s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x0C, temp);
+
+			mutex_unlock(&fuelgauge->fg_lock);
+
+			compliment = (data[1] << 8) | (data[0]);
+
+			/* data[] store 2's compliment format number */
+			if (compliment & (0x1 << 15)) {
+				/* Negative */
+				rsoc1 = ((~compliment) & 0xFFFF) + 1;
+				rsoc1 = (rsoc1 * (-1)) / (0x1 << 1);
+			} else {
+				rsoc1 = compliment & 0x7FFF;
+				rsoc1 = ((rsoc1 * 1) / (0x1 << 1));
+			}
+
+			pr_info("%s: remcap (%d) \n", __func__, rsoc1);
+		}
+		/* ------ read remaining capacity -------- */
+	}
+
+	/* S2MU005 FG debug */
+	if(fuelgauge->pdata->fg_log_enable)
+		s2mu005_fg_test_read(fuelgauge->i2c);
+
+	return min(fuelgauge->info.soc, 10000);
+
+err:
+	mutex_unlock(&fuelgauge->fg_lock);
+	return -EINVAL;
+}
+
+static int s2mu005_get_current(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u16 compliment;
+	int curr = 0;
+
+	if (s2mu005_read_reg(fuelgauge->i2c, S2MU005_REG_RCUR_CC, data) < 0)
+		return -EINVAL;
+	compliment = (data[1] << 8) | (data[0]);
+	dev_dbg(&fuelgauge->i2c->dev, "%s: rCUR_CC(0x%4x)\n", __func__, compliment);
+
+	if (compliment & (0x1 << 15)) { /* Charging */
+		curr = ((~compliment) & 0xFFFF) + 1;
+		curr = (curr * 1000) >> 12;
+	} else { /* dischaging */
+		curr = compliment & 0x7FFF;
+		curr = (curr * (-1000)) >> 12;
+	}
+
+	dev_info(&fuelgauge->i2c->dev, "%s: current (%d)mA\n", __func__, curr);
+
+	return curr;
+}
+
+#define TABLE_SIZE	22
+static int s2mu005_get_ocv(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	/* 22 values of mapping table for EVT1*/
+
+	int *soc_arr;
+	int *ocv_arr;
+
+	int soc = fuelgauge->info.soc;
+	int ocv = 0;
+
+	int high_index = TABLE_SIZE - 1;
+	int low_index = 0;
+	int mid_index = 0;
+
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	soc_arr = fuelgauge->age_data_info[fuelgauge->fg_age_step].soc_arr_val;
+	ocv_arr = fuelgauge->age_data_info[fuelgauge->fg_age_step].ocv_arr_val;
+#else
+	if(fuelgauge->revision >= 2) {
+		soc_arr = fuelgauge->info.soc_arr_evt2;
+		ocv_arr = fuelgauge->info.ocv_arr_evt2;
+	} else {
+		soc_arr = fuelgauge->info.soc_arr_evt1;
+		ocv_arr = fuelgauge->info.ocv_arr_evt1;
+	}
+#endif
+	dev_err(&fuelgauge->i2c->dev,
+		"%s: soc (%d) soc_arr[TABLE_SIZE-1] (%d) ocv_arr[TABLE_SIZE-1) (%d)\n",
+		__func__, soc, soc_arr[TABLE_SIZE-1], ocv_arr[TABLE_SIZE-1]);
+
+	if(soc <= soc_arr[TABLE_SIZE - 1]) {
+		ocv = ocv_arr[TABLE_SIZE - 1];
+		goto ocv_soc_mapping;
+	} else if (soc >= soc_arr[0]) {
+		ocv = ocv_arr[0];
+		goto ocv_soc_mapping;
+	}
+	while (low_index <= high_index) {
+		mid_index = (low_index + high_index) >> 1;
+		if(soc_arr[mid_index] > soc)
+			low_index = mid_index + 1;
+		else if(soc_arr[mid_index] < soc)
+			high_index = mid_index - 1;
+		else {
+			ocv = ocv_arr[mid_index];
+			goto ocv_soc_mapping;
+		}
+	}
+	ocv = ocv_arr[high_index];
+	ocv += ((ocv_arr[low_index] - ocv_arr[high_index]) *
+					(soc - soc_arr[high_index])) /
+					(soc_arr[low_index] - soc_arr[high_index]);
+
+ocv_soc_mapping:
+	dev_info(&fuelgauge->i2c->dev, "%s: soc (%d), ocv (%d)\n", __func__, soc, ocv);
+	return ocv;
+}
+
+static int s2mu005_get_avgcurrent(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u16 compliment;
+	int curr = 0;
+
+	mutex_lock(&fuelgauge->fg_lock);
+
+	if(fuelgauge->revision >= 0x0A)
+		s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, S2MU005_REG_MONOUT_SEL, 0x17);
+	else
+		s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, S2MU005_REG_MONOUT_SEL, 0x26);
+
+	if (s2mu005_read_reg(fuelgauge->i2c, S2MU005_REG_MONOUT, data) < 0)
+		goto err;
+	compliment = (data[1] << 8) | (data[0]);
+	dev_dbg(&fuelgauge->i2c->dev, "%s: MONOUT(0x%4x)\n", __func__, compliment);
+
+	if (compliment & (0x1 << 15)) { /* Charging */
+		curr = ((~compliment) & 0xFFFF) + 1;
+		curr = (curr * 1000) >> 12;
+	} else { /* dischaging */
+		curr = compliment & 0x7FFF;
+		curr = (curr * (-1000)) >> 12;
+	}
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, S2MU005_REG_MONOUT_SEL, 0x10);
+
+	mutex_unlock(&fuelgauge->fg_lock);
+
+	dev_info(&fuelgauge->i2c->dev, "%s: avg current (%d)mA\n", __func__, curr);
+
+	dev_info(&fuelgauge->i2c->dev, "%s: SOC(%d)%%\n", __func__, fuelgauge->info.soc);
+
+	return curr;
+
+err:
+	mutex_unlock(&fuelgauge->fg_lock);
+	return -EINVAL;
+}
+
+static int s2mu005_maintain_avgcurrent(
+	struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	static int cnt;
+	int vcell = 0;
+	int curr = 0;
+
+	curr = s2mu005_get_avgcurrent(fuelgauge);
+	
+	vcell = s2mu005_get_vbat(fuelgauge);
+	if ((cnt < 10) && (curr < 0) && (fuelgauge->is_charging) &&
+		(vcell < 3500)) {
+			curr = 1;
+			cnt++;
+			dev_info(&fuelgauge->i2c->dev, "%s: vcell (%d)mV,  modified avg current (%d)mA\n",
+				 __func__, vcell, curr);
+	}
+
+	return curr;
+}
+
+static int s2mu005_get_vbat(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u32 vbat = 0;
+
+	if (s2mu005_read_reg(fuelgauge->i2c, S2MU005_REG_RVBAT, data) < 0)
+		return -EINVAL;
+
+	dev_dbg(&fuelgauge->i2c->dev, "%s: data0 (%d) data1 (%d) \n", __func__, data[0], data[1]);
+	vbat = ((data[0] + (data[1] << 8)) * 1000) >> 13;
+
+	dev_info(&fuelgauge->i2c->dev, "%s: vbat (%d)\n", __func__, vbat);
+
+	return vbat;
+}
+
+static int s2mu005_get_monout_avgvbat(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u16 compliment, avg_vbat;
+
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x40, 0x08);
+	mutex_lock(&fuelgauge->fg_lock);
+
+	if(fuelgauge->revision >= 0x0A)
+		s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, S2MU005_REG_MONOUT_SEL, 0x16);
+	else
+		s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, S2MU005_REG_MONOUT_SEL, 0x27);
+
+	mdelay(50);
+
+	if (s2mu005_read_reg(fuelgauge->i2c, S2MU005_REG_MONOUT, data) < 0)
+		goto err;
+	compliment = (data[1] << 8) | (data[0]);
+
+	avg_vbat = (compliment * 1000) >> 12;
+
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, S2MU005_REG_MONOUT_SEL, 0x10);
+
+	mutex_unlock(&fuelgauge->fg_lock);
+
+	dev_info(&fuelgauge->i2c->dev, "%s: avgvbat (%d)\n", __func__, avg_vbat);
+
+	return avg_vbat;
+
+err:
+	mutex_unlock(&fuelgauge->fg_lock);
+	return -EINVAL;
+}
+
+static int s2mu005_get_avgvbat(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u32 new_vbat, old_vbat = 0;
+	int cnt;
+
+	for (cnt = 0; cnt < 5; cnt++) {
+		if (s2mu005_read_reg(fuelgauge->i2c, S2MU005_REG_RVBAT, data) < 0)
+			return -EINVAL;
+
+		new_vbat = ((data[0] + (data[1] << 8)) * 1000) >> 13;
+
+		if (cnt == 0)
+			old_vbat = new_vbat;
+		else
+			old_vbat = new_vbat / 2 + old_vbat / 2;
+	}
+
+	dev_info(&fuelgauge->i2c->dev, "%s: avgvbat (%d)\n", __func__, old_vbat);
+
+	if ((fuelgauge->vbatl_mode == VBATL_MODE_SW_VALERT) &&
+		(fuelgauge->temperature > (int)fuelgauge->low_temp_limit) &&
+		(old_vbat >= fuelgauge->sw_vbat_l_recovery_vol)) {
+		fuelgauge->vbatl_mode = VBATL_MODE_SW_RECOVERY;
+		pr_info("%s : Recover from VBAT_L Activation\n", __func__);
+	}
+
+	return old_vbat;
+}
+
+int static s2mu005_set_adc_curroffset_In(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	s32 coffset_old, coffset_new, coffset_old1, coffset_new1;
+
+	if (s2mu005_read_reg(fuelgauge->i2c, S2MU005_REG_COFFSET, data) < 0)
+		return -EINVAL;
+
+	coffset_old = data[0] + ((data[1] & 0xF) << 8);
+	fuelgauge->coffset_old = data[0] + (data[1] << 8);
+
+	if (coffset_old & (0x1 << 11)) {
+
+		if(coffset_old > 0x852)
+			coffset_new = coffset_old - 82;
+		else
+			coffset_new = 0x800;
+	} else {
+
+		if(coffset_old > 82)
+			coffset_new = coffset_old - 82;
+		else
+			coffset_new = ((~(82 - coffset_old))&0xFFF) + 1;
+	}
+
+	data[0] = (coffset_new & 0x0FF);
+    data[1] = ((coffset_new & 0xF00) >> 8) | (data[1] & 0xF0);
+	s2mu005_write_reg(fuelgauge->i2c, S2MU005_REG_COFFSET, data);
+
+	if (coffset_new & (0x1 << 11))
+		coffset_new1 = -1 * ((((~coffset_new&0xFFF)+1) * 1000) >> 13);
+	else
+		coffset_new1 = (coffset_new * 1000 ) >> 13;
+
+	if (coffset_old & (0x1 << 11))
+		coffset_old1 = -1 * ((((~coffset_old&0xFFF)+1) * 1000) >> 13);
+	else
+		coffset_old1 = (coffset_old * 1000 ) >> 13;
+
+	dev_info(&fuelgauge->i2c->dev,
+	"%s: 0x48[2]=1 -10mA :coffset_old:0x%x, coffset_new:0x%x, coffset_old1:(%d)mA, coffset_new1:(%d)mA\n",
+	__func__, fuelgauge->coffset_old, coffset_new,coffset_old1, coffset_new1);
+
+	return 0;
+}
+
+int static s2mu005_set_adc_curroffset_out(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+    u8 data[2];
+    s32 coffset_old, coffset_new, coffset_old1, coffset_new1;
+
+    if (s2mu005_read_reg(fuelgauge->i2c, S2MU005_REG_COFFSET, data) < 0)
+        return -EINVAL;
+
+    coffset_old = data[0] + ((data[1] & 0xF) << 8);
+    fuelgauge->coffset_old = data[0] + (data[1] << 8);
+
+    coffset_new = coffset_old + 82;
+    coffset_new = coffset_new & 0xFFF;
+
+    data[0] = (coffset_new & 0x0FF);
+    data[1] = ((coffset_new & 0xF00) >> 8) | (data[1] & 0xF0);
+    s2mu005_write_reg(fuelgauge->i2c, S2MU005_REG_COFFSET, data);
+
+    if (coffset_new & (0x1 << 11))
+        coffset_new1 = -1 * ((((~coffset_new&0xFFF)+1) * 1000) >> 13);
+    else
+        coffset_new1 = (coffset_new * 1000 ) >> 13;
+
+    if (coffset_old & (0x1 << 11))
+        coffset_old1 = -1 * ((((~coffset_old&0xFFF)+1) * 1000) >> 13);
+    else
+        coffset_old1 = (coffset_old * 1000 ) >> 13;
+
+    dev_info(&fuelgauge->i2c->dev,
+    "%s: 0x48[2]=0 +10mA :coffset_old:0x%x, coffset_new:0x%x, coffset_old1:(%d)mA, coffset_new1:(%d)mA\n",
+    __func__, fuelgauge->coffset_old, coffset_new,coffset_old1, coffset_new1);
+
+	return 0;
+}
+
+/* capacity is  0.1% unit */
+static void s2mu005_fg_get_scaled_capacity(
+		struct s2mu005_fuelgauge_data *fuelgauge,
+		union power_supply_propval *val)
+{
+	val->intval = (val->intval < fuelgauge->pdata->capacity_min) ?
+		0 : ((val->intval - fuelgauge->pdata->capacity_min) * 1000 /
+		(fuelgauge->capacity_max - fuelgauge->pdata->capacity_min));
+
+	dev_info(&fuelgauge->i2c->dev,
+			"%s: scaled capacity (%d.%d)\n",
+			__func__, val->intval/10, val->intval%10);
+}
+
+/* capacity is integer */
+static void s2mu005_fg_get_atomic_capacity(
+		struct s2mu005_fuelgauge_data *fuelgauge,
+		union power_supply_propval *val)
+{
+	if (fuelgauge->pdata->capacity_calculation_type &
+			SEC_FUELGAUGE_CAPACITY_TYPE_ATOMIC) {
+		if (fuelgauge->capacity_old < val->intval)
+			val->intval = fuelgauge->capacity_old + 1;
+		else if (fuelgauge->capacity_old > val->intval)
+			val->intval = fuelgauge->capacity_old - 1;
+	}
+
+	/* keep SOC stable in abnormal status */
+	if (fuelgauge->pdata->capacity_calculation_type &
+			SEC_FUELGAUGE_CAPACITY_TYPE_SKIP_ABNORMAL) {
+		if (!fuelgauge->is_charging &&
+				fuelgauge->capacity_old < val->intval) {
+			dev_err(&fuelgauge->i2c->dev,
+					"%s: capacity (old %d : new %d)\n",
+					__func__, fuelgauge->capacity_old, val->intval);
+			val->intval = fuelgauge->capacity_old;
+		}
+	}
+
+	/* updated old capacity */
+	fuelgauge->capacity_old = val->intval;
+}
+
+static int s2mu005_fg_check_capacity_max(
+		struct s2mu005_fuelgauge_data *fuelgauge, int capacity_max)
+{
+	int new_capacity_max = capacity_max;
+
+	if (new_capacity_max < (fuelgauge->pdata->capacity_max -
+				fuelgauge->pdata->capacity_max_margin - 10)) {
+		new_capacity_max =
+			(fuelgauge->pdata->capacity_max -
+			 fuelgauge->pdata->capacity_max_margin);
+
+		dev_info(&fuelgauge->i2c->dev, "%s: set capacity max(%d --> %d)\n",
+				__func__, capacity_max, new_capacity_max);
+	} else if (new_capacity_max > (fuelgauge->pdata->capacity_max +
+				fuelgauge->pdata->capacity_max_margin)) {
+		new_capacity_max =
+			(fuelgauge->pdata->capacity_max +
+			 fuelgauge->pdata->capacity_max_margin);
+
+		dev_info(&fuelgauge->i2c->dev, "%s: set capacity max(%d --> %d)\n",
+				__func__, capacity_max, new_capacity_max);
+	}
+
+	return new_capacity_max;
+}
+
+static int s2mu005_fg_calculate_dynamic_scale(
+		struct s2mu005_fuelgauge_data *fuelgauge, int capacity)
+{
+	union power_supply_propval raw_soc_val;
+	raw_soc_val.intval = s2mu005_get_rawsoc(fuelgauge) / 10;
+
+	if (raw_soc_val.intval <
+			fuelgauge->pdata->capacity_max -
+			fuelgauge->pdata->capacity_max_margin) {
+		fuelgauge->capacity_max =
+			fuelgauge->pdata->capacity_max -
+			fuelgauge->pdata->capacity_max_margin;
+		dev_dbg(&fuelgauge->i2c->dev, "%s: capacity_max (%d)",
+				__func__, fuelgauge->capacity_max);
+	} else {
+		fuelgauge->capacity_max =
+			(raw_soc_val.intval >
+			 fuelgauge->pdata->capacity_max +
+			 fuelgauge->pdata->capacity_max_margin) ?
+			(fuelgauge->pdata->capacity_max +
+			 fuelgauge->pdata->capacity_max_margin) :
+			raw_soc_val.intval;
+		dev_dbg(&fuelgauge->i2c->dev, "%s: raw soc (%d)",
+				__func__, fuelgauge->capacity_max);
+	}
+
+	if (capacity != 100) {
+		fuelgauge->capacity_max = s2mu005_fg_check_capacity_max(
+			fuelgauge, (fuelgauge->capacity_max * 100 / (capacity + 1)));
+	} else  {
+		fuelgauge->capacity_max =
+			(fuelgauge->capacity_max * 99 / 100);
+	}
+
+	/* update capacity_old for sec_fg_get_atomic_capacity algorithm */
+	fuelgauge->capacity_old = capacity;
+
+	dev_info(&fuelgauge->i2c->dev, "%s: %d is used for capacity_max\n",
+			__func__, fuelgauge->capacity_max);
+
+	return fuelgauge->capacity_max;
+}
+
+bool s2mu005_fuelgauge_fuelalert_init(struct i2c_client *client, int soc)
+{
+	struct s2mu005_fuelgauge_data *fuelgauge = i2c_get_clientdata(client);
+	u8 data[2];
+
+	fuelgauge->is_fuel_alerted = false;
+
+	/* 1. Set s2mu005 alert configuration. */
+	s2mu005_alert_init(fuelgauge);
+
+	if (s2mu005_read_reg(client, S2MU005_REG_IRQ, data) < 0)
+		return -1;
+
+	/*Enable VBAT, SOC */
+	data[1] &= 0xfc;
+
+	/*Disable IDLE_ST, INIT)ST */
+	data[1] |= 0x0c;
+
+	s2mu005_write_reg(client, S2MU005_REG_IRQ, data);
+
+	dev_dbg(&client->dev, "%s: irq_reg(%02x%02x) irq(%d)\n",
+			__func__, data[1], data[0], fuelgauge->pdata->fg_irq);
+
+	return true;
+}
+
+bool s2mu005_fuelgauge_is_fuelalerted(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	return s2mu005_check_status(fuelgauge->i2c);
+}
+
+bool s2mu005_hal_fg_fuelalert_process(void *irq_data, bool is_fuel_alerted)
+{
+	struct s2mu005_fuelgauge_data *fuelgauge = irq_data;
+	int ret;
+
+	ret = i2c_smbus_write_byte_data(fuelgauge->i2c, S2MU005_REG_IRQ, 0x00);
+	if (ret < 0)
+		dev_err(&fuelgauge->i2c->dev, "%s: Error(%d)\n", __func__, ret);
+
+	return ret;
+}
+
+bool s2mu005_hal_fg_full_charged(struct i2c_client *client)
+{
+	return true;
+}
+
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+static int s2mu005_fg_aging_check(
+		struct s2mu005_fuelgauge_data *fuelgauge, int step)
+{
+	u8 batcap0, batcap1, batcap2, batcap3;
+	union power_supply_propval value;
+	int charging_enabled = false;
+
+	fuelgauge->fg_age_step = step;
+
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x0F, &batcap0);
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x0E, &batcap1);
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x11, &batcap2);
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x10, &batcap3);
+
+	pr_info("%s: [Long life] orig. batcap : %02x, %02x, %02x, %02x , fg_age_step data : %02x, %02x, %02x, %02x\n",
+		__func__, batcap0, batcap1, batcap2, batcap3,
+		fuelgauge->age_data_info[fuelgauge->fg_age_step].batcap[0],
+		fuelgauge->age_data_info[fuelgauge->fg_age_step].batcap[1],
+		fuelgauge->age_data_info[fuelgauge->fg_age_step].batcap[2],
+		fuelgauge->age_data_info[fuelgauge->fg_age_step].batcap[3]);
+
+	if ((batcap0 != fuelgauge->age_data_info[fuelgauge->fg_age_step].batcap[0]) ||
+		(batcap1 != fuelgauge->age_data_info[fuelgauge->fg_age_step].batcap[1]) ||
+		(batcap2 != fuelgauge->age_data_info[fuelgauge->fg_age_step].batcap[2]) ||
+		(batcap3 != fuelgauge->age_data_info[fuelgauge->fg_age_step].batcap[3])) {
+
+		pr_info("%s: [Long life] reset gauge for age forcast , step[%d]\n", __func__, fuelgauge->fg_age_step);
+
+		fuelgauge->age_reset_status = 1;
+
+		/* check charging enable */
+		psy_do_property("s2mu005-charger", get, POWER_SUPPLY_PROP_CHARGING_ENABLED, value);
+		charging_enabled = value.intval;
+
+		if (charging_enabled == true) {
+			pr_info("%s: [Long life] disable charger for reset gauge age forcast\n", __func__);
+			value.intval = SEC_BAT_CHG_MODE_CHARGING_OFF;
+			psy_do_property("s2mu005-charger", set, POWER_SUPPLY_PROP_CHARGING_ENABLED, value);
+		}
+
+		s2mu005_reset_fg(fuelgauge);
+
+		if (charging_enabled == true) {
+			psy_do_property("battery", get, POWER_SUPPLY_PROP_STATUS, value);
+			charging_enabled = value.intval;
+
+			if (charging_enabled == 1) { /* POWER_SUPPLY_STATUS_CHARGING 1 */
+				pr_info("%s: [Long life] enable charger for reset gauge age forcast\n", __func__);
+				value.intval = SEC_BAT_CHG_MODE_CHARGING;
+				psy_do_property("s2mu005-charger", set, POWER_SUPPLY_PROP_CHARGING_ENABLED, value);
+			}
+		}
+
+		fuelgauge->age_reset_status = 0;
+
+		return 1;
+	}
+	return 0;
+}
+#endif
+
+static void s2mu005_fg_reset_capacity_by_jig_connection(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	u8 data = 0;
+
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x48, &data);
+	data |= 0x01; /* set 0x48[0]=1 for next boot up initializing fuelgague */
+	s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x48, data);
+
+	pr_info("%s: set 0x48[0] (0x%x)\n", __func__, data);
+}
+
+static int s2mu005_fg_get_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		union power_supply_propval *val)
+{
+	u8 temp = 0;
+	union power_supply_propval ui_soc_val;
+	union power_supply_propval cable_type_val;
+
+	struct s2mu005_fuelgauge_data *fuelgauge =
+		container_of(psy, struct s2mu005_fuelgauge_data, psy_fg);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+	case POWER_SUPPLY_PROP_ENERGY_NOW:
+		return -ENODATA;
+		/* Cell voltage (VCELL, mV) */
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = s2mu005_get_vbat(fuelgauge);
+		break;
+		/* Additional Voltage Information (mV) */
+	case POWER_SUPPLY_PROP_VOLTAGE_AVG:
+		switch (val->intval) {
+			case SEC_BATTERY_VOLTAGE_AVERAGE:
+				val->intval = s2mu005_get_avgvbat(fuelgauge);
+				break;
+			case SEC_BATTERY_VOLTAGE_OCV:
+				val->intval = s2mu005_get_ocv(fuelgauge);
+				break;
+		}
+		break;
+		/* Current (mA) */
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		if (val->intval == SEC_BATTERY_CURRENT_UA)
+			val->intval = s2mu005_get_current(fuelgauge) * 1000;
+		else
+			val->intval = s2mu005_get_current(fuelgauge);
+		break;
+		/* Average Current (mA) */
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+		if (val->intval == SEC_BATTERY_CURRENT_UA)
+			val->intval = s2mu005_maintain_avgcurrent(fuelgauge) * 1000;
+		else
+			val->intval = s2mu005_maintain_avgcurrent(fuelgauge);
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		if (val->intval == SEC_FUELGAUGE_CAPACITY_TYPE_RAW) {
+			val->intval = s2mu005_get_rawsoc(fuelgauge);
+		} else {
+			val->intval = s2mu005_get_rawsoc(fuelgauge) / 10;
+
+			if (fuelgauge->pdata->capacity_calculation_type &
+				(SEC_FUELGAUGE_CAPACITY_TYPE_SCALE |
+					SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE))
+				s2mu005_fg_get_scaled_capacity(fuelgauge, val);
+
+			/* capacity should be between 0% and 100%
+			 * (0.1% degree)
+			 */
+			if (val->intval > 1000)
+				val->intval = 1000;
+			if (val->intval < 0)
+				val->intval = 0;
+
+			/* get only integer part */
+			val->intval /= 10;
+
+			if (!fuelgauge->is_charging &&
+			    fuelgauge->vbatl_mode == VBATL_MODE_SW_VALERT && !lpcharge) {
+				pr_info("%s : VBAT_L (low voltage). Decrease SOC\n", __func__);
+				val->intval = 0;
+			} else if ((fuelgauge->vbatl_mode == VBATL_MODE_SW_RECOVERY) &&
+				   (val->intval == fuelgauge->capacity_old)) {
+				fuelgauge->vbatl_mode =  VBATL_MODE_NORMAL;
+			}
+
+			/* change adc current offset when 100% for EVT1 */
+			if (fuelgauge->revision < 2) {
+				psy_do_property("battery", get, POWER_SUPPLY_PROP_CAPACITY, ui_soc_val);
+				psy_do_property("battery", get, POWER_SUPPLY_PROP_ONLINE, cable_type_val);
+				dev_info(&fuelgauge->i2c->dev, "%s: UI SOC = %d, cable_type = %d\n",
+								__func__, ui_soc_val.intval, cable_type_val.intval);
+
+				s2mu005_read_reg_byte(fuelgauge->i2c, 0x48, &temp);
+				if((fuelgauge->is_charging == true) && (ui_soc_val.intval >= 100) && !(temp & 0x04)) {
+					if(s2mu005_set_adc_curroffset_In(fuelgauge) < 0)
+						return -EINVAL;
+					temp |= 0x04;
+					s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x48, temp); /* 0x48[2]=1 : adc_offset_on */
+					dev_info(&fuelgauge->i2c->dev, "%s: change coffset to -10mA. 0x48:0x%x\n", __func__, temp);
+				} else if(((cable_type_val.intval == POWER_SUPPLY_TYPE_BATTERY) ||
+								(cable_type_val.intval == POWER_SUPPLY_TYPE_UNKNOWN) ||
+								(cable_type_val.intval == POWER_SUPPLY_TYPE_OTG)) &&
+								(temp & 0x04)) {					
+					if(s2mu005_set_adc_curroffset_out(fuelgauge) < 0)
+						return -EINVAL;
+					temp &= ~0x04;
+					s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x48, temp); /* 0x48[2]=0 : adc_offset_off */
+					dev_info(&fuelgauge->i2c->dev, "%s: change coffset to +10mA. 0x48:0x%x\n", __func__, temp);					
+				}
+			}
+
+			/* check whether doing the wake_unlock */
+			if ((val->intval > fuelgauge->pdata->fuel_alert_soc) &&
+					fuelgauge->is_fuel_alerted) {
+				wake_unlock(&fuelgauge->fuel_alert_wake_lock);
+				s2mu005_fuelgauge_fuelalert_init(fuelgauge->i2c,
+						fuelgauge->pdata->fuel_alert_soc);
+			}
+
+			/* (Only for atomic capacity)
+			 * In initial time, capacity_old is 0.
+			 * and in resume from sleep,
+			 * capacity_old is too different from actual soc.
+			 * should update capacity_old
+			 * by val->intval in booting or resume.
+			 */
+			if ((fuelgauge->initial_update_of_soc) &&
+				(fuelgauge->vbatl_mode != VBATL_MODE_SW_VALERT)) {
+				/* updated old capacity */
+				fuelgauge->capacity_old = val->intval;
+				fuelgauge->initial_update_of_soc = false;
+				break;
+			}
+
+			if (fuelgauge->sleep_initial_update_of_soc) {
+				/* updated old capacity in case of resume */
+				if (fuelgauge->is_charging) {
+					fuelgauge->capacity_old = val->intval;
+					fuelgauge->sleep_initial_update_of_soc = false;
+					break;
+				} else if ((fuelgauge->vbatl_mode != VBATL_MODE_SW_VALERT) &&
+					((!fuelgauge->is_charging) && (fuelgauge->capacity_old >= val->intval))) {
+					fuelgauge->capacity_old = val->intval;
+					fuelgauge->sleep_initial_update_of_soc = false;
+					break;
+				}
+			}
+
+			if (fuelgauge->pdata->capacity_calculation_type &
+				(SEC_FUELGAUGE_CAPACITY_TYPE_ATOMIC |
+					 SEC_FUELGAUGE_CAPACITY_TYPE_SKIP_ABNORMAL))
+				s2mu005_fg_get_atomic_capacity(fuelgauge, val);
+		}
+
+		break;
+	/* Battery Temperature */
+	case POWER_SUPPLY_PROP_TEMP:
+	/* Target Temperature */
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		val->intval = s2mu005_get_temperature(fuelgauge);
+		break;
+	case POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:
+		val->intval = fuelgauge->capacity_max;
+		break;
+	case POWER_SUPPLY_PROP_SCOPE:
+		val->intval = fuelgauge->mode;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int s2mu005_fg_set_property(struct power_supply *psy,
+                            enum power_supply_property psp,
+                            const union power_supply_propval *val)
+{
+	struct s2mu005_fuelgauge_data *fuelgauge =
+		container_of(psy, struct s2mu005_fuelgauge_data, psy_fg);
+
+	u8 temp = 0;	
+	enum power_supply_ext_property ext_psp = psp;
+
+	switch (psp) {
+		case POWER_SUPPLY_PROP_STATUS:
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+			if (val->intval == POWER_SUPPLY_STATUS_FULL)
+				s2mu005_fg_aging_check(fuelgauge,
+					fuelgauge->change_step);
+#endif
+			break;
+		case POWER_SUPPLY_PROP_CHARGE_FULL:
+			if (fuelgauge->pdata->capacity_calculation_type &
+					SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE) {
+#if defined(CONFIG_PREVENT_SOC_JUMP)
+				s2mu005_fg_calculate_dynamic_scale(fuelgauge, val->intval);
+#else
+				s2mu005_fg_calculate_dynamic_scale(fuelgauge, 100);
+#endif
+			}
+			break;
+		case POWER_SUPPLY_PROP_ONLINE:
+			fuelgauge->cable_type = val->intval;
+			if (!(val->intval == POWER_SUPPLY_TYPE_BATTERY)) {
+				if (fuelgauge->vbatl_mode >= VBATL_MODE_SW_VALERT) {
+					fuelgauge->vbatl_mode = VBATL_MODE_NORMAL;
+					fuelgauge->initial_update_of_soc = true;
+				}
+			}
+			if (val->intval == POWER_SUPPLY_TYPE_BATTERY)
+				fuelgauge->is_charging = false;
+			else
+				fuelgauge->is_charging = true;
+			break;
+		case POWER_SUPPLY_PROP_CAPACITY:
+			if (val->intval == SEC_FUELGAUGE_CAPACITY_TYPE_RESET) {
+				fuelgauge->initial_update_of_soc = true;
+				s2mu005_restart_gauging(fuelgauge);
+			}
+			break;
+		case POWER_SUPPLY_PROP_TEMP:
+		case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+			s2mu005_set_temperature(fuelgauge, val->intval);
+			break;
+		case POWER_SUPPLY_PROP_ENERGY_NOW:
+			s2mu005_fg_reset_capacity_by_jig_connection(fuelgauge);
+			break;
+		case POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:
+			dev_info(&fuelgauge->i2c->dev,
+				"%s: capacity_max changed, %d -> %d\n",
+				__func__, fuelgauge->capacity_max, val->intval);
+			fuelgauge->capacity_max = s2mu005_fg_check_capacity_max(fuelgauge, val->intval);
+			fuelgauge->initial_update_of_soc = true;
+			break;
+		case POWER_SUPPLY_PROP_CHARGE_TYPE:
+			/* rt5033_fg_reset_capacity_by_jig_connection(fuelgauge->i2c); */
+			break;
+		case POWER_SUPPLY_PROP_CHARGE_EMPTY:
+			pr_info("%s: WA for battery 0 percent\n", __func__);
+			s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x1F, 0x01);
+			break;
+		case POWER_SUPPLY_PROP_ENERGY_AVG:
+			pr_info("%s: WA for power off issue: val(%d)\n", __func__, val->intval);
+			if(val->intval)
+				s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x41, 0x10); /* charger start */
+			else
+				s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x41, 0x04); /* charger end */
+			break;
+		case POWER_SUPPLY_PROP_FUELGAUGE_FACTORY:
+			pr_info("%s:[DEBUG_FAC]  fuelgauge \n", __func__);
+			s2mu005_read_reg_byte(fuelgauge->i2c, 0x25, &temp);
+			temp &= 0xCF;
+			temp |= 0x30;
+			s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x25, temp);
+			s2mu005_fg_reset_capacity_by_jig_connection(fuelgauge);
+			break;
+		case POWER_SUPPLY_PROP_MAX ... POWER_SUPPLY_EXT_PROP_MAX:
+			switch (ext_psp) {
+			case POWER_SUPPLY_EXT_PROP_INBAT_VOLTAGE_FGSRC_SWITCHING:
+				if (val->intval == SEC_BAT_INBAT_FGSRC_SWITCHING_ON) {
+					/* Get Battery voltage (by I2C control) */
+					s2mu005_read_reg_byte(fuelgauge->i2c, 0x25, &temp);
+					temp &= 0xCF;
+					temp |= 0x10;
+					s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x25, temp);
+					mdelay(1000);
+					s2mu005_restart_gauging(fuelgauge);
+					s2mu005_fg_reset_capacity_by_jig_connection(fuelgauge);
+					s2mu005_fg_test_read(fuelgauge->i2c);
+					pr_info("%s: SEC_BAT_INBAT_FGSRC_SWITCHING_ON : 0x25 = %x\n", __func__,temp);
+				} else if (val->intval == SEC_BAT_INBAT_FGSRC_SWITCHING_OFF) {
+					s2mu005_read_reg_byte(fuelgauge->i2c, 0x25, &temp);
+					temp &= 0xCF;
+					temp |= 0x30;
+					s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x25, temp);
+					mdelay(1000);
+					s2mu005_restart_gauging(fuelgauge);
+					s2mu005_fg_test_read(fuelgauge->i2c);
+					pr_info("%s: SEC_BAT_INBAT_FGSRC_SWITCHING_OFF : 0x25 = %x\n", __func__,temp);
+				}
+				s2mu005_read_reg_byte(fuelgauge->i2c, 0x25, &temp);
+				pr_info("%s: [%d] Internal switch 0x%X\n", __func__, val->intval, (temp & 0x30) >> 4);
+				break;
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+		case POWER_SUPPLY_EXT_PROP_UPDATE_BATTERY_DATA:
+			fuelgauge->change_step = val->intval;
+			break;
+#endif
+			default:
+				return -EINVAL;
+			}
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void s2mu005_fg_isr_work(struct work_struct *work)
+{
+	struct s2mu005_fuelgauge_data *fuelgauge =
+		container_of(work, struct s2mu005_fuelgauge_data, isr_work.work);
+	u8 fg_alert_status = 0;
+
+	s2mu005_read_reg_byte(fuelgauge->i2c, S2MU005_REG_STATUS, &fg_alert_status);
+	dev_info(&fuelgauge->i2c->dev, "%s : fg_alert_status(0x%x)\n",
+		__func__, fg_alert_status);
+
+	fg_alert_status &= 0x03;
+	if (fg_alert_status & 0x01) {
+		pr_info("%s : Battery Level(SOC) is very Low!\n", __func__);
+	}
+
+	if (fg_alert_status & 0x02) {
+		pr_info("%s : Battery Voltage is Very Low!\n", __func__);
+	}
+
+	if (!fg_alert_status) {
+		fuelgauge->is_fuel_alerted = false;
+		pr_info("%s : SOC or Voltage is Good!\n", __func__);
+		wake_unlock(&fuelgauge->fuel_alert_wake_lock);
+	}
+}
+
+static irqreturn_t s2mu005_fg_irq_thread(int irq, void *irq_data)
+{
+	struct s2mu005_fuelgauge_data *fuelgauge = irq_data;
+	u8 fg_irq = 0;
+
+	s2mu005_read_reg_byte(fuelgauge->i2c, S2MU005_REG_IRQ, &fg_irq);
+	dev_info(&fuelgauge->i2c->dev, "%s: fg_irq(0x%x)\n",
+		__func__, fg_irq);
+	if (fuelgauge->is_fuel_alerted) {
+		return IRQ_HANDLED;
+	} else {
+		wake_lock(&fuelgauge->fuel_alert_wake_lock);
+		fuelgauge->is_fuel_alerted = true;
+		schedule_delayed_work(&fuelgauge->isr_work, 0);
+	}
+
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_OF
+static int s2mu005_fuelgauge_parse_dt(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	struct device_node *np = of_find_node_by_name(NULL, "s2mu005-fuelgauge");
+	int ret;
+	int i, len;
+	const u32 *p;
+
+	        /* reset, irq gpio info */
+	if (np == NULL) {
+		pr_err("%s np NULL\n", __func__);
+	} else {
+		fuelgauge->pdata->fg_irq = of_get_named_gpio(np, "fuelgauge,fuel_int", 0);
+		if (fuelgauge->pdata->fg_irq < 0)
+			pr_err("%s error reading fg_irq = %d\n",
+				__func__, fuelgauge->pdata->fg_irq);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_max",
+				&fuelgauge->pdata->capacity_max);
+		if (ret < 0)
+			pr_err("%s error reading capacity_max %d\n", __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_max_margin",
+				&fuelgauge->pdata->capacity_max_margin);
+		if (ret < 0)
+			pr_err("%s error reading capacity_max_margin %d\n", __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_min",
+				&fuelgauge->pdata->capacity_min);
+		if (ret < 0)
+			pr_err("%s error reading capacity_min %d\n", __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_calculation_type",
+				&fuelgauge->pdata->capacity_calculation_type);
+		if (ret < 0)
+			pr_err("%s error reading capacity_calculation_type %d\n",
+					__func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,evt2_val",
+				&fuelgauge->pdata->evt2_val);
+		if (ret < 0){
+			fuelgauge->pdata->evt2_val = 0x00;
+			pr_info("%s Default value of evt2_val = %x\n",
+					__func__, fuelgauge->pdata->evt2_val);
+		}
+
+		ret = of_property_read_u32(np, "fuelgauge,fg_log_enable",
+				&fuelgauge->pdata->fg_log_enable);
+		if (ret < 0)
+			pr_err("%s fg_log_disabled %d\n", __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,fuel_alert_soc",
+				&fuelgauge->pdata->fuel_alert_soc);
+		if (ret < 0)
+			pr_err("%s error reading pdata->fuel_alert_soc %d\n",
+					__func__, ret);
+		fuelgauge->pdata->repeated_fuelalert = of_property_read_bool(np,
+				"fuelgauge,repeated_fuelalert");
+
+		ret = of_property_read_u32(np, "fuelgauge,low_temp_limit",
+					   &fuelgauge->low_temp_limit);
+		if (ret < 0) {
+			pr_err("%s error reading low temp limit %d\n", __func__, ret);
+			fuelgauge->low_temp_limit = 100;
+		}
+
+		pr_info("%s : LOW TEMP LIMIT(%d)\n",
+			__func__, fuelgauge->low_temp_limit);
+
+		ret = of_property_read_u32(np, "fuelgauge,sw_vbat_l_recovery_vol",
+						&fuelgauge->sw_vbat_l_recovery_vol);
+		if (ret < 0) {
+			pr_err("%s error reading sw_vbat_l_recovery_vol %d\n",
+				__func__, ret);
+			fuelgauge->sw_vbat_l_recovery_vol = 3465;
+		}
+
+		pr_info("%s : SW VBAT_L recovery (%d)mV\n",
+			__func__, fuelgauge->sw_vbat_l_recovery_vol);
+
+		np = of_find_node_by_name(NULL, "battery");
+		if (!np) {
+			pr_err("%s np NULL\n", __func__);
+		} else {
+			ret = of_property_read_string(np,
+				"battery,fuelgauge_name",
+				(char const **)&fuelgauge->pdata->fuelgauge_name);
+			p = of_get_property(np,
+					"battery,input_current_limit", &len);
+			if (!p)
+				return 1;
+
+			len = len / sizeof(u32);
+			fuelgauge->pdata->charging_current =
+					kzalloc(sizeof(struct sec_charging_current) * len,
+					GFP_KERNEL);
+
+			for(i = 0; i < len; i++) {
+				ret = of_property_read_u32_index(np,
+					"battery,input_current_limit", i,
+					&fuelgauge->pdata->charging_current[i].input_current_limit);
+				ret = of_property_read_u32_index(np,
+					"battery,fast_charging_current", i,
+					&fuelgauge->pdata->charging_current[i].fast_charging_current);
+				ret = of_property_read_u32_index(np,
+					"battery,full_check_current_1st", i,
+					&fuelgauge->pdata->charging_current[i].full_check_current_1st);
+				ret = of_property_read_u32_index(np,
+					"battery,full_check_current_2nd", i,
+					&fuelgauge->pdata->charging_current[i].full_check_current_2nd);
+			}
+		}
+
+		/* get battery_params node */
+		np = of_find_node_by_name(NULL, "battery_params");
+		if (!np) {
+			pr_err("%s battery_params node NULL\n", __func__);
+		} else {
+#if !defined(CONFIG_BATTERY_AGE_FORECAST)
+			/* get battery_table */
+			ret = of_property_read_u32_array(np, "battery,battery_table1", fuelgauge->info.battery_table1, 88);
+			if (ret < 0) {
+				pr_err("%s error reading battery,battery_table1\n", __func__);
+			}
+
+			ret = of_property_read_u32_array(np, "battery,battery_table2", fuelgauge->info.battery_table2, 22);
+			if (ret < 0) {
+				pr_err("%s error reading battery,battery_table2\n", __func__);
+			}
+
+			ret = of_property_read_u32_array(np, "battery,battery_table3", fuelgauge->info.battery_table3, 88);
+			if (ret < 0) {
+				pr_err("%s error reading battery,battery_table3\n", __func__);
+			}
+
+			ret = of_property_read_u32_array(np, "battery,battery_table4", fuelgauge->info.battery_table4, 22);
+			if (ret < 0) {
+				pr_err("%s error reading battery,battery_table4\n", __func__);
+			}
+
+			ret = of_property_read_u32_array(np, "battery,batcap", fuelgauge->info.batcap, 4);
+			if (ret < 0) {
+				pr_err("%s error reading battery,batcap\n", __func__);
+			}
+
+			ret = of_property_read_u32_array(np, "battery,soc_arr_evt1", fuelgauge->info.soc_arr_evt1, 22);
+			if (ret < 0) {
+				pr_err("%s error reading battery,soc_arr_evt1\n", __func__);
+			}
+
+			ret = of_property_read_u32_array(np, "battery,ocv_arr_evt1", fuelgauge->info.ocv_arr_evt1, 22);
+			if (ret < 0) {
+				pr_err("%s error reading battery,ocv_arr_evt1\n", __func__);
+			}
+
+			ret = of_property_read_u32_array(np, "battery,soc_arr_evt2", fuelgauge->info.soc_arr_evt2, 22);
+			if (ret < 0) {
+				pr_err("%s error reading battery,soc_arr_evt2\n", __func__);
+			}
+
+			ret = of_property_read_u32_array(np, "battery,ocv_arr_evt2", fuelgauge->info.ocv_arr_evt2, 22);
+			if (ret < 0) {
+				pr_err("%s error reading battery,ocv_arr_evt2\n", __func__);
+			}
+			ret = of_property_read_u32_array(np, "battery,FG_Accumulative_rate_evt2", fuelgauge->info.fg_accumulative_rate_evt2, 2);
+			if (ret < 0) {
+
+				fuelgauge->info.fg_accumulative_rate_evt2[0]=0x00;    // REG 0x44
+				fuelgauge->info.fg_accumulative_rate_evt2[1]=0x08;    // REG 0x45
+				pr_err("%s There is no FG_Accumulative_rate value in DT. set to the default value(0x800)\n", __func__);
+			}
+#else
+			of_get_property(np, "battery,battery_data", &len);
+			fuelgauge->fg_num_age_step = len / sizeof(fg_age_data_info_t);
+			fuelgauge->age_data_info = kzalloc(len, GFP_KERNEL);
+			ret = of_property_read_u32_array(np, "battery,battery_data",
+					(int *)fuelgauge->age_data_info, len/sizeof(int));
+
+			pr_err("%s: [Long life] fuelgauge->fg_num_age_step %d\n", __func__, fuelgauge->fg_num_age_step);
+
+			for (i = 0 ; i < fuelgauge->fg_num_age_step ; i++) {
+				pr_err("%s: [Long life] age_step = %d, table3[0] %d, table4[0] %d, batcap[0] %02x, accum[0] %02x, soc_arr[0] %d, ocv_arr[0] %d\n",
+					__func__, i,
+					fuelgauge->age_data_info[i].battery_table3[0],
+					fuelgauge->age_data_info[i].battery_table4[0],
+					fuelgauge->age_data_info[i].batcap[0],
+					fuelgauge->age_data_info[i].accum[0],
+					fuelgauge->age_data_info[i].soc_arr_val[0],
+					fuelgauge->age_data_info[i].ocv_arr_val[0]);
+			}
+#endif
+		}
+	}
+
+	return 0;
+}
+
+static struct of_device_id s2mu005_fuelgauge_match_table[] = {
+        { .compatible = "samsung,s2mu005-fuelgauge",},
+        {},
+};
+#else
+static int s2mu005_fuelgauge_parse_dt(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+    return -ENOSYS;
+}
+
+#define s2mu005_fuelgauge_match_table NULL
+#endif /* CONFIG_OF */
+
+static int s2mu005_fuelgauge_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+	struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
+	struct s2mu005_fuelgauge_data *fuelgauge;
+	union power_supply_propval raw_soc_val;
+	int ret = 0;
+	u8 temp = 0;
+
+	pr_info("%s: S2MU005 Fuelgauge Driver Loading\n", __func__);
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE))
+		return -EIO;
+
+	fuelgauge = kzalloc(sizeof(*fuelgauge), GFP_KERNEL);
+	if (!fuelgauge)
+		return -ENOMEM;
+
+	mutex_init(&fuelgauge->fg_lock);
+
+	fuelgauge->i2c = client;
+
+	if (client->dev.of_node) {
+		fuelgauge->pdata = devm_kzalloc(&client->dev, sizeof(*(fuelgauge->pdata)),
+				GFP_KERNEL);
+		if (!fuelgauge->pdata) {
+			dev_err(&client->dev, "Failed to allocate memory\n");
+			ret = -ENOMEM;
+			goto err_parse_dt_nomem;
+		}
+		ret = s2mu005_fuelgauge_parse_dt(fuelgauge);
+		if (ret < 0)
+			goto err_parse_dt;
+	} else {
+		fuelgauge->pdata = client->dev.platform_data;
+	}
+
+	i2c_set_clientdata(client, fuelgauge);
+
+	if (fuelgauge->pdata->fuelgauge_name == NULL)
+		fuelgauge->pdata->fuelgauge_name = "sec-fuelgauge";
+
+	fuelgauge->psy_fg.name          = fuelgauge->pdata->fuelgauge_name;
+	fuelgauge->psy_fg.type          = POWER_SUPPLY_TYPE_UNKNOWN;
+	fuelgauge->psy_fg.get_property  = s2mu005_fg_get_property;
+	fuelgauge->psy_fg.set_property  = s2mu005_fg_set_property;
+	fuelgauge->psy_fg.properties    = s2mu005_fuelgauge_props;
+	fuelgauge->psy_fg.num_properties =
+			ARRAY_SIZE(s2mu005_fuelgauge_props);
+
+	/* 0x48[7:4]=0010 : EVT2 */
+	fuelgauge->revision = 0;
+	s2mu005_read_reg_byte(fuelgauge->i2c, 0x48, &temp);
+	fuelgauge->revision = (temp & 0xF0) >> 4;
+
+	pr_info("%s: S2MU005 Fuelgauge revision: %d, reg 0x48 = 0x%x\n", __func__, fuelgauge->revision, temp);
+
+	fuelgauge->capacity_max = fuelgauge->pdata->capacity_max;
+	fuelgauge->info.soc = 0;
+	fuelgauge->mode = CURRENT_MODE;
+
+	raw_soc_val.intval = s2mu005_get_rawsoc(fuelgauge);
+	raw_soc_val.intval = raw_soc_val.intval / 10;
+
+	if (raw_soc_val.intval > fuelgauge->capacity_max)
+		s2mu005_fg_calculate_dynamic_scale(fuelgauge, 100);
+
+	s2mu005_init_regs(fuelgauge);
+
+	ret = power_supply_register(&client->dev, &fuelgauge->psy_fg);
+	if (ret) {
+		pr_err("%s: Failed to Register psy_fg\n", __func__);
+		goto err_data_free;
+	}
+
+	fuelgauge->is_fuel_alerted = false;
+	if (fuelgauge->pdata->fuel_alert_soc >= 0) {
+		s2mu005_fuelgauge_fuelalert_init(fuelgauge->i2c,
+					fuelgauge->pdata->fuel_alert_soc);
+		wake_lock_init(&fuelgauge->fuel_alert_wake_lock,
+					WAKE_LOCK_SUSPEND, "fuel_alerted");
+
+		if (fuelgauge->pdata->fg_irq > 0) {
+			INIT_DELAYED_WORK(
+					&fuelgauge->isr_work, s2mu005_fg_isr_work);
+
+			fuelgauge->fg_irq = gpio_to_irq(fuelgauge->pdata->fg_irq);
+			dev_info(&client->dev,
+					"%s : fg_irq = %d\n", __func__, fuelgauge->fg_irq);
+			if (fuelgauge->fg_irq > 0) {
+				ret = request_threaded_irq(fuelgauge->fg_irq,
+						NULL, s2mu005_fg_irq_thread,
+						IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING
+						| IRQF_ONESHOT,
+						"fuelgauge-irq", fuelgauge);
+				if (ret) {
+					dev_err(&client->dev,
+							"%s: Failed to Request IRQ\n", __func__);
+					goto err_supply_unreg;
+				}
+
+				ret = enable_irq_wake(fuelgauge->fg_irq);
+				if (ret < 0)
+					dev_err(&client->dev,
+							"%s: Failed to Enable Wakeup Source(%d)\n",
+							__func__, ret);
+			} else {
+				dev_err(&client->dev, "%s: Failed gpio_to_irq(%d)\n",
+						__func__, fuelgauge->fg_irq);
+				goto err_supply_unreg;
+			}
+		}
+	}
+
+	fuelgauge->sleep_initial_update_of_soc = false;
+	fuelgauge->initial_update_of_soc = true;
+
+	fuelgauge->cc_on = true;
+
+	pr_info("%s: S2MU005 Fuelgauge Driver Loaded\n", __func__);
+	return 0;
+
+err_supply_unreg:
+	power_supply_unregister(&fuelgauge->psy_fg);
+err_data_free:
+	if (client->dev.of_node)
+		kfree(fuelgauge->pdata);
+
+err_parse_dt:
+err_parse_dt_nomem:
+	mutex_destroy(&fuelgauge->fg_lock);
+	kfree(fuelgauge);
+
+	return ret;
+}
+
+static const struct i2c_device_id s2mu005_fuelgauge_id[] = {
+	{"s2mu005-fuelgauge", 0},
+	{}
+};
+
+static void s2mu005_fuelgauge_shutdown(struct i2c_client *client)
+{
+	struct s2mu005_fuelgauge_data *fuelgauge = i2c_get_clientdata(client);
+	u8 temp = 0;
+
+	if(fuelgauge->revision < 2) {
+		s2mu005_read_reg_byte(fuelgauge->i2c, 0x45, &temp);
+		temp &= 0xF0;
+		s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x45, temp);
+		s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x44, 0x00);
+	}
+}
+
+static int s2mu005_fuelgauge_remove(struct i2c_client *client)
+{
+	struct s2mu005_fuelgauge_data *fuelgauge = i2c_get_clientdata(client);
+
+	if (fuelgauge->pdata->fuel_alert_soc >= 0)
+		wake_lock_destroy(&fuelgauge->fuel_alert_wake_lock);
+
+	return 0;
+}
+
+#if defined CONFIG_PM
+static int s2mu005_fuelgauge_suspend(struct device *dev)
+{
+	struct s2mu005_fuelgauge_data *fuelgauge = dev_get_drvdata(dev);
+	u8 temp = 0;
+
+	if(fuelgauge->revision < 2) {
+		if (!fuelgauge->is_charging) {
+			if (fuelgauge->mode == CURRENT_MODE) {
+				s2mu005_read_reg_byte(fuelgauge->i2c, 0x45, &temp);
+				temp &= 0xF0;
+				temp |= 0x06;
+				s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x45, temp);
+
+				s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x44, 0xBD);
+			} else {
+				s2mu005_read_reg_byte(fuelgauge->i2c, 0x45, &temp);
+				temp &= 0xF0;
+				s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x45, temp);
+
+				s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x44, 0x00);
+			}
+
+			s2mu005_read_reg_byte(fuelgauge->i2c, 0x44, &temp);
+			pr_info("%s: Reg set suspend 0x44 : 0x%x\n",
+				__func__, temp);
+			s2mu005_read_reg_byte(fuelgauge->i2c, 0x45, &temp);
+			pr_info("%s: Reg set suspend 0x45 : 0x%x\n",
+				__func__, temp);
+		}
+	}
+	return 0;
+}
+
+static int s2mu005_fuelgauge_resume(struct device *dev)
+{
+	struct s2mu005_fuelgauge_data *fuelgauge = dev_get_drvdata(dev);
+	static int avg_vbat[5] = {0, };
+	static int vbat[5] = {0, };
+	static int avg_current[5] = {100, 100, 100, 100, 100};
+	static int loop_count = 0;
+	int target_ocv = 0, target_soc = 0, temp_vol = 0, j = 0, k = 0;
+	u8 temp = 0;
+
+	if(fuelgauge->revision < 2) {
+		if (fuelgauge->mode == CURRENT_MODE) {
+			avg_current[loop_count] = s2mu005_get_avgcurrent(fuelgauge);
+			avg_vbat[loop_count] =  s2mu005_get_avgvbat(fuelgauge);
+			vbat[loop_count] = s2mu005_get_vbat(fuelgauge);
+
+			if (loop_count++ >= 5) loop_count = 0;
+
+			for (j = 0; j < 5; j++) {
+				pr_info("%s: abs avergae current : %ld\n", __func__, abs(avg_current[j]));
+				if (abs(avg_current[j]) > 30)
+					break;
+			}
+
+			pr_info("%s: avg current count : %d\n", __func__, j);
+			if (j >= 5) {
+				for (k = 0; k < 5; k++) {
+					if (avg_vbat[k] > vbat[k])
+						temp_vol = avg_vbat[k];
+					else
+						temp_vol = vbat[k];
+
+					if (temp_vol > target_ocv)
+						target_ocv = temp_vol;
+				}
+
+				pr_info("%s: target ocv : %d\n", __func__, target_ocv);
+
+				/* work-around for restart */
+				fuelgauge->target_ocv = target_ocv;      /* max( vbat[5], avgvbat[5] ) */
+				target_soc = s2mu005_get_soc_from_ocv(fuelgauge, fuelgauge->target_ocv);
+
+				if( abs(target_soc - fuelgauge->info.soc) > 300 )
+					WA_0_issue_at_init1(fuelgauge, fuelgauge->target_ocv);
+			}
+		}
+
+		if (!fuelgauge->is_charging) {
+			if (fuelgauge->mode == CURRENT_MODE) {
+				s2mu005_read_reg_byte(fuelgauge->i2c, 0x45, &temp);
+				temp &= 0xF0;
+				temp |= 0x07;
+				s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x45, temp);
+
+				s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x44, 0xCC);
+			} else {
+				s2mu005_read_reg_byte(fuelgauge->i2c, 0x45, &temp);
+				temp &= 0xF0;
+				s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x45, temp);
+
+				s2mu005_write_and_verify_reg_byte(fuelgauge->i2c, 0x44, 0x00);
+			}
+		}
+
+		s2mu005_read_reg_byte(fuelgauge->i2c, 0x44, &temp);
+		pr_info("%s: Reg set resume 0x44 : 0x%x\n",
+				__func__, temp);
+		s2mu005_read_reg_byte(fuelgauge->i2c, 0x45, &temp);
+		pr_info("%s: Reg set resume 0x45 : 0x%x\n",
+				__func__, temp);
+	}
+
+	fuelgauge->sleep_initial_update_of_soc = true;
+
+	return 0;
+}
+#else
+#define s2mu005_fuelgauge_suspend NULL
+#define s2mu005_fuelgauge_resume NULL
+#endif
+
+static SIMPLE_DEV_PM_OPS(s2mu005_fuelgauge_pm_ops, s2mu005_fuelgauge_suspend,
+		s2mu005_fuelgauge_resume);
+
+static struct i2c_driver s2mu005_fuelgauge_driver = {
+	.driver = {
+		.name = "s2mu005-fuelgauge",
+		.owner = THIS_MODULE,
+		.pm = &s2mu005_fuelgauge_pm_ops,
+		.of_match_table = s2mu005_fuelgauge_match_table,
+	},
+	.probe  = s2mu005_fuelgauge_probe,
+	.remove = s2mu005_fuelgauge_remove,
+	.shutdown   = s2mu005_fuelgauge_shutdown,
+	.id_table   = s2mu005_fuelgauge_id,
+};
+
+static int __init s2mu005_fuelgauge_init(void)
+{
+	pr_info("%s: S2MU005 Fuelgauge Init\n", __func__);
+	return i2c_add_driver(&s2mu005_fuelgauge_driver);
+}
+
+static void __exit s2mu005_fuelgauge_exit(void)
+{
+	i2c_del_driver(&s2mu005_fuelgauge_driver);
+}
+module_init(s2mu005_fuelgauge_init);
+module_exit(s2mu005_fuelgauge_exit);
+
+MODULE_DESCRIPTION("Samsung S2MU005 Fuel Gauge Driver");
+MODULE_AUTHOR("Samsung Electronics");
+MODULE_LICENSE("GPL");
diff -Naur linux-3.18.14/drivers/battery_v2/sec_adc.c samsung/drivers/battery_v2/sec_adc.c
--- linux-3.18.14/drivers/battery_v2/sec_adc.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/sec_adc.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,190 @@
+/*
+ *  sec_adc.c
+ *  Samsung Mobile Battery Driver
+ *
+ *  Copyright (C) 2012 Samsung Electronics
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "include/sec_adc.h"
+
+struct adc_list {
+	const char*	name;
+	struct iio_channel *channel;
+	bool is_used;
+	int prev_value;
+};
+
+static struct adc_list batt_adc_list[] = {
+	{.name = "adc-cable"},
+	{.name = "adc-bat"},
+	{.name = "adc-temp"},
+	{.name = "adc-temp"},
+	{.name = "adc-full"},
+	{.name = "adc-volt"},
+	{.name = "adc-chg-temp"},
+	{.name = "adc-in-bat"},
+	{.name = "adc-wpc-temp"},
+	{.name = "adc-slave-chg-temp"},
+	{.name = "adc-usb-temp"},
+};
+
+static void sec_bat_adc_ap_init(struct platform_device *pdev)
+{
+	int i = 0;
+	struct iio_channel *temp_adc;
+
+	for (i = 0; i < SEC_BAT_ADC_CHANNEL_NUM; i++) {
+		temp_adc = iio_channel_get(&pdev->dev, batt_adc_list[i].name);
+		batt_adc_list[i].channel = temp_adc;
+		batt_adc_list[i].is_used = !IS_ERR_OR_NULL(temp_adc);
+	}
+}
+
+static int sec_bat_adc_ap_read(int channel)
+{
+	int data = -1;
+	int ret = 0;
+	int retry_cnt = RETRY_CNT;
+
+	if (batt_adc_list[channel].is_used) {
+		do {
+			ret = (batt_adc_list[channel].is_used) ?
+			iio_read_channel_raw(batt_adc_list[channel].channel, &data) : 0;
+			retry_cnt--;
+		} while ((retry_cnt > 0) && (data < 0));
+	}
+
+	if (retry_cnt <= 0) {
+		pr_err("%s: Error in ADC\n", __func__);
+		data = batt_adc_list[channel].prev_value;
+	} else
+		batt_adc_list[channel].prev_value = data;
+
+	return data;
+}
+
+static void sec_bat_adc_ap_exit(void)
+{
+	int i = 0;
+	for (i = 0; i < SEC_BAT_ADC_CHANNEL_NUM; i++) {
+		if (batt_adc_list[i].is_used) {
+			iio_channel_release(batt_adc_list[i].channel);
+		}
+	}
+}
+
+static void sec_bat_adc_none_init(struct platform_device *pdev)
+{
+}
+
+static int sec_bat_adc_none_read(int channel)
+{
+	return 0;
+}
+
+static void sec_bat_adc_none_exit(void)
+{
+}
+
+static void sec_bat_adc_ic_init(struct platform_device *pdev)
+{
+}
+
+static int sec_bat_adc_ic_read(int channel)
+{
+	return 0;
+}
+
+static void sec_bat_adc_ic_exit(void)
+{
+}
+static int adc_read_type(struct sec_battery_info *battery, int channel)
+{
+	int adc = 0;
+
+	switch (battery->pdata->temp_adc_type)
+	{
+	case SEC_BATTERY_ADC_TYPE_NONE :
+		adc = sec_bat_adc_none_read(channel);
+		break;
+	case SEC_BATTERY_ADC_TYPE_AP :
+		adc = sec_bat_adc_ap_read(channel);
+		break;
+	case SEC_BATTERY_ADC_TYPE_IC :
+		adc = sec_bat_adc_ic_read(channel);
+		break;
+	case SEC_BATTERY_ADC_TYPE_NUM :
+		break;
+	default :
+		break;
+	}
+	return adc;
+}
+
+static void adc_init_type(struct platform_device *pdev,
+			  struct sec_battery_info *battery)
+{
+	switch (battery->pdata->temp_adc_type)
+	{
+	case SEC_BATTERY_ADC_TYPE_NONE :
+		sec_bat_adc_none_init(pdev);
+		break;
+	case SEC_BATTERY_ADC_TYPE_AP :
+		sec_bat_adc_ap_init(pdev);
+		break;
+	case SEC_BATTERY_ADC_TYPE_IC :
+		sec_bat_adc_ic_init(pdev);
+		break;
+	case SEC_BATTERY_ADC_TYPE_NUM :
+		break;
+	default :
+		break;
+	}
+}
+
+static void adc_exit_type(struct sec_battery_info *battery)
+{
+	switch (battery->pdata->temp_adc_type)
+	{
+	case SEC_BATTERY_ADC_TYPE_NONE :
+		sec_bat_adc_none_exit();
+		break;
+	case SEC_BATTERY_ADC_TYPE_AP :
+		sec_bat_adc_ap_exit();
+		break;
+	case SEC_BATTERY_ADC_TYPE_IC :
+		sec_bat_adc_ic_exit();
+		break;
+	case SEC_BATTERY_ADC_TYPE_NUM :
+		break;
+	default :
+		break;
+	}
+}
+
+int adc_read(struct sec_battery_info *battery, int channel)
+{
+	int adc = 0;
+
+	adc = adc_read_type(battery, channel);
+
+	dev_dbg(battery->dev, "[%s]adc = %d\n", __func__, adc);
+
+	return adc;
+}
+
+void adc_init(struct platform_device *pdev, struct sec_battery_info *battery)
+{
+	adc_init_type(pdev, battery);
+}
+
+void adc_exit(struct sec_battery_info *battery)
+{
+	adc_exit_type(battery);
+}
+
diff -Naur linux-3.18.14/drivers/battery_v2/sec_battery.c samsung/drivers/battery_v2/sec_battery.c
--- linux-3.18.14/drivers/battery_v2/sec_battery.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/sec_battery.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,10011 @@
+/*
+ *  sec_battery.c
+ *  Samsung Mobile Battery Driver
+ *
+ *  Copyright (C) 2012 Samsung Electronics
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include "include/sec_battery.h"
+#if defined(CONFIG_SEC_ABC)
+#include <linux/sti/abc_common.h>
+#endif
+
+bool sleep_mode = false;
+
+static struct device_attribute sec_battery_attrs[] = {
+	SEC_BATTERY_ATTR(batt_reset_soc),
+	SEC_BATTERY_ATTR(batt_read_raw_soc),
+	SEC_BATTERY_ATTR(batt_read_adj_soc),
+	SEC_BATTERY_ATTR(batt_type),
+	SEC_BATTERY_ATTR(batt_vfocv),
+	SEC_BATTERY_ATTR(batt_vol_adc),
+	SEC_BATTERY_ATTR(batt_vol_adc_cal),
+	SEC_BATTERY_ATTR(batt_vol_aver),
+	SEC_BATTERY_ATTR(batt_vol_adc_aver),
+	SEC_BATTERY_ATTR(batt_current_ua_now),
+	SEC_BATTERY_ATTR(batt_current_ua_avg),
+	SEC_BATTERY_ATTR(batt_filter_cfg),
+	SEC_BATTERY_ATTR(batt_temp),
+	SEC_BATTERY_ATTR(batt_temp_adc),
+	SEC_BATTERY_ATTR(batt_temp_aver),
+	SEC_BATTERY_ATTR(batt_temp_adc_aver),
+	SEC_BATTERY_ATTR(usb_temp),
+	SEC_BATTERY_ATTR(usb_temp_adc),
+	SEC_BATTERY_ATTR(chg_temp),
+	SEC_BATTERY_ATTR(chg_temp_adc),
+	SEC_BATTERY_ATTR(slave_chg_temp),
+	SEC_BATTERY_ATTR(slave_chg_temp_adc),
+
+	SEC_BATTERY_ATTR(batt_vf_adc),
+	SEC_BATTERY_ATTR(batt_slate_mode),
+
+	SEC_BATTERY_ATTR(batt_lp_charging),
+	SEC_BATTERY_ATTR(siop_activated),
+	SEC_BATTERY_ATTR(siop_level),
+	SEC_BATTERY_ATTR(siop_event),
+	SEC_BATTERY_ATTR(batt_charging_source),
+	SEC_BATTERY_ATTR(fg_reg_dump),
+	SEC_BATTERY_ATTR(fg_reset_cap),
+	SEC_BATTERY_ATTR(fg_capacity),
+	SEC_BATTERY_ATTR(fg_asoc),
+	SEC_BATTERY_ATTR(auth),
+	SEC_BATTERY_ATTR(chg_current_adc),
+	SEC_BATTERY_ATTR(wc_adc),
+	SEC_BATTERY_ATTR(wc_status),
+	SEC_BATTERY_ATTR(wc_enable),
+	SEC_BATTERY_ATTR(wc_control),
+	SEC_BATTERY_ATTR(wc_control_cnt),
+	SEC_BATTERY_ATTR(hv_charger_status),
+	SEC_BATTERY_ATTR(hv_wc_charger_status),
+	SEC_BATTERY_ATTR(hv_charger_set),
+	SEC_BATTERY_ATTR(factory_mode),
+	SEC_BATTERY_ATTR(store_mode),
+	SEC_BATTERY_ATTR(update),
+	SEC_BATTERY_ATTR(test_mode),
+
+	SEC_BATTERY_ATTR(call),
+	SEC_BATTERY_ATTR(2g_call),
+	SEC_BATTERY_ATTR(talk_gsm),
+	SEC_BATTERY_ATTR(3g_call),
+	SEC_BATTERY_ATTR(talk_wcdma),
+	SEC_BATTERY_ATTR(music),
+	SEC_BATTERY_ATTR(video),
+	SEC_BATTERY_ATTR(browser),
+	SEC_BATTERY_ATTR(hotspot),
+	SEC_BATTERY_ATTR(camera),
+	SEC_BATTERY_ATTR(camcorder),
+	SEC_BATTERY_ATTR(data_call),
+	SEC_BATTERY_ATTR(wifi),
+	SEC_BATTERY_ATTR(wibro),
+	SEC_BATTERY_ATTR(lte),
+	SEC_BATTERY_ATTR(lcd),
+	SEC_BATTERY_ATTR(gps),
+	SEC_BATTERY_ATTR(event),
+	SEC_BATTERY_ATTR(batt_temp_table),
+	SEC_BATTERY_ATTR(batt_high_current_usb),
+#if defined(CONFIG_SAMSUNG_BATTERY_ENG_TEST)
+	SEC_BATTERY_ATTR(test_charge_current),
+#endif
+	SEC_BATTERY_ATTR(set_stability_test),
+	SEC_BATTERY_ATTR(batt_capacity_max),
+	SEC_BATTERY_ATTR(batt_inbat_voltage),
+	SEC_BATTERY_ATTR(batt_inbat_voltage_ocv),
+	SEC_BATTERY_ATTR(batt_inbat_voltage_adc),
+	SEC_BATTERY_ATTR(check_slave_chg),
+	SEC_BATTERY_ATTR(batt_inbat_wireless_cs100),
+	SEC_BATTERY_ATTR(hmt_ta_connected),
+	SEC_BATTERY_ATTR(hmt_ta_charge),
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	SEC_BATTERY_ATTR(fg_cycle),
+	SEC_BATTERY_ATTR(fg_full_voltage),
+	SEC_BATTERY_ATTR(fg_fullcapnom),
+	SEC_BATTERY_ATTR(battery_cycle),
+#if defined(CONFIG_BATTERY_AGE_FORECAST_DETACHABLE)
+        SEC_BATTERY_ATTR(batt_after_manufactured),
+#endif
+#endif
+#if defined(CONFIG_DCM_JPN_CONCEPT_FG_CYCLE_CHECK)
+	SEC_BATTERY_ATTR(fg_cycle_check_value),
+#endif
+	SEC_BATTERY_ATTR(batt_wpc_temp),
+	SEC_BATTERY_ATTR(batt_wpc_temp_adc),
+#if defined(CONFIG_WIRELESS_FIRMWARE_UPDATE)
+	SEC_BATTERY_ATTR(batt_wireless_firmware_update),
+	SEC_BATTERY_ATTR(otp_firmware_result),
+	SEC_BATTERY_ATTR(wc_ic_grade),
+	SEC_BATTERY_ATTR(otp_firmware_ver_bin),
+	SEC_BATTERY_ATTR(otp_firmware_ver),
+	SEC_BATTERY_ATTR(tx_firmware_result),
+	SEC_BATTERY_ATTR(tx_firmware_ver),
+	SEC_BATTERY_ATTR(batt_tx_status),
+#endif
+	SEC_BATTERY_ATTR(wc_vout),
+	SEC_BATTERY_ATTR(wc_vrect),
+	SEC_BATTERY_ATTR(batt_hv_wireless_status),
+	SEC_BATTERY_ATTR(batt_hv_wireless_pad_ctrl),
+	SEC_BATTERY_ATTR(wc_op_freq),
+	SEC_BATTERY_ATTR(wc_cmd_info),
+	SEC_BATTERY_ATTR(batt_tune_float_voltage),
+	SEC_BATTERY_ATTR(batt_tune_input_charge_current),
+	SEC_BATTERY_ATTR(batt_tune_fast_charge_current),
+	SEC_BATTERY_ATTR(batt_tune_ui_term_cur_1st),
+	SEC_BATTERY_ATTR(batt_tune_ui_term_cur_2nd),
+	SEC_BATTERY_ATTR(batt_tune_temp_high_normal),
+	SEC_BATTERY_ATTR(batt_tune_temp_high_rec_normal),
+	SEC_BATTERY_ATTR(batt_tune_temp_low_normal),
+	SEC_BATTERY_ATTR(batt_tune_temp_low_rec_normal),
+	SEC_BATTERY_ATTR(batt_tune_chg_temp_high),
+	SEC_BATTERY_ATTR(batt_tune_chg_temp_rec),
+	SEC_BATTERY_ATTR(batt_tune_chg_limit_cur),
+	SEC_BATTERY_ATTR(batt_tune_coil_temp_high),
+	SEC_BATTERY_ATTR(batt_tune_coil_temp_rec),
+	SEC_BATTERY_ATTR(batt_tune_coil_limit_cur),
+#if defined(CONFIG_UPDATE_BATTERY_DATA)
+	SEC_BATTERY_ATTR(batt_update_data),
+#endif
+	SEC_BATTERY_ATTR(batt_misc_event),
+	SEC_BATTERY_ATTR(batt_ext_dev_chg),
+	SEC_BATTERY_ATTR(cisd_fullcaprep_max),
+#if defined(CONFIG_BATTERY_CISD)	
+	SEC_BATTERY_ATTR(cisd_data),
+	SEC_BATTERY_ATTR(cisd_data_json),
+	SEC_BATTERY_ATTR(cisd_wire_count),
+	SEC_BATTERY_ATTR(cisd_data_efs_path),
+#endif	
+	SEC_BATTERY_ATTR(batt_wdt_control),
+	SEC_BATTERY_ATTR(batt_swelling_control),
+	SEC_BATTERY_ATTR(safety_timer_set),
+	SEC_BATTERY_ATTR(safety_timer_info),
+	SEC_BATTERY_ATTR(mode),
+	SEC_BATTERY_ATTR(check_ps_ready),
+	SEC_BATTERY_ATTR(factory_mode_relieve),
+	SEC_BATTERY_ATTR(factory_mode_bypass),
+	SEC_BATTERY_ATTR(normal_mode_bypass),
+	SEC_BATTERY_ATTR(factory_voltage_regulation),
+	SEC_BATTERY_ATTR(factory_mode_disable),
+	SEC_BATTERY_ATTR(batt_present),
+};
+
+static enum power_supply_property sec_battery_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_CHARGE_TYPE,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_VOLTAGE_AVG,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CURRENT_AVG,
+	POWER_SUPPLY_PROP_CHARGE_NOW,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_TEMP_AMBIENT,
+#if defined(CONFIG_CALC_TIME_TO_FULL)
+	POWER_SUPPLY_PROP_TIME_TO_FULL_NOW,
+#endif
+#if defined(CONFIG_BATTERY_SWELLING)
+	POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT,
+#endif
+	POWER_SUPPLY_PROP_CHARGE_COUNTER_SHADOW,
+	POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL,
+	POWER_SUPPLY_PROP_CHARGE_UNO_CONTROL,
+};
+
+static enum power_supply_property sec_wireless_props[] = {
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_PRESENT,
+};
+
+static enum power_supply_property sec_power_props[] = {
+	POWER_SUPPLY_PROP_ONLINE,
+};
+
+static enum power_supply_property sec_ac_props[] = {
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_TEMP,
+};
+
+static enum power_supply_property sec_ps_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_ONLINE,
+};
+
+static char *supply_list[] = {
+	"battery",
+};
+
+char *sec_bat_charging_mode_str[] = {
+	"None",
+	"Normal",
+	"Additional",
+	"Re-Charging",
+	"ABS"
+};
+
+char *sec_bat_status_str[] = {
+	"Unknown",
+	"Charging",
+	"Discharging",
+	"Not-charging",
+	"Full"
+};
+
+char *sec_bat_health_str[] = {
+	"Unknown",
+	"Good",
+	"Overheat",
+	"Warm",
+	"Dead",
+	"OverVoltage",
+	"UnspecFailure",
+	"Cold",
+	"Cool",
+	"WatchdogTimerExpire",
+	"SafetyTimerExpire",
+	"UnderVoltage",
+	"OverheatLimit",
+	"VsysOVP",
+	"VbatOVP",
+};
+
+static int sec_bat_set_charge(
+				struct sec_battery_info *battery,
+				int chg_mode);
+
+
+static void sec_bat_set_misc_event(struct sec_battery_info *battery,
+	const int misc_event_type, bool do_clear) {
+
+	int xor_misc_event;
+
+	mutex_lock(&battery->misclock);
+	pr_info("%s: %s misc event(now=0x%x, value=0x%x)\n",
+		__func__, ((do_clear) ? "clear" : "set"), battery->misc_event, misc_event_type);
+	if (do_clear) {
+		battery->misc_event &= ~misc_event_type;
+	} else {
+		battery->misc_event |= misc_event_type;
+	}
+	
+	if (battery->prev_misc_event != battery->misc_event) {
+		xor_misc_event = battery->prev_misc_event ^ battery->misc_event;
+
+		if ((xor_misc_event & (BATT_MISC_EVENT_UNDEFINED_RANGE_TYPE | BATT_MISC_EVENT_UNDEFINED_RANGE_POGO)) &&
+			(battery->cable_type == POWER_SUPPLY_TYPE_BATTERY)) {
+			if (battery->misc_event & (BATT_MISC_EVENT_UNDEFINED_RANGE_TYPE | BATT_MISC_EVENT_UNDEFINED_RANGE_POGO)) {
+				sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_BUCK_OFF);
+			} else if (battery->prev_misc_event & (BATT_MISC_EVENT_UNDEFINED_RANGE_TYPE | BATT_MISC_EVENT_UNDEFINED_RANGE_POGO)) {
+				sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING_OFF);
+			}
+		}
+
+		pr_info("%s: change misc event(0x%x --> 0x%x)\n",
+			__func__, battery->prev_misc_event, battery->misc_event);
+		battery->prev_misc_event = battery->misc_event;
+		
+		wake_lock(&battery->monitor_wake_lock);
+		queue_delayed_work(battery->monitor_wqueue, &battery->monitor_work, 0);
+	}
+	mutex_unlock(&battery->misclock);
+}
+
+
+static void sec_bat_set_current_event(struct sec_battery_info *battery,
+	const int current_event_type, bool do_clear) {
+	mutex_lock(&battery->current_eventlock);
+	pr_info("%s: %s current event(now=0x%x, value=0x%x)\n",
+		__func__, ((do_clear) ? "clear" : "set"), battery->current_event, current_event_type);
+	if (do_clear) {
+		battery->current_event &= ~current_event_type;
+	} else {
+		battery->current_event |= current_event_type;
+	}
+	mutex_unlock(&battery->current_eventlock);
+}
+
+static void sec_bat_change_default_current(struct sec_battery_info *battery,
+					int cable_type, int input, int output)
+{
+	battery->pdata->charging_current[cable_type].input_current_limit = input;
+	battery->pdata->charging_current[cable_type].fast_charging_current = output;
+	pr_info("%s: cable_type: %d input: %d output: %d\n",__func__, cable_type, input, output);
+}
+
+static int sec_bat_get_wireless_current(struct sec_battery_info *battery, int incurr)
+{
+	/* 1. SIOP EVENT */
+	if (battery->siop_event & SIOP_EVENT_WPC_CALL &&
+			(battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK ||
+			battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK_TA)) {
+		if (battery->capacity >= battery->pdata->wireless_cc_cv) {
+			if (incurr > battery->pdata->siop_call_cv_current)
+				incurr = battery->pdata->siop_call_cv_current;
+		} else {
+			if (incurr > battery->pdata->siop_call_cc_current)
+				incurr = battery->pdata->siop_call_cc_current;
+		}
+	}
+
+	/* 2. WPC_SLEEP_MODE */
+	if (is_hv_wireless_type(battery->cable_type) && sleep_mode) {
+		if (incurr > battery->pdata->sleep_mode_limit_current)
+			incurr = battery->pdata->sleep_mode_limit_current;
+		pr_info("%s sleep_mode =%d, chg_limit =%d, in_curr = %d \n", __func__,
+			sleep_mode, battery->chg_limit, incurr);
+	}
+
+	/* 3. WPC_TEMP_MODE */
+	if (is_wireless_type(battery->cable_type) && battery->chg_limit &&
+		(incurr > battery->pdata->wpc_charging_limit_current[battery->chg_limit - 1]))
+		incurr = battery->pdata->wpc_charging_limit_current[battery->chg_limit - 1];
+
+	/* 4. WPC_CV_MODE */
+	if (battery->wc_cv_mode) {
+		if (battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS ||
+		    battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_STAND ||
+		    battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK_TA) {
+			if (incurr > battery->pdata->wc_cv_current)
+				incurr = battery->pdata->wc_cv_current;
+		} else if (battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK) {
+			if (incurr > battery->pdata->wc_cv_pack_current)
+				incurr = battery->pdata->wc_cv_pack_current;
+		}
+	}
+
+	/* 5. Full-Additional state */
+	if (battery->status == POWER_SUPPLY_STATUS_FULL && battery->charging_mode == SEC_BATTERY_CHARGING_2ND) {
+		if (incurr > battery->pdata->siop_hv_wireless_input_limit_current)
+			incurr = battery->pdata->siop_hv_wireless_input_limit_current;
+	}
+
+	/* 6. Full-None state && SIOP_LEVEL 100 */
+	if (battery->siop_level == 100 &&
+		battery->status == POWER_SUPPLY_STATUS_FULL && battery->charging_mode == SEC_BATTERY_CHARGING_NONE) {
+		incurr = battery->pdata->wc_full_input_limit_current;
+	}
+
+	return incurr;
+}
+
+static void sec_bat_get_charging_current_by_siop(struct sec_battery_info *battery,
+		int *input_current, int *charging_current) {
+	int usb_charging_current = battery->pdata->charging_current[POWER_SUPPLY_TYPE_USB].fast_charging_current;
+	if (battery->siop_level == 3) {
+		/* side sync scenario : siop_level 3 */
+		if (is_nv_wireless_type(battery->cable_type)) {
+			if (*input_current > battery->pdata->siop_wireless_input_limit_current)
+				*input_current = battery->pdata->siop_wireless_input_limit_current;
+			*charging_current = battery->pdata->siop_wireless_charging_limit_current;
+		} else if (is_hv_wireless_type(battery->cable_type)) {
+			if (*input_current > battery->pdata->siop_hv_wireless_input_limit_current)
+				*input_current = battery->pdata->siop_hv_wireless_input_limit_current;
+			*charging_current = battery->pdata->siop_hv_wireless_charging_limit_current;
+		} else if (is_hv_wire_type(battery->cable_type)) {
+			if (*input_current > 450)
+				*input_current = 450;
+			*charging_current = battery->pdata->siop_hv_charging_limit_current;
+#if defined(CONFIG_CCIC_NOTIFIER)
+		} else if (battery->cable_type == POWER_SUPPLY_TYPE_PDIC) {
+			if (*input_current > (4000 / battery->input_voltage))
+				*input_current = 4000 / battery->input_voltage;
+			*charging_current = battery->pdata->siop_hv_charging_limit_current;
+#endif
+		} else {
+			if (*input_current > 800)
+				*input_current = 800;
+			*charging_current = battery->pdata->charging_current[
+				battery->cable_type].fast_charging_current;
+			if (*charging_current > battery->pdata->siop_charging_limit_current)
+				*charging_current = battery->pdata->siop_charging_limit_current;
+		}
+	} else if (battery->siop_level == 5) {
+		/* special senario : calling or browsing during wired charging */
+		if (is_hv_wire_type(battery->cable_type)) {
+			if (battery->cable_type == POWER_SUPPLY_TYPE_HV_MAINS_12V)
+				*input_current = 440;
+			else
+				*input_current = 600;
+			*charging_current = 900;
+		} else if (battery->cable_type == POWER_SUPPLY_TYPE_MAINS ||
+			battery->cable_type == POWER_SUPPLY_TYPE_HV_MAINS_CHG_LIMIT) {
+			*input_current = 1000;
+			*charging_current = 900;
+		}
+	} else if (battery->siop_level < 100) {
+		int max_charging_current;
+
+		if (is_wireless_type(battery->cable_type)) {
+			/* decrease the charging current according to siop level */
+			*charging_current = *charging_current * battery->siop_level / 100;
+
+			/* do forced set charging current */
+			if (*charging_current > 0 && *charging_current < usb_charging_current)
+				*charging_current = usb_charging_current;
+
+			/* if siop level is 0, set minimum charging current from dt */
+			if (battery->siop_level == 0 && 
+				battery->pdata->minimum_charging_current_by_siop_0 > 0){
+				pr_info("%s: set minimum charging current(%d) when siop level is 0\n", __func__, battery->pdata->minimum_charging_current_by_siop_0);
+				*charging_current = battery->pdata->minimum_charging_current_by_siop_0;
+			}
+		} else {
+			max_charging_current = 1800; /* 1 step(70) */
+
+			/* do forced set charging current */
+			if (*charging_current > max_charging_current)
+				*charging_current = max_charging_current;
+		}
+
+		if (is_nv_wireless_type(battery->cable_type)) {
+			if (*input_current > battery->pdata->siop_wireless_input_limit_current)
+				*input_current = battery->pdata->siop_wireless_input_limit_current;
+			if (*charging_current > battery->pdata->siop_wireless_charging_limit_current)
+				*charging_current = battery->pdata->siop_wireless_charging_limit_current;
+		} else if (is_hv_wireless_type(battery->cable_type)) {
+			if (*input_current > battery->pdata->siop_hv_wireless_input_limit_current)
+				*input_current = battery->pdata->siop_hv_wireless_input_limit_current;
+			if (*charging_current > battery->pdata->siop_hv_wireless_charging_limit_current)
+				*charging_current = battery->pdata->siop_hv_wireless_charging_limit_current;
+		} else if (is_hv_wire_type(battery->cable_type)) {
+			if (is_hv_wire_12v_type(battery->cable_type)) {
+				if (*input_current > battery->pdata->siop_hv_12v_input_limit_current)
+					*input_current = battery->pdata->siop_hv_12v_input_limit_current;
+			} else {
+				if (*input_current > battery->pdata->siop_hv_input_limit_current)
+					*input_current = battery->pdata->siop_hv_input_limit_current;
+			}
+#if defined(CONFIG_CCIC_NOTIFIER)
+		} else if (battery->cable_type == POWER_SUPPLY_TYPE_PDIC) {
+			if (*input_current > (6000 / battery->input_voltage))
+				*input_current = 6000 / battery->input_voltage;
+#endif
+		} else {
+			if (*input_current > battery->pdata->siop_input_limit_current)
+				*input_current = battery->pdata->siop_input_limit_current;
+		}
+	}
+}
+
+
+#if !defined(CONFIG_SEC_FACTORY)
+static int sec_bat_check_mix_temp(struct sec_battery_info *battery, int input_current)
+{
+	if (battery->pdata->chg_temp_check && battery->siop_level >= 100 && is_not_wireless_type(battery->cable_type)) {
+		if ((!battery->mix_limit &&
+				(battery->temperature > battery->pdata->mix_high_temp) &&
+				(battery->chg_temp > battery->pdata->mix_high_chg_temp)) ||
+			(battery->mix_limit &&
+				(battery->temperature >= battery->pdata->mix_high_temp_recovery))) {
+			int max_input_current =
+				battery->pdata->charging_current[battery->cable_type].full_check_current_1st + 50;
+
+			/* input current = float voltage * (topoff_current_1st + 50mA(margin)) / (vbus_level * 0.9) */
+#if defined(CONFIG_HUNDREDMICRO_PRECISION_FG)
+			input_current = (((battery->pdata->chg_float_voltage / 10) * max_input_current) /
+				(battery->input_voltage * 90)) / 10;
+#else
+			input_current = (((battery->pdata->chg_float_voltage) * max_input_current) /
+				(battery->input_voltage * 90)) / 10;
+#endif
+			if (input_current > max_input_current)
+				input_current = max_input_current;
+
+			battery->mix_limit = true;
+			/* skip other heating control */
+			sec_bat_set_current_event(battery, SEC_BAT_CURRENT_EVENT_SKIP_HEATING_CONTROL, 0);
+		} else if (battery->mix_limit) {
+			battery->mix_limit = false;
+		}
+
+		pr_info("%s: mix_limit(%d), temp(%d), chg_temp(%d), input_current(%d)\n",
+			__func__, battery->mix_limit, battery->temperature, battery->chg_temp, input_current);
+	} else {
+		battery->mix_limit = false;
+	}
+	return input_current;
+}
+
+static int sec_bat_chg_temperature_check(struct sec_battery_info *battery,
+	int input_current)
+{
+	if (!battery->pdata->chg_temp_check)
+		return input_current;
+
+	if ((battery->siop_level >= 100) &&
+			!battery->mix_limit) {
+		if (!battery->chg_limit &&
+				(battery->chg_temp > battery->pdata->chg_high_temp) &&
+				is_hv_wire_type(battery->cable_type)) {
+			battery->chg_limit = true;
+			if (battery->input_current > battery->pdata->chg_charging_limit_current) {
+				input_current = battery->pdata->chg_charging_limit_current;
+				dev_info(battery->dev,"%s: Chg current is reduced by Temp: %d\n",
+						__func__, battery->chg_temp);
+			}
+		} else if (!battery->chg_limit &&
+				(battery->chg_temp > battery->pdata->chg_high_temp) &&
+				(battery->max_charge_power >= (battery->base_charge_power - 500))) {
+			battery->chg_limit = true;
+			if (battery->input_current > battery->pdata->default_input_current) {
+				input_current = battery->pdata->default_input_current;
+				dev_info(battery->dev,"%s: Chg current is reduced by Temp(power): %d\n",
+						__func__, battery->chg_temp);
+			}				
+		} else if (battery->chg_limit &&
+				(battery->chg_temp < battery->pdata->chg_high_temp_recovery) &&
+				(is_hv_wire_type(battery->cable_type) ||
+				(battery->max_charge_power >= (battery->base_charge_power - 500)))) {
+			battery->chg_limit = false;
+			input_current = battery->pdata->charging_current
+				[battery->cable_type].input_current_limit;
+			dev_info(battery->dev,"%s: Chg current is recovered by Temp: %d\n",
+					__func__, battery->chg_temp);
+		} else if (battery->chg_limit &&
+				(battery->chg_temp > battery->pdata->chg_high_temp) &&
+				(is_hv_wire_type(battery->cable_type) ||
+				(battery->max_charge_power >= (battery->base_charge_power - 500)))) {
+			input_current = battery->pdata->chg_charging_limit_current;
+		}
+	}
+	pr_info("%s: cable_type(%d), chg_limit(%d)\n", __func__,
+			battery->cable_type, battery->chg_limit);
+	return input_current;
+}
+
+static int sec_bat_check_wpc_temp(struct sec_battery_info *battery, int input_current)
+{
+	if (battery->pdata->wpc_temp_check && is_wireless_type(battery->cable_type)) {
+		union power_supply_propval value;
+		int wpc_vout_level = WIRELESS_VOUT_9V;
+
+		if (battery->siop_level >= 100) {
+			unsigned int chg_limit_index = battery->chg_limit;
+
+			if ((chg_limit_index < battery->pdata->wpc_high_temp_size) &&
+				(battery->wpc_temp > battery->pdata->wpc_high_temp[chg_limit_index])) {
+				do {
+					pr_info("%s: TRIGGER - chg_limit_index(%d), wpc_high_temp(%d)\n",
+						__func__, chg_limit_index, battery->pdata->wpc_high_temp[chg_limit_index]);
+					chg_limit_index++;
+				} while ((chg_limit_index < battery->pdata->wpc_high_temp_size) &&
+					(battery->wpc_temp > battery->pdata->wpc_high_temp[chg_limit_index]));
+			} else if ((chg_limit_index) &&
+				(battery->wpc_temp < battery->pdata->wpc_high_temp_recovery[chg_limit_index - 1])) {
+				do {
+					pr_info("%s: RELEASE - chg_limit_index(%d), wpc_high_temp_recovery(%d)\n",
+						__func__, chg_limit_index, battery->pdata->wpc_high_temp_recovery[chg_limit_index - 1]);
+					chg_limit_index--;
+				} while ((chg_limit_index) &&
+					(battery->wpc_temp < battery->pdata->wpc_high_temp_recovery[chg_limit_index - 1]));
+			}
+
+			input_current = (!chg_limit_index) ? input_current :
+				battery->pdata->wpc_charging_limit_current[chg_limit_index - 1];
+			battery->chg_limit = chg_limit_index;
+		} else {
+			if (is_hv_wireless_type(battery->cable_type)) {
+				if ((!battery->chg_limit &&	battery->wpc_temp > battery->pdata->wpc_lcd_on_high_temp) ||
+					(battery->chg_limit && battery->wpc_temp >= battery->pdata->wpc_lcd_on_high_temp_rec)) {
+					input_current = battery->pdata->wpc_hv_lcd_on_input_limit_current;
+					battery->chg_limit = true;
+					wpc_vout_level = (battery->capacity < 95) ? WIRELESS_VOUT_5V : WIRELESS_VOUT_9V;
+				} else if (battery->chg_limit) {
+					battery->chg_limit = false;
+				}
+			}
+		}
+
+		if (is_hv_wireless_type(battery->cable_type) &&	wpc_vout_level != battery->wpc_vout_level) {
+			battery->wpc_vout_level = wpc_vout_level;
+			value.intval = wpc_vout_level;
+			psy_do_property(battery->pdata->wireless_charger_name, set,
+						POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+			pr_info("%s: change vout level(%d)",
+				__func__, battery->wpc_vout_level);
+		}
+		pr_info("%s: change input_current(%d), chg_limit(%d), wpc_temp(%d)\n",
+			__func__, input_current, battery->chg_limit, battery->wpc_temp);
+	}
+
+	return input_current;
+}
+
+#if defined(CONFIG_HV_MUIC_VOLTAGE_CTRL) || defined(CONFIG_SUPPORT_QC30)
+extern int muic_afc_set_voltage(int vol);	
+#endif
+static int sec_bat_check_afc_temp(struct sec_battery_info *battery, int input_current)
+{
+	if (!battery->pdata->chg_temp_check)
+		return input_current;
+
+	if (battery->siop_level >= 100) {
+#if defined(CONFIG_HV_MUIC_VOLTAGE_CTRL) || defined(CONFIG_SUPPORT_QC30)
+		union power_supply_propval value;
+		if (is_hv_wire_type(battery->cable_type) || battery->cable_type == POWER_SUPPLY_TYPE_HV_MAINS_CHG_LIMIT) {
+			switch (battery->cable_type) {
+			case POWER_SUPPLY_TYPE_HV_MAINS:
+			case POWER_SUPPLY_TYPE_HV_ERR:
+			case POWER_SUPPLY_TYPE_HV_QC20:
+				if (!battery->chg_limit && battery->chg_temp > battery->pdata->chg_high_temp) {
+					/* set prepare afc current */
+					input_current = battery->pdata->pre_afc_input_current;
+					value.intval = input_current;					
+					psy_do_property(battery->pdata->charger_name, set,
+						POWER_SUPPLY_PROP_CURRENT_MAX, value);
+					battery->input_current = input_current;
+					/* vbus level : 9V --> 5V */
+					battery->chg_limit_recovery_cable = battery->cable_type;
+					muic_afc_set_voltage(SEC_INPUT_VOLTAGE_5V);
+					battery->chg_limit = true;
+				}
+				break;
+			case POWER_SUPPLY_TYPE_HV_MAINS_CHG_LIMIT:
+				if (battery->chg_limit && ((battery->chg_temp < battery->pdata->chg_high_temp_recovery) || battery->vbus_chg_by_siop)) {
+					/* set prepare afc current */
+					input_current = battery->pdata->pre_afc_input_current;
+					value.intval = input_current;
+					psy_do_property(battery->pdata->charger_name, set,
+						POWER_SUPPLY_PROP_CURRENT_MAX, value);
+					battery->input_current = input_current;
+					/* vbus level : 5V --> 9V */
+					if (battery->chg_limit_recovery_cable == POWER_SUPPLY_TYPE_HV_MAINS_12V) {
+						muic_afc_set_voltage(SEC_INPUT_VOLTAGE_12V);
+					} else {
+						muic_afc_set_voltage(SEC_INPUT_VOLTAGE_9V);
+					}
+					battery->chg_limit = battery->vbus_chg_by_siop = false;
+					/* set current event */
+					sec_bat_set_current_event(battery, SEC_BAT_CURRENT_EVENT_AFC, 0);
+				}
+				break;
+			case POWER_SUPPLY_TYPE_HV_MAINS_12V:
+			case POWER_SUPPLY_TYPE_HV_QC30:
+				if (!battery->chg_limit && battery->chg_temp > battery->pdata->chg_12v_high_temp) {
+					/* set prepare afc current */
+					input_current = battery->pdata->pre_afc_input_current;
+					value.intval = input_current;
+					psy_do_property(battery->pdata->charger_name, set,
+						POWER_SUPPLY_PROP_CURRENT_MAX, value);
+					battery->input_current = input_current;					
+					/* vbus level : 12V --> 5V */
+					battery->chg_limit_recovery_cable = POWER_SUPPLY_TYPE_HV_MAINS;
+					muic_afc_set_voltage(SEC_INPUT_VOLTAGE_5V);
+					battery->chg_limit = true;
+				}
+				break;
+			}
+		}
+#endif
+		pr_info("%s: cable_type(%d), chg_limit(%d)\n", __func__, battery->cable_type, battery->chg_limit);
+#if defined(CONFIG_HV_MUIC_VOLTAGE_CTRL) || defined(CONFIG_SUPPORT_QC30)
+	} else if (!battery->chg_limit && is_hv_wire_type(battery->cable_type) && (battery->cable_type != POWER_SUPPLY_TYPE_HV_QC30)) {	
+			union power_supply_propval value;
+			battery->chg_limit_recovery_cable = battery->cable_type;
+			/* set prepare afc current */
+			input_current = battery->pdata->pre_afc_input_current;
+			value.intval = input_current;
+			psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_CURRENT_MAX, value);
+			battery->input_current = input_current;			
+			/* vbus level : 9V --> 5V */
+			muic_afc_set_voltage(SEC_INPUT_VOLTAGE_5V);
+			battery->chg_limit = battery->vbus_chg_by_siop = true;
+			pr_info("%s: vbus set 5V by siop(recovery cable: %d)\n", __func__,battery->chg_limit_recovery_cable);
+#endif
+	}
+
+	return input_current;
+}
+
+#if defined(CONFIG_CCIC_NOTIFIER)
+extern void select_pdo(int num);
+static int sec_bat_check_pdic_temp(struct sec_battery_info *battery, int input_current)
+{
+	if (battery->pdic_ps_rdy && battery->pdata->chg_temp_check &&
+		battery->siop_level >= 100 && battery->cable_type == POWER_SUPPLY_TYPE_PDIC) {
+
+		struct sec_bat_pdic_list *pd_list = &battery->pd_list;
+		int pd_index = pd_list->now_pd_index;
+
+		if (!battery->chg_limit) {
+			if (battery->chg_temp > battery->pdata->chg_high_temp) {
+				battery->chg_limit = true;
+				pd_index--;
+			} else
+				pd_index++;
+		} else {
+			if (battery->chg_temp < battery->pdata->chg_high_temp_recovery)
+				battery->chg_limit = false;
+			else if (battery->chg_temp > battery->pdata->chg_high_temp)
+				pd_index--;
+		}
+
+		if (pd_index < 0) {
+			if (battery->chg_limit) {
+				input_current = (input_current > (10000 / (pd_list->pd_info[0].input_voltage / 1000))) ?
+					(10000 / (pd_list->pd_info[0].input_voltage / 1000)) : input_current;
+				pd_index = -1;
+			} else {
+				pd_index = 0;
+			}
+			pd_list->now_pd_index = pd_index;
+		} else {
+			pd_index = 
+				(pd_index >= pd_list->max_pd_count) ? (pd_list->max_pd_count - 1) : pd_index;
+
+			if (pd_list->now_pd_index != pd_index) {
+				/* change input current */
+				input_current = (pd_list->pd_info[pd_index].input_current < input_current) ?
+					pd_list->pd_info[pd_index].input_current : input_current;
+				/* select next pdo */
+				battery->pdic_ps_rdy = false;
+				select_pdo(pd_list->pd_info[pd_index].pdo_index);
+				pr_info("%s: change pd_list - index: %d, pdo_index: %d\n",
+					__func__, pd_index, pd_list->pd_info[pd_index].pdo_index);
+			}
+		}
+		pr_info("%s: pd_index(%d), input_current(%d), chg_limit(%d)\n",
+			__func__, pd_index, input_current, battery->chg_limit);
+	}
+
+	return input_current;
+}
+#endif
+#endif
+
+static int sec_bat_check_afc_input_current(struct sec_battery_info *battery, int input_current)
+{
+	if (battery->current_event & SEC_BAT_CURRENT_EVENT_AFC) {
+		int work_delay;
+
+		if (battery->cable_type == POWER_SUPPLY_TYPE_MAINS ||
+			battery->cable_type == POWER_SUPPLY_TYPE_HV_MAINS_CHG_LIMIT) {
+			input_current = battery->pdata->pre_afc_input_current; // 1000mA
+			work_delay = battery->pdata->pre_afc_work_delay;
+		} else {
+			input_current = battery->pdata->pre_wc_afc_input_current; // 480mA
+			work_delay = 4000; /* do not reduce this time, this is for noble pad */
+		}
+
+		wake_lock(&battery->afc_wake_lock);
+		cancel_delayed_work(&battery->afc_work);
+		queue_delayed_work(battery->monitor_wqueue,
+			&battery->afc_work , msecs_to_jiffies(work_delay));
+
+		pr_info("%s: change input_current(%d), cable_type(%d)\n", __func__, input_current, battery->cable_type);
+	}
+
+	return input_current;
+}
+
+#if defined(CONFIG_CCIC_NOTIFIER)
+static void sec_bat_get_input_current_in_power_list(struct sec_battery_info *battery)
+{
+	int min_input_current = battery->pdata->charging_current[POWER_SUPPLY_TYPE_BATTERY].input_current_limit;
+	int pdo_num = battery->pdic_info.sink_status.current_pdo_num;
+	int max_input_current = 0;
+
+	max_input_current = battery->pdic_info.sink_status.power_list[pdo_num].max_current > min_input_current ?
+		battery->pdic_info.sink_status.power_list[pdo_num].max_current : min_input_current;
+	battery->pdata->charging_current[POWER_SUPPLY_TYPE_PDIC].input_current_limit = max_input_current;
+
+	pr_info("%s:max_input_current : %dmA\n", __func__, max_input_current);
+}
+
+static void sec_bat_get_charging_current_in_power_list(struct sec_battery_info *battery)
+{
+	int max_charging_current = 0;
+	int pdo_num = battery->pdic_info.sink_status.current_pdo_num;
+	int pd_power = (battery->pdic_info.sink_status.power_list[pdo_num].max_voltage *
+		battery->pdic_info.sink_status.power_list[pdo_num].max_current) / 1000;
+
+	/* We assume that output voltage to 5V and efficiency to 90% */
+	max_charging_current = (pd_power * battery->pd_current_efficiency) / 500;
+	max_charging_current = max_charging_current > battery->pdata->max_charging_current ?
+		battery->pdata->max_charging_current : max_charging_current;
+	battery->pdata->charging_current[POWER_SUPPLY_TYPE_PDIC].fast_charging_current = max_charging_current;
+	battery->charge_power = pd_power;
+
+	pr_info("%s:pd_charge_power : %dmW, max_charging_current : %dmA\n", __func__,
+		battery->charge_power, max_charging_current);
+}
+#endif
+
+static int sec_bat_set_charging_current(struct sec_battery_info *battery)
+{
+	static int afc_init = false;
+	union power_supply_propval value = {0, };
+	int input_current = battery->pdata->charging_current[battery->cable_type].input_current_limit,
+		charging_current = battery->pdata->charging_current[battery->cable_type].fast_charging_current,
+		topoff_current = battery->pdata->charging_current[battery->cable_type].full_check_current_1st;
+
+	if (battery->aicl_current)
+		input_current = battery->aicl_current;
+	mutex_lock(&battery->iolock);
+	if (battery->cable_type == POWER_SUPPLY_TYPE_BATTERY) {
+	} else {
+#if !defined(CONFIG_SEC_FACTORY)
+		if (!(battery->current_event & SEC_BAT_CURRENT_EVENT_SKIP_HEATING_CONTROL)) {
+			input_current = sec_bat_check_mix_temp(battery, input_current);
+		}
+#endif
+
+		/* check input current */
+#if !defined(CONFIG_SEC_FACTORY)
+		if (!(battery->current_event & SEC_BAT_CURRENT_EVENT_SKIP_HEATING_CONTROL)) {
+			input_current = sec_bat_check_wpc_temp(battery, input_current);
+			switch (battery->pdata->chg_heating_prevention_method) {
+			case SEC_BATTERY_BY_CHANGING_VOLTAGE:
+				input_current = sec_bat_check_afc_temp(battery, input_current);
+				break;
+			case SEC_BATTERY_BY_CHANGING_CURRENT:
+				input_current = sec_bat_chg_temperature_check(battery, input_current);
+				break;
+			default:
+				input_current = sec_bat_check_afc_temp(battery, input_current);
+				break;
+			}
+#if defined(CONFIG_CCIC_NOTIFIER)
+			input_current = sec_bat_check_pdic_temp(battery, input_current);
+#endif
+		}
+#endif
+		input_current = sec_bat_check_afc_input_current(battery, input_current);
+		if (battery->store_mode && is_hv_wire_type(battery->cable_type)) {
+			input_current = battery->pdata->store_mode_afc_input_current;
+		}
+
+		sec_bat_get_charging_current_by_siop(battery, &input_current, &charging_current);
+
+		/* Calculate wireless input current under the specific conditions (siop_event, wpc_sleep_mode, chg_limit)*/
+		if (battery->wc_status != SEC_WIRELESS_PAD_NONE) {
+			input_current = sec_bat_get_wireless_current(battery, input_current);
+		}
+
+		/* check topoff current */
+		if (battery->charging_mode == SEC_BATTERY_CHARGING_2ND &&
+			battery->pdata->full_check_type_2nd == SEC_BATTERY_FULLCHARGED_CHGPSY) {
+			topoff_current =
+				battery->pdata->charging_current[battery->cable_type].full_check_current_2nd;
+		}
+
+		/* check swelling state */
+		if (battery->current_event & SEC_BAT_CURRENT_EVENT_LOW_TEMP_SWELLING) {
+			charging_current = (charging_current > battery->pdata->swelling_low_temp_current) ?
+				battery->pdata->swelling_low_temp_current : charging_current;
+			topoff_current = (topoff_current > battery->pdata->swelling_low_temp_topoff) ?
+				battery->pdata->swelling_low_temp_topoff : topoff_current;
+		} else if (battery->current_event & SEC_BAT_CURRENT_EVENT_HIGH_TEMP_SWELLING) {
+			charging_current = (charging_current > battery->pdata->swelling_high_temp_current) ?
+				battery->pdata->swelling_high_temp_current : charging_current;
+			topoff_current = (topoff_current > battery->pdata->swelling_high_temp_topoff) ?
+				battery->pdata->swelling_high_temp_topoff : topoff_current;
+		} else if (battery->current_event & SEC_BAT_CURRENT_EVENT_LOW_TEMP) {
+				charging_current = (charging_current > battery->pdata->swelling_low_temp_current) ?
+					battery->pdata->swelling_low_temp_current : charging_current;
+		}
+#if defined(CONFIG_ENABLE_100MA_CHARGING_BEFORE_USB_CONFIGURED)
+		/* usb unconfigured or suspend */
+		if ((battery->cable_type == POWER_SUPPLY_TYPE_USB) && !lpcharge) {
+#if defined(CONFIG_CCIC_NOTIFIER)
+			if (battery->pdic_info.sink_status.rp_currentlvl == RP_CURRENT_LEVEL_DEFAULT)
+#endif
+				if (battery->current_event & SEC_BAT_CURRENT_EVENT_USB_100MA) {
+					pr_info("%s: usb unconfigured\n", __func__);
+					input_current = USB_CURRENT_UNCONFIGURED;
+					charging_current = USB_CURRENT_UNCONFIGURED;
+				}
+		}
+#endif
+		
+	}
+
+	/* In wireless charging, must be set charging current before input current. */
+	if (is_wireless_type(battery->cable_type) &&
+		battery->charging_current != charging_current) {
+		value.intval = charging_current;
+		psy_do_property(battery->pdata->charger_name, set,
+			POWER_SUPPLY_PROP_CURRENT_NOW, value);
+		battery->charging_current = charging_current;
+	}
+	/* set input current */
+	if (battery->input_current != input_current) {
+		/* update charge power */
+		battery->charge_power = battery->input_voltage * input_current;
+		pr_info("%s: update charge_power(%d)\n", __func__, battery->charge_power);
+		value.intval = input_current;
+		psy_do_property(battery->pdata->charger_name, set,
+			POWER_SUPPLY_PROP_CURRENT_MAX, value);
+		battery->input_current = input_current;
+	}
+	/* set charging current */
+	if (battery->charging_current != charging_current) {
+		value.intval = charging_current;
+		psy_do_property(battery->pdata->charger_name, set,
+			POWER_SUPPLY_PROP_CURRENT_NOW, value);
+		battery->charging_current = charging_current;
+	}
+	/* set topoff current */
+	if (battery->topoff_current != topoff_current) {
+		value.intval = topoff_current;
+		psy_do_property(battery->pdata->charger_name, set,
+			POWER_SUPPLY_PROP_CURRENT_FULL, value);
+		battery->topoff_current = topoff_current;
+	}
+	if (!afc_init) {
+		afc_init = true;
+#if defined(CONFIG_AFC_CHARGER_MODE)
+		value.intval = 1;
+		psy_do_property(battery->pdata->charger_name, set,
+			POWER_SUPPLY_PROP_AFC_CHARGER_MODE,
+			value);
+#endif
+	}
+	mutex_unlock(&battery->iolock);
+	return 0;
+}
+
+static int sec_bat_set_charge(
+				struct sec_battery_info *battery,
+				int chg_mode)
+{
+	union power_supply_propval val = {0, };
+	ktime_t current_time = {0, };
+	struct timespec ts = {0, };
+
+/* Prevent duplicated operation with OTG and Charger mode */
+#if defined(CONFIG_CHARGER_S2MU004) || defined(CONFIG_CHARGER_S2MU005) ||\
+	defined(CONFIG_CHARGER_SM5703) || defined(CONFIG_CHARGER_SM5705)
+	if ((battery->cable_type == POWER_SUPPLY_TYPE_HMT_CONNECTED) ||
+		(battery->cable_type == POWER_SUPPLY_TYPE_OTG))
+#else
+	if (battery->cable_type == POWER_SUPPLY_TYPE_HMT_CONNECTED)
+#endif
+		return 0;
+
+	if (((battery->current_event & SEC_BAT_CURRENT_EVENT_CHARGE_DISABLE) ||
+		(battery->current_event & SEC_BAT_CURRENT_EVENT_BLOCK_CHG_IN_SWELLLING)) &&
+		(chg_mode == SEC_BAT_CHG_MODE_CHARGING)) {
+		dev_info(battery->dev, "%s: charge disable by: 0x%02x\n", __func__,
+			battery->current_event);
+		chg_mode = SEC_BAT_CHG_MODE_CHARGING_OFF;
+	}
+
+	val.intval = battery->status;
+	psy_do_property(battery->pdata->charger_name, set,
+		POWER_SUPPLY_PROP_STATUS, val);
+	current_time = ktime_get_boottime();
+	ts = ktime_to_timespec(current_time);
+
+	if (chg_mode == SEC_BAT_CHG_MODE_CHARGING) {
+		/*Reset charging start time only in initial charging start */
+		if (battery->charging_start_time == 0) {
+			if (ts.tv_sec < 1)
+				ts.tv_sec = 1;
+			battery->charging_start_time = ts.tv_sec;
+			battery->charging_next_time =
+				battery->pdata->charging_reset_time;
+		}
+		battery->charging_block = false;
+	} else {
+		battery->charging_start_time = 0;
+		battery->charging_passed_time = 0;
+		battery->charging_next_time = 0;
+		battery->charging_fullcharged_time = 0;
+		battery->full_check_cnt = 0;
+		battery->charging_block = true;
+#if defined(CONFIG_STEP_CHARGING)
+		sec_bat_reset_step_charging(battery);
+#endif
+#if defined(CONFIG_BATTERY_CISD)
+		battery->cisd.ab_vbat_check_count = 0;
+#endif
+	}
+
+	battery->temp_highlimit_cnt = 0;
+	battery->temp_high_cnt = 0;
+	battery->temp_low_cnt = 0;
+	battery->temp_recover_cnt = 0;
+
+	val.intval = chg_mode;
+	psy_do_property(battery->pdata->charger_name, set,
+		POWER_SUPPLY_PROP_CHARGING_ENABLED, val);
+
+	return 0;
+}
+
+static int sec_bat_get_adc_data(struct sec_battery_info *battery,
+			int adc_ch, int count)
+{
+	int adc_data;
+	int adc_max;
+	int adc_min;
+	int adc_total;
+	int i;
+
+	adc_data = 0;
+	adc_max = 0;
+	adc_min = 0;
+	adc_total = 0;
+
+	for (i = 0; i < count; i++) {
+		mutex_lock(&battery->adclock);
+#ifdef CONFIG_OF
+		adc_data = adc_read(battery, adc_ch);
+#else
+		adc_data = adc_read(battery->pdata, adc_ch);
+#endif
+		mutex_unlock(&battery->adclock);
+
+		if (i != 0) {
+			if (adc_data > adc_max)
+				adc_max = adc_data;
+			else if (adc_data < adc_min)
+				adc_min = adc_data;
+		} else {
+			adc_max = adc_data;
+			adc_min = adc_data;
+		}
+		adc_total += adc_data;
+	}
+
+	return (adc_total - adc_max - adc_min) / (count - 2);
+}
+
+/*
+static unsigned long calculate_average_adc(
+			struct sec_battery_info *battery,
+			int channel, int adc)
+{
+	unsigned int cnt = 0;
+	int total_adc = 0;
+	int average_adc = 0;
+	int index = 0;
+
+	cnt = battery->adc_sample[channel].cnt;
+	total_adc = battery->adc_sample[channel].total_adc;
+
+	if (adc < 0) {
+		dev_err(battery->dev,
+			"%s : Invalid ADC : %d\n", __func__, adc);
+		adc = battery->adc_sample[channel].average_adc;
+	}
+
+	if (cnt < ADC_SAMPLE_COUNT) {
+		battery->adc_sample[channel].adc_arr[cnt] = adc;
+		battery->adc_sample[channel].index = cnt;
+		battery->adc_sample[channel].cnt = ++cnt;
+
+		total_adc += adc;
+		average_adc = total_adc / cnt;
+	} else {
+		index = battery->adc_sample[channel].index;
+		if (++index >= ADC_SAMPLE_COUNT)
+			index = 0;
+
+		total_adc = total_adc -
+			battery->adc_sample[channel].adc_arr[index] + adc;
+		average_adc = total_adc / ADC_SAMPLE_COUNT;
+
+		battery->adc_sample[channel].adc_arr[index] = adc;
+		battery->adc_sample[channel].index = index;
+	}
+
+	battery->adc_sample[channel].total_adc = total_adc;
+	battery->adc_sample[channel].average_adc = average_adc;
+
+	return average_adc;
+}
+*/
+static int sec_bat_get_adc_value(
+		struct sec_battery_info *battery, int channel)
+{
+	int adc;
+
+	adc = sec_bat_get_adc_data(battery, channel,
+		battery->pdata->adc_check_count);
+
+	if (adc < 0) {
+		dev_err(battery->dev,
+			"%s: Error in ADC\n", __func__);
+		return adc;
+	}
+
+	return adc;
+}
+
+static int sec_bat_get_charger_type_adc
+				(struct sec_battery_info *battery)
+{
+	/* It is true something valid is
+	connected to the device for charging.
+	By default this something is considered to be USB.*/
+	int result = POWER_SUPPLY_TYPE_USB;
+
+	int adc = 0;
+	int i;
+
+	/* Do NOT check cable type when cable_switch_check() returns false
+	 * and keep current cable type
+	 */
+	if (battery->pdata->cable_switch_check &&
+	    !battery->pdata->cable_switch_check())
+		return battery->cable_type;
+
+	adc = sec_bat_get_adc_value(battery,
+		SEC_BAT_ADC_CHANNEL_CABLE_CHECK);
+
+	/* Do NOT check cable type when cable_switch_normal() returns false
+	 * and keep current cable type
+	 */
+	if (battery->pdata->cable_switch_normal &&
+	    !battery->pdata->cable_switch_normal())
+		return battery->cable_type;
+
+	for (i = 0; i < SEC_SIZEOF_POWER_SUPPLY_TYPE; i++)
+		if ((adc > battery->pdata->cable_adc_value[i].min) &&
+			(adc < battery->pdata->cable_adc_value[i].max))
+			break;
+	if (i >= SEC_SIZEOF_POWER_SUPPLY_TYPE)
+		dev_err(battery->dev,
+			"%s : default USB\n", __func__);
+	else
+		result = i;
+
+	dev_dbg(battery->dev, "%s : result(%d), adc(%d)\n",
+		__func__, result, adc);
+
+	return result;
+}
+
+static bool sec_bat_check_vf_adc(struct sec_battery_info *battery)
+{
+	int adc;
+
+	adc = sec_bat_get_adc_data(battery,
+		SEC_BAT_ADC_CHANNEL_BAT_CHECK,
+		battery->pdata->adc_check_count);
+
+	if (adc < 0) {
+		dev_err(battery->dev, "%s: VF ADC error\n", __func__);
+		adc = battery->check_adc_value;
+	} else
+		battery->check_adc_value = adc;
+
+	if ((battery->check_adc_value <= battery->pdata->check_adc_max) &&
+		(battery->check_adc_value >= battery->pdata->check_adc_min)) {
+		return true;
+	} else {
+		dev_info(battery->dev, "%s: adc (%d)\n", __func__, battery->check_adc_value);
+		return false;
+	}
+}
+
+static bool sec_bat_check_by_psy(struct sec_battery_info *battery)
+{
+	char *psy_name = NULL;
+	union power_supply_propval value = {0, };
+	bool ret = true;
+
+	switch (battery->pdata->battery_check_type) {
+	case SEC_BATTERY_CHECK_PMIC:
+		psy_name = battery->pdata->pmic_name;
+		break;
+	case SEC_BATTERY_CHECK_FUELGAUGE:
+		psy_name = battery->pdata->fuelgauge_name;
+		break;
+	case SEC_BATTERY_CHECK_CHARGER:
+		psy_name = battery->pdata->charger_name;
+		break;
+	default:
+		dev_err(battery->dev,
+			"%s: Invalid Battery Check Type\n", __func__);
+		ret = false;
+		goto battery_check_error;
+		break;
+	}
+
+	psy_do_property(psy_name, get,
+		POWER_SUPPLY_PROP_PRESENT, value);
+	ret = (bool)value.intval;
+
+battery_check_error:
+	return ret;
+}
+
+static bool sec_bat_check(struct sec_battery_info *battery)
+{
+	bool ret = true;
+
+	if (battery->factory_mode || battery->is_jig_on) {
+		dev_dbg(battery->dev, "%s: No need to check in factory mode\n",
+			__func__);
+		return ret;
+	}
+
+	if (battery->health != POWER_SUPPLY_HEALTH_GOOD &&
+		battery->health != POWER_SUPPLY_HEALTH_UNSPEC_FAILURE) {
+		dev_dbg(battery->dev, "%s: No need to check\n", __func__);
+		return ret;
+	}
+
+	switch (battery->pdata->battery_check_type) {
+	case SEC_BATTERY_CHECK_ADC:
+		if (battery->cable_type == POWER_SUPPLY_TYPE_BATTERY)
+			ret = battery->present;
+		else
+			ret = sec_bat_check_vf_adc(battery);
+		break;
+	case SEC_BATTERY_CHECK_INT:
+		dev_info(battery->dev, "%s: battery_check_type = %d\n", __func__,battery->pdata->battery_check_type);
+		if(battery->cable_type == POWER_SUPPLY_TYPE_BATTERY)
+			ret = battery->present;
+		else {
+			msleep(50);
+			/* high is miss the battery */
+			ret = !(gpio_get_value(battery->pdata->bat_irq_gpio));
+			dev_info(battery->dev, "%s: gpio_get_value = %d\n", __func__,ret);
+		}
+		break;
+	case SEC_BATTERY_CHECK_CALLBACK:
+		if (battery->cable_type == POWER_SUPPLY_TYPE_BATTERY) {
+			ret = battery->present;
+		} else {
+			if (battery->pdata->check_battery_callback)
+				ret = battery->pdata->check_battery_callback();
+		}
+		break;
+	case SEC_BATTERY_CHECK_PMIC:
+	case SEC_BATTERY_CHECK_FUELGAUGE:
+	case SEC_BATTERY_CHECK_CHARGER:
+		ret = sec_bat_check_by_psy(battery);
+		break;
+	case SEC_BATTERY_CHECK_NONE:
+		dev_dbg(battery->dev, "%s: No Check\n", __func__);
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+static bool sec_bat_get_cable_type(
+			struct sec_battery_info *battery,
+			int cable_source_type)
+{
+	bool ret = false;
+	int cable_type = battery->cable_type;
+
+	if (cable_source_type & SEC_BATTERY_CABLE_SOURCE_CALLBACK) {
+		if (battery->pdata->check_cable_callback)
+			cable_type =
+				battery->pdata->check_cable_callback();
+	}
+
+	if (cable_source_type & SEC_BATTERY_CABLE_SOURCE_ADC) {
+		if (gpio_get_value_cansleep(
+			battery->pdata->bat_gpio_ta_nconnected) ^
+			battery->pdata->bat_polarity_ta_nconnected)
+			cable_type = POWER_SUPPLY_TYPE_BATTERY;
+		else
+			cable_type =
+				sec_bat_get_charger_type_adc(battery);
+	}
+
+	if (battery->cable_type == cable_type) {
+		dev_dbg(battery->dev,
+			"%s: No need to change cable status\n", __func__);
+	} else {
+		if (cable_type < POWER_SUPPLY_TYPE_BATTERY ||
+			cable_type >= SEC_SIZEOF_POWER_SUPPLY_TYPE) {
+			dev_err(battery->dev,
+				"%s: Invalid cable type\n", __func__);
+		} else {
+			battery->cable_type = cable_type;
+			if (battery->pdata->check_cable_result_callback)
+				battery->pdata->check_cable_result_callback(
+						battery->cable_type);
+
+			ret = true;
+
+			dev_dbg(battery->dev, "%s: Cable Changed (%d)\n",
+				__func__, battery->cable_type);
+		}
+	}
+
+	return ret;
+}
+
+static void sec_bat_set_charging_status(struct sec_battery_info *battery,
+		int status) {
+	union power_supply_propval value = {0, };
+
+	switch (status) {
+	case POWER_SUPPLY_STATUS_CHARGING:
+		if (battery->siop_level != 100)
+			battery->stop_timer = true;
+		break;
+	case POWER_SUPPLY_STATUS_NOT_CHARGING:
+	case POWER_SUPPLY_STATUS_DISCHARGING:
+		if ((battery->status == POWER_SUPPLY_STATUS_FULL ||
+		     (battery->capacity == 100 && !battery->slate_mode)) &&
+		    !battery->store_mode) {
+			value.intval = 100;
+			psy_do_property(battery->pdata->fuelgauge_name, set,
+					POWER_SUPPLY_PROP_CHARGE_FULL, value);
+			/* To get SOC value (NOT raw SOC), need to reset value */
+			value.intval = 0;
+			psy_do_property(battery->pdata->fuelgauge_name, get,
+					POWER_SUPPLY_PROP_CAPACITY, value);
+			battery->capacity = value.intval;
+		}
+		battery->expired_time = battery->pdata->expired_time;
+		battery->prev_safety_time = 0;
+		break;
+	case POWER_SUPPLY_STATUS_FULL:
+		if (is_wireless_type(battery->cable_type)) {
+#ifdef CONFIG_CS100_JPNCONCEPT
+				if (battery->charging_mode == SEC_BATTERY_CHARGING_2ND ||
+					battery->charging_passed_time > battery->pdata->charging_total_time) {
+#endif
+					value.intval = POWER_SUPPLY_STATUS_FULL;
+					psy_do_property(battery->pdata->wireless_charger_name, set,
+						POWER_SUPPLY_PROP_STATUS, value);
+#ifdef CONFIG_CS100_JPNCONCEPT
+				}
+#endif
+			}
+			break;
+		default:
+			break;
+	}
+	battery->status = status;
+}
+
+static bool sec_bat_battery_cable_check(struct sec_battery_info *battery)
+{
+	if (!sec_bat_check(battery)) {
+		if (battery->check_count < battery->pdata->check_count)
+			battery->check_count++;
+		else {
+			dev_err(battery->dev,
+				"%s: Battery Disconnected\n", __func__);
+			battery->present = false;
+			battery->health = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;
+
+			if (battery->status !=
+				POWER_SUPPLY_STATUS_DISCHARGING) {
+				sec_bat_set_charging_status(battery,
+						POWER_SUPPLY_STATUS_NOT_CHARGING);
+				sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_BUCK_OFF);
+			}
+
+			if (battery->pdata->check_battery_result_callback)
+				battery->pdata->
+					check_battery_result_callback();
+			return false;
+		}
+	} else
+		battery->check_count = 0;
+
+	battery->present = true;
+
+	if (battery->health == POWER_SUPPLY_HEALTH_UNSPEC_FAILURE) {
+		battery->health = POWER_SUPPLY_HEALTH_GOOD;
+
+		if (battery->status == POWER_SUPPLY_STATUS_NOT_CHARGING) {
+			sec_bat_set_charging_status(battery,
+					POWER_SUPPLY_STATUS_CHARGING);
+#if defined(CONFIG_BATTERY_SWELLING)
+			if (!battery->swelling_mode)
+#endif
+			sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING);
+		}
+	}
+
+	dev_dbg(battery->dev, "%s: Battery Connected\n", __func__);
+
+	if (battery->pdata->cable_check_type &
+		SEC_BATTERY_CABLE_CHECK_POLLING) {
+		if (sec_bat_get_cable_type(battery,
+			battery->pdata->cable_source_type)) {
+			wake_lock(&battery->cable_wake_lock);
+			queue_delayed_work(battery->monitor_wqueue,
+					   &battery->cable_work, 0);
+		}
+	}
+	return true;
+}
+
+static int sec_bat_ovp_uvlo_by_psy(struct sec_battery_info *battery)
+{
+	char *psy_name = NULL;
+	union power_supply_propval value = {0, };
+
+	value.intval = POWER_SUPPLY_HEALTH_GOOD;
+
+	switch (battery->pdata->ovp_uvlo_check_type) {
+	case SEC_BATTERY_OVP_UVLO_PMICPOLLING:
+		psy_name = battery->pdata->pmic_name;
+		break;
+	case SEC_BATTERY_OVP_UVLO_CHGPOLLING:
+		psy_name = battery->pdata->charger_name;
+		break;
+	default:
+		dev_err(battery->dev,
+			"%s: Invalid OVP/UVLO Check Type\n", __func__);
+		goto ovp_uvlo_check_error;
+		break;
+	}
+
+	psy_do_property(psy_name, get,
+		POWER_SUPPLY_PROP_HEALTH, value);
+
+ovp_uvlo_check_error:
+	return value.intval;
+}
+
+static bool sec_bat_ovp_uvlo_result(
+		struct sec_battery_info *battery, int health)
+{
+	if (battery->health != health) {
+		battery->health = health;
+		switch (health) {
+		case POWER_SUPPLY_HEALTH_GOOD:
+			dev_info(battery->dev, "%s: Safe voltage\n", __func__);
+			dev_info(battery->dev, "%s: is_recharging : %d\n", __func__, battery->is_recharging);
+			sec_bat_set_charging_status(battery,
+					POWER_SUPPLY_STATUS_CHARGING);
+			battery->charging_mode = SEC_BATTERY_CHARGING_1ST;
+#if defined(CONFIG_BATTERY_SWELLING)
+			if (!battery->swelling_mode)
+#endif
+			sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING);
+			battery->health_check_count = 0;
+			break;
+		case POWER_SUPPLY_HEALTH_OVERVOLTAGE:
+		case POWER_SUPPLY_HEALTH_UNDERVOLTAGE:
+			dev_info(battery->dev,
+				"%s: Unsafe voltage (%d)\n",
+				__func__, health);
+			sec_bat_set_charging_status(battery,
+					POWER_SUPPLY_STATUS_NOT_CHARGING);
+			sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING_OFF);
+			battery->charging_mode = SEC_BATTERY_CHARGING_NONE;
+			battery->is_recharging = false;
+			battery->health_check_count = DEFAULT_HEALTH_CHECK_COUNT;
+#if defined(CONFIG_BATTERY_CISD)
+			battery->cisd.data[CISD_UNSAFE_VOLTAGE]++;
+#endif
+			/* Take the wakelock during 10 seconds
+			   when over-voltage status is detected	 */
+			wake_lock_timeout(&battery->vbus_wake_lock, HZ * 10);
+			break;
+		}
+		power_supply_changed(&battery->psy_bat);
+		return true;
+	}
+
+	return false;
+}
+
+static bool sec_bat_ovp_uvlo(struct sec_battery_info *battery)
+{
+	int health = POWER_SUPPLY_HEALTH_GOOD;
+
+	if (battery->wdt_kick_disable) {
+		dev_dbg(battery->dev,
+			"%s: No need to check in wdt test\n",
+			__func__);
+		return false;
+	} else if ((battery->status == POWER_SUPPLY_STATUS_FULL) &&
+		   (battery->charging_mode == SEC_BATTERY_CHARGING_NONE)) {
+		dev_dbg(battery->dev, "%s: No need to check in Full status", __func__);
+		return false;
+	}
+
+	if (battery->health != POWER_SUPPLY_HEALTH_GOOD &&
+		battery->health != POWER_SUPPLY_HEALTH_OVERVOLTAGE &&
+		battery->health != POWER_SUPPLY_HEALTH_UNDERVOLTAGE) {
+		dev_dbg(battery->dev, "%s: No need to check\n", __func__);
+		return false;
+	}
+
+	health = battery->health;
+
+	switch (battery->pdata->ovp_uvlo_check_type) {
+	case SEC_BATTERY_OVP_UVLO_CALLBACK:
+		if (battery->pdata->ovp_uvlo_callback)
+			health = battery->pdata->ovp_uvlo_callback();
+		break;
+	case SEC_BATTERY_OVP_UVLO_PMICPOLLING:
+	case SEC_BATTERY_OVP_UVLO_CHGPOLLING:
+		health = sec_bat_ovp_uvlo_by_psy(battery);
+		break;
+	case SEC_BATTERY_OVP_UVLO_PMICINT:
+	case SEC_BATTERY_OVP_UVLO_CHGINT:
+		/* nothing for interrupt check */
+	default:
+		break;
+	}
+
+	/* Move the location for calling the get_health
+	   in case of attaching the jig */ 
+	if (battery->factory_mode || battery->is_jig_on) {
+		dev_dbg(battery->dev,
+			"%s: No need to check in factory mode\n",
+			__func__);
+		return false;
+	}
+
+	return sec_bat_ovp_uvlo_result(battery, health);
+}
+
+static bool sec_bat_check_recharge(struct sec_battery_info *battery)
+{
+#if defined(CONFIG_BATTERY_SWELLING)
+	if (battery->swelling_mode == SWELLING_MODE_CHARGING ||
+		battery->swelling_mode == SWELLING_MODE_FULL) {
+		pr_info("%s: Skip normal recharge check routine for swelling mode\n",
+			__func__);
+		return false;
+	}
+#endif
+	if ((battery->status == POWER_SUPPLY_STATUS_CHARGING) &&
+			(battery->pdata->full_condition_type &
+			 SEC_BATTERY_FULL_CONDITION_NOTIMEFULL) &&
+			(battery->charging_mode == SEC_BATTERY_CHARGING_NONE)) {
+		dev_info(battery->dev,
+				"%s: Re-charging by NOTIMEFULL (%d)\n",
+				__func__, battery->capacity);
+		goto check_recharge_check_count;
+	}
+
+	if (battery->status == POWER_SUPPLY_STATUS_FULL &&
+			battery->charging_mode == SEC_BATTERY_CHARGING_NONE) {
+		int recharging_voltage = battery->pdata->recharge_condition_vcell;
+		if ((battery->current_event & SEC_BAT_CURRENT_EVENT_LOW_TEMP)
+			&& (battery->pdata->swelling_low_temp_2step_mode)) {
+			/* float voltage - 150mV */
+			recharging_voltage =\
+				(battery->pdata->chg_float_voltage /\
+				battery->pdata->chg_float_voltage_conv) - 150;
+			dev_info(battery->dev, "%s: recharging voltage changed by low temp(%d)\n",
+					__func__, recharging_voltage);
+		}
+
+		if ((battery->pdata->recharge_condition_type &
+					SEC_BATTERY_RECHARGE_CONDITION_SOC) &&
+				(battery->capacity <=
+				 battery->pdata->recharge_condition_soc)) {
+			battery->expired_time = battery->pdata->recharging_expired_time;
+			battery->prev_safety_time = 0;
+			dev_info(battery->dev,
+					"%s: Re-charging by SOC (%d)\n",
+					__func__, battery->capacity);
+			goto check_recharge_check_count;
+		}
+
+		if ((battery->pdata->recharge_condition_type &
+		     SEC_BATTERY_RECHARGE_CONDITION_AVGVCELL) &&
+		    (battery->voltage_avg <= recharging_voltage)) {
+			battery->expired_time = battery->pdata->recharging_expired_time;
+			battery->prev_safety_time = 0;
+			dev_info(battery->dev,
+					"%s: Re-charging by average VCELL (%d)\n",
+					__func__, battery->voltage_avg);
+			goto check_recharge_check_count;
+		}
+
+		if ((battery->pdata->recharge_condition_type &
+		     SEC_BATTERY_RECHARGE_CONDITION_VCELL) &&
+		    (battery->voltage_now <= recharging_voltage)) {
+			battery->expired_time = battery->pdata->recharging_expired_time;
+			battery->prev_safety_time = 0;
+			dev_info(battery->dev,
+					"%s: Re-charging by VCELL (%d)\n",
+					__func__, battery->voltage_now);
+			goto check_recharge_check_count;
+		}
+	}
+
+	battery->recharge_check_cnt = 0;
+	return false;
+
+check_recharge_check_count:
+	if (battery->recharge_check_cnt <
+		battery->pdata->recharge_check_count)
+		battery->recharge_check_cnt++;
+	dev_dbg(battery->dev,
+		"%s: recharge count = %d\n",
+		__func__, battery->recharge_check_cnt);
+
+	if (battery->recharge_check_cnt >=
+		battery->pdata->recharge_check_count)
+		return true;
+	else
+		return false;
+}
+
+static bool sec_bat_voltage_check(struct sec_battery_info *battery)
+{
+	union power_supply_propval value = {0, };
+
+	if (battery->status == POWER_SUPPLY_STATUS_DISCHARGING) {
+		dev_dbg(battery->dev,
+			"%s: Charging Disabled\n", __func__);
+		return true;
+	}
+
+	/* OVP/UVLO check */
+	if (sec_bat_ovp_uvlo(battery)) {
+		if (battery->pdata->ovp_uvlo_result_callback)
+			battery->pdata->
+				ovp_uvlo_result_callback(battery->health);
+		return false;
+	}
+
+	if ((battery->status == POWER_SUPPLY_STATUS_FULL) &&
+#if defined(CONFIG_BATTERY_SWELLING)
+	    (battery->charging_mode == SEC_BATTERY_CHARGING_2ND ||
+	     battery->is_recharging || battery->swelling_mode)) {
+#else
+		(battery->charging_mode == SEC_BATTERY_CHARGING_2ND ||
+		 battery->is_recharging)) {
+#endif
+		value.intval = 0;
+		psy_do_property(battery->pdata->fuelgauge_name, get,
+			POWER_SUPPLY_PROP_CAPACITY, value);
+		if (value.intval <
+			battery->pdata->full_condition_soc &&
+				battery->voltage_now <
+				(battery->pdata->recharge_condition_vcell - 50)) {
+			sec_bat_set_charging_status(battery,
+					POWER_SUPPLY_STATUS_CHARGING);
+			dev_info(battery->dev,
+				"%s: battery status full -> charging, RepSOC(%d)\n", __func__, value.intval);
+			return false;
+		}
+	}
+
+	/* Re-Charging check */
+	if (sec_bat_check_recharge(battery)) {
+		if (battery->pdata->full_check_type !=
+			SEC_BATTERY_FULLCHARGED_NONE)
+			battery->charging_mode = SEC_BATTERY_CHARGING_1ST;
+		else
+			battery->charging_mode = SEC_BATTERY_CHARGING_2ND;
+		battery->is_recharging = true;
+#if defined(CONFIG_BATTERY_CISD)
+		battery->cisd.recharge_count++;
+		battery->cisd.recharge_count_2++;
+		if (battery->cisd.charging_end_time_2 > 0) {
+			struct timespec now_ts;
+			struct cisd *pcisd = &battery->cisd;
+			now_ts = ktime_to_timespec(ktime_get_boottime());
+			if ((now_ts.tv_sec - pcisd->charging_end_time_2) < pcisd->data[CISD_DATA_RECHARGING_TIME]) {
+				pcisd->data[CISD_DATA_RECHARGING_TIME] = (int)(now_ts.tv_sec - pcisd->charging_end_time_2);
+				dev_info(battery->dev,
+						"%s: cisd Recharging TIME(%d)\n", __func__, pcisd->data[CISD_DATA_RECHARGING_TIME]);
+			}
+		}
+#endif
+#if defined(CONFIG_BATTERY_SWELLING)
+		if (!battery->swelling_mode)
+#endif
+		sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING);
+		return false;
+	}
+
+	return true;
+}
+
+static bool sec_bat_get_temperature_by_adc(
+				struct sec_battery_info *battery,
+				enum sec_battery_adc_channel channel,
+				union power_supply_propval *value)
+{
+	int temp = 0;
+	int temp_adc;
+	int low = 0;
+	int high = 0;
+	int mid = 0;
+	const sec_bat_adc_table_data_t *temp_adc_table;
+	unsigned int temp_adc_table_size;
+	
+#if defined(CONFIG_XADC_SHARE_BATT_WITH_USB_THM)
+		if(channel == SEC_BAT_ADC_CHANNEL_USB_TEMP){
+			gpio_direction_output(battery->pdata->xadc_mux_sel_pin, 1);
+			temp_adc = sec_bat_get_adc_value(battery, SEC_BAT_ADC_CHANNEL_TEMP);
+		}
+		else{
+			gpio_direction_output(battery->pdata->xadc_mux_sel_pin, 0);
+			temp_adc = sec_bat_get_adc_value(battery, channel);
+		}
+#else
+#if defined(CONFIG_THM_MUX_SHARE)
+		gpio_direction_output(battery->pdata->thm_mux, 1);
+		temp_adc = sec_bat_get_adc_value(battery, channel);
+		gpio_direction_output(battery->pdata->thm_mux, 0);
+#else
+		temp_adc = sec_bat_get_adc_value(battery, channel);
+#endif
+#endif
+	if (temp_adc < 0)
+		return true;
+
+	switch (channel) {
+	case SEC_BAT_ADC_CHANNEL_TEMP:
+		temp_adc_table = battery->pdata->temp_adc_table;
+		temp_adc_table_size =
+			battery->pdata->temp_adc_table_size;
+		battery->temp_adc = temp_adc;
+		break;
+	case SEC_BAT_ADC_CHANNEL_TEMP_AMBIENT:
+		temp_adc_table = battery->pdata->temp_amb_adc_table;
+		temp_adc_table_size =
+			battery->pdata->temp_amb_adc_table_size;
+		battery->temp_ambient_adc = temp_adc;
+		break;
+	case SEC_BAT_ADC_CHANNEL_CHG_TEMP:
+		temp_adc_table = battery->pdata->chg_temp_adc_table;
+		temp_adc_table_size =
+			battery->pdata->chg_temp_adc_table_size;
+		battery->chg_temp_adc = temp_adc;
+		break;
+	case SEC_BAT_ADC_CHANNEL_WPC_TEMP:
+		temp_adc_table = battery->pdata->wpc_temp_adc_table;
+		temp_adc_table_size =
+			battery->pdata->wpc_temp_adc_table_size;
+		battery->wpc_temp_adc = temp_adc;
+		break;
+	case SEC_BAT_ADC_CHANNEL_SLAVE_CHG_TEMP:
+		temp_adc_table = battery->pdata->slave_chg_temp_adc_table;
+		temp_adc_table_size =
+			battery->pdata->slave_chg_temp_adc_table_size;
+		battery->slave_chg_temp_adc = temp_adc;
+		break;
+	case SEC_BAT_ADC_CHANNEL_USB_TEMP:
+			temp_adc_table = battery->pdata->usb_temp_adc_table;
+		temp_adc_table_size =
+			battery->pdata->usb_temp_adc_table_size;
+		battery->usb_temp_adc = temp_adc;
+		break;
+	default:
+		dev_err(battery->dev,
+			"%s: Invalid Property\n", __func__);
+		return false;
+	}
+
+	if (temp_adc_table[0].adc >= temp_adc) {
+		temp = temp_adc_table[0].data;
+		goto temp_by_adc_goto;
+	} else if (temp_adc_table[temp_adc_table_size-1].adc <= temp_adc) {
+		temp = temp_adc_table[temp_adc_table_size-1].data;
+		goto temp_by_adc_goto;
+	}
+
+	high = temp_adc_table_size - 1;
+
+	while (low <= high) {
+		mid = (low + high) / 2;
+		if (temp_adc_table[mid].adc > temp_adc)
+			high = mid - 1;
+		else if (temp_adc_table[mid].adc < temp_adc)
+			low = mid + 1;
+		else {
+			temp = temp_adc_table[mid].data;
+			goto temp_by_adc_goto;
+		}
+	}
+
+	temp = temp_adc_table[high].data;
+	temp += ((temp_adc_table[low].data - temp_adc_table[high].data) *
+		 (temp_adc - temp_adc_table[high].adc)) /
+		(temp_adc_table[low].adc - temp_adc_table[high].adc);
+
+temp_by_adc_goto:
+	value->intval = temp;
+
+	dev_err(battery->dev,
+		"%s: Temp(%d), Temp-ADC(%d)\n",
+		__func__, temp, temp_adc);
+
+	return true;
+}
+
+static bool sec_bat_temperature(
+				struct sec_battery_info *battery)
+{
+	bool ret;
+	ret = true;
+
+	if (lpcharge) {
+		battery->temp_highlimit_threshold =
+			battery->pdata->temp_highlimit_threshold_lpm;
+		battery->temp_highlimit_recovery =
+			battery->pdata->temp_highlimit_recovery_lpm;
+		battery->temp_high_threshold =
+			battery->pdata->temp_high_threshold_lpm;
+		battery->temp_high_recovery =
+			battery->pdata->temp_high_recovery_lpm;
+		battery->temp_low_recovery =
+			battery->pdata->temp_low_recovery_lpm;
+		battery->temp_low_threshold =
+			battery->pdata->temp_low_threshold_lpm;
+	} else {
+		battery->temp_highlimit_threshold =
+			battery->pdata->temp_highlimit_threshold_normal;
+		battery->temp_highlimit_recovery =
+			battery->pdata->temp_highlimit_recovery_normal;
+		battery->temp_high_threshold =
+			battery->pdata->temp_high_threshold_normal;
+		battery->temp_high_recovery =
+			battery->pdata->temp_high_recovery_normal;
+		battery->temp_low_recovery =
+			battery->pdata->temp_low_recovery_normal;
+		battery->temp_low_threshold =
+			battery->pdata->temp_low_threshold_normal;
+	}
+
+	dev_info(battery->dev,
+		"%s: HLT(%d) HLR(%d) HT(%d), HR(%d), LT(%d), LR(%d)\n",
+		__func__, battery->temp_highlimit_threshold,
+		battery->temp_highlimit_recovery,
+		battery->temp_high_threshold,
+		battery->temp_high_recovery,
+		battery->temp_low_threshold,
+		battery->temp_low_recovery);
+	return ret;
+}
+
+#if defined(CONFIG_BATTERY_SWELLING)
+static void sec_bat_swelling_check(struct sec_battery_info *battery, int temperature)
+{
+	union power_supply_propval val = {0, };
+	int swelling_rechg_voltage = battery->pdata->swelling_high_rechg_voltage;
+	bool en_swelling = false, en_rechg = false;
+	int float_voltage = battery->pdata->swelling_drop_float_voltage;
+
+	if (battery->skip_swelling) {
+		pr_info("%s : skip swelling check in 15 test mode\n", __func__);
+		return;
+	}
+
+	psy_do_property(battery->pdata->charger_name, get,
+			POWER_SUPPLY_PROP_VOLTAGE_MAX, val);
+
+	pr_info("%s: status(%d), swell_mode(%d:%d:%d), cv(%d)mV, temp(%d)\n",
+		__func__, battery->status, battery->swelling_mode,
+		battery->charging_block, (battery->current_event & SEC_BAT_CURRENT_EVENT_LOW_TEMP),
+		val.intval, temperature);
+
+	/* swelling_mode
+		under voltage over voltage, battery missing */
+	if ((battery->status == POWER_SUPPLY_STATUS_DISCHARGING) ||\
+		(battery->status == POWER_SUPPLY_STATUS_NOT_CHARGING)) {
+		pr_debug("%s: DISCHARGING or NOT-CHARGING. stop swelling mode\n", __func__);
+		battery->swelling_mode = SWELLING_MODE_NONE;
+		sec_bat_set_current_event(battery,
+				(SEC_BAT_CURRENT_EVENT_LOW_TEMP_SWELLING |
+				SEC_BAT_CURRENT_EVENT_LOW_TEMP |
+				SEC_BAT_CURRENT_EVENT_HIGH_TEMP_SWELLING |
+				SEC_BAT_CURRENT_EVENT_BLOCK_CHG_IN_SWELLLING), 1);
+		goto skip_swelling_check;
+	}
+
+	if (!battery->swelling_mode) {
+		if (((temperature >= battery->pdata->swelling_high_temp_block) ||
+			(temperature <= battery->pdata->swelling_low_temp_block_2nd)) &&
+			battery->pdata->temp_check_type) {
+			pr_info("%s: swelling mode start. stop charging\n", __func__);
+			battery->swelling_mode = SWELLING_MODE_CHARGING;
+			battery->swelling_full_check_cnt = 0;
+			sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING_OFF);
+			sec_bat_set_current_event(battery,
+				SEC_BAT_CURRENT_EVENT_BLOCK_CHG_IN_SWELLLING, 0);
+			en_swelling = true;
+		} else if ((temperature <= battery->pdata->swelling_low_temp_block_1st) &&
+			!(battery->current_event & SEC_BAT_CURRENT_EVENT_LOW_TEMP)) {
+			pr_info("%s: low temperature reduce current\n", __func__);
+			sec_bat_set_current_event(battery, SEC_BAT_CURRENT_EVENT_LOW_TEMP, 0);
+		} else if ((temperature >= battery->pdata->swelling_low_temp_recov_1st) &&
+			(battery->current_event & SEC_BAT_CURRENT_EVENT_LOW_TEMP)) {
+			pr_info("%s: normal temperature temperature recover current\n", __func__);
+			sec_bat_set_current_event(battery, SEC_BAT_CURRENT_EVENT_LOW_TEMP, 1);
+		}
+#if defined(CONFIG_BATTERY_CISD)
+			if (temperature >= battery->pdata->swelling_high_temp_block)
+				battery->cisd.data[CISD_DATA_HIGH_TEMP_SWELLING]++;
+			else if (temperature <= battery->pdata->swelling_low_temp_block_2nd)
+				battery->cisd.data[CISD_DATA_LOW_TEMP_SWELLING]++;
+#endif
+	}
+
+	if (!battery->voltage_now)
+		return;
+
+	if (battery->swelling_mode) {
+		if (temperature <= battery->pdata->swelling_low_temp_recov_2nd) {
+			swelling_rechg_voltage = battery->pdata->swelling_low_rechg_voltage;
+		}
+
+		if (val.intval != float_voltage) {
+			pr_info("%s: float voltage change(%d -> %d)\n", __func__, val.intval, float_voltage);
+			if (!battery->charging_block) {
+				sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING_OFF);
+				val.intval = float_voltage;
+				psy_do_property(battery->pdata->charger_name, set,
+						POWER_SUPPLY_PROP_VOLTAGE_MAX, val);
+				sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING);
+			} else {
+				val.intval = float_voltage;
+				psy_do_property(battery->pdata->charger_name, set,
+						POWER_SUPPLY_PROP_VOLTAGE_MAX, val);
+			}
+		}
+
+		if ((temperature <= battery->pdata->swelling_high_temp_recov) &&
+		    (temperature >= battery->pdata->swelling_low_temp_recov_2nd)) {
+			pr_info("%s: swelling mode end. restart charging\n", __func__);
+			battery->swelling_mode = SWELLING_MODE_NONE;
+			battery->charging_mode = SEC_BATTERY_CHARGING_1ST;
+			sec_bat_set_current_event(battery,
+				(SEC_BAT_CURRENT_EVENT_LOW_TEMP_SWELLING |
+				SEC_BAT_CURRENT_EVENT_LOW_TEMP |
+				SEC_BAT_CURRENT_EVENT_HIGH_TEMP_SWELLING |
+				SEC_BAT_CURRENT_EVENT_BLOCK_CHG_IN_SWELLLING), 1);
+			sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING);
+			/* restore 4.4V float voltage */
+			val.intval = battery->pdata->swelling_normal_float_voltage;
+			psy_do_property(battery->pdata->charger_name, set,
+					POWER_SUPPLY_PROP_VOLTAGE_MAX, val);
+			if (temperature <= battery->pdata->swelling_low_temp_block_1st) {
+				sec_bat_set_current_event(battery, SEC_BAT_CURRENT_EVENT_LOW_TEMP, 0);
+			}
+		} else if (battery->voltage_now < swelling_rechg_voltage &&
+			battery->charging_block) {
+			pr_info("%s: swelling mode recharging start. Vbatt(%d)\n",
+				__func__, battery->voltage_now);
+
+			sec_bat_set_current_event(battery,
+				SEC_BAT_CURRENT_EVENT_BLOCK_CHG_IN_SWELLLING, 1);
+
+			battery->charging_mode = SEC_BATTERY_CHARGING_1ST;
+			en_rechg = true;
+			psy_do_property(battery->pdata->charger_name, set,
+					POWER_SUPPLY_PROP_VOLTAGE_MAX, val);
+			/* set charging enable */
+			sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING);
+			if (temperature <= battery->pdata->swelling_low_temp_recov_2nd) {
+				pr_info("%s: swelling mode reduce charging current(LOW-temp:%d)\n",
+					__func__, temperature);
+				sec_bat_set_current_event(battery, SEC_BAT_CURRENT_EVENT_LOW_TEMP_SWELLING, 0);
+			} else if (temperature >= battery->pdata->swelling_high_temp_recov) {
+				pr_info("%s: swelling mode reduce charging current(HIGH-temp:%d)\n",
+					__func__, temperature);
+				sec_bat_set_current_event(battery, SEC_BAT_CURRENT_EVENT_HIGH_TEMP_SWELLING, 0);
+			}
+#if defined(CONFIG_BATTERY_CISD)
+			battery->cisd.data[CISD_DATA_SWELLING_CHARGING_COUNT]++;
+#endif
+		}
+	}
+
+	if (en_swelling && !en_rechg) {
+		pr_info("%s : SAFETY TIME RESET (SWELLING MODE CHARING STOP!)\n", __func__);
+		battery->expired_time = battery->pdata->expired_time;
+		battery->prev_safety_time = 0;
+	}
+
+skip_swelling_check:
+	dev_dbg(battery->dev, "%s end\n", __func__);
+}
+#endif
+
+static void sec_bat_set_fg_learn(struct sec_battery_info *battery, int enable)
+{
+	union power_supply_propval value;
+	static int prev_enable = -1;
+
+	if (prev_enable == enable) {
+		pr_info("%s: skip set capacity learn(%d <-> %d)\n", __func__, prev_enable, enable);
+		return;
+	}
+
+	/* If you want to disable the fg learning, send the negative number to FG IC.*/
+	value.intval = (enable) ?
+		battery->pdata->chg_float_voltage : (-1);
+	psy_do_property(battery->pdata->fuelgauge_name, set,
+		POWER_SUPPLY_PROP_CAPACITY_LEVEL, value);
+	prev_enable = enable;
+	pr_info("%s: set(%d) capacity learn(%d)\n", __func__, enable, value.intval);
+}
+
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+static bool sec_bat_set_aging_step(struct sec_battery_info *battery, int step)
+{
+	union power_supply_propval value = {0, };
+
+	if (battery->pdata->num_age_step <= 0 || step < 0 || step >= battery->pdata->num_age_step) {
+		pr_info("%s: [AGE] abnormal age step : %d/%d\n",
+			__func__, step, battery->pdata->num_age_step-1);
+		return false;
+	}
+
+	battery->pdata->age_step = step;
+
+	/* float voltage */
+	battery->pdata->chg_float_voltage =
+		battery->pdata->age_data[battery->pdata->age_step].float_voltage;
+	battery->pdata->swelling_normal_float_voltage =
+		battery->pdata->chg_float_voltage;
+	if (!battery->swelling_mode) {
+		value.intval = battery->pdata->chg_float_voltage;
+		psy_do_property(battery->pdata->charger_name, set,
+			POWER_SUPPLY_PROP_VOLTAGE_MAX, value);
+	}
+
+	/* full/recharge condition */
+	battery->pdata->recharge_condition_vcell =
+		battery->pdata->age_data[battery->pdata->age_step].recharge_condition_vcell;
+	battery->pdata->full_condition_soc =
+		battery->pdata->age_data[battery->pdata->age_step].full_condition_soc;
+	battery->pdata->full_condition_vcell =
+		battery->pdata->age_data[battery->pdata->age_step].full_condition_vcell;
+
+#if defined(CONFIG_FUELGAUGE_S2MU004) || defined(CONFIG_FUELGAUGE_S2MU005)
+	value.intval = battery->pdata->age_step;
+	psy_do_property(battery->pdata->fuelgauge_name, set,
+		POWER_SUPPLY_EXT_PROP_UPDATE_BATTERY_DATA, value);
+#elif defined(CONFIG_FUELGAUGE_SM5703)
+	sec_bat_set_fg_learn(battery, 1);
+#else
+	value.intval = battery->pdata->full_condition_soc;
+	psy_do_property(battery->pdata->fuelgauge_name, set,
+		POWER_SUPPLY_PROP_CAPACITY_LEVEL, value);
+#endif
+	dev_info(battery->dev,
+		 "%s: Step(%d/%d), Cycle(%d), float_v(%d), r_v(%d), f_s(%d), f_vl(%d)\n",
+		 __func__,
+		 battery->pdata->age_step, battery->pdata->num_age_step-1, battery->batt_cycle,
+		 battery->pdata->chg_float_voltage,
+		 battery->pdata->recharge_condition_vcell,
+		 battery->pdata->full_condition_soc,
+		 battery->pdata->full_condition_vcell);
+
+#if defined(CONFIG_BATTERY_AGE_FORECAST_B2B)
+	{
+		int i;
+		bool bChanged = false;
+		battery->pdata->max_charging_current =
+			battery->pdata->age_data[battery->pdata->age_step].max_charging_current;
+
+		for (i = 0; i < POWER_SUPPLY_TYPE_MAX; i++) {
+			if (battery->pdata->charging_current[i].fast_charging_current >
+				battery->pdata->max_charging_current) {
+
+				dev_info(battery->dev, "%s: cable(%d) charging current(%d->%d)\n",
+					__func__, i,
+					battery->pdata->charging_current[i].fast_charging_current, 
+					battery->pdata->max_charging_current);
+				battery->pdata->charging_current[i].fast_charging_current =
+					battery->pdata->max_charging_current;
+				if (battery->cable_type == i)
+					bChanged = true;
+			}
+		}
+		if (bChanged)
+			sec_bat_set_charging_current(battery);
+	}
+#endif
+
+	return true;
+}
+
+static void sec_bat_aging_check(struct sec_battery_info *battery)
+{
+	int prev_step = battery->pdata->age_step;
+	int calc_step = -1;
+	bool ret = 0;
+
+	if (battery->pdata->num_age_step <= 0 || battery->batt_cycle < 0)
+		return;
+
+	if (battery->temperature < 50) {
+		pr_info("%s: [AGE] skip (temperature:%d)\n", __func__, battery->temperature);
+		return;
+	}
+
+	for (calc_step = battery->pdata->num_age_step - 1; calc_step >= 0; calc_step--) {
+		if (battery->pdata->age_data[calc_step].cycle <= battery->batt_cycle)
+			break;
+	}
+
+	dev_info(battery->dev,
+		 "%s: [Long life] prev_step = %d, calc_step = %d\n",  __func__, prev_step, calc_step);
+
+	if (calc_step == prev_step)
+		return;
+
+	ret = sec_bat_set_aging_step(battery, calc_step);
+	dev_info(battery->dev,
+		 "%s: %s change step (%d->%d), Cycle(%d)\n",
+		 __func__, ret ? "Succeed in" : "Fail to",
+		 prev_step, battery->pdata->age_step, battery->batt_cycle);
+}
+#endif
+
+static bool sec_bat_temperature_check(
+				struct sec_battery_info *battery)
+{
+	int temp_value = 0;
+	int pre_health = POWER_SUPPLY_HEALTH_GOOD;
+
+	if (battery->status == POWER_SUPPLY_STATUS_DISCHARGING) {
+		battery->health_change = false;
+		dev_dbg(battery->dev,
+			"%s: Charging Disabled\n", __func__);
+		return true;
+	}
+
+	if (battery->health != POWER_SUPPLY_HEALTH_GOOD &&
+		battery->health != POWER_SUPPLY_HEALTH_OVERHEAT &&
+		battery->health != POWER_SUPPLY_HEALTH_COLD &&
+		battery->health != POWER_SUPPLY_HEALTH_OVERHEATLIMIT) {
+		dev_dbg(battery->dev, "%s: No need to check\n", __func__);
+		return false;
+	}
+
+	sec_bat_temperature(battery);
+
+	switch (battery->pdata->temp_check_type) {
+	case SEC_BATTERY_TEMP_CHECK_ADC:
+		temp_value = battery->temp_adc;
+		break;
+	case SEC_BATTERY_TEMP_CHECK_TEMP:
+		temp_value = battery->temperature;
+		break;
+	default:
+		dev_err(battery->dev,
+			"%s: Invalid Temp Check Type\n", __func__);
+		return true;
+	}
+	pre_health = battery->health;
+
+	if (temp_value >= battery->temp_highlimit_threshold) {
+		if (battery->health != POWER_SUPPLY_HEALTH_OVERHEATLIMIT) {
+			if (battery->temp_highlimit_cnt <
+			    battery->pdata->temp_check_count) {
+				battery->temp_highlimit_cnt++;
+				battery->temp_high_cnt = 0;
+				battery->temp_low_cnt = 0;
+				battery->temp_recover_cnt = 0;
+			}
+			dev_dbg(battery->dev,
+				"%s: highlimit count = %d\n",
+				__func__, battery->temp_highlimit_cnt);
+		}
+	} else if (temp_value >= battery->temp_high_threshold) {
+		if (battery->health == POWER_SUPPLY_HEALTH_OVERHEATLIMIT) {
+			if (temp_value <= battery->temp_highlimit_recovery) {
+				if (battery->temp_recover_cnt <
+				    battery->pdata->temp_check_count) {
+					battery->temp_recover_cnt++;
+					battery->temp_highlimit_cnt = 0;
+					battery->temp_high_cnt = 0;
+					battery->temp_low_cnt = 0;
+				}
+				dev_dbg(battery->dev,
+					"%s: recovery count = %d\n",
+					__func__, battery->temp_recover_cnt);
+			}
+		} else if (battery->health != POWER_SUPPLY_HEALTH_OVERHEAT) {
+			if (battery->temp_high_cnt <
+			    battery->pdata->temp_check_count) {
+				battery->temp_high_cnt++;
+				battery->temp_highlimit_cnt = 0;
+				battery->temp_low_cnt = 0;
+				battery->temp_recover_cnt = 0;
+			}
+			dev_dbg(battery->dev,
+				"%s: high count = %d\n",
+				__func__, battery->temp_high_cnt);
+		}
+	} else if ((temp_value <= battery->temp_high_recovery) &&
+				(temp_value >= battery->temp_low_recovery)) {
+		if (battery->health == POWER_SUPPLY_HEALTH_OVERHEAT ||
+			battery->health == POWER_SUPPLY_HEALTH_OVERHEATLIMIT ||
+		    battery->health == POWER_SUPPLY_HEALTH_COLD) {
+			if (battery->temp_recover_cnt <
+			    battery->pdata->temp_check_count) {
+				battery->temp_recover_cnt++;
+				battery->temp_highlimit_cnt = 0;
+				battery->temp_high_cnt = 0;
+				battery->temp_low_cnt = 0;
+			}
+			dev_dbg(battery->dev,
+				"%s: recovery count = %d\n",
+				__func__, battery->temp_recover_cnt);
+		}
+	} else if (temp_value <= battery->temp_low_threshold) {
+		if (battery->health != POWER_SUPPLY_HEALTH_COLD) {
+			if (battery->temp_low_cnt <
+			    battery->pdata->temp_check_count) {
+				battery->temp_low_cnt++;
+				battery->temp_highlimit_cnt = 0;
+				battery->temp_high_cnt = 0;
+				battery->temp_recover_cnt = 0;
+			}
+			dev_dbg(battery->dev,
+				"%s: low count = %d\n",
+				__func__, battery->temp_low_cnt);
+		}
+	} else {
+		battery->temp_highlimit_cnt = 0;
+		battery->temp_high_cnt = 0;
+		battery->temp_low_cnt = 0;
+		battery->temp_recover_cnt = 0;
+	}
+
+	if (battery->temp_highlimit_cnt >=
+	    battery->pdata->temp_check_count) {
+		battery->health = POWER_SUPPLY_HEALTH_OVERHEATLIMIT;
+		battery->temp_highlimit_cnt = 0;
+	} else if (battery->temp_high_cnt >=
+		battery->pdata->temp_check_count) {
+		battery->health = POWER_SUPPLY_HEALTH_OVERHEAT;
+		battery->temp_high_cnt = 0;
+	} else if (battery->temp_low_cnt >=
+		battery->pdata->temp_check_count) {
+		battery->health = POWER_SUPPLY_HEALTH_COLD;
+		battery->temp_low_cnt = 0;
+	} else if (battery->temp_recover_cnt >=
+		 battery->pdata->temp_check_count) {
+		if (battery->health == POWER_SUPPLY_HEALTH_OVERHEATLIMIT) {
+			battery->health = POWER_SUPPLY_HEALTH_OVERHEAT;
+		} else {
+			battery->health = POWER_SUPPLY_HEALTH_GOOD;
+		}
+		battery->temp_recover_cnt = 0;
+	}
+	if (pre_health != battery->health) {
+		battery->health_change = true;
+		dev_info(battery->dev, "%s, health_change true\n", __func__);
+	} else {
+		battery->health_change = false;
+	}
+
+	if ((battery->health == POWER_SUPPLY_HEALTH_OVERHEAT) ||
+		(battery->health == POWER_SUPPLY_HEALTH_COLD) ||
+		(battery->health == POWER_SUPPLY_HEALTH_OVERHEATLIMIT)) {
+		if (battery->health_change) {
+#if defined(CONFIG_BATTERY_SWELLING_SELF_DISCHARGING) || defined(CONFIG_SW_SELF_DISCHARGING)
+			if ((battery->health == POWER_SUPPLY_HEALTH_OVERHEAT) ||
+				(battery->health == POWER_SUPPLY_HEALTH_OVERHEATLIMIT)) {
+				union power_supply_propval val;
+				/* change 4.20V float voltage */
+				val.intval = battery->pdata->swelling_drop_float_voltage;
+				psy_do_property(battery->pdata->charger_name, set,
+						POWER_SUPPLY_PROP_VOLTAGE_MAX, val);
+			}
+#endif
+			union power_supply_propval val;
+			if (is_wireless_type(battery->cable_type)) {
+				val.intval = battery->health;
+				psy_do_property(battery->pdata->wireless_charger_name, set,
+						POWER_SUPPLY_PROP_HEALTH, val);
+			}
+			dev_info(battery->dev,
+				"%s: Unsafe Temperature\n", __func__);
+			sec_bat_set_charging_status(battery,
+					POWER_SUPPLY_STATUS_NOT_CHARGING);
+#if defined(CONFIG_BATTERY_CISD)
+			battery->cisd.data[CISD_UNSAFE_TEMPERATURE]++;
+#endif
+
+			if (battery->health == POWER_SUPPLY_HEALTH_OVERHEATLIMIT) {
+				/* change charging current to battery (default 0mA) */
+				sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_BUCK_OFF);
+			} else {
+				sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING_OFF);
+			}
+
+			psy_do_property(battery->pdata->charger_name, get,
+					POWER_SUPPLY_PROP_VOLTAGE_MAX, val);
+			if (val.intval != battery->pdata->swelling_drop_float_voltage) {
+				val.intval = battery->pdata->swelling_drop_float_voltage;
+				psy_do_property(battery->pdata->charger_name, set,
+						POWER_SUPPLY_PROP_VOLTAGE_MAX, val);
+
+			}
+			return false;
+		}
+	} else {
+		/* if recovered from not charging */
+		if ((battery->health == POWER_SUPPLY_HEALTH_GOOD) &&
+			(battery->status ==
+			 POWER_SUPPLY_STATUS_NOT_CHARGING)) {
+			dev_info(battery->dev,
+					"%s: Safe Temperature\n", __func__);
+			if (battery->capacity >= 100)
+				sec_bat_set_charging_status(battery,
+						POWER_SUPPLY_STATUS_FULL);
+			else	/* Normal Charging */
+				sec_bat_set_charging_status(battery,
+						POWER_SUPPLY_STATUS_CHARGING);
+#if defined(CONFIG_BATTERY_SWELLING)
+			if ((temp_value >= battery->pdata->swelling_high_temp_recov) ||
+				(temp_value <= battery->pdata->swelling_low_temp_recov_2nd)) {
+				pr_info("%s: swelling mode start. stop charging\n", __func__);
+				battery->swelling_mode = SWELLING_MODE_CHARGING;
+				battery->swelling_full_check_cnt = 0;
+				sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING_OFF);
+			} else {
+				union power_supply_propval val = {0, };
+				/* restore float voltage */
+				val.intval = battery->pdata->swelling_normal_float_voltage;
+				psy_do_property(battery->pdata->charger_name, set,
+						POWER_SUPPLY_PROP_VOLTAGE_MAX, val);
+				/* turn on charger by cable type */
+				if((battery->status == POWER_SUPPLY_STATUS_FULL) &&
+						(battery->charging_mode == SEC_BATTERY_CHARGING_NONE)) {
+					sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING_OFF);
+				} else {
+					sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING);
+				}
+			}
+#else
+			/* turn on charger by cable type */
+			if((battery->status == POWER_SUPPLY_STATUS_FULL) &&
+					(battery->charging_mode == SEC_BATTERY_CHARGING_NONE)) {
+				sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING_OFF);
+			} else {
+				sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING);
+			}
+#endif
+			return false;
+		}
+	}
+	return true;
+}
+
+static int sec_bat_get_inbat_vol_by_adc(struct sec_battery_info *battery)
+{
+	int inbat = 0;
+	int inbat_adc;
+	int low = 0;
+	int high = 0;
+	int mid = 0;
+	const sec_bat_adc_table_data_t *inbat_adc_table;
+	unsigned int inbat_adc_table_size;
+
+	if (!battery->pdata->inbat_adc_table) {
+		dev_err(battery->dev, "%s: not designed to read in-bat voltage\n", __func__);
+		return -1;
+	}
+
+	inbat_adc_table = battery->pdata->inbat_adc_table;
+	inbat_adc_table_size =
+		battery->pdata->inbat_adc_table_size;
+
+	inbat_adc = sec_bat_get_adc_value(battery, SEC_BAT_ADC_CHANNEL_INBAT_VOLTAGE);
+	if (inbat_adc <= 0)
+		return inbat_adc;
+	battery->inbat_adc = inbat_adc;
+
+	if (inbat_adc_table[0].adc <= inbat_adc) {
+		inbat = inbat_adc_table[0].data;
+		goto inbat_by_adc_goto;
+	} else if (inbat_adc_table[inbat_adc_table_size-1].adc >= inbat_adc) {
+		inbat = inbat_adc_table[inbat_adc_table_size-1].data;
+		goto inbat_by_adc_goto;
+	}
+
+	high = inbat_adc_table_size - 1;
+
+	while (low <= high) {
+		mid = (low + high) / 2;
+		if (inbat_adc_table[mid].adc < inbat_adc)
+			high = mid - 1;
+		else if (inbat_adc_table[mid].adc > inbat_adc)
+			low = mid + 1;
+		else {
+			inbat = inbat_adc_table[mid].data;
+			goto inbat_by_adc_goto;
+		}
+	}
+
+	inbat = inbat_adc_table[high].data;
+	inbat +=
+		((inbat_adc_table[low].data - inbat_adc_table[high].data) *
+		 (inbat_adc - inbat_adc_table[high].adc)) /
+		(inbat_adc_table[low].adc - inbat_adc_table[high].adc);
+
+	if (inbat < 0)
+		inbat = 0;
+
+inbat_by_adc_goto:
+	dev_info(battery->dev,
+			"%s: inbat(%d), inbat-ADC(%d)\n",
+			__func__, inbat, inbat_adc);
+
+	return inbat;
+}
+
+static bool sec_bat_check_fullcharged_condition(
+					struct sec_battery_info *battery)
+{
+	int full_check_type = SEC_BATTERY_FULLCHARGED_NONE;
+
+	if (battery->charging_mode == SEC_BATTERY_CHARGING_1ST)
+		full_check_type = battery->pdata->full_check_type;
+	else
+		full_check_type = battery->pdata->full_check_type_2nd;
+
+	switch (full_check_type) {
+	case SEC_BATTERY_FULLCHARGED_ADC:
+	case SEC_BATTERY_FULLCHARGED_FG_CURRENT:
+	case SEC_BATTERY_FULLCHARGED_SOC:
+	case SEC_BATTERY_FULLCHARGED_CHGGPIO:
+	case SEC_BATTERY_FULLCHARGED_CHGPSY:
+		break;
+
+	/* If these is NOT full check type or NONE full check type,
+	 * it is full-charged
+	 */
+	case SEC_BATTERY_FULLCHARGED_CHGINT:
+	case SEC_BATTERY_FULLCHARGED_TIME:
+	case SEC_BATTERY_FULLCHARGED_NONE:
+	default:
+		return true;
+		break;
+	}
+
+	if (battery->pdata->full_condition_type &
+		SEC_BATTERY_FULL_CONDITION_SOC) {
+		if (battery->capacity <
+			battery->pdata->full_condition_soc) {
+			dev_dbg(battery->dev,
+				"%s: Not enough SOC (%d%%)\n",
+				__func__, battery->capacity);
+			return false;
+		}
+	}
+
+	if (battery->pdata->full_condition_type &
+		SEC_BATTERY_FULL_CONDITION_VCELL) {
+		if (battery->voltage_now <
+			battery->pdata->full_condition_vcell) {
+			dev_dbg(battery->dev,
+				"%s: Not enough VCELL (%dmV)\n",
+				__func__, battery->voltage_now);
+			return false;
+		}
+	}
+
+	if (battery->pdata->full_condition_type &
+		SEC_BATTERY_FULL_CONDITION_AVGVCELL) {
+		if (battery->voltage_avg <
+			battery->pdata->full_condition_avgvcell) {
+			dev_dbg(battery->dev,
+				"%s: Not enough AVGVCELL (%dmV)\n",
+				__func__, battery->voltage_avg);
+			return false;
+		}
+	}
+
+	if (battery->pdata->full_condition_type &
+		SEC_BATTERY_FULL_CONDITION_OCV) {
+		if (battery->voltage_ocv <
+			battery->pdata->full_condition_ocv) {
+			dev_dbg(battery->dev,
+				"%s: Not enough OCV (%dmV)\n",
+				__func__, battery->voltage_ocv);
+			return false;
+		}
+	}
+
+	return true;
+}
+
+static void sec_bat_do_test_function(
+		struct sec_battery_info *battery)
+{
+	union power_supply_propval value = {0, };
+
+	switch (battery->test_mode) {
+		case 1:
+			if (battery->status == POWER_SUPPLY_STATUS_CHARGING) {
+				sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING_OFF);
+				sec_bat_set_charging_status(battery,
+						POWER_SUPPLY_STATUS_DISCHARGING);
+			}
+			break;
+		case 2:
+			if (battery->status == POWER_SUPPLY_STATUS_DISCHARGING) {
+				sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING);
+				psy_do_property(battery->pdata->charger_name, get,
+						POWER_SUPPLY_PROP_STATUS, value);
+				sec_bat_set_charging_status(battery, value.intval);
+			}
+			battery->test_mode = 0;
+			break;
+		case 3: // clear temp block
+			battery->health = POWER_SUPPLY_HEALTH_GOOD;
+			sec_bat_set_charging_status(battery,
+					POWER_SUPPLY_STATUS_DISCHARGING);
+			break;
+		case 4:
+			if (battery->status == POWER_SUPPLY_STATUS_DISCHARGING) {
+				sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING);
+				psy_do_property(battery->pdata->charger_name, get,
+						POWER_SUPPLY_PROP_STATUS, value);
+				sec_bat_set_charging_status(battery, value.intval);
+			}
+			break;
+		default:
+			pr_info("%s: error test: unknown state\n", __func__);
+			break;
+	}
+}
+
+static bool sec_bat_time_management(
+				struct sec_battery_info *battery)
+{
+	struct timespec ts = {0, };
+	unsigned long charging_time;
+
+	if (battery->charging_start_time == 0 || !battery->safety_timer_set) {
+		dev_dbg(battery->dev,
+			"%s: Charging Disabled\n", __func__);
+		return true;
+	}
+
+	get_monotonic_boottime(&ts);
+
+	if (ts.tv_sec >= battery->charging_start_time) {
+		charging_time = ts.tv_sec - battery->charging_start_time;
+	} else {
+		charging_time = 0xFFFFFFFF - battery->charging_start_time
+			+ ts.tv_sec;
+	}
+
+	battery->charging_passed_time = charging_time;
+
+	switch (battery->status) {
+	case POWER_SUPPLY_STATUS_FULL:
+		if (battery->expired_time == 0) {
+			dev_info(battery->dev,
+				"%s: Recharging Timer Expired\n", __func__);
+			battery->charging_mode = SEC_BATTERY_CHARGING_NONE;
+			battery->health = POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE;
+			sec_bat_set_charging_status(battery, POWER_SUPPLY_STATUS_NOT_CHARGING);
+			battery->is_recharging = false;
+			if (sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING_OFF)) {
+				dev_err(battery->dev,
+					"%s: Fail to Set Charger\n", __func__);
+				return true;
+			}
+
+			return false;
+		}
+		break;
+	case POWER_SUPPLY_STATUS_CHARGING:
+		if ((battery->pdata->full_condition_type &
+		     SEC_BATTERY_FULL_CONDITION_NOTIMEFULL) &&
+		    (battery->is_recharging && (battery->expired_time == 0))) {
+			dev_info(battery->dev,
+			"%s: Recharging Timer Expired\n", __func__);
+			battery->charging_mode = SEC_BATTERY_CHARGING_NONE;
+			battery->health = POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE;
+			sec_bat_set_charging_status(battery, POWER_SUPPLY_STATUS_NOT_CHARGING);
+			battery->is_recharging = false;
+			if (sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING_OFF)) {
+				dev_err(battery->dev,
+					"%s: Fail to Set Charger\n", __func__);
+				return true;
+			}
+			return false;
+		} else if (!battery->is_recharging &&
+			   (battery->expired_time == 0)) {
+			dev_info(battery->dev,
+				"%s: Charging Timer Expired\n", __func__);
+			battery->charging_mode = SEC_BATTERY_CHARGING_NONE;
+			battery->health = POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE;
+			sec_bat_set_charging_status(battery, POWER_SUPPLY_STATUS_NOT_CHARGING);
+#if defined(CONFIG_BATTERY_CISD)
+			battery->cisd.data[CISD_SAFETY_TIMER]++;
+#endif
+#if defined(CONFIG_SEC_ABC)
+			sec_abc_send_event("MODULE=battery@ERROR=safety_timer");
+#endif
+			if (sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING_OFF)) {
+				dev_err(battery->dev,
+					"%s: Fail to Set Charger\n", __func__);
+				return true;
+			}
+#if 0
+			if (charging_total_time == battery->pdata->hv_charging_total_time)
+				battery->cisd.data[CISD_DATA_SAFETY_TIMER_3]++;
+			else if (charging_total_time == battery->pdata->normal_charging_total_time)
+				battery->cisd.data[CISD_DATA_SAFETY_TIMER_5]++;
+			else
+				battery->cisd.data[CISD_DATA_SAFETY_TIMER_10]++;
+#endif
+			return false;
+		}
+		break;
+	default:
+		dev_err(battery->dev,
+			"%s: Undefine Battery Status\n", __func__);
+		return true;
+	}
+
+	return true;
+}
+
+static bool sec_bat_check_fullcharged(
+				struct sec_battery_info *battery)
+{
+	union power_supply_propval value = {0, };
+	int current_adc = 0;
+	int full_check_type = SEC_BATTERY_FULLCHARGED_NONE;
+	bool ret = false;
+	int err = 0;
+
+	if (!sec_bat_check_fullcharged_condition(battery))
+		goto not_full_charged;
+
+	if (battery->charging_mode == SEC_BATTERY_CHARGING_1ST)
+		full_check_type = battery->pdata->full_check_type;
+	else
+		full_check_type = battery->pdata->full_check_type_2nd;
+
+	switch (full_check_type) {
+	case SEC_BATTERY_FULLCHARGED_ADC:
+		current_adc =
+			sec_bat_get_adc_value(battery,
+			SEC_BAT_ADC_CHANNEL_FULL_CHECK);
+
+		dev_dbg(battery->dev,
+			"%s: Current ADC (%d)\n",
+			__func__, current_adc);
+
+		if (current_adc < 0)
+			break;
+		battery->current_adc = current_adc;
+
+		if (battery->current_adc <
+			(battery->charging_mode ==
+			SEC_BATTERY_CHARGING_1ST ?
+			battery->pdata->charging_current[
+			battery->cable_type].full_check_current_1st :
+			battery->pdata->charging_current[
+			battery->cable_type].full_check_current_2nd)) {
+			battery->full_check_cnt++;
+			dev_dbg(battery->dev,
+				"%s: Full Check ADC (%d)\n",
+				__func__,
+				battery->full_check_cnt);
+		} else
+			battery->full_check_cnt = 0;
+		break;
+
+	case SEC_BATTERY_FULLCHARGED_FG_CURRENT:
+		if ((battery->current_now > 0 && battery->current_now <
+			battery->pdata->charging_current[
+			battery->cable_type].full_check_current_1st) &&
+			(battery->current_avg > 0 && battery->current_avg <
+			(battery->charging_mode ==
+			SEC_BATTERY_CHARGING_1ST ?
+			battery->pdata->charging_current[
+			battery->cable_type].full_check_current_1st :
+			battery->pdata->charging_current[
+			battery->cable_type].full_check_current_2nd))) {
+				battery->full_check_cnt++;
+				dev_dbg(battery->dev,
+				"%s: Full Check Current (%d)\n",
+				__func__,
+				battery->full_check_cnt);
+		} else
+			battery->full_check_cnt = 0;
+		break;
+
+	case SEC_BATTERY_FULLCHARGED_TIME:
+		if ((battery->charging_mode ==
+			SEC_BATTERY_CHARGING_2ND ?
+			(battery->charging_passed_time -
+			battery->charging_fullcharged_time) :
+			battery->charging_passed_time) >
+			(battery->charging_mode ==
+			SEC_BATTERY_CHARGING_1ST ?
+			battery->pdata->charging_current[
+			battery->cable_type].full_check_current_1st :
+			battery->pdata->charging_current[
+			battery->cable_type].full_check_current_2nd)) {
+			battery->full_check_cnt++;
+			dev_dbg(battery->dev,
+				"%s: Full Check Time (%d)\n",
+				__func__,
+				battery->full_check_cnt);
+		} else
+			battery->full_check_cnt = 0;
+		break;
+
+	case SEC_BATTERY_FULLCHARGED_SOC:
+		if (battery->capacity <=
+			(battery->charging_mode ==
+			SEC_BATTERY_CHARGING_1ST ?
+			battery->pdata->charging_current[
+			battery->cable_type].full_check_current_1st :
+			battery->pdata->charging_current[
+			battery->cable_type].full_check_current_2nd)) {
+			battery->full_check_cnt++;
+			dev_dbg(battery->dev,
+				"%s: Full Check SOC (%d)\n",
+				__func__,
+				battery->full_check_cnt);
+		} else
+			battery->full_check_cnt = 0;
+		break;
+
+	case SEC_BATTERY_FULLCHARGED_CHGGPIO:
+		err = gpio_request(
+			battery->pdata->chg_gpio_full_check,
+			"GPIO_CHG_FULL");
+		if (err) {
+			dev_err(battery->dev,
+				"%s: Error in Request of GPIO\n", __func__);
+			break;
+		}
+		if (!(gpio_get_value_cansleep(
+			battery->pdata->chg_gpio_full_check) ^
+			!battery->pdata->chg_polarity_full_check)) {
+			battery->full_check_cnt++;
+			dev_dbg(battery->dev,
+				"%s: Full Check GPIO (%d)\n",
+				__func__, battery->full_check_cnt);
+		} else
+			battery->full_check_cnt = 0;
+		gpio_free(battery->pdata->chg_gpio_full_check);
+		break;
+
+	case SEC_BATTERY_FULLCHARGED_CHGINT:
+	case SEC_BATTERY_FULLCHARGED_CHGPSY:
+		psy_do_property(battery->pdata->charger_name, get,
+			POWER_SUPPLY_PROP_STATUS, value);
+
+		if (value.intval == POWER_SUPPLY_STATUS_FULL) {
+			battery->full_check_cnt++;
+			dev_info(battery->dev,
+				"%s: Full Check Charger (%d)\n",
+				__func__, battery->full_check_cnt);
+		} else
+			battery->full_check_cnt = 0;
+		break;
+
+	/* If these is NOT full check type or NONE full check type,
+	 * it is full-charged
+	 */
+	case SEC_BATTERY_FULLCHARGED_NONE:
+		battery->full_check_cnt = 0;
+		ret = true;
+		break;
+	default:
+		dev_err(battery->dev,
+			"%s: Invalid Full Check\n", __func__);
+		break;
+	}
+
+	if (battery->full_check_cnt >=
+		battery->pdata->full_check_count) {
+		battery->full_check_cnt = 0;
+		ret = true;
+	}
+
+not_full_charged:
+	return ret;
+}
+
+static void sec_bat_do_fullcharged(
+				struct sec_battery_info *battery)
+{
+	union power_supply_propval value = {0, };
+
+	/* To let charger/fuel gauge know the full status,
+	 * set status before calling sec_bat_set_charge()
+	 */
+#if defined(CONFIG_BATTERY_CISD)
+	struct timespec now_ts;
+
+	if (battery->status != POWER_SUPPLY_STATUS_FULL)
+		battery->cisd.data[CISD_DATA_FULL_COUNT]++;
+#endif
+	sec_bat_set_charging_status(battery,
+			POWER_SUPPLY_STATUS_FULL);
+
+	if (battery->charging_mode == SEC_BATTERY_CHARGING_1ST &&
+		battery->pdata->full_check_type_2nd != SEC_BATTERY_FULLCHARGED_NONE) {
+		battery->charging_mode = SEC_BATTERY_CHARGING_2ND;
+		battery->charging_fullcharged_time = battery->charging_passed_time;
+		value.intval = SEC_BAT_CHG_MODE_CHARGING_OFF;
+		psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_CHARGING_ENABLED, value);
+		value.intval = POWER_SUPPLY_STATUS_FULL;
+        psy_do_property(battery->pdata->fuelgauge_name, set,
+				POWER_SUPPLY_PROP_STATUS, value);
+		sec_bat_set_charging_current(battery);
+		sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING);
+	} else {
+		battery->charging_mode = SEC_BATTERY_CHARGING_NONE;
+#if defined(CONFIG_BATTERY_CISD)
+		now_ts = ktime_to_timespec(ktime_get_boottime());
+		if (!battery->is_recharging) {
+			battery->cisd.charging_end_time = now_ts.tv_sec;
+		}
+		if (battery->siop_level == 100) {
+			dev_info(battery->dev, "%s: cisd - leakage EFGH start(%ld)\n", __func__, ((unsigned long)now_ts.tv_sec));
+			battery->cisd.state &= ~(CISD_STATE_LEAK_E|CISD_STATE_LEAK_F|CISD_STATE_LEAK_G);
+			battery->cisd.charging_end_time_2 = now_ts.tv_sec;
+			battery->cisd.recharge_count_2 = 0;
+		} else {
+			battery->cisd.state &= ~(CISD_STATE_LEAK_E|CISD_STATE_LEAK_F|CISD_STATE_LEAK_G);
+			battery->cisd.recharge_count_2 = 0;
+			battery->cisd.charging_end_time_2 = 0;
+		}
+#endif
+		battery->is_recharging = false;
+
+		if (!battery->wdt_kick_disable) {
+			pr_info("%s: wdt kick enable -> Charger Off, %d\n",
+					__func__, battery->wdt_kick_disable);
+			sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING_OFF);
+		} else {
+			pr_info("%s: wdt kick disabled -> skip charger off, %d\n",
+					__func__, battery->wdt_kick_disable);
+		}
+
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+		sec_bat_aging_check(battery);
+#endif
+
+		value.intval = POWER_SUPPLY_STATUS_FULL;
+		psy_do_property(battery->pdata->fuelgauge_name, set,
+			POWER_SUPPLY_PROP_STATUS, value);
+	}
+
+	/* platform can NOT get information of battery
+	 * because wakeup time is too short to check uevent
+	 * To make sure that target is wakeup if full-charged,
+	 * activated wake lock in a few seconds
+	 */
+	if (battery->pdata->polling_type == SEC_BATTERY_MONITOR_ALARM)
+		wake_lock_timeout(&battery->vbus_wake_lock, HZ * 10);
+}
+
+static bool sec_bat_fullcharged_check(
+				struct sec_battery_info *battery)
+{
+	if ((battery->charging_mode == SEC_BATTERY_CHARGING_NONE) ||
+		(battery->status == POWER_SUPPLY_STATUS_NOT_CHARGING)) {
+		dev_dbg(battery->dev,
+			"%s: No Need to Check Full-Charged\n", __func__);
+		return true;
+	}
+
+	if (sec_bat_check_fullcharged(battery)) {
+		union power_supply_propval value = {0, };
+		if (battery->capacity < 100) {
+			battery->full_check_cnt = battery->pdata->full_check_count;
+		} else {
+			sec_bat_do_fullcharged(battery);
+		}
+
+		/* update capacity max */
+		value.intval = battery->capacity;
+		psy_do_property(battery->pdata->fuelgauge_name, set,
+				POWER_SUPPLY_PROP_CHARGE_FULL, value);
+		pr_info("%s : forced full-charged sequence for the capacity(%d)\n",
+				__func__, battery->capacity);
+	}
+
+	dev_info(battery->dev,
+		"%s: Charging Mode : %s\n", __func__,
+		battery->is_recharging ?
+		sec_bat_charging_mode_str[SEC_BATTERY_CHARGING_RECHARGING] :
+		sec_bat_charging_mode_str[battery->charging_mode]);
+
+	return true;
+}
+
+static void sec_bat_get_temperature_info(
+				struct sec_battery_info *battery)
+{
+	union power_supply_propval value = {0, };
+
+	switch (battery->pdata->thermal_source) {
+	case SEC_BATTERY_THERMAL_SOURCE_FG:
+		psy_do_property(battery->pdata->fuelgauge_name, get,
+			POWER_SUPPLY_PROP_TEMP, value);
+		battery->temperature = value.intval;
+
+		psy_do_property(battery->pdata->fuelgauge_name, get,
+			POWER_SUPPLY_PROP_TEMP_AMBIENT, value);
+		battery->temper_amb = value.intval;
+		break;
+	case SEC_BATTERY_THERMAL_SOURCE_CALLBACK:
+		if (battery->pdata->get_temperature_callback) {
+			battery->pdata->get_temperature_callback(
+				POWER_SUPPLY_PROP_TEMP, &value);
+			battery->temperature = value.intval;
+			psy_do_property(battery->pdata->fuelgauge_name, set,
+				POWER_SUPPLY_PROP_TEMP, value);
+
+			battery->pdata->get_temperature_callback(
+				POWER_SUPPLY_PROP_TEMP_AMBIENT, &value);
+			battery->temper_amb = value.intval;
+			psy_do_property(battery->pdata->fuelgauge_name, set,
+				POWER_SUPPLY_PROP_TEMP_AMBIENT, value);
+		}
+		break;
+	case SEC_BATTERY_THERMAL_SOURCE_ADC:
+		sec_bat_get_temperature_by_adc(battery,
+			SEC_BAT_ADC_CHANNEL_TEMP, &value);
+		battery->temperature = value.intval;
+		psy_do_property(battery->pdata->fuelgauge_name, set,
+			POWER_SUPPLY_PROP_TEMP, value);
+
+		sec_bat_get_temperature_by_adc(battery,
+			SEC_BAT_ADC_CHANNEL_TEMP_AMBIENT, &value);
+		battery->temper_amb = value.intval;
+		psy_do_property(battery->pdata->fuelgauge_name, set,
+			POWER_SUPPLY_PROP_TEMP_AMBIENT, value);
+
+		switch (battery->pdata->chg_thermal_source) {
+		case SEC_CHARGER_THERMAL_SOURCE_FG:
+			psy_do_property(battery->pdata->fuelgauge_name, get,
+				POWER_SUPPLY_PROP_TEMP, value);
+				battery->chg_temp = value.intval;
+			break;
+		case SEC_CHARGER_THERMAL_SOURCE_ADC:
+			sec_bat_get_temperature_by_adc(battery,
+				SEC_BAT_ADC_CHANNEL_CHG_TEMP, &value);
+				battery->chg_temp = value.intval;
+			break;
+		default:
+			value.intval = 0;
+			break;
+		}
+		
+		if (battery->pdata->usb_thermal_source) {
+			sec_bat_get_temperature_by_adc(battery,
+				   SEC_BAT_ADC_CHANNEL_USB_TEMP, &value);
+			battery->usb_temp = value.intval;
+		}
+
+		if (battery->pdata->wpc_thermal_source) {
+			sec_bat_get_temperature_by_adc(battery,
+				SEC_BAT_ADC_CHANNEL_WPC_TEMP, &value);
+			battery->wpc_temp = value.intval;
+		}
+
+		if (battery->pdata->slave_thermal_source) {
+			sec_bat_get_temperature_by_adc(battery,
+				SEC_BAT_ADC_CHANNEL_SLAVE_CHG_TEMP, &value);
+			battery->slave_chg_temp = value.intval;
+
+			/* set temperature */
+			value.intval = ((battery->slave_chg_temp) << 16) | (battery->chg_temp);
+			psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_TEMP, value);
+		}
+		break;
+	default:
+		break;
+	}
+
+#if defined(CONFIG_BATTERY_CISD)
+	if (battery->temperature > battery->cisd.data[CISD_DATA_BATT_TEMP_MAX])
+		battery->cisd.data[CISD_DATA_BATT_TEMP_MAX] = battery->temperature;
+	if (battery->temperature < battery->cisd.data[CISD_DATA_BATT_TEMP_MIN])
+		battery->cisd.data[CISD_DATA_BATT_TEMP_MIN] = battery->temperature;
+
+	if (battery->chg_temp > battery->cisd.data[CISD_DATA_CHG_TEMP_MAX])
+		battery->cisd.data[CISD_DATA_CHG_TEMP_MAX] = battery->chg_temp;
+	if (battery->chg_temp < battery->cisd.data[CISD_DATA_CHG_TEMP_MIN])
+		battery->cisd.data[CISD_DATA_CHG_TEMP_MIN] = battery->chg_temp;
+
+	if (battery->wpc_temp > battery->cisd.data[CISD_DATA_WPC_TEMP_MAX])
+		battery->cisd.data[CISD_DATA_WPC_TEMP_MAX] = battery->wpc_temp;
+	if (battery->wpc_temp < battery->cisd.data[CISD_DATA_WPC_TEMP_MIN])
+		battery->cisd.data[CISD_DATA_WPC_TEMP_MIN] = battery->wpc_temp;
+#endif
+
+}
+
+static void sec_bat_get_battery_info(
+				struct sec_battery_info *battery)
+{
+	union power_supply_propval value = {0, };
+
+	psy_do_property(battery->pdata->fuelgauge_name, get,
+		POWER_SUPPLY_PROP_VOLTAGE_NOW, value);
+	battery->voltage_now = value.intval;
+
+	value.intval = SEC_BATTERY_VOLTAGE_AVERAGE;
+	psy_do_property(battery->pdata->fuelgauge_name, get,
+		POWER_SUPPLY_PROP_VOLTAGE_AVG, value);
+	battery->voltage_avg = value.intval;
+
+	/* Do not call it to reduce time after cable_work, this funtion call FG full log*/
+	if (!(battery->current_event & SEC_BAT_CURRENT_EVENT_SKIP_HEATING_CONTROL)) {
+		value.intval = SEC_BATTERY_VOLTAGE_OCV;
+		psy_do_property(battery->pdata->fuelgauge_name, get,
+				POWER_SUPPLY_PROP_VOLTAGE_AVG, value);
+		battery->voltage_ocv = value.intval;
+	}
+
+	value.intval = SEC_BATTERY_CURRENT_MA;
+	psy_do_property(battery->pdata->fuelgauge_name, get,
+		POWER_SUPPLY_PROP_CURRENT_NOW, value);
+	battery->current_now = value.intval;
+
+	value.intval = SEC_BATTERY_CURRENT_MA;
+	psy_do_property(battery->pdata->fuelgauge_name, get,
+		POWER_SUPPLY_PROP_CURRENT_AVG, value);
+	battery->current_avg = value.intval;
+
+	/* input current limit in charger */
+	psy_do_property(battery->pdata->charger_name, get,
+		POWER_SUPPLY_PROP_CURRENT_MAX, value);
+	battery->current_max = value.intval;
+
+	/* check abnormal status for wireless charging */
+	if (is_wireless_type(battery->cable_type)) {
+		psy_do_property(battery->pdata->wireless_charger_name, set,
+			POWER_SUPPLY_PROP_ENERGY_NOW, value);
+	}
+
+	sec_bat_get_temperature_info(battery);
+
+	/* To get SOC value (NOT raw SOC), need to reset value */
+	value.intval = 0;
+	psy_do_property(battery->pdata->fuelgauge_name, get,
+			POWER_SUPPLY_PROP_CAPACITY, value);
+	/* if the battery status was full, and SOC wasn't 100% yet,
+		then ignore FG SOC, and report (previous SOC +1)% */
+	battery->capacity = value.intval;
+
+
+	dev_info(battery->dev,
+		"%s:Vnow(%dmV),Inow(%dmA),Imax(%dmA),SOC(%d%%),Tbat(%d),Tusb(%d),Tchg(%d),Twpc(%d)"
+		"\n", __func__,
+		battery->voltage_now, battery->current_now,
+		battery->current_max, battery->capacity,
+		battery->temperature, battery->usb_temp,
+		battery->chg_temp, battery->wpc_temp
+		);
+	dev_dbg(battery->dev,
+		"%s,Vavg(%dmV),Vocv(%dmV),Tamb(%d),"
+		"Iavg(%dmA),Iadc(%d)\n",
+		battery->present ? "Connected" : "Disconnected",
+		battery->voltage_avg, battery->voltage_ocv,
+		battery->temper_amb,
+		battery->current_avg, battery->current_adc);
+}
+
+static void sec_bat_polling_work(struct work_struct *work)
+{
+	struct sec_battery_info *battery = container_of(
+		work, struct sec_battery_info, polling_work.work);
+
+	wake_lock(&battery->monitor_wake_lock);
+	queue_delayed_work(battery->monitor_wqueue, &battery->monitor_work, 0);
+	dev_dbg(battery->dev, "%s: Activated\n", __func__);
+}
+
+static void sec_bat_program_alarm(
+				struct sec_battery_info *battery, int seconds)
+{
+	alarm_start(&battery->polling_alarm,
+		    ktime_add(battery->last_poll_time, ktime_set(seconds, 0)));
+}
+
+static unsigned int sec_bat_get_polling_time(
+	struct sec_battery_info *battery)
+{
+	if (battery->status ==
+		POWER_SUPPLY_STATUS_FULL)
+		battery->polling_time =
+			battery->pdata->polling_time[
+			POWER_SUPPLY_STATUS_CHARGING];
+	else
+		battery->polling_time =
+			battery->pdata->polling_time[
+			battery->status];
+
+	battery->polling_short = true;
+
+	switch (battery->status) {
+	case POWER_SUPPLY_STATUS_CHARGING:
+		if (battery->polling_in_sleep)
+			battery->polling_short = false;
+		break;
+	case POWER_SUPPLY_STATUS_DISCHARGING:
+		if (battery->polling_in_sleep && (battery->ps_enable != true)) {
+			battery->polling_time =
+				battery->pdata->polling_time[
+					SEC_BATTERY_POLLING_TIME_SLEEP];
+		} else
+			battery->polling_time =
+				battery->pdata->polling_time[
+				battery->status];
+		if (!battery->wc_enable) {
+			battery->polling_time = battery->pdata->polling_time[
+					SEC_BATTERY_POLLING_TIME_CHARGING];
+			pr_info("%s: wc_enable is false, polling time is 30sec\n", __func__);
+		}
+		battery->polling_short = false;
+		break;
+	case POWER_SUPPLY_STATUS_FULL:
+		if (battery->polling_in_sleep) {
+			if (!(battery->pdata->full_condition_type &
+				SEC_BATTERY_FULL_CONDITION_NOSLEEPINFULL) &&
+				battery->charging_mode ==
+				SEC_BATTERY_CHARGING_NONE) {
+				battery->polling_time =
+					battery->pdata->polling_time[
+						SEC_BATTERY_POLLING_TIME_SLEEP];
+			}
+			battery->polling_short = false;
+		} else {
+			if (battery->charging_mode ==
+				SEC_BATTERY_CHARGING_NONE)
+				battery->polling_short = false;
+		}
+		break;
+	case POWER_SUPPLY_STATUS_NOT_CHARGING:
+		if ((battery->health == POWER_SUPPLY_HEALTH_OVERVOLTAGE ||
+			(battery->health == POWER_SUPPLY_HEALTH_UNDERVOLTAGE)) &&
+			(battery->health_check_count > 0)) {
+			battery->health_check_count--;
+			battery->polling_time = 1;
+			battery->polling_short = false;
+		}
+		break;
+	}
+
+	if (battery->polling_short)
+		return battery->pdata->polling_time[
+			SEC_BATTERY_POLLING_TIME_BASIC];
+	/* set polling time to 46s to reduce current noise on wc */
+	else if (battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS &&
+			battery->status == POWER_SUPPLY_STATUS_CHARGING)
+		battery->polling_time = 46;
+
+	return battery->polling_time;
+}
+
+static bool sec_bat_is_short_polling(
+	struct sec_battery_info *battery)
+{
+	/* Change the full and short monitoring sequence
+	 * Originally, full monitoring was the last time of polling_count
+	 * But change full monitoring to first time
+	 * because temperature check is too late
+	 */
+	if (!battery->polling_short || battery->polling_count == 1)
+		return false;
+	else
+		return true;
+}
+
+static void sec_bat_update_polling_count(
+	struct sec_battery_info *battery)
+{
+	/* do NOT change polling count in sleep
+	 * even though it is short polling
+	 * to keep polling count along sleep/wakeup
+	 */
+	if (battery->polling_short && battery->polling_in_sleep)
+		return;
+
+	if (battery->polling_short &&
+		((battery->polling_time /
+		battery->pdata->polling_time[
+		SEC_BATTERY_POLLING_TIME_BASIC])
+		> battery->polling_count))
+		battery->polling_count++;
+	else
+		battery->polling_count = 1;	/* initial value = 1 */
+}
+
+static void sec_bat_set_polling(
+	struct sec_battery_info *battery)
+{
+	unsigned int polling_time_temp = 0;
+
+	dev_dbg(battery->dev, "%s: Start\n", __func__);
+
+	polling_time_temp = sec_bat_get_polling_time(battery);
+
+	dev_dbg(battery->dev,
+		"%s: Status:%s, Sleep:%s, Charging:%s, Short Poll:%s\n",
+		__func__, sec_bat_status_str[battery->status],
+		battery->polling_in_sleep ? "Yes" : "No",
+		(battery->charging_mode ==
+		SEC_BATTERY_CHARGING_NONE) ? "No" : "Yes",
+		battery->polling_short ? "Yes" : "No");
+	dev_dbg(battery->dev,
+		"%s: Polling time %d/%d sec.\n", __func__,
+		battery->polling_short ?
+		(polling_time_temp * battery->polling_count) :
+		polling_time_temp, battery->polling_time);
+
+	/* To sync with log above,
+	 * change polling count after log is displayed
+	 * Do NOT update polling count in initial monitor
+	 */
+	if (!battery->pdata->monitor_initial_count)
+		sec_bat_update_polling_count(battery);
+	else
+		dev_dbg(battery->dev,
+			"%s: Initial monitor %d times left.\n", __func__,
+			battery->pdata->monitor_initial_count);
+
+	switch (battery->pdata->polling_type) {
+	case SEC_BATTERY_MONITOR_WORKQUEUE:
+		if (battery->pdata->monitor_initial_count) {
+			battery->pdata->monitor_initial_count--;
+			schedule_delayed_work(&battery->polling_work, HZ);
+		} else
+			schedule_delayed_work(&battery->polling_work,
+				polling_time_temp * HZ);
+		break;
+	case SEC_BATTERY_MONITOR_ALARM:
+		battery->last_poll_time = ktime_get_boottime();
+
+		if (battery->pdata->monitor_initial_count) {
+			battery->pdata->monitor_initial_count--;
+			sec_bat_program_alarm(battery, 1);
+		} else
+			sec_bat_program_alarm(battery, polling_time_temp);
+		break;
+	case SEC_BATTERY_MONITOR_TIMER:
+		break;
+	default:
+		break;
+	}
+	dev_dbg(battery->dev, "%s: End\n", __func__);
+}
+
+/* OTG during HV wireless charging or sleep mode have 4.5W normal wireless charging UI */
+static bool sec_bat_hv_wc_normal_mode_check(struct sec_battery_info *battery)
+{
+	union power_supply_propval value = {0, };
+
+	psy_do_property(battery->pdata->charger_name, get,
+			POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL, value);
+	if (value.intval || sleep_mode) {
+		pr_info("%s: otg(%d), sleep_mode(%d)\n", __func__, value.intval, sleep_mode);
+		return true;
+	}
+	return false;
+}
+
+#if defined(CONFIG_BATTERY_SWELLING)
+static void sec_bat_swelling_fullcharged_check(struct sec_battery_info *battery)
+{
+	union power_supply_propval value = {0, };
+	int topoff_current = battery->pdata->charging_current[battery->cable_type].full_check_current_1st;
+
+	switch (battery->pdata->full_check_type_2nd) {
+	case SEC_BATTERY_FULLCHARGED_FG_CURRENT:
+		if (battery->current_event & SEC_BAT_CURRENT_EVENT_LOW_TEMP_SWELLING)
+			topoff_current = (topoff_current > battery->pdata->swelling_low_temp_topoff) ?
+				battery->pdata->swelling_low_temp_topoff : topoff_current;
+		else if (battery->current_event & SEC_BAT_CURRENT_EVENT_HIGH_TEMP_SWELLING)
+			topoff_current = (topoff_current > battery->pdata->swelling_high_temp_topoff) ?
+				battery->pdata->swelling_high_temp_topoff : topoff_current;
+
+		if ((battery->current_now > 0 && battery->current_now < topoff_current) &&
+			(battery->current_avg > 0 && battery->current_avg < topoff_current) &&
+			((battery->pdata->swelling_drop_float_voltage - 100) < battery->voltage_now)) {
+			value.intval = POWER_SUPPLY_STATUS_FULL;
+		}
+		break;
+	default:
+		psy_do_property(battery->pdata->charger_name, get,
+			POWER_SUPPLY_PROP_STATUS, value);
+		break;
+	}
+
+	if (value.intval == POWER_SUPPLY_STATUS_FULL) {
+		battery->swelling_full_check_cnt++;
+		pr_info("%s: Swelling mode full-charged check (%d)\n",
+			__func__, battery->swelling_full_check_cnt);
+	} else
+		battery->swelling_full_check_cnt = 0;
+
+	if (battery->swelling_full_check_cnt >=
+		battery->pdata->full_check_count) {
+		battery->swelling_full_check_cnt = 0;
+		battery->charging_mode = SEC_BATTERY_CHARGING_NONE;
+		battery->is_recharging = false;
+		battery->swelling_mode = SWELLING_MODE_FULL;
+		sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING_OFF);
+		battery->expired_time = battery->pdata->expired_time;
+		battery->prev_safety_time = 0;
+	}
+}
+#endif
+
+#if defined(CONFIG_CALC_TIME_TO_FULL)
+static void sec_bat_calc_time_to_full(struct sec_battery_info * battery)
+{
+	if (battery->status == POWER_SUPPLY_STATUS_CHARGING ||
+		(battery->status == POWER_SUPPLY_STATUS_FULL && battery->capacity != 100)) {
+		union power_supply_propval value = {0, };
+		int charge = 0;
+
+		if (is_hv_wire_12v_type(battery->cable_type) || battery->max_charge_power >= 20000) {
+			charge = battery->pdata->ttf_hv_12v_charge_current;
+		} else if (is_hv_wire_type(battery->cable_type) || battery->max_charge_power >= 15000 ||
+				(battery->cable_type == POWER_SUPPLY_TYPE_HV_MAINS_CHG_LIMIT)) {
+			charge = battery->pdata->ttf_hv_charge_current;
+		} else if (is_hv_wireless_type(battery->cable_type)) {
+			if (sec_bat_hv_wc_normal_mode_check(battery))
+				charge = battery->pdata->ttf_wireless_charge_current;
+			 else 
+				charge = battery->pdata->ttf_hv_wireless_charge_current;
+		} else {
+			charge = battery->max_charge_power / 5;
+		}
+		value.intval = charge;
+		psy_do_property(battery->pdata->fuelgauge_name, get,
+				POWER_SUPPLY_PROP_TIME_TO_FULL_NOW, value);
+		dev_info(battery->dev, "%s: T: %5d sec, passed time: %5ld, current: %d\n",
+				__func__, value.intval, battery->charging_passed_time, charge);
+		battery->timetofull = value.intval;
+	} else {
+		battery->timetofull = -1;
+	}
+}
+
+static void sec_bat_time_to_full_work(struct work_struct *work)
+{
+	struct sec_battery_info *battery = container_of(work,
+				struct sec_battery_info, timetofull_work.work);
+	union power_supply_propval value;
+
+	psy_do_property(battery->pdata->charger_name, get,
+		POWER_SUPPLY_PROP_CURRENT_MAX, value);
+	battery->current_max = value.intval;
+
+	value.intval = SEC_BATTERY_CURRENT_MA;
+	psy_do_property(battery->pdata->fuelgauge_name, get,
+		POWER_SUPPLY_PROP_CURRENT_NOW, value);
+	battery->current_now = value.intval;
+
+	value.intval = SEC_BATTERY_CURRENT_MA;
+	psy_do_property(battery->pdata->fuelgauge_name, get,
+		POWER_SUPPLY_PROP_CURRENT_AVG, value);
+	battery->current_avg = value.intval;
+
+	sec_bat_calc_time_to_full(battery);
+	battery->complete_timetofull = true;
+	dev_info(battery->dev, "%s: \n",__func__);
+	if (battery->voltage_now > 0)
+		battery->voltage_now--;
+	power_supply_changed(&battery->psy_bat);
+}
+#endif
+
+#if defined(CONFIG_ENABLE_100MA_CHARGING_BEFORE_USB_CONFIGURED)
+extern bool get_usb_enumeration_state(void);
+/* To disaply slow charging when usb charging 100MA*/
+static void sec_bat_check_slowcharging_work(struct work_struct *work)
+{
+	struct sec_battery_info *battery = container_of(work,
+				struct sec_battery_info, slowcharging_work.work);
+#if defined(CONFIG_CCIC_NOTIFIER)
+	if (battery->pdic_info.sink_status.rp_currentlvl == RP_CURRENT_LEVEL_DEFAULT &&
+		battery->cable_type == POWER_SUPPLY_TYPE_USB) {
+#else
+	if (battery->cable_type == POWER_SUPPLY_TYPE_USB) {
+#endif
+		if (!get_usb_enumeration_state() &&
+			(battery->current_event & SEC_BAT_CURRENT_EVENT_USB_100MA)) {
+			sec_bat_set_misc_event(battery, BATT_MISC_EVENT_TIMEOUT_OPEN_TYPE, 0);
+			battery->max_charge_power = battery->input_voltage * battery->current_max;
+		}
+	}
+	dev_info(battery->dev, "%s: \n",__func__);
+}
+#endif
+
+static void sec_bat_wc_cv_mode_check(struct sec_battery_info *battery)
+{
+	union power_supply_propval value = {0, };
+
+	pr_info("%s: battery->wc_cv_mode = %d \n", __func__, battery->wc_cv_mode);
+
+	if (battery->capacity >= battery->pdata->wireless_cc_cv) {
+		pr_info("%s: 4.5W WC Changed Vout input current limit\n", __func__);
+		battery->wc_cv_mode = true;
+		sec_bat_set_charging_current(battery);
+		value.intval = WIRELESS_VOUT_CC_CV_VOUT; // 5.5V
+		psy_do_property(battery->pdata->wireless_charger_name, set,
+			POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+		value.intval = WIRELESS_VRECT_ADJ_ROOM_5; // 80mv
+		psy_do_property(battery->pdata->wireless_charger_name, set,
+			POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+		if ((battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS ||
+			battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_STAND ||
+			battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK_TA)) {
+			value.intval = WIRELESS_CLAMP_ENABLE;
+			psy_do_property(battery->pdata->wireless_charger_name, set,
+				POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+		}
+		/* Change FOD values for CV mode */
+		value.intval = POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE;
+		psy_do_property(battery->pdata->wireless_charger_name, set,
+			POWER_SUPPLY_PROP_STATUS, value);
+	}
+}
+
+static void sec_bat_siop_work(struct work_struct *work)
+{
+	struct sec_battery_info *battery = container_of(work,
+				struct sec_battery_info, siop_work.work);
+#if 0
+#if defined(CONFIG_WIRELESS_CHARGER_HIGH_VOLTAGE)
+	if (battery->siop_event == SIOP_EVENT_WPC_CALL_START) {
+		value.intval = battery->siop_event;
+		pr_info("%s : set current by siop event(%d)\n",__func__, battery->siop_event);
+		psy_do_property(battery->pdata->charger_name, set,
+						POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN, value);
+		if (battery->capacity >= battery->pdata->wireless_cc_cv) {
+			pr_info("%s SIOP EVENT CALL START.\n", __func__);
+			value.intval = WIRELESS_VOUT_CV_CALL;
+			psy_do_property(battery->pdata->wireless_charger_name, set,
+							POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+		} else {
+			pr_info("%s SIOP EVENT CALL START.\n", __func__);
+			value.intval = WIRELESS_VOUT_CC_CALL;
+			psy_do_property(battery->pdata->wireless_charger_name, set,
+							POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+		}
+		wake_unlock(&battery->siop_wake_lock);
+		return;
+	} else if (battery->siop_event == SIOP_EVENT_WPC_CALL_END) {
+		battery->siop_event = 0;
+		value.intval = WIRELESS_VOUT_5V;
+		psy_do_property(battery->pdata->wireless_charger_name, set,
+						POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+	}
+#endif
+#endif
+	pr_info("%s : set current by siop level(%d)\n",__func__, battery->siop_level);
+
+	sec_bat_set_charging_current(battery);
+	wake_unlock(&battery->siop_wake_lock);
+}
+
+static void sec_bat_siop_level_work(struct work_struct *work)
+{
+	struct sec_battery_info *battery = container_of(work,
+			struct sec_battery_info, siop_level_work.work);
+
+	if (battery->siop_prev_event != battery->siop_event) {
+		wake_unlock(&battery->siop_level_wake_lock);
+		return;
+	}
+
+	if (is_wireless_type(battery->cable_type)) {
+		queue_delayed_work(battery->monitor_wqueue, &battery->siop_work, 0);
+	}
+	else
+		queue_delayed_work(battery->monitor_wqueue, &battery->siop_work, 0);
+
+	wake_lock(&battery->siop_wake_lock);
+	wake_unlock(&battery->siop_level_wake_lock);
+}
+
+static void sec_bat_wc_headroom_work(struct work_struct *work)
+{
+	struct sec_battery_info *battery = container_of(work,
+			struct sec_battery_info, wc_headroom_work.work);
+	union power_supply_propval value = {0, };
+
+	/* The default headroom is high, because initial wireless charging state is unstable.
+		After 10sec wireless charging, however, recover headroom level to avoid chipset damage */
+	if (battery->wc_status != SEC_WIRELESS_PAD_NONE) {
+		/* When the capacity is higher than 99, and the device is in 5V wireless charging state,
+			then Vrect headroom has to be headroom_2.
+			Refer to the sec_bat_siop_work function. */
+		if (battery->capacity < 99 && battery->status != POWER_SUPPLY_STATUS_FULL) {
+			if (battery->wc_status == SEC_WIRELESS_PAD_WPC ||
+				battery->wc_status == SEC_WIRELESS_PAD_WPC_PACK ||
+				battery->wc_status == SEC_WIRELESS_PAD_WPC_PACK_TA ||
+				battery->wc_status == SEC_WIRELESS_PAD_WPC_STAND) {
+				if (battery->capacity < battery->pdata->wireless_cc_cv)
+					value.intval = WIRELESS_VRECT_ADJ_ROOM_4; /* WPC 4.5W, Vrect Room 30mV */
+				else
+					value.intval = WIRELESS_VRECT_ADJ_ROOM_5; /* WPC 4.5W, Vrect Room 80mV */
+			} else if (battery->wc_status == SEC_WIRELESS_PAD_WPC_HV ||
+					battery->wc_status == SEC_WIRELESS_PAD_WPC_STAND_HV) {
+				value.intval = WIRELESS_VRECT_ADJ_ROOM_5;
+			} else {
+				value.intval = WIRELESS_VRECT_ADJ_OFF;
+			}
+			psy_do_property(battery->pdata->wireless_charger_name, set,
+				POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+			pr_info("%s: Changed Vrect adjustment from Rx activation(10seconds)", __func__);
+		}
+		if (battery->wc_status == SEC_WIRELESS_PAD_WPC ||
+			battery->wc_status == SEC_WIRELESS_PAD_WPC_PACK ||
+			battery->wc_status == SEC_WIRELESS_PAD_WPC_PACK_TA)
+			sec_bat_wc_cv_mode_check(battery);
+	}
+	wake_unlock(&battery->wc_headroom_wake_lock);
+}
+
+static void sec_bat_siop_event_work(struct work_struct *work)
+{
+	struct sec_battery_info *battery = container_of(work,
+			struct sec_battery_info, siop_event_work.work);
+
+	union power_supply_propval value = {0, };
+
+	if (battery->cable_type != POWER_SUPPLY_TYPE_WIRELESS_PACK &&
+		battery->cable_type != POWER_SUPPLY_TYPE_WIRELESS_PACK_TA) {
+		battery->siop_prev_event = battery->siop_event;
+		wake_unlock(&battery->siop_event_wake_lock);
+		return;
+	}
+
+	if (!(battery->siop_prev_event & SIOP_EVENT_WPC_CALL) && (battery->siop_event & SIOP_EVENT_WPC_CALL)) {
+		pr_info("%s : set current by siop event(%d)\n",__func__, battery->siop_event);
+		if (battery->capacity >= battery->pdata->wireless_cc_cv) {
+			pr_info("%s SIOP EVENT CALL CV START.\n", __func__);
+			value.intval = WIRELESS_VOUT_CV_CALL;
+		} else {
+			pr_info("%s SIOP EVENT CALL CC START.\n", __func__);
+			value.intval = WIRELESS_VOUT_CC_CALL;
+		}
+		/* set current first */
+		sec_bat_set_charging_current(battery);
+		psy_do_property(battery->pdata->wireless_charger_name, set,
+				POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+	} else if ((battery->siop_prev_event & SIOP_EVENT_WPC_CALL) && !(battery->siop_event & SIOP_EVENT_WPC_CALL)) {
+		if (battery->wc_cv_mode)
+			value.intval = WIRELESS_VOUT_CC_CV_VOUT; // 5.5V
+		else
+			value.intval = WIRELESS_VOUT_5V;
+		psy_do_property(battery->pdata->wireless_charger_name, set,
+				POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+		wake_lock(&battery->siop_level_wake_lock);
+		queue_delayed_work(battery->monitor_wqueue, &battery->siop_level_work, 0);
+	}
+	battery->siop_prev_event = battery->siop_event;
+	wake_unlock(&battery->siop_event_wake_lock);
+}
+
+#if defined(CONFIG_WIRELESS_FIRMWARE_UPDATE)
+static void sec_bat_fw_update_work(struct sec_battery_info *battery, int mode)
+{
+	union power_supply_propval value = {0, };
+
+	dev_info(battery->dev, "%s \n", __func__);
+
+	wake_lock_timeout(&battery->vbus_wake_lock, HZ * 10);
+
+	switch (mode) {
+		case SEC_WIRELESS_RX_SDCARD_MODE:
+		case SEC_WIRELESS_RX_BUILT_IN_MODE:
+			value.intval = true;
+			psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_CHARGE_UNO_CONTROL, value);
+
+			value.intval = mode;
+			psy_do_property(battery->pdata->wireless_charger_name, set,
+				POWER_SUPPLY_PROP_CHARGE_POWERED_OTG_CONTROL, value);
+
+			value.intval = false;
+			psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_CHARGE_UNO_CONTROL, value);
+
+			break;
+		case SEC_WIRELESS_TX_ON_MODE:
+			value.intval = true;
+			psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_CHARGE_UNO_CONTROL, value);
+
+			value.intval = mode;
+			psy_do_property(battery->pdata->wireless_charger_name, set,
+				POWER_SUPPLY_PROP_CHARGE_POWERED_OTG_CONTROL, value);
+
+			break;
+		case SEC_WIRELESS_TX_OFF_MODE:
+			value.intval = false;
+			psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_CHARGE_UNO_CONTROL, value);
+			break;
+		default:
+			break;
+	}
+}
+
+static void sec_bat_fw_init_work(struct work_struct *work)
+{
+	struct sec_battery_info *battery = container_of(work,
+				struct sec_battery_info, fw_init_work.work);
+
+	union power_supply_propval value = {0, };
+	int uno_status = 0, wpc_det = 0;
+
+	dev_info(battery->dev, "%s \n", __func__);
+
+	wpc_det = gpio_get_value(battery->pdata->wpc_det);
+
+	pr_info("%s wpc_det = %d \n", __func__, wpc_det);
+
+	psy_do_property(battery->pdata->charger_name, get,
+		POWER_SUPPLY_PROP_CHARGE_UNO_CONTROL, value);
+	uno_status = value.intval;
+	pr_info("%s uno = %d \n", __func__, uno_status);
+
+	if (!uno_status && !wpc_det) {
+		pr_info("%s uno on \n", __func__);
+		value.intval = true;
+		psy_do_property(battery->pdata->charger_name, set,
+			POWER_SUPPLY_PROP_CHARGE_UNO_CONTROL, value);
+	}
+
+	value.intval = SEC_WIRELESS_RX_INIT;
+	psy_do_property(battery->pdata->wireless_charger_name, set,
+		POWER_SUPPLY_PROP_CHARGE_POWERED_OTG_CONTROL, value);
+
+	if (!uno_status && !wpc_det) {
+		pr_info("%s uno off \n", __func__);
+		value.intval = false;
+		psy_do_property(battery->pdata->charger_name, set,
+			POWER_SUPPLY_PROP_CHARGE_UNO_CONTROL, value);
+	}
+}
+#endif
+#if defined(CONFIG_UPDATE_BATTERY_DATA)
+static int sec_bat_parse_dt(struct device *dev, struct sec_battery_info *battery);
+static void sec_bat_update_data_work(struct work_struct *work)
+{
+	struct sec_battery_info *battery = container_of(work,
+				struct sec_battery_info, batt_data_work.work);
+
+	sec_battery_update_data(battery->data_path);
+	wake_unlock(&battery->batt_data_wake_lock);
+}
+#endif
+
+static void sec_bat_calculate_safety_time(struct sec_battery_info *battery)
+{
+	unsigned long long expired_time = battery->expired_time;
+	struct timespec ts = {0, };
+	int curr = 0;
+	int input_power = battery->current_max * battery->input_voltage * 1000;
+	int charging_power = battery->charging_current * (battery->pdata->chg_float_voltage / battery->pdata->chg_float_voltage_conv);
+	static int discharging_cnt = 0;
+
+	if (battery->current_avg < 0) {
+		discharging_cnt++;
+	} else {
+		discharging_cnt = 0;
+	}
+
+	if (discharging_cnt >= 5) {
+		battery->expired_time = battery->pdata->expired_time;
+		battery->prev_safety_time = 0;
+		pr_info("%s : SAFETY TIME RESET! DISCHARGING CNT(%d)\n",
+			__func__, discharging_cnt);
+		discharging_cnt = 0;
+		return;
+	} else if (battery->lcd_status && battery->stop_timer) {
+		battery->prev_safety_time = 0;
+		return;
+	}
+
+	get_monotonic_boottime(&ts);
+
+	if (battery->prev_safety_time == 0) {
+		battery->prev_safety_time = ts.tv_sec;
+	}
+
+	if (input_power > charging_power) {
+		curr = battery->charging_current;
+	} else {
+		curr = input_power / (battery->pdata->chg_float_voltage / battery->pdata->chg_float_voltage_conv);
+		curr = (curr * 9) / 10;
+	}
+
+	if (battery->lcd_status && !battery->stop_timer) {
+		battery->stop_timer = true;
+	} else if (!battery->lcd_status && battery->stop_timer) {
+		battery->stop_timer = false;
+	}
+
+	pr_info("%s : EXPIRED_TIME(%llu), IP(%d), CP(%d), CURR(%d), STANDARD(%d)\n",
+		__func__, expired_time, input_power, charging_power, curr, battery->pdata->standard_curr);
+
+	if (curr == 0)
+		return;
+
+	expired_time = (expired_time * battery->pdata->standard_curr) / curr;
+
+	pr_info("%s : CAL_EXPIRED_TIME(%llu) TIME NOW(%ld) TIME PREV(%ld)\n", __func__, expired_time, ts.tv_sec, battery->prev_safety_time);
+
+	if (expired_time <= ((ts.tv_sec - battery->prev_safety_time) * 1000))
+		expired_time = 0;
+	else
+		expired_time -= ((ts.tv_sec - battery->prev_safety_time) * 1000);
+
+	battery->cal_safety_time = expired_time;
+	expired_time = (expired_time * curr) / battery->pdata->standard_curr;
+
+	battery->expired_time = expired_time;
+	battery->prev_safety_time = ts.tv_sec;
+	pr_info("%s : REMAIN_TIME(%ld) CAL_REMAIN_TIME(%ld)\n", __func__, battery->expired_time, battery->cal_safety_time);
+}
+
+static void sec_bat_monitor_work(
+				struct work_struct *work)
+{
+	struct sec_battery_info *battery =
+		container_of(work, struct sec_battery_info,
+		monitor_work.work);
+	static struct timespec old_ts = {0, };
+	struct timespec c_ts = {0, };
+
+	dev_dbg(battery->dev, "%s: Start\n", __func__);
+	c_ts = ktime_to_timespec(ktime_get_boottime());
+
+	if (!battery->wc_enable) {
+		pr_info("%s: wc_enable(%d), cnt(%d)\n",
+			__func__, battery->wc_enable, battery->wc_enable_cnt);
+		if (battery->wc_enable_cnt > battery->wc_enable_cnt_value) {
+			battery->wc_enable = true;
+			battery->wc_enable_cnt = 0;
+			if (battery->pdata->wpc_en) {
+				gpio_direction_output(battery->pdata->wpc_en, 0);
+				pr_info("%s: WC CONTROL: Enable", __func__);
+			}
+			pr_info("%s: wpc_en(%d)\n",
+				__func__, gpio_get_value(battery->pdata->wpc_en));
+		}
+		battery->wc_enable_cnt++;
+	}
+
+	/* monitor once after wakeup */
+	if (battery->polling_in_sleep) {
+		battery->polling_in_sleep = false;
+		if ((battery->status == POWER_SUPPLY_STATUS_DISCHARGING) &&
+			(battery->ps_enable != true)) {
+			if ((unsigned long)(c_ts.tv_sec - old_ts.tv_sec) < 10 * 60) {
+				union power_supply_propval value = {0, };
+
+					psy_do_property(battery->pdata->fuelgauge_name, get,
+						POWER_SUPPLY_PROP_VOLTAGE_NOW, value);
+					battery->voltage_now = value.intval;
+
+					value.intval = 0;
+					psy_do_property(battery->pdata->fuelgauge_name, get,
+							POWER_SUPPLY_PROP_CAPACITY, value);
+					battery->capacity = value.intval;
+
+					sec_bat_get_temperature_info(battery);
+#if defined(CONFIG_BATTERY_CISD)
+					sec_bat_cisd_check(battery);
+#endif
+					power_supply_changed(&battery->psy_bat);
+					pr_info("Skip monitor work(%ld, Vnow:%d(mV), SoC:%d(%%), Tbat:%d(0.1'C))\n",
+						c_ts.tv_sec - old_ts.tv_sec, battery->voltage_now, battery->capacity, battery->temperature);
+
+				goto skip_monitor;
+			}
+		}
+	}
+	/* update last monitor time */
+	old_ts = c_ts;
+
+	sec_bat_get_battery_info(battery);
+#if defined(CONFIG_BATTERY_CISD)
+	sec_bat_cisd_check(battery);
+#endif
+#if defined(CONFIG_STEP_CHARGING)
+	sec_bat_check_step_charging(battery);
+#endif
+#if defined(CONFIG_CALC_TIME_TO_FULL)
+	/* time to full check */
+	sec_bat_calc_time_to_full(battery);
+#endif
+
+	/* 0. test mode */
+	if (battery->test_mode) {
+		dev_err(battery->dev, "%s: Test Mode\n", __func__);
+		sec_bat_do_test_function(battery);
+		if (battery->test_mode != 0)
+			goto continue_monitor;
+	}
+
+	/* 1. battery check */
+	if (!sec_bat_battery_cable_check(battery))
+		goto continue_monitor;
+
+	/* 2. voltage check */
+	if (!sec_bat_voltage_check(battery))
+		goto continue_monitor;
+
+	/* monitor short routine in initial monitor */
+	if (battery->pdata->monitor_initial_count || sec_bat_is_short_polling(battery))
+		goto skip_current_monitor;
+
+	/* 3. time management */
+	if (!sec_bat_time_management(battery))
+		goto continue_monitor;
+
+	/* 4. temperature check */
+	if (!sec_bat_temperature_check(battery))
+		goto continue_monitor;
+
+#if defined(CONFIG_BATTERY_SWELLING)
+	sec_bat_swelling_check(battery, battery->temperature);
+
+	if ((battery->swelling_mode == SWELLING_MODE_CHARGING || battery->swelling_mode == SWELLING_MODE_FULL) &&
+		(!battery->charging_block))
+		sec_bat_swelling_fullcharged_check(battery);
+	else
+		sec_bat_fullcharged_check(battery);
+#else
+	/* 5. full charging check */
+	sec_bat_fullcharged_check(battery);
+#endif /* CONFIG_BATTERY_SWELLING */
+
+	/* 6. additional check */
+	if (battery->pdata->monitor_additional_check)
+		battery->pdata->monitor_additional_check();
+
+	if ((battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS ||
+		battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_STAND ||
+		battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK_TA) &&
+		!battery->wc_cv_mode && battery->charging_passed_time > 10)
+		sec_bat_wc_cv_mode_check(battery);
+
+continue_monitor:
+	/* clear HEATING_CONTROL*/
+	sec_bat_set_current_event(battery, SEC_BAT_CURRENT_EVENT_SKIP_HEATING_CONTROL, 1);
+	if (!battery->charging_block)
+		sec_bat_calculate_safety_time(battery);
+
+	/* set charging current */
+	sec_bat_set_charging_current(battery);
+
+skip_current_monitor:
+	dev_info(battery->dev,
+		 "%s: Status(%s), mode(%s), Health(%s), Cable(%d, %d, %d, %d), level(%d%%), slate_mode(%d), store_mode(%d)"
+#if defined(CONFIG_AFC_CHARGER_MODE)
+		", HV(%s), sleep_mode(%d)"
+#endif
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+#if defined(CONFIG_BATTERY_AGE_FORECAST_DETACHABLE)
+		", Cycle(%dw)"
+#else
+		", Cycle(%d)"
+#endif
+#endif
+		 "\n", __func__,
+		 sec_bat_status_str[battery->status],
+		 sec_bat_charging_mode_str[battery->charging_mode],
+		 sec_bat_health_str[battery->health],
+		 battery->cable_type, battery->wire_status,
+		 battery->muic_cable_type, battery->pd_usb_attached,
+		 battery->siop_level,
+		 battery->slate_mode,
+		 battery->store_mode
+#if defined(CONFIG_AFC_CHARGER_MODE)
+		, battery->hv_chg_name, sleep_mode
+#endif
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+		, battery->batt_cycle
+#endif
+		 );
+#if defined(CONFIG_SAMSUNG_BATTERY_ENG_TEST)
+	dev_info(battery->dev,
+			"%s: battery->stability_test(%d), battery->eng_not_full_status(%d)\n",
+			__func__, battery->stability_test, battery->eng_not_full_status);
+#endif
+#if defined(CONFIG_SEC_FACTORY)
+	if ((battery->cable_type != POWER_SUPPLY_TYPE_BATTERY) && (battery->cable_type != POWER_SUPPLY_TYPE_OTG)) {
+#else
+	if (battery->store_mode && battery->cable_type != POWER_SUPPLY_TYPE_BATTERY) {
+#endif
+		dev_info(battery->dev,
+			"%s: @battery->capacity = (%d), battery->status= (%d), battery->store_mode=(%d)\n",
+			__func__, battery->capacity, battery->status, battery->store_mode);
+
+		if ((battery->capacity >= STORE_MODE_CHARGING_MAX) && (battery->status == POWER_SUPPLY_STATUS_CHARGING)) {
+			sec_bat_set_charging_status(battery,
+					POWER_SUPPLY_STATUS_DISCHARGING);
+			sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING_OFF);
+		}
+		if ((battery->capacity <= STORE_MODE_CHARGING_MIN) && (battery->status == POWER_SUPPLY_STATUS_DISCHARGING)) {
+			sec_bat_set_charging_status(battery,
+					POWER_SUPPLY_STATUS_CHARGING);
+			sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING);
+		}
+		sec_bat_set_fg_learn(battery, 0);
+	}
+	power_supply_changed(&battery->psy_bat);
+
+skip_monitor:
+	sec_bat_set_polling(battery);
+
+	if (battery->capacity <= 0 || battery->health_change)
+		wake_lock_timeout(&battery->monitor_wake_lock, HZ * 5);
+	else
+		wake_unlock(&battery->monitor_wake_lock);
+
+	dev_dbg(battery->dev, "%s: End\n", __func__);
+
+	return;
+}
+
+static enum alarmtimer_restart sec_bat_alarm(
+	struct alarm *alarm, ktime_t now)
+{
+	struct sec_battery_info *battery = container_of(alarm,
+				struct sec_battery_info, polling_alarm);
+
+	dev_dbg(battery->dev,
+			"%s\n", __func__);
+
+	/* In wake up, monitor work will be queued in complete function
+	 * To avoid duplicated queuing of monitor work,
+	 * do NOT queue monitor work in wake up by polling alarm
+	 */
+	if (!battery->polling_in_sleep) {
+		wake_lock(&battery->monitor_wake_lock);
+		queue_delayed_work(battery->monitor_wqueue, &battery->monitor_work, 0);
+		dev_dbg(battery->dev, "%s: Activated\n", __func__);
+	}
+
+	return ALARMTIMER_NORESTART;
+}
+
+static void sec_bat_check_input_voltage(struct sec_battery_info *battery)
+{
+	unsigned int voltage = 0;
+	int input_current = battery->pdata->charging_current[battery->cable_type].input_current_limit;
+
+	if (battery->cable_type == POWER_SUPPLY_TYPE_PDIC) {
+		battery->max_charge_power = battery->pd_max_charge_power;
+		return;
+	}
+	else if (is_hv_wire_12v_type(battery->cable_type))
+		voltage = SEC_INPUT_VOLTAGE_12V;
+	else if (is_hv_wire_9v_type(battery->cable_type))
+		voltage = SEC_INPUT_VOLTAGE_9V;
+	else if (is_hv_wireless_type(battery->cable_type))
+		voltage = SEC_INPUT_VOLTAGE_10V;
+	else
+		voltage = SEC_INPUT_VOLTAGE_5V;
+
+	battery->input_voltage = voltage;
+	battery->charge_power = voltage * input_current;
+#if !defined(CONFIG_SEC_FACTORY)
+	if (battery->charge_power > battery->max_charge_power)
+#endif
+	battery->max_charge_power = battery->charge_power;
+
+	pr_info("%s: battery->input_voltage : %dV, %dmW, %dmW)\n", __func__,
+		battery->input_voltage, battery->charge_power, battery->max_charge_power);
+}
+
+static void sec_bat_cable_work(struct work_struct *work)
+{
+	struct sec_battery_info *battery = container_of(work,
+				struct sec_battery_info, cable_work.work);
+	union power_supply_propval val = {0, };
+	int current_cable_type, prev_cable_type;
+	bool keep_charging_state = false;
+
+	dev_info(battery->dev, "%s: Start\n", __func__);
+	sec_bat_set_current_event(battery, SEC_BAT_CURRENT_EVENT_SKIP_HEATING_CONTROL, 0);
+#if defined(CONFIG_CCIC_NOTIFIER)
+	if (battery->wire_status == POWER_SUPPLY_TYPE_PDIC) {
+		sec_bat_get_input_current_in_power_list(battery);
+		sec_bat_get_charging_current_in_power_list(battery);
+	}
+#endif
+	if (battery->wc_status && battery->wc_enable) {
+		int wireless_current, wire_current;
+
+                if (battery->wc_status == SEC_WIRELESS_PAD_WPC) {
+			current_cable_type = POWER_SUPPLY_TYPE_WIRELESS;
+                } else if (battery->wc_status == SEC_WIRELESS_PAD_WPC_HV) {
+			current_cable_type = POWER_SUPPLY_TYPE_HV_WIRELESS;
+		} else if (battery->wc_status == SEC_WIRELESS_PAD_WPC_PACK) {
+			current_cable_type = POWER_SUPPLY_TYPE_WIRELESS_PACK;
+		} else if (battery->wc_status == SEC_WIRELESS_PAD_WPC_PACK_TA) {
+			current_cable_type = POWER_SUPPLY_TYPE_WIRELESS_PACK_TA;
+		} else if (battery->wc_status == SEC_WIRELESS_PAD_WPC_STAND) {
+			current_cable_type = POWER_SUPPLY_TYPE_WIRELESS_STAND;
+		} else if (battery->wc_status == SEC_WIRELESS_PAD_WPC_STAND_HV) {
+			current_cable_type = POWER_SUPPLY_TYPE_WIRELESS_HV_STAND;
+		} else {
+			current_cable_type = POWER_SUPPLY_TYPE_PMA_WIRELESS;
+                }
+
+		if (battery->wire_status != POWER_SUPPLY_TYPE_BATTERY) {
+			wireless_current = battery->pdata->charging_current[current_cable_type].input_current_limit;
+			wireless_current = wireless_current * (is_hv_wireless_type(current_cable_type) ?
+				SEC_INPUT_VOLTAGE_9V : SEC_INPUT_VOLTAGE_5V);
+			if (battery->wire_status == POWER_SUPPLY_TYPE_PDIC) {
+				if (wireless_current < battery->pd_max_charge_power)
+					current_cable_type = battery->wire_status;
+			} else {
+				wire_current = (battery->wire_status == POWER_SUPPLY_TYPE_HV_PREPARE_MAINS ?
+					battery->pdata->charging_current[POWER_SUPPLY_TYPE_MAINS].input_current_limit :
+					battery->pdata->charging_current[battery->wire_status].input_current_limit);
+
+				wire_current = wire_current * (is_hv_wire_type(battery->wire_status) ?
+					(battery->wire_status == POWER_SUPPLY_TYPE_HV_MAINS_12V ? SEC_INPUT_VOLTAGE_12V : SEC_INPUT_VOLTAGE_9V)
+					: SEC_INPUT_VOLTAGE_5V);
+				pr_info("%s: wl_cur(%d), wr_cur(%d), wc_cable_type(%d), wire_cable_type(%d)\n",
+					__func__, wireless_current, wire_current, current_cable_type, battery->wire_status);
+
+				if (wireless_current < wire_current)
+					current_cable_type = battery->wire_status;
+			}
+		}
+	}
+#if defined(CONFIG_USE_POGO)
+	else if (battery->pogo_status) {
+		int pogo_current, wire_current;
+
+		current_cable_type = POWER_SUPPLY_TYPE_POGO;
+
+		if (battery->water_det || (battery->misc_event & (BATT_MISC_EVENT_UNDEFINED_RANGE_TYPE |
+						BATT_MISC_EVENT_UNDEFINED_RANGE_POGO))) {
+			current_cable_type = POWER_SUPPLY_TYPE_BATTERY;
+			pr_info("%s: Water Detect cable type change to Battery\n", __func__);
+		}
+
+		if (battery->wire_status != POWER_SUPPLY_TYPE_BATTERY) {
+			pogo_current = battery->pdata->charging_current[current_cable_type].input_current_limit;
+			pogo_current = pogo_current * SEC_INPUT_VOLTAGE_5V;
+
+			if (battery->wire_status == POWER_SUPPLY_TYPE_PDIC) {
+				if (pogo_current < battery->pd_max_charge_power)
+					current_cable_type = battery->wire_status;
+			} else {
+				wire_current = (battery->wire_status == POWER_SUPPLY_TYPE_HV_PREPARE_MAINS ?
+						battery->pdata->charging_current[POWER_SUPPLY_TYPE_MAINS].input_current_limit :
+						battery->pdata->charging_current[battery->wire_status].input_current_limit);
+
+				wire_current = wire_current * (is_hv_wire_type(battery->wire_status) ?
+						(battery->wire_status == POWER_SUPPLY_TYPE_HV_MAINS_12V ? SEC_INPUT_VOLTAGE_12V : SEC_INPUT_VOLTAGE_9V)
+						: SEC_INPUT_VOLTAGE_5V);
+				pr_info("%s: pogo_cur(%d), wr_cur(%d), pogo_cable_type(%d), wire_cable_type(%d)\n",
+						__func__, pogo_current, wire_current, current_cable_type, battery->wire_status);
+
+				if (pogo_current < wire_current)
+					current_cable_type = battery->wire_status;
+			}
+		}
+	}
+#endif
+	else
+		current_cable_type = battery->wire_status;
+
+	if (battery->cable_type == POWER_SUPPLY_TYPE_PDIC && battery->pdic_attach) {
+		sec_bat_set_current_event(battery, SEC_BAT_CURRENT_EVENT_AFC, 1);
+		battery->aicl_current = 0;
+		sec_bat_set_charging_current(battery);
+		goto end_of_cable_work;
+	}
+
+	/* to clear this value when cable type switched without dettach */
+	if ((is_wired_type(battery->cable_type) && is_wireless_type(current_cable_type)) ||
+	    (is_wireless_type(battery->cable_type) && is_wired_type(current_cable_type)))
+		battery->max_charge_power = 0;
+
+	if ((current_cable_type == battery->cable_type) && !battery->slate_mode && !battery->rp_attach) {
+		dev_dbg(battery->dev,
+				"%s: Cable is NOT Changed(%d)\n",
+				__func__, battery->cable_type);
+		/* Do NOT activate cable work for NOT changed */
+		goto end_of_cable_work;
+	}
+
+#if defined(CONFIG_BATTERY_SWELLING)
+	if ((current_cable_type == POWER_SUPPLY_TYPE_BATTERY) ||
+		(battery->cable_type == POWER_SUPPLY_TYPE_BATTERY && battery->swelling_mode == SWELLING_MODE_NONE)) {
+		battery->swelling_mode = SWELLING_MODE_NONE;
+		sec_bat_set_current_event(battery,
+			(SEC_BAT_CURRENT_EVENT_LOW_TEMP_SWELLING |
+			SEC_BAT_CURRENT_EVENT_HIGH_TEMP_SWELLING |
+			SEC_BAT_CURRENT_EVENT_BLOCK_CHG_IN_SWELLLING), 1);
+		/* restore 4.4V float voltage */
+		val.intval = battery->pdata->swelling_normal_float_voltage;
+		psy_do_property(battery->pdata->charger_name, set,
+			POWER_SUPPLY_PROP_VOLTAGE_MAX, val);
+		pr_info("%s: float voltage = %d\n", __func__, val.intval);
+	} else {
+		pr_info("%s: skip float_voltage setting, swelling_mode(%d)\n",
+			__func__, battery->swelling_mode);
+	}
+#endif
+
+	if (battery->charging_block &&
+		((battery->cable_type != POWER_SUPPLY_TYPE_BATTERY && current_cable_type == POWER_SUPPLY_TYPE_HV_MAINS_CHG_LIMIT) ||
+		 (current_cable_type != POWER_SUPPLY_TYPE_BATTERY && battery->cable_type == POWER_SUPPLY_TYPE_HV_MAINS_CHG_LIMIT) ||
+		 (current_cable_type != POWER_SUPPLY_TYPE_BATTERY && battery->cable_type == POWER_SUPPLY_TYPE_HV_PREPARE_MAINS) ||
+		 (battery->current_event & SEC_BAT_CURRENT_EVENT_AFC))) {
+		keep_charging_state = true;
+		pr_info("%s: keep charging state (prev cable type:%d, now cable type:%d)\n",
+				__func__, battery->cable_type, current_cable_type);
+	}
+
+	prev_cable_type = battery->cable_type;
+	battery->cable_type = current_cable_type;
+#if defined(CONFIG_CALC_TIME_TO_FULL)
+	if ((prev_cable_type != POWER_SUPPLY_TYPE_HV_MAINS_CHG_LIMIT) && (battery->cable_type != POWER_SUPPLY_TYPE_HV_MAINS_CHG_LIMIT))
+		battery->complete_timetofull = false;
+#endif
+	battery->wpc_vout_level = WIRELESS_VOUT_9V;
+	if (is_wireless_type(battery->cable_type)) {
+		power_supply_changed(&battery->psy_bat);
+		/* After 10sec wireless charging, Vrect headroom has to be reduced */
+		wake_lock(&battery->wc_headroom_wake_lock);
+		queue_delayed_work(battery->monitor_wqueue, &battery->wc_headroom_work,
+			msecs_to_jiffies(10000));
+	}
+
+	if (battery->pdata->check_cable_result_callback)
+		battery->pdata->check_cable_result_callback(battery->cable_type);
+	/* platform can NOT get information of cable connection
+	 * because wakeup time is too short to check uevent
+	 * To make sure that target is wakeup
+	 * if cable is connected and disconnected,
+	 * activated wake lock in a few seconds
+	 */
+	wake_lock_timeout(&battery->vbus_wake_lock, HZ * 10);
+
+	if (battery->cable_type == POWER_SUPPLY_TYPE_BATTERY ||
+		((battery->pdata->cable_check_type &
+		SEC_BATTERY_CABLE_CHECK_NOINCOMPATIBLECHARGE) &&
+		battery->cable_type == POWER_SUPPLY_TYPE_UNKNOWN)) {
+		battery->charging_mode = SEC_BATTERY_CHARGING_NONE;
+		battery->vbus_chg_by_siop = false;
+		battery->is_recharging = false;
+#if defined(CONFIG_BATTERY_CISD)
+		battery->cisd.charging_end_time = 0;
+		battery->cisd.recharge_count = 0;
+		battery->cisd.charging_end_time_2 = 0;
+		battery->cisd.recharge_count_2 = 0;
+		battery->cisd.ab_vbat_check_count = 0;
+		battery->cisd.state &= ~CISD_STATE_OVER_VOLTAGE;
+#endif
+		battery->input_voltage = 0;
+		battery->charge_power = 0;
+		battery->max_charge_power = 0;
+		battery->pd_max_charge_power = 0;
+		sec_bat_set_charging_status(battery,
+				POWER_SUPPLY_STATUS_DISCHARGING);
+		battery->chg_limit = false;
+		battery->mix_limit = false;
+		battery->wc_heating_start_time = 0;
+		sec_bat_set_current_event(battery, (SEC_BAT_CURRENT_EVENT_CHARGE_DISABLE | SEC_BAT_CURRENT_EVENT_AFC), 1);
+#if defined(CONFIG_CALC_TIME_TO_FULL)
+		cancel_delayed_work(&battery->timetofull_work);
+#endif
+		/* usb default current is 100mA before configured, but this it HW dependent! */
+		sec_bat_set_current_event(battery,
+					  (SEC_BAT_CURRENT_EVENT_CHARGE_DISABLE |
+					   SEC_BAT_CURRENT_EVENT_AFC |
+					   SEC_BAT_CURRENT_EVENT_USB_SUPER |
+					   SEC_BAT_CURRENT_EVENT_USB_100MA |
+					   SEC_BAT_CURRENT_EVENT_VBAT_OVP |
+					   SEC_BAT_CURRENT_EVENT_VSYS_OVP |
+					   SEC_BAT_CURRENT_EVENT_CHG_LIMIT), 1);
+		sec_bat_set_current_event(battery, SEC_BAT_CURRENT_EVENT_USB_100MA, 0);
+#if defined(CONFIG_ENABLE_100MA_CHARGING_BEFORE_USB_CONFIGURED)
+		cancel_delayed_work(&battery->slowcharging_work);
+#endif
+		
+		battery->wc_cv_mode = false;
+		battery->is_sysovlo = false;
+		battery->is_vbatovlo = false;
+
+		battery->health = POWER_SUPPLY_HEALTH_GOOD;
+		sec_bat_change_default_current(battery, POWER_SUPPLY_TYPE_USB,
+			battery->pdata->default_usb_input_current,
+			battery->pdata->default_usb_charging_current);
+		sec_bat_change_default_current(battery, POWER_SUPPLY_TYPE_MAINS,
+			battery->pdata->default_input_current,
+			battery->pdata->default_charging_current);
+		if (battery->misc_event & (BATT_MISC_EVENT_UNDEFINED_RANGE_TYPE | BATT_MISC_EVENT_UNDEFINED_RANGE_POGO)) {
+                    if (sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_BUCK_OFF))
+                          goto end_of_cable_work;
+                } else {
+                    if (sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING_OFF))
+                          goto end_of_cable_work;
+                }
+	} else if (battery->slate_mode == true) {
+		sec_bat_set_charging_status(battery,
+				POWER_SUPPLY_STATUS_DISCHARGING);
+		battery->cable_type = POWER_SUPPLY_TYPE_BATTERY;
+
+		val.intval = 0;
+		psy_do_property(battery->pdata->charger_name, set,
+			POWER_SUPPLY_PROP_CURRENT_NOW, val);
+
+		dev_info(battery->dev,
+			"%s:slate mode on\n",__func__);
+
+		if (sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_BUCK_OFF))
+			goto end_of_cable_work;
+	} else {
+#if defined(CONFIG_EN_OOPS)
+		val.intval = battery->cable_type;
+		psy_do_property(battery->pdata->fuelgauge_name, set,
+				POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN, val);
+#endif
+		/* Do NOT display the charging icon when OTG or HMT_CONNECTED is enabled */
+		if (battery->cable_type == POWER_SUPPLY_TYPE_OTG ||
+			battery->cable_type == POWER_SUPPLY_TYPE_POWER_SHARING) {
+			battery->charging_mode = SEC_BATTERY_CHARGING_NONE;
+			battery->status = POWER_SUPPLY_STATUS_DISCHARGING;
+		} else {
+			if (!keep_charging_state) {
+				if (battery->pdata->full_check_type !=
+						SEC_BATTERY_FULLCHARGED_NONE)
+					battery->charging_mode =
+						SEC_BATTERY_CHARGING_1ST;
+				else
+					battery->charging_mode =
+						SEC_BATTERY_CHARGING_2ND;
+
+				battery->health = POWER_SUPPLY_HEALTH_GOOD;
+			}
+			
+			if (battery->status == POWER_SUPPLY_STATUS_FULL)
+				sec_bat_set_charging_status(battery,
+						POWER_SUPPLY_STATUS_FULL);
+			else if (!keep_charging_state)
+				sec_bat_set_charging_status(battery,
+						POWER_SUPPLY_STATUS_CHARGING);
+		}
+
+#if defined(CONFIG_ENABLE_100MA_CHARGING_BEFORE_USB_CONFIGURED)
+		if (battery->cable_type == POWER_SUPPLY_TYPE_USB && !lpcharge)
+			queue_delayed_work(battery->monitor_wqueue, &battery->slowcharging_work,
+						msecs_to_jiffies(3000));
+#endif
+
+		if ((battery->cable_type == POWER_SUPPLY_TYPE_MAINS && !battery->rp_attach) ||
+			battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS ||
+			battery->cable_type == POWER_SUPPLY_TYPE_PMA_WIRELESS) {
+#if defined(CONFIG_AFC_CHARGER_MODE)
+			sec_bat_set_current_event(battery, SEC_BAT_CURRENT_EVENT_AFC, 0);
+#endif
+		} else {
+			sec_bat_set_current_event(battery, SEC_BAT_CURRENT_EVENT_AFC, 1);
+		}
+
+		if (battery->cable_type == POWER_SUPPLY_TYPE_OTG ||
+			battery->cable_type == POWER_SUPPLY_TYPE_POWER_SHARING) {
+			sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING_OFF);
+			goto end_of_cable_work;
+		} else if (!keep_charging_state) {
+			if (sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING))
+				goto end_of_cable_work;
+		}
+
+#if defined(CONFIG_CALC_TIME_TO_FULL)
+		queue_delayed_work(battery->monitor_wqueue, &battery->timetofull_work,
+					msecs_to_jiffies(7000));
+#endif
+	}
+
+	/* set online(cable type) */
+	val.intval = battery->cable_type;
+	psy_do_property(battery->pdata->charger_name, set,
+		POWER_SUPPLY_PROP_ONLINE, val);
+	psy_do_property(battery->pdata->fuelgauge_name, set,
+		POWER_SUPPLY_PROP_ONLINE, val);
+	battery->aicl_current = 0;
+	if (battery->status != POWER_SUPPLY_STATUS_DISCHARGING)
+		sec_bat_check_input_voltage(battery);
+	sec_bat_set_charging_current(battery);
+
+	/* polling time should be reset when cable is changed
+	 * polling_in_sleep should be reset also
+	 * before polling time is re-calculated
+	 * to prevent from counting 1 for events
+	 * right after cable is connected
+	 */
+	battery->polling_in_sleep = false;
+	sec_bat_get_polling_time(battery);
+
+	dev_info(battery->dev,
+		"%s: Status:%s, Sleep:%s, Charging:%s, Short Poll:%s\n",
+		__func__, sec_bat_status_str[battery->status],
+		battery->polling_in_sleep ? "Yes" : "No",
+		(battery->charging_mode ==
+		SEC_BATTERY_CHARGING_NONE) ? "No" : "Yes",
+		battery->polling_short ? "Yes" : "No");
+	dev_info(battery->dev,
+		"%s: Polling time is reset to %d sec.\n", __func__,
+		battery->polling_time);
+
+	battery->polling_count = 1;	/* initial value = 1 */
+
+	wake_lock(&battery->monitor_wake_lock);
+	queue_delayed_work(battery->monitor_wqueue, &battery->monitor_work, 0);
+end_of_cable_work:
+	wake_unlock(&battery->cable_wake_lock);
+	dev_dbg(battery->dev, "%s: End\n", __func__);
+}
+
+static void sec_bat_afc_work(struct work_struct *work)
+{
+	struct sec_battery_info *battery = container_of(work,
+				struct sec_battery_info, afc_work.work);
+	union power_supply_propval value = {0, };
+
+	psy_do_property(battery->pdata->charger_name, get,
+		POWER_SUPPLY_PROP_CURRENT_MAX, value);
+	battery->current_max = value.intval;
+
+	if (battery->current_event & SEC_BAT_CURRENT_EVENT_AFC) {
+		sec_bat_set_current_event(battery, SEC_BAT_CURRENT_EVENT_AFC, 1);
+		if ((battery->wc_status != SEC_WIRELESS_PAD_NONE &&
+			battery->current_max >= battery->pdata->pre_wc_afc_input_current) ||
+			((battery->cable_type == POWER_SUPPLY_TYPE_MAINS ||
+				battery->cable_type == POWER_SUPPLY_TYPE_HV_MAINS_CHG_LIMIT) &&
+			battery->current_max >= battery->pdata->pre_afc_input_current)) {
+			sec_bat_check_input_voltage(battery);
+			sec_bat_set_charging_current(battery);
+		}
+	}
+	wake_unlock(&battery->afc_wake_lock);
+}
+
+ssize_t sec_bat_show_attrs(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct sec_battery_info *battery =
+		container_of(psy, struct sec_battery_info, psy_bat);
+	const ptrdiff_t offset = attr - sec_battery_attrs;
+	union power_supply_propval value = {0, };
+	int i = 0;
+	int ret = 0;
+
+	switch (offset) {
+	case BATT_RESET_SOC:
+		break;
+	case BATT_READ_RAW_SOC:
+		{
+			value.intval =
+				SEC_FUELGAUGE_CAPACITY_TYPE_RAW;
+			psy_do_property(battery->pdata->fuelgauge_name, get,
+				POWER_SUPPLY_PROP_CAPACITY, value);
+
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				value.intval);
+		}
+		break;
+	case BATT_READ_ADJ_SOC:
+		break;
+	case BATT_TYPE:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%s\n",
+			battery->batt_type);
+		break;
+	case BATT_VFOCV:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			battery->voltage_ocv);
+		break;
+	case BATT_VOL_ADC:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			battery->inbat_adc);
+		break;
+	case BATT_VOL_ADC_CAL:
+		break;
+	case BATT_VOL_AVER:
+		break;
+	case BATT_VOL_ADC_AVER:
+		break;
+
+	case BATT_CURRENT_UA_NOW:
+		{
+			value.intval = SEC_BATTERY_CURRENT_UA;
+			psy_do_property(battery->pdata->fuelgauge_name, get,
+				POWER_SUPPLY_PROP_CURRENT_NOW, value);
+#if defined(CONFIG_SEC_FACTORY)
+			pr_err("%s: batt_current_ua_now (%d)\n",
+					__func__, value.intval);
+#endif
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				value.intval);
+		}
+		break;
+	case BATT_CURRENT_UA_AVG:
+		{
+			value.intval = SEC_BATTERY_CURRENT_UA;
+			psy_do_property(battery->pdata->fuelgauge_name, get,
+				POWER_SUPPLY_PROP_CURRENT_AVG, value);
+
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				value.intval);
+		}
+		break;
+
+	case BATT_FILTER_CFG:
+		{
+			psy_do_property(battery->pdata->fuelgauge_name, get,
+				POWER_SUPPLY_PROP_FILTER_CFG, value);
+
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%x\n",
+				value.intval);
+		}
+		break;
+	case BATT_TEMP:
+		switch (battery->pdata->thermal_source) {
+		case SEC_BATTERY_THERMAL_SOURCE_FG:
+			psy_do_property(battery->pdata->fuelgauge_name, get,
+				POWER_SUPPLY_PROP_TEMP, value);
+			break;
+		case SEC_BATTERY_THERMAL_SOURCE_CALLBACK:
+			if (battery->pdata->get_temperature_callback) {
+			battery->pdata->get_temperature_callback(
+				POWER_SUPPLY_PROP_TEMP, &value);
+			}
+			break;
+		case SEC_BATTERY_THERMAL_SOURCE_ADC:
+			sec_bat_get_temperature_by_adc(battery,
+				SEC_BAT_ADC_CHANNEL_TEMP, &value);
+			break;
+		default:
+			break;
+		}
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			value.intval);
+		break;
+	case BATT_TEMP_ADC:
+		/*
+			If F/G is used for reading the temperature and
+			compensation table is used,
+			the raw value that isn't compensated can be read by
+			POWER_SUPPLY_PROP_TEMP_AMBIENT
+		 */
+		switch (battery->pdata->thermal_source) {
+		case SEC_BATTERY_THERMAL_SOURCE_FG:
+			psy_do_property(battery->pdata->fuelgauge_name, get,
+				POWER_SUPPLY_PROP_TEMP_AMBIENT, value);
+			battery->temp_adc = value.intval;
+			break;
+		default:
+			break;
+		}
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			battery->temp_adc);
+		break;
+	case BATT_TEMP_AVER:
+		break;
+	case BATT_TEMP_ADC_AVER:
+		break;
+	case USB_TEMP:
+		if (battery->pdata->usb_thermal_source) {
+			sec_bat_get_temperature_by_adc(battery,
+					       SEC_BAT_ADC_CHANNEL_USB_TEMP, &value);
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				       value.intval);
+		} else {
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				       0);
+		}
+		break;
+	case USB_TEMP_ADC:
+		if (battery->pdata->usb_thermal_source) {
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				       battery->usb_temp_adc);
+		} else {
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				       0);
+		}
+		break;
+	case BATT_CHG_TEMP:
+		switch (battery->pdata->chg_thermal_source) {
+		case SEC_CHARGER_THERMAL_SOURCE_FG:
+			psy_do_property(battery->pdata->fuelgauge_name, get,
+				POWER_SUPPLY_PROP_TEMP, value);
+			break;
+		case SEC_CHARGER_THERMAL_SOURCE_ADC:
+			sec_bat_get_temperature_by_adc(battery,
+				SEC_BAT_ADC_CHANNEL_CHG_TEMP, &value);
+			break;
+		default:
+			value.intval = 0;
+			break;
+		}
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			value.intval);
+		break;
+	case BATT_CHG_TEMP_ADC:
+		if (battery->pdata->chg_thermal_source ==
+				SEC_CHARGER_THERMAL_SOURCE_ADC) {
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				       battery->chg_temp_adc);
+		} else {
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				       0);
+		}
+		break;
+	case BATT_SLAVE_CHG_TEMP:
+		if (battery->pdata->slave_thermal_source) {
+			sec_bat_get_temperature_by_adc(battery,
+						   SEC_BAT_ADC_CHANNEL_SLAVE_CHG_TEMP, &value);
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+					   value.intval);
+		} else {
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+					   0);
+		}
+		break;
+	case BATT_SLAVE_CHG_TEMP_ADC:
+		if (battery->pdata->slave_thermal_source) {
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+					   battery->slave_chg_temp_adc);
+		} else {
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+					   0);
+		}
+		break;
+	case BATT_VF_ADC:
+		break;
+	case BATT_SLATE_MODE:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			battery->slate_mode);
+		break;
+
+	case BATT_LP_CHARGING:
+		if (lpcharge) {
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				       lpcharge ? 1 : 0);
+		}
+		break;
+	case SIOP_ACTIVATED:
+		break;
+	case SIOP_LEVEL:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			battery->siop_level);
+		break;
+	case SIOP_EVENT:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			battery->siop_event);
+		break;
+	case BATT_CHARGING_SOURCE:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			battery->cable_type);
+		break;
+	case FG_REG_DUMP:
+		break;
+	case FG_RESET_CAP:
+		break;
+	case FG_CAPACITY:
+	{
+		value.intval =
+			SEC_BATTERY_CAPACITY_DESIGNED;
+		psy_do_property(battery->pdata->fuelgauge_name, get,
+			POWER_SUPPLY_PROP_ENERGY_NOW, value);
+
+		i += scnprintf(buf + i, PAGE_SIZE - i, "0x%04x ",
+			value.intval);
+
+		value.intval =
+			SEC_BATTERY_CAPACITY_ABSOLUTE;
+		psy_do_property(battery->pdata->fuelgauge_name, get,
+			POWER_SUPPLY_PROP_ENERGY_NOW, value);
+
+		i += scnprintf(buf + i, PAGE_SIZE - i, "0x%04x ",
+			value.intval);
+
+		value.intval =
+			SEC_BATTERY_CAPACITY_TEMPERARY;
+		psy_do_property(battery->pdata->fuelgauge_name, get,
+			POWER_SUPPLY_PROP_ENERGY_NOW, value);
+
+		i += scnprintf(buf + i, PAGE_SIZE - i, "0x%04x ",
+			value.intval);
+
+		value.intval =
+			SEC_BATTERY_CAPACITY_CURRENT;
+		psy_do_property(battery->pdata->fuelgauge_name, get,
+			POWER_SUPPLY_PROP_ENERGY_NOW, value);
+
+		i += scnprintf(buf + i, PAGE_SIZE - i, "0x%04x\n",
+			value.intval);
+	}
+		break;
+	case FG_ASOC:
+		value.intval = -1;
+		{
+			struct power_supply *psy_fg = NULL;
+			psy_fg = get_power_supply_by_name(battery->pdata->fuelgauge_name);
+			if (!psy_fg) {
+				pr_err("%s: Fail to get psy (%s)\n",
+						__func__, battery->pdata->fuelgauge_name);
+			} else {
+				if (psy_fg->get_property != NULL) {
+#if defined(CONFIG_FUELGAUGE_ASOC_FROM_CYCLES)
+					value.intval = battery->batt_cycle;
+#endif
+					ret = psy_fg->get_property(psy_fg,
+							POWER_SUPPLY_PROP_ENERGY_FULL, &value);
+					if (ret < 0) {
+						pr_err("%s: Fail to %s get (%d=>%d)\n",
+								__func__, battery->pdata->fuelgauge_name,
+								POWER_SUPPLY_PROP_ENERGY_FULL, ret);
+					}
+				}
+			}
+		}
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			       value.intval);
+		break;
+	case AUTH:
+		break;
+	case CHG_CURRENT_ADC:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			battery->current_adc);
+		break;
+	case WC_ADC:
+		break;
+	case WC_STATUS:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			is_wireless_type(battery->cable_type) ? 1: 0);
+		break;
+	case WC_ENABLE:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			battery->wc_enable);
+		break;
+	case WC_CONTROL:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			battery->wc_enable);
+		break;
+	case WC_CONTROL_CNT:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+		battery->wc_enable_cnt_value);
+		break;
+	case HV_CHARGER_STATUS:
+		{
+			int check_val = 0;
+			if (is_hv_wire_12v_type(battery->cable_type) ||
+				battery->max_charge_power >= 20000)
+				check_val = 2;
+			else if (is_hv_wire_type(battery->cable_type) ||
+				battery->cable_type == POWER_SUPPLY_TYPE_HV_MAINS_CHG_LIMIT ||
+				battery->max_charge_power >= 15000)
+				check_val = 1;
+
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n", check_val);
+		}
+		break;
+	case HV_WC_CHARGER_STATUS:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			is_hv_wireless_type(battery->cable_type) ? 1 : 0);
+		break;
+	case HV_CHARGER_SET:
+		break;
+	case FACTORY_MODE:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			battery->factory_mode);
+		break;
+	case STORE_MODE:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			battery->store_mode);
+		break;
+	case UPDATE:
+		break;
+	case TEST_MODE:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			battery->test_mode);
+		break;
+
+	case BATT_EVENT_CALL:
+	case BATT_EVENT_2G_CALL:
+	case BATT_EVENT_TALK_GSM:
+		break;
+	case BATT_EVENT_3G_CALL:
+	case BATT_EVENT_TALK_WCDMA:
+		break;
+	case BATT_EVENT_MUSIC:
+		break;
+	case BATT_EVENT_VIDEO:
+		break;
+	case BATT_EVENT_BROWSER:
+		break;
+	case BATT_EVENT_HOTSPOT:
+		break;
+	case BATT_EVENT_CAMERA:
+		break;
+	case BATT_EVENT_CAMCORDER:
+		break;
+	case BATT_EVENT_DATA_CALL:
+		break;
+	case BATT_EVENT_WIFI:
+		break;
+	case BATT_EVENT_WIBRO:
+		break;
+	case BATT_EVENT_LTE:
+		break;
+	case BATT_EVENT_LCD:
+		break;
+	case BATT_EVENT_GPS:
+		break;
+	case BATT_EVENT:
+		break;
+	case BATT_TEMP_TABLE:
+		i += scnprintf(buf + i, PAGE_SIZE - i,
+			"%d %d %d %d %d %d %d %d\n",
+			battery->pdata->temp_high_threshold_normal,
+			battery->pdata->temp_high_recovery_normal,
+			battery->pdata->temp_low_threshold_normal,
+			battery->pdata->temp_low_recovery_normal,
+			battery->pdata->temp_high_threshold_lpm,
+			battery->pdata->temp_high_recovery_lpm,
+			battery->pdata->temp_low_threshold_lpm,
+			battery->pdata->temp_low_recovery_lpm);
+		break;
+	case BATT_HIGH_CURRENT_USB:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			battery->is_hc_usb);
+		break;
+#if defined(CONFIG_SAMSUNG_BATTERY_ENG_TEST)
+	case BATT_TEST_CHARGE_CURRENT:
+		{
+			psy_do_property(battery->pdata->charger_name, get,
+				POWER_SUPPLY_PROP_CURRENT_NOW, value);
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+					value.intval);
+		}
+		break;
+#endif
+	case BATT_STABILITY_TEST:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			battery->stability_test);
+		break;
+	case BATT_CAPACITY_MAX:
+		psy_do_property(battery->pdata->fuelgauge_name, get,
+				POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN, value);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n", value.intval);
+		break;
+	case BATT_INBAT_VOLTAGE:
+	case BATT_INBAT_VOLTAGE_OCV:
+		if (battery->pdata->support_fgsrc_change == true) {
+			int j, k, ocv, ocv_data[5];
+
+			if (strcmp(battery->pdata->fgsrc_switch_name, "sm5705-fuelgauge")==0)
+			{
+				pr_info("%s SM5705_FGSRC_SWITCH \n", __func__);
+				for (j = 0; j < 5; j++) {
+					psy_do_property(battery->pdata->fuelgauge_name, get,
+							POWER_SUPPLY_EXT_PROP_INBAT_VOLTAGE_FGSRC_SWITCHING, value);
+					ocv_data[j] = value.intval;
+				}
+			} else {
+				value.intval = SEC_BAT_INBAT_FGSRC_SWITCHING_ON;
+				psy_do_property(battery->pdata->fgsrc_switch_name, set,
+						POWER_SUPPLY_EXT_PROP_INBAT_VOLTAGE_FGSRC_SWITCHING, value);
+
+				for (j = 0; j < 5; j++) {
+					psy_do_property(battery->pdata->fuelgauge_name, get,
+							POWER_SUPPLY_PROP_VOLTAGE_NOW, value);
+					ocv_data[j] = value.intval;
+				}
+				if (battery->is_jig_on || battery->factory_mode || factory_mode == 1) {
+					value.intval = SEC_BAT_INBAT_FGSRC_SWITCHING_OFF;
+					psy_do_property(battery->pdata->fgsrc_switch_name, set,
+							POWER_SUPPLY_EXT_PROP_INBAT_VOLTAGE_FGSRC_SWITCHING, value);
+				}
+			}
+
+			for (j = 1; j < 5; j++) {
+				ocv = ocv_data[j];
+				k = j;
+				while (k > 0 && ocv_data[k-1] > ocv) {
+					ocv_data[k] = ocv_data[k-1];
+					k--;
+				}
+				ocv_data[k] = ocv;
+			}
+
+			for (j = 0; j < 5; j++)
+				pr_info("%s: %d\n", __func__, ocv_data[j]);
+
+			ocv = 0;
+			for (j = 1; j < 4; j++) {
+				ocv += ocv_data[j];
+			}
+			ret = ocv / 3;
+		} else {
+			/* run twice */
+			ret = (sec_bat_get_inbat_vol_by_adc(battery) + sec_bat_get_inbat_vol_by_adc(battery)) / 2;
+		}
+		dev_info(battery->dev, "in-battery voltage ocv(%d)\n", ret);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				ret);
+		break;
+	case BATT_INBAT_VOLTAGE_ADC:
+		/* run twice */
+		ret = (sec_bat_get_inbat_vol_by_adc(battery) + sec_bat_get_inbat_vol_by_adc(battery)) / 2;
+		dev_info(battery->dev, "in-battery voltage adc(%d)\n", ret);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				ret);
+		break;
+	case CHECK_SLAVE_CHG:
+		psy_do_property(battery->pdata->charger_name, get,
+			POWER_SUPPLY_EXT_PROP_CHECK_SLAVE_I2C, value);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				value.intval);
+		pr_info("%s : CHECK_SLAVE_CHG=%d\n",__func__,value.intval);
+		break;
+	case BATT_INBAT_WIRELESS_CS100:
+		psy_do_property(battery->pdata->wireless_charger_name, get,
+			POWER_SUPPLY_PROP_STATUS, value);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n", value.intval);
+		break;
+	case HMT_TA_CONNECTED:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			(battery->cable_type == POWER_SUPPLY_TYPE_HMT_CONNECTED) ? 1 : 0);
+		break;
+	case HMT_TA_CHARGE:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			(battery->cable_type == POWER_SUPPLY_TYPE_HMT_CHARGE) ? 1 : 0);
+		break;
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	case FG_CYCLE:
+		value.intval = SEC_BATTERY_CAPACITY_CYCLE;
+		psy_do_property(battery->pdata->fuelgauge_name, get,
+			POWER_SUPPLY_PROP_ENERGY_NOW, value);
+		value.intval = value.intval / 100;
+		dev_info(battery->dev, "fg cycle(%d)\n", value.intval);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n", value.intval);
+		break;
+	case FG_FULL_VOLTAGE:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n", battery->pdata->chg_float_voltage);
+		break;
+	case FG_FULLCAPNOM:
+		value.intval =
+			SEC_BATTERY_CAPACITY_AGEDCELL;
+		psy_do_property(battery->pdata->fuelgauge_name, get,
+			POWER_SUPPLY_PROP_ENERGY_NOW, value);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n", value.intval);
+		break;
+#if defined(CONFIG_BATTERY_AGE_FORECAST_DETACHABLE)
+	case BATT_AFTER_MANUFACTURED:
+#if defined(CONFIG_ENG_BATTERY_CONCEPT) || defined(CONFIG_SEC_FACTORY)
+	case BATTERY_CYCLE:
+#endif
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n", battery->batt_cycle);
+		break;	
+#else
+	case BATTERY_CYCLE:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n", battery->batt_cycle);
+		break;
+#endif
+#endif
+#if defined(CONFIG_DCM_JPN_CONCEPT_FG_CYCLE_CHECK)
+	case FG_CYCLE_CHECK_VALUE:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n", battery->fg_cycle_check_value);
+		break;
+#endif
+	case BATT_WPC_TEMP:
+		if (battery->pdata->wpc_thermal_source) {
+			sec_bat_get_temperature_by_adc(battery,
+				SEC_BAT_ADC_CHANNEL_WPC_TEMP, &value);
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				value.intval);
+		} else {
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				0);
+		}
+		break;
+	case BATT_WPC_TEMP_ADC:
+		if (battery->pdata->wpc_thermal_source) {
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				battery->wpc_temp_adc);
+		} else {
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				0);
+		}
+		break;
+#if defined(CONFIG_WIRELESS_FIRMWARE_UPDATE)
+	case BATT_WIRELESS_FIRMWARE_UPDATE:
+		value.intval = SEC_WIRELESS_OTP_FIRM_VERIFY;
+		psy_do_property(battery->pdata->wireless_charger_name, get,
+			POWER_SUPPLY_PROP_MANUFACTURER, value);
+		pr_info("%s RX firmware verify. result: %d\n", __func__, value.intval);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n", value.intval);
+		break;
+	case BATT_WIRELESS_OTP_FIRMWARE_RESULT:
+		value.intval = SEC_WIRELESS_OTP_FIRM_RESULT;
+		psy_do_property(battery->pdata->wireless_charger_name, get,
+			POWER_SUPPLY_PROP_MANUFACTURER, value);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n", value.intval);
+		break;
+	case BATT_WIRELESS_IC_GRADE:
+		value.intval = SEC_WIRELESS_IC_REVISION;
+		psy_do_property(battery->pdata->wireless_charger_name, get,
+			POWER_SUPPLY_PROP_MANUFACTURER, value);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "0x%x ", value.intval);
+
+		value.intval = SEC_WIRELESS_IC_GRADE;
+		psy_do_property(battery->pdata->wireless_charger_name, get,
+			POWER_SUPPLY_PROP_MANUFACTURER, value);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "0x%x\n", value.intval);
+		break;
+	case BATT_WIRELESS_FIRMWARE_VER_BIN:
+		value.intval = SEC_WIRELESS_OTP_FIRM_VER_BIN;
+		psy_do_property(battery->pdata->wireless_charger_name, get,
+			POWER_SUPPLY_PROP_MANUFACTURER, value);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%x\n", value.intval);
+		break;
+	case BATT_WIRELESS_FIRMWARE_VER:
+		value.intval = SEC_WIRELESS_OTP_FIRM_VER;
+		psy_do_property(battery->pdata->wireless_charger_name, get,
+			POWER_SUPPLY_PROP_MANUFACTURER, value);
+
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%x\n", value.intval);
+		break;
+	case BATT_WIRELESS_TX_FIRMWARE_RESULT:
+		value.intval = SEC_WIRELESS_TX_FIRM_RESULT;
+		psy_do_property(battery->pdata->wireless_charger_name, get,
+			POWER_SUPPLY_PROP_MANUFACTURER, value);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n", value.intval);
+		break;
+	case BATT_WIRELESS_TX_FIRMWARE_VER:
+		value.intval = SEC_WIRELESS_TX_FIRM_VER;
+		psy_do_property(battery->pdata->wireless_charger_name, get,
+			POWER_SUPPLY_PROP_MANUFACTURER, value);
+
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%x\n", value.intval);
+		break;
+	case BATT_TX_STATUS:
+		value.intval = SEC_TX_FIRMWARE;
+		psy_do_property(battery->pdata->wireless_charger_name, get,
+			POWER_SUPPLY_PROP_MANUFACTURER, value);
+
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%x\n", value.intval);
+		break;
+#endif
+	case BATT_WIRELESS_VOUT:
+		psy_do_property(battery->pdata->wireless_charger_name, get,
+			POWER_SUPPLY_PROP_ENERGY_NOW, value);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n", value.intval);
+		break;
+	case BATT_WIRELESS_VRCT:
+		psy_do_property(battery->pdata->wireless_charger_name, get,
+			POWER_SUPPLY_PROP_ENERGY_AVG, value);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n", value.intval);
+		break;
+	case BATT_HV_WIRELESS_STATUS:
+		psy_do_property(battery->pdata->wireless_charger_name, get,
+			POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n", value.intval);
+		break;
+	case BATT_HV_WIRELESS_PAD_CTRL:
+		break;
+	case BATT_WIRELESS_OP_FREQ:
+		psy_do_property(battery->pdata->wireless_charger_name, get,
+			POWER_SUPPLY_EXT_PROP_WIRELESS_OP_FREQ, value);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n", value.intval);
+		break;
+	case BATT_WIRELESS_CMD_INFO:
+		psy_do_property(battery->pdata->wireless_charger_name, get,
+			POWER_SUPPLY_EXT_PROP_WIRELESS_TX_CMD, value);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "0x%02x ",
+			value.intval);
+
+		psy_do_property(battery->pdata->wireless_charger_name, get,
+			POWER_SUPPLY_EXT_PROP_WIRELESS_TX_VAL, value);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "0x%02x ",
+			value.intval);	
+		break;
+	case BATT_TUNE_FLOAT_VOLTAGE:
+		ret = battery->pdata->chg_float_voltage;
+		pr_info("%s float voltage = %d mA",__func__, ret);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				ret);
+		break;
+	case BATT_TUNE_INPUT_CHARGE_CURRENT:
+		ret = battery->pdata->charging_current[i].input_current_limit;
+		pr_info("%s input charge current = %d mA",__func__, ret);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				ret);
+		break;
+	case BATT_TUNE_FAST_CHARGE_CURRENT:
+		ret = battery->pdata->charging_current[i].fast_charging_current;
+		pr_info("%s fast charge current = %d mA",__func__, ret);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				ret);
+		break;
+	case BATT_TUNE_UI_TERM_CURRENT_1ST:
+		ret = battery->pdata->charging_current[i].full_check_current_1st;
+		pr_info("%s ui term current = %d mA",__func__, ret);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				ret);
+		break;
+	case BATT_TUNE_UI_TERM_CURRENT_2ND:
+		ret = battery->pdata->charging_current[i].full_check_current_1st;
+		pr_info("%s ui term current = %d mA",__func__, ret);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				ret);
+		break;
+	case BATT_TUNE_TEMP_HIGH_NORMAL:
+		ret = battery->pdata->temp_high_threshold_normal;
+		pr_info("%s temp high normal block	= %d ",__func__, ret);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				ret);
+		break;
+	case BATT_TUNE_TEMP_HIGH_REC_NORMAL:
+		ret = battery->pdata->temp_high_recovery_normal;
+		pr_info("%s temp high normal recover  = %d ",__func__, ret);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				ret);
+		break;
+	case BATT_TUNE_TEMP_LOW_NORMAL:
+		ret = battery->pdata->temp_low_threshold_normal;
+		pr_info("%s temp low normal block  = %d ",__func__, ret);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				ret);
+		break;
+	case BATT_TUNE_TEMP_LOW_REC_NORMAL:
+		ret = battery->pdata->temp_low_recovery_normal;
+		pr_info("%s temp low normal recover  = %d ",__func__, ret);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				ret);
+		break;
+	case BATT_TUNE_CHG_TEMP_HIGH:
+		ret = battery->pdata->chg_high_temp;
+		pr_info("%s chg_high_temp = %d ",__func__, ret);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				ret);
+		break;
+	case BATT_TUNE_CHG_TEMP_REC:
+		ret = battery->pdata->chg_high_temp_recovery;
+		pr_info("%s chg_high_temp_recovery	= %d ",__func__, ret);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				ret);
+		break;
+	case BATT_TUNE_CHG_LIMMIT_CURRENT:
+		ret = battery->pdata->chg_charging_limit_current;
+		pr_info("%s chg_charging_limit_current = %d ",__func__, ret);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				ret);
+		break;
+	case BATT_TUNE_COIL_TEMP_HIGH:
+		break;
+	case BATT_TUNE_COIL_TEMP_REC:
+		break;
+	case BATT_TUNE_COIL_LIMMIT_CURRENT:
+		break;
+#if defined(CONFIG_UPDATE_BATTERY_DATA)
+	case BATT_UPDATE_DATA:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%s\n",
+				battery->data_path ? "OK" : "NOK");
+		break;
+#endif
+	case BATT_MISC_EVENT:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				battery->misc_event);
+		break;
+	case BATT_EXT_DEV_CHG:
+		break;
+	case CISD_FULLCAPREP_MAX:
+		{
+			union power_supply_propval fullcaprep_val;
+			
+			fullcaprep_val.intval = SEC_BATTERY_CAPACITY_FULL;
+			psy_do_property(battery->pdata->fuelgauge_name, get,
+				POWER_SUPPLY_PROP_ENERGY_NOW, fullcaprep_val);
+
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+					fullcaprep_val.intval);
+		}
+		break;
+#if defined(CONFIG_BATTERY_CISD)
+	case CISD_DATA:
+		{
+			struct cisd *pcisd = &battery->cisd;
+
+			i+= scnprintf(buf + i, PAGE_SIZE - i, "%d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d\n",
+				pcisd->data[CISD_DATA_FULL_COUNT], pcisd->data[CISD_DATA_CAP_MAX],
+				pcisd->data[CISD_DATA_CAP_MIN], pcisd->data[CISD_DATA_CAP_ONCE],
+				pcisd->data[CISD_DATA_LEAKAGE_A], pcisd->data[CISD_DATA_LEAKAGE_B],
+				pcisd->data[CISD_DATA_LEAKAGE_C], pcisd->data[CISD_DATA_LEAKAGE_D],
+				pcisd->data[CISD_DATA_CAP_PER_TIME], pcisd->data[CISD_DATA_ERRCAP_LOW],
+				pcisd->data[CISD_DATA_ERRCAP_HIGH], pcisd->data[CISD_DATA_OVER_VOLTAGE],
+				pcisd->data[CISD_DATA_LEAKAGE_E], pcisd->data[CISD_DATA_LEAKAGE_F],
+				pcisd->data[CISD_DATA_LEAKAGE_G], pcisd->data[CISD_DATA_RECHARGING_TIME],
+				pcisd->data[CISD_DATA_VALERT_COUNT], pcisd->data[CISD_DATA_CYCLE],
+				pcisd->data[CISD_DATA_WIRE_COUNT], pcisd->data[CISD_DATA_WIRELESS_COUNT],
+				pcisd->data[CISD_DATA_HIGH_TEMP_SWELLING], pcisd->data[CISD_DATA_LOW_TEMP_SWELLING],
+				pcisd->data[CISD_DATA_SWELLING_CHARGING_COUNT], pcisd->data[CISD_DATA_SAFETY_TIMER_3],
+				pcisd->data[CISD_DATA_SAFETY_TIMER_5], pcisd->data[CISD_DATA_SAFETY_TIMER_10],
+				pcisd->data[CISD_DATA_AICL_COUNT],
+				pcisd->data[CISD_DATA_BATT_TEMP_MAX], pcisd->data[CISD_DATA_BATT_TEMP_MIN],
+				pcisd->data[CISD_DATA_CHG_TEMP_MAX], pcisd->data[CISD_DATA_CHG_TEMP_MIN],
+				pcisd->data[CISD_DATA_WPC_TEMP_MAX], pcisd->data[CISD_DATA_WPC_TEMP_MIN],
+				pcisd->data[CISD_UNSAFE_VOLTAGE], pcisd->data[CISD_UNSAFE_TEMPERATURE],
+				pcisd->data[CISD_SAFETY_TIMER], pcisd->data[CISD_VSYS_OVP],
+				pcisd->data[CISD_VBAT_OVP], pcisd->data[CISD_WATER_DETECT],
+				pcisd->data[CISD_AFC_FAIL],
+				pcisd->cisd_alg_index);
+		}
+		break;
+	case CISD_DATA_JSON:
+		{
+			struct cisd *pcisd = &battery->cisd;
+
+			i+= scnprintf(buf + i, PAGE_SIZE - i,
+				"\"FULL_COUNT\":\"%d\",\"CAP_MAX\":\"%d\",\"CAP_MIN\":\"%d\",\"CAP_ONCE\":\"%d\","
+				"\"LEAKAGE_A\":\"%d\",\"LEAKAGE_B\":\"%d\",\"LEAKAGE_C\":\"%d\",\"LEAKAGE_D\":\"%d\","
+				"\"CAP_PER_TIME\":\"%d\",\"ERRCAP_LOW\":\"%d\",\"ERRCAP_HIGH\":\"%d\",\"OVER_VOLTAGE\":\"%d\","
+				"\"LEAKAGE_E\":\"%d\",\"LEAKAGE_F\":\"%d\",\"LEAKAGE_G\":\"%d\",\"RECHARGING_TIME\":\"%d\","
+				"\"VALERT_COUNT\":\"%d\",\"BATT_CYCLE\":\"%d\",\"WIRE_COUNT\":\"%d\",\"WIRELESS_COUNT\":\"%d\","
+				"\"HIGH_SWELLING_COUNT\":\"%d\",\"LOW_SWELLING_COUNT\":\"%d\",\"SWELLING_CHARGING\":\"%d\","
+				"\"SAFETY_TIMER_3\":\"%d\",\"SAFETY_TIMER_5\":\"%d\",\"SAFETY_TIMER_10\":\"%d\","
+				"\"AICL_COUNT\":\"%d\",\"BATT_THM_MAX\":\"%d\",\"BATT_THM_MIN\":\"%d\","
+				"\"CHG_THM_MAX\":\"%d\",\"CHG_THM_MIN\":\"%d\",\"WPC_THM_MAX\":\"%d\",\"WPC_THM_MIN\":\"%d\","
+				"\"UNSAFE_VOLTAGE\":\"%d\",\"UNSAFE_TEMPERATURE\":\"%d\",\"SAFETY_TIMER\":\"%d\",\"VSYS_OVP\":\"%d\","
+				"\"VBAT_OVP\":\"%d\",\"WATER_DETECT\":\"%d\",\"AFC_FAIL\":\"%d\","
+				"\"ALG_INDEX\":\"%d\"\n",
+				pcisd->data[CISD_DATA_FULL_COUNT], pcisd->data[CISD_DATA_CAP_MAX],
+				pcisd->data[CISD_DATA_CAP_MIN], pcisd->data[CISD_DATA_CAP_ONCE],
+				pcisd->data[CISD_DATA_LEAKAGE_A], pcisd->data[CISD_DATA_LEAKAGE_B],
+				pcisd->data[CISD_DATA_LEAKAGE_C], pcisd->data[CISD_DATA_LEAKAGE_D],
+				pcisd->data[CISD_DATA_CAP_PER_TIME], pcisd->data[CISD_DATA_ERRCAP_LOW],
+				pcisd->data[CISD_DATA_ERRCAP_HIGH], pcisd->data[CISD_DATA_OVER_VOLTAGE],
+				pcisd->data[CISD_DATA_LEAKAGE_E], pcisd->data[CISD_DATA_LEAKAGE_F],
+				pcisd->data[CISD_DATA_LEAKAGE_G], pcisd->data[CISD_DATA_RECHARGING_TIME],
+				pcisd->data[CISD_DATA_VALERT_COUNT], pcisd->data[CISD_DATA_CYCLE],
+				pcisd->data[CISD_DATA_WIRE_COUNT], pcisd->data[CISD_DATA_WIRELESS_COUNT],
+				pcisd->data[CISD_DATA_HIGH_TEMP_SWELLING], pcisd->data[CISD_DATA_LOW_TEMP_SWELLING],
+				pcisd->data[CISD_DATA_SWELLING_CHARGING_COUNT],	pcisd->data[CISD_DATA_SAFETY_TIMER_3],
+				pcisd->data[CISD_DATA_SAFETY_TIMER_5], pcisd->data[CISD_DATA_SAFETY_TIMER_10],
+				pcisd->data[CISD_DATA_AICL_COUNT],
+				pcisd->data[CISD_DATA_BATT_TEMP_MAX], pcisd->data[CISD_DATA_BATT_TEMP_MIN],
+				pcisd->data[CISD_DATA_CHG_TEMP_MAX], pcisd->data[CISD_DATA_CHG_TEMP_MIN],
+				pcisd->data[CISD_DATA_WPC_TEMP_MAX], pcisd->data[CISD_DATA_WPC_TEMP_MIN],
+				pcisd->data[CISD_UNSAFE_VOLTAGE], pcisd->data[CISD_UNSAFE_TEMPERATURE],
+				pcisd->data[CISD_SAFETY_TIMER], pcisd->data[CISD_VSYS_OVP],
+				pcisd->data[CISD_VBAT_OVP], pcisd->data[CISD_WATER_DETECT],
+				pcisd->data[CISD_AFC_FAIL],
+				pcisd->cisd_alg_index);
+
+			pcisd->data[CISD_DATA_CAP_ONCE] = 0;
+			pcisd->data[CISD_DATA_CAP_PER_TIME] = 0;
+		}
+		break;
+	case CISD_WIRE_COUNT:
+		{
+			struct cisd *pcisd = &battery->cisd;
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				pcisd->data[CISD_DATA_WIRE_COUNT]);
+		}
+		break;
+	case CISD_DATA_EFS_PATH:
+		if (battery->pdata->cisd_data_efs_path) {
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%s\n",
+				battery->pdata->cisd_data_efs_path);
+		}
+		break;		
+#endif
+	case BATT_WDT_CONTROL:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				battery->wdt_kick_disable);
+		break;
+	case BATT_SWELLING_CONTROL:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			       battery->skip_swelling);
+		break;
+	case SAFETY_TIMER_SET:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			       battery->safety_timer_set);
+		break;
+	case SAFETY_TIMER_INFO:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%ld\n",
+			       battery->cal_safety_time);
+		break;
+
+	case MODE:
+		value.strval = NULL;
+		psy_do_property(battery->pdata->charger_name, get,
+			POWER_SUPPLY_EXT_PROP_MULTI_CHARGER_MODE, value);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%s\n",
+			(value.strval) ? value.strval : "master");
+		break;
+	case CHECK_PS_READY:
+#if defined(CONFIG_CCIC_NOTIFIER)
+		value.intval = battery->pdic_ps_rdy;
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				value.intval);
+		pr_info("%s : CHECK_PS_READY=%d\n",__func__,value.intval);
+#endif
+		break;
+	case FACTORY_MODE_RELIEVE:
+		break;
+	case FACTORY_MODE_BYPASS:
+		break;
+	case NORMAL_MODE_BYPASS:
+		break;
+	case FACTORY_VOLTAGE_REGULATION:
+		break;
+	case FACTORY_MODE_DISABLE:
+		break;
+	case BATT_PRESENT:
+		if (factory_mode == 2) {
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				       factory_mode);
+		} else {
+			i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				       battery->present);
+		}
+		break;
+	default:
+		i = -EINVAL;
+		break;
+	}
+
+	return i;
+}
+
+void update_external_temp_table(struct sec_battery_info *battery, int temp[])
+{
+	battery->pdata->temp_high_threshold_normal = temp[0];
+	battery->pdata->temp_high_recovery_normal = temp[1];
+	battery->pdata->temp_low_threshold_normal = temp[2];
+	battery->pdata->temp_low_recovery_normal = temp[3];
+	battery->pdata->temp_high_threshold_lpm = temp[4];
+	battery->pdata->temp_high_recovery_lpm = temp[5];
+	battery->pdata->temp_low_threshold_lpm = temp[6];
+	battery->pdata->temp_low_recovery_lpm = temp[7];
+
+}
+
+ssize_t sec_bat_store_attrs(
+					struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct sec_battery_info *battery =
+		container_of(psy, struct sec_battery_info, psy_bat);
+	const ptrdiff_t offset = attr - sec_battery_attrs;
+	int ret = -EINVAL;
+	int x = 0;
+	int t[12];
+	int i = 0;
+	union power_supply_propval value = {0, };
+
+	switch (offset) {
+	case BATT_RESET_SOC:
+		/* Do NOT reset fuel gauge in charging mode */
+		if ((battery->cable_type == POWER_SUPPLY_TYPE_BATTERY) ||
+			battery->is_jig_on) {
+			sec_bat_set_misc_event(battery, BATT_MISC_EVENT_BATT_RESET_SOC, 0);
+
+			value.intval =
+				SEC_FUELGAUGE_CAPACITY_TYPE_RESET;
+			psy_do_property(battery->pdata->fuelgauge_name, set,
+					POWER_SUPPLY_PROP_CAPACITY, value);
+			dev_info(battery->dev,"do reset SOC\n");
+			/* update battery info */
+			sec_bat_get_battery_info(battery);
+		}
+		ret = count;
+		break;
+	case BATT_READ_RAW_SOC:
+		break;
+	case BATT_READ_ADJ_SOC:
+		break;
+	case BATT_TYPE:
+		strncpy(battery->batt_type, buf, sizeof(battery->batt_type) - 1);
+		battery->batt_type[sizeof(battery->batt_type)-1] = '\0';
+		ret = count;
+		break;
+	case BATT_VFOCV:
+		break;
+	case BATT_VOL_ADC:
+		break;
+	case BATT_VOL_ADC_CAL:
+		break;
+	case BATT_VOL_AVER:
+		break;
+	case BATT_VOL_ADC_AVER:
+		break;
+	case BATT_CURRENT_UA_NOW:
+		break;
+	case BATT_CURRENT_UA_AVG:
+		break;
+	case BATT_FILTER_CFG:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			value.intval = x;
+			psy_do_property(battery->pdata->fuelgauge_name, set,
+					POWER_SUPPLY_PROP_FILTER_CFG, value);
+			ret = count;
+		}
+		break;
+	case BATT_TEMP:
+		break;
+	case BATT_TEMP_ADC:
+		break;
+	case BATT_TEMP_AVER:
+		break;
+	case BATT_TEMP_ADC_AVER:
+		break;
+	case USB_TEMP:
+		break;
+	case USB_TEMP_ADC:
+		break;
+	case BATT_CHG_TEMP:
+		break;
+	case BATT_CHG_TEMP_ADC:
+		break;
+	case BATT_SLAVE_CHG_TEMP:
+		break;
+	case BATT_SLAVE_CHG_TEMP_ADC:
+		break;
+	case BATT_VF_ADC:
+		break;
+	case BATT_SLATE_MODE:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			if (x == battery->slate_mode) {
+				dev_info(battery->dev,
+						"%s: skip same slate mode: %d\n", __func__, x);
+				return count;
+			} else if (x == 1) {
+				battery->slate_mode = true;
+				dev_info(battery->dev,
+						"%s: enable slate mode : %d\n", __func__, x);
+			} else if (x == 0) {
+				battery->slate_mode = false;
+				dev_info(battery->dev,
+						"%s: disable slate mode : %d\n", __func__, x);				
+			} else {
+				dev_info(battery->dev,
+					"%s: SLATE MODE unknown command\n",
+					__func__);
+				return -EINVAL;
+			}
+			wake_lock(&battery->cable_wake_lock);
+			queue_delayed_work(battery->monitor_wqueue,
+					   &battery->cable_work, 0);
+			ret = count;
+		}
+		break;
+
+	case BATT_LP_CHARGING:
+		break;
+	case SIOP_ACTIVATED:
+		break;
+	case SIOP_LEVEL:
+		if (sscanf(buf, "%10d\n", &x) == 1) {
+			dev_info(battery->dev,
+					"%s: siop level: %d\n", __func__, x);
+			battery->chg_limit =
+				(is_hv_wire_type(battery->cable_type) || battery->cable_type == POWER_SUPPLY_TYPE_HV_MAINS_CHG_LIMIT) ?
+				battery->chg_limit : false;
+			battery->wc_heating_start_time = 0;
+			if (x == battery->siop_level) {
+				dev_info(battery->dev,
+					"%s: skip same siop level: %d\n", __func__, x);
+				return count;
+			} else if (x >= 0 && x <= 100) {
+				battery->siop_level = x;
+			} else {
+				battery->siop_level = 100;
+			}
+
+			if (battery->siop_event == SIOP_EVENT_WPC_CALL_START ||
+				battery->siop_event == SIOP_EVENT_WPC_CALL_END)
+				return count;
+
+			if (delayed_work_pending(&battery->siop_event_work))
+				return count;
+
+			cancel_delayed_work(&battery->siop_work);
+			wake_lock(&battery->siop_level_wake_lock);
+			queue_delayed_work(battery->monitor_wqueue, &battery->siop_level_work, 0);
+
+			ret = count;
+		}
+		break;
+	case SIOP_EVENT:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			if (battery->pdata->siop_event_check_type & SIOP_EVENT_WPC_CALL) { // To reduce call noise with battery pack
+				if (x == SIOP_EVENT_WPC_CALL_START) {
+					battery->siop_event |= SIOP_EVENT_WPC_CALL;
+					pr_info("%s : WPC Enable & SIOP EVENT CALL START. 0x%x\n",
+						__func__, battery->siop_event);
+					cancel_delayed_work(&battery->siop_level_work);
+					cancel_delayed_work(&battery->siop_work);
+					wake_lock(&battery->siop_event_wake_lock);
+					queue_delayed_work(battery->monitor_wqueue, &battery->siop_event_work, 0);
+				} else if (x == SIOP_EVENT_WPC_CALL_END) {
+					battery->siop_event &= ~SIOP_EVENT_WPC_CALL;
+					pr_info("%s : WPC Enable & SIOP EVENT CALL END. 0x%x\n",
+						__func__, battery->siop_event);
+					cancel_delayed_work(&battery->siop_level_work);
+					cancel_delayed_work(&battery->siop_work);
+					wake_lock(&battery->siop_event_wake_lock);
+					queue_delayed_work(battery->monitor_wqueue, &battery->siop_event_work,
+							msecs_to_jiffies(5000));
+				} else {
+					battery->siop_event &= ~SIOP_EVENT_WPC_CALL;
+					pr_info("%s : WPC Disable & SIOP EVENT 0x%x\n", __func__, battery->siop_event);
+				}
+			}
+			ret = count;
+		}
+		break;
+	case BATT_CHARGING_SOURCE:
+		break;
+	case FG_REG_DUMP:
+		break;
+	case FG_RESET_CAP:
+		break;
+	case FG_CAPACITY:
+		break;
+	case AUTH:
+		break;
+	case CHG_CURRENT_ADC:
+		break;
+	case WC_ADC:
+		break;
+	case WC_STATUS:
+		break;
+	case WC_ENABLE:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			if (x == 0) {
+				battery->wc_enable = false;
+				battery->wc_enable_cnt = 0;
+			} else if (x == 1) {
+				battery->wc_enable = true;
+				battery->wc_enable_cnt = 0;
+			} else {
+				dev_info(battery->dev,
+					"%s: WPC ENABLE unknown command\n",
+					__func__);
+				return -EINVAL;
+			}
+			wake_lock(&battery->cable_wake_lock);
+			queue_delayed_work(battery->monitor_wqueue,
+					&battery->cable_work, 0);
+			ret = count;
+		}
+		break;
+	case WC_CONTROL:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			if (battery->pdata->wpc_en) {
+				if (x == 0) {
+					battery->wc_enable = false;
+					battery->wc_enable_cnt = 0;
+					gpio_direction_output(battery->pdata->wpc_en, 1);
+					pr_info("%s: WC CONTROL: Disable", __func__);
+				} else if (x == 1) {
+					battery->wc_enable = true;
+					battery->wc_enable_cnt = 0;
+					gpio_direction_output(battery->pdata->wpc_en, 0);
+					pr_info("%s: WC CONTROL: Enable", __func__);
+				} else {
+					dev_info(battery->dev,
+						"%s: WC CONTROL unknown command\n",
+						__func__);
+					return -EINVAL;
+				}
+			}
+			ret = count;
+		}
+		break;
+	case WC_CONTROL_CNT:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			battery->wc_enable_cnt_value = x;
+			ret = count;
+		}
+		break;
+	case HV_CHARGER_STATUS:
+		break;
+	case HV_WC_CHARGER_STATUS:
+		break;
+	case HV_CHARGER_SET:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			dev_info(battery->dev,
+				"%s: HV_CHARGER_SET(%d)\n", __func__, x);
+			if (x == 1) {
+				battery->wire_status = POWER_SUPPLY_TYPE_HV_MAINS;
+				wake_lock(&battery->cable_wake_lock);
+				queue_delayed_work(battery->monitor_wqueue, &battery->cable_work, 0);
+			} else {
+				battery->wire_status = POWER_SUPPLY_TYPE_BATTERY;
+				wake_lock(&battery->cable_wake_lock);
+				queue_delayed_work(battery->monitor_wqueue, &battery->cable_work, 0);
+			}
+			ret = count;
+		}
+		break;
+	case FACTORY_MODE:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			battery->factory_mode = x ? true : false;
+			ret = count;
+		}
+		break;
+	case STORE_MODE:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+#if !defined(CONFIG_SEC_FACTORY)
+			if (x) {
+				battery->store_mode = true;
+				if (is_hv_wire_type(battery->cable_type) ||
+					is_hv_wireless_type(battery->cable_type)) {
+					sec_bat_set_charging_current(battery);
+				}
+			}
+#endif
+			ret = count;
+		}
+		break;
+	case UPDATE:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+#ifdef CONFIG_FUELGAUGE_S2MU005
+
+			/* update rVBAT register every 250ms for AT+BATTTEST */
+			value.intval = 1;
+			psy_do_property(battery->pdata->fuelgauge_name, set,
+							POWER_SUPPLY_PROP_ENERGY_NOW, value);
+			msleep(250);
+
+			sec_bat_get_battery_info(battery);
+
+			/* update rVBAT register every 4s for normal case */
+			value.intval = 0;
+			psy_do_property(battery->pdata->fuelgauge_name, set,
+							POWER_SUPPLY_PROP_ENERGY_NOW, value);
+#else
+			/* update battery info */
+			sec_bat_get_battery_info(battery);
+#endif
+			ret = count;
+		}
+		break;
+	case TEST_MODE:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			battery->test_mode = x;
+			wake_lock(&battery->monitor_wake_lock);
+			queue_delayed_work(battery->monitor_wqueue,
+				&battery->monitor_work, 0);
+			ret = count;
+		}
+		break;
+
+	case BATT_EVENT_CALL:
+	case BATT_EVENT_2G_CALL:
+	case BATT_EVENT_TALK_GSM:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			ret = count;
+		}
+		break;
+	case BATT_EVENT_3G_CALL:
+	case BATT_EVENT_TALK_WCDMA:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			ret = count;
+		}
+		break;
+	case BATT_EVENT_MUSIC:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			ret = count;
+		}
+		break;
+	case BATT_EVENT_VIDEO:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			ret = count;
+		}
+		break;
+	case BATT_EVENT_BROWSER:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			ret = count;
+		}
+		break;
+	case BATT_EVENT_HOTSPOT:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			ret = count;
+		}
+		break;
+	case BATT_EVENT_CAMERA:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			ret = count;
+		}
+		break;
+	case BATT_EVENT_CAMCORDER:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			ret = count;
+		}
+		break;
+	case BATT_EVENT_DATA_CALL:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			ret = count;
+		}
+		break;
+	case BATT_EVENT_WIFI:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			ret = count;
+		}
+		break;
+	case BATT_EVENT_WIBRO:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			ret = count;
+		}
+		break;
+	case BATT_EVENT_LTE:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			ret = count;
+		}
+		break;
+	case BATT_EVENT_LCD:
+		if (sscanf(buf, "%10d\n", &x) == 1) {
+			struct timespec ts;
+			get_monotonic_boottime(&ts);
+			if (x) {
+				battery->lcd_status = true;
+			} else {
+				battery->lcd_status = false;
+			}
+			ret = count;
+		}
+		break;
+	case BATT_EVENT_GPS:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			ret = count;
+		}
+		break;
+	case BATT_TEMP_TABLE:
+		if (sscanf(buf, "%10d %10d %10d %10d %10d %10d %10d %10d\n",
+			&t[0], &t[1], &t[2], &t[3], &t[4], &t[5], &t[6], &t[7]) == 8) {
+			pr_info("%s: (new) %d %d %d %d %d %d %d %d\n",
+				__func__, t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7]);
+			pr_info("%s: (default) %d %d %d %d %d %d %d %d\n",
+				__func__,
+				battery->pdata->temp_high_threshold_normal,
+				battery->pdata->temp_high_recovery_normal,
+				battery->pdata->temp_low_threshold_normal,
+				battery->pdata->temp_low_recovery_normal,
+				battery->pdata->temp_high_threshold_lpm,
+				battery->pdata->temp_high_recovery_lpm,
+				battery->pdata->temp_low_threshold_lpm,
+				battery->pdata->temp_low_recovery_lpm);
+			update_external_temp_table(battery, t);
+			ret = count;
+		}
+		break;
+	case BATT_HIGH_CURRENT_USB:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			union power_supply_propval value;
+			battery->is_hc_usb = x ? true : false;
+			value.intval = battery->is_hc_usb;
+
+			psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_USB_HC, value);
+
+			pr_info("%s: is_hc_usb (%d)\n", __func__, battery->is_hc_usb);
+			ret = count;
+		}
+		break;
+#if defined(CONFIG_SAMSUNG_BATTERY_ENG_TEST)
+	case BATT_TEST_CHARGE_CURRENT:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			if (x >= 0 && x <= 2000) {
+				dev_err(battery->dev,
+					"%s: BATT_TEST_CHARGE_CURRENT(%d)\n", __func__, x);
+				battery->pdata->charging_current[
+					POWER_SUPPLY_TYPE_USB].input_current_limit = x;
+				battery->pdata->charging_current[
+					POWER_SUPPLY_TYPE_USB].fast_charging_current = x;
+				if (x > 500) {
+					battery->eng_not_full_status = true;
+					battery->pdata->temp_check_type =
+						SEC_BATTERY_TEMP_CHECK_NONE;
+					battery->pdata->charging_total_time =
+						10000 * 60 * 60;
+				}
+				if (battery->cable_type == POWER_SUPPLY_TYPE_USB) {
+					value.intval = x;
+					psy_do_property(battery->pdata->charger_name, set,
+						POWER_SUPPLY_PROP_CURRENT_NOW,
+						value);
+				}
+			}
+			ret = count;
+		}
+		break;
+#endif
+	case BATT_STABILITY_TEST:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			dev_err(battery->dev,
+				"%s: BATT_STABILITY_TEST(%d)\n", __func__, x);
+			if (x) {
+				battery->stability_test = true;
+				battery->eng_not_full_status = true;
+			}
+			else {
+				battery->stability_test = false;
+				battery->eng_not_full_status = false;
+			}
+			ret = count;
+		}
+		break;
+	case BATT_CAPACITY_MAX:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			dev_err(battery->dev,
+					"%s: BATT_CAPACITY_MAX(%d), fg_reset(%d)\n", __func__, x, fg_reset);
+			if (!fg_reset) {
+				value.intval = x;
+				psy_do_property(battery->pdata->fuelgauge_name, set,
+						POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN, value);
+
+				/* update soc */
+				value.intval = 0;
+				psy_do_property(battery->pdata->fuelgauge_name, get,
+						POWER_SUPPLY_PROP_CAPACITY, value);
+				battery->capacity = value.intval;
+			}
+			ret = count;
+		}
+		break;
+	case BATT_INBAT_VOLTAGE:
+		break;
+	case BATT_INBAT_VOLTAGE_OCV:
+		break;
+	case CHECK_SLAVE_CHG:
+		break;
+	case BATT_INBAT_WIRELESS_CS100:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+
+			pr_info("%s send cs100 command \n",__func__);
+			value.intval = POWER_SUPPLY_STATUS_FULL;
+			psy_do_property(battery->pdata->wireless_charger_name, set,
+					POWER_SUPPLY_PROP_STATUS, value);
+			ret = count;
+		}
+		break;
+	case HMT_TA_CONNECTED:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+#if !defined(CONFIG_CCIC_NOTIFIER)
+			dev_info(battery->dev,
+					"%s: HMT_TA_CONNECTED(%d)\n", __func__, x);
+			if (x) {
+				value.intval = false;
+				psy_do_property(battery->pdata->charger_name, set,
+						POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL,
+						value);
+				dev_info(battery->dev,
+						"%s: changed to OTG cable detached\n", __func__);
+
+				battery->wire_status = POWER_SUPPLY_TYPE_HMT_CONNECTED;
+				wake_lock(&battery->cable_wake_lock);
+				queue_delayed_work(battery->monitor_wqueue, &battery->cable_work, 0);
+			} else {
+				value.intval = true;
+				psy_do_property(battery->pdata->charger_name, set,
+						POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL,
+						value);
+				dev_info(battery->dev,
+						"%s: changed to OTG cable attached\n", __func__);
+
+				battery->wire_status = POWER_SUPPLY_TYPE_OTG;
+				wake_lock(&battery->cable_wake_lock);
+				queue_delayed_work(battery->monitor_wqueue, &battery->cable_work, 0);
+			}
+#endif
+			ret = count;
+		}
+		break;
+	case HMT_TA_CHARGE:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+#if defined(CONFIG_CCIC_NOTIFIER)
+			dev_info(battery->dev,
+					"%s: HMT_TA_CHARGE(%d)\n", __func__, x);
+			sec_bat_set_current_event(battery, SEC_BAT_CURRENT_EVENT_CHARGE_DISABLE, x);
+			sec_bat_set_charge(battery, x? SEC_BAT_CHG_MODE_CHARGING:SEC_BAT_CHG_MODE_CHARGING_OFF);
+			ret = count;
+#else
+			dev_info(battery->dev,
+					"%s: HMT_TA_CHARGE(%d)\n", __func__, x);
+			psy_do_property(battery->pdata->charger_name, get,
+					POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL, value);
+			if (value.intval) {
+				dev_info(battery->dev,
+					"%s: ignore HMT_TA_CHARGE(%d)\n", __func__, x);
+			} else {
+				if (x) {
+					value.intval = false;
+					psy_do_property(battery->pdata->charger_name, set,
+							POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL,
+							value);
+					dev_info(battery->dev,
+						"%s: changed to OTG cable detached\n", __func__);
+					battery->wire_status = POWER_SUPPLY_TYPE_HMT_CHARGE;
+					wake_lock(&battery->cable_wake_lock);
+					queue_delayed_work(battery->monitor_wqueue, &battery->cable_work, 0);
+				} else {
+					value.intval = false;
+					psy_do_property(battery->pdata->charger_name, set,
+							POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL,
+							value);
+					dev_info(battery->dev,
+							"%s: changed to OTG cable detached\n", __func__);
+					battery->wire_status = POWER_SUPPLY_TYPE_HMT_CONNECTED;
+					wake_lock(&battery->cable_wake_lock);
+					queue_delayed_work(battery->monitor_wqueue, &battery->cable_work, 0);
+				}
+			}
+			ret = count;
+#endif
+		}
+		break;
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	case FG_CYCLE:
+		break;
+	case FG_FULL_VOLTAGE:
+		break;
+	case FG_FULLCAPNOM:
+		break;
+#if defined(CONFIG_BATTERY_AGE_FORECAST_DETACHABLE)
+	case BATT_AFTER_MANUFACTURED:
+#else
+	case BATTERY_CYCLE:
+#endif
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			dev_info(battery->dev, "%s: %s(%d)\n", __func__,
+				(offset == BATTERY_CYCLE) ?
+				"BATTERY_CYCLE" : "BATTERY_CYCLE(W)", x);
+			if (x >= 0) {
+				int prev_battery_cycle = battery->batt_cycle;
+				battery->batt_cycle = x;
+#if defined(CONFIG_BATTERY_CISD)
+				battery->cisd.data[CISD_DATA_CYCLE] = x;
+#endif
+				dev_info(battery->dev, "%s: [Long life] prev_battery_cycle = %d, new bat. cycle = %d\n", __func__, prev_battery_cycle, battery->batt_cycle);
+				if (prev_battery_cycle < 0) {
+					dev_info(battery->dev, "%s: [Long life] Do sec_bat_aging_check()\n", __func__);
+					sec_bat_aging_check(battery);
+				}
+			}
+			ret = count;
+		}
+		break;
+#endif
+#if defined(CONFIG_DCM_JPN_CONCEPT_FG_CYCLE_CHECK)
+	case FG_CYCLE_CHECK_VALUE:
+		break;
+#endif
+	case BATT_WPC_TEMP:
+	case BATT_WPC_TEMP_ADC:
+		break;
+#if defined(CONFIG_WIRELESS_FIRMWARE_UPDATE)
+	case BATT_WIRELESS_FIRMWARE_UPDATE:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			if (x == SEC_WIRELESS_RX_SDCARD_MODE) {
+				pr_info("%s fw mode is SDCARD \n", __func__);
+				sec_bat_fw_update_work(battery, SEC_WIRELESS_RX_SDCARD_MODE);
+			} else if (x == SEC_WIRELESS_RX_BUILT_IN_MODE) {
+				pr_info("%s fw mode is BUILD IN \n", __func__);
+				sec_bat_fw_update_work(battery, SEC_WIRELESS_RX_BUILT_IN_MODE);
+			} else if (x == SEC_WIRELESS_TX_ON_MODE) {
+				pr_info("%s tx mode is on \n", __func__);
+				sec_bat_fw_update_work(battery, SEC_WIRELESS_TX_ON_MODE);
+			} else if (x == SEC_WIRELESS_TX_OFF_MODE) {
+				pr_info("%s tx mode is off \n", __func__);
+				sec_bat_fw_update_work(battery, SEC_WIRELESS_TX_OFF_MODE);
+			} else {
+				dev_info(battery->dev, "%s: wireless firmware unknown command\n", __func__);
+				return -EINVAL;
+			}
+			ret = count;
+		}
+		break;
+	case BATT_WIRELESS_OTP_FIRMWARE_RESULT:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			if (x == 2) {
+				value.intval = x;
+				pr_info("%s RX firmware update ready!\n", __func__);
+				psy_do_property(battery->pdata->wireless_charger_name, set,
+								POWER_SUPPLY_PROP_MANUFACTURER, value);
+			} else {
+				dev_info(battery->dev, "%s: firmware unknown command\n", __func__);
+				return -EINVAL;
+			}
+			ret = count;
+		}
+		break;
+	case BATT_WIRELESS_IC_GRADE:
+	case BATT_WIRELESS_FIRMWARE_VER_BIN:
+	case BATT_WIRELESS_FIRMWARE_VER:
+	case BATT_WIRELESS_TX_FIRMWARE_RESULT:
+	case BATT_WIRELESS_TX_FIRMWARE_VER:
+		break;
+	case BATT_TX_STATUS:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			if (x == SEC_TX_OFF) {
+				pr_info("%s TX mode is off \n", __func__);
+				sec_bat_fw_update_work(battery, SEC_WIRELESS_TX_OFF_MODE);
+			} else if (x == SEC_TX_STANDBY) {
+				pr_info("%s TX mode is on \n", __func__);
+				sec_bat_fw_update_work(battery, SEC_WIRELESS_TX_ON_MODE);
+			} else {
+				dev_info(battery->dev, "%s: TX firmware unknown command\n", __func__);
+				return -EINVAL;
+			}
+			ret = count;
+		}
+		break;
+#endif
+	case BATT_WIRELESS_VOUT:
+	case BATT_WIRELESS_VRCT:
+		break;
+	case BATT_HV_WIRELESS_STATUS:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			if (x == 1 && is_hv_wireless_type(battery->cable_type)) {
+				wake_lock(&battery->cable_wake_lock);
+#ifdef CONFIG_SEC_FACTORY
+				pr_info("%s change cable type HV WIRELESS -> WIRELESS \n", __func__);
+				battery->wc_status = SEC_WIRELESS_PAD_WPC;
+				battery->cable_type = POWER_SUPPLY_TYPE_WIRELESS;
+				sec_bat_set_charging_current(battery);
+#endif
+				pr_info("%s HV_WIRELESS_STATUS set to 1. Vout set to 5V. \n", __func__);
+				value.intval = WIRELESS_VOUT_5V;
+				psy_do_property(battery->pdata->wireless_charger_name, set,
+					POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+				wake_unlock(&battery->cable_wake_lock);
+			} else if (x == 3 && is_hv_wireless_type(battery->cable_type)) {
+				pr_info("%s HV_WIRELESS_STATUS set to 3. Vout set to 9V. \n", __func__);
+				value.intval = WIRELESS_VOUT_9V;
+				psy_do_property(battery->pdata->wireless_charger_name, set,
+					POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+			} else {
+				dev_info(battery->dev, "%s: HV_WIRELESS_STATUS unknown command\n", __func__);
+				return -EINVAL;
+			}
+			ret = count;
+		}
+		break;
+	case BATT_HV_WIRELESS_PAD_CTRL:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+
+			pr_err("%s: x : %d\n", __func__, x);
+
+			if (x == 1) {
+#if 0 //temp block
+				ret = sec_set_param(CM_OFFSET, '1');
+#endif
+				if (ret < 0) {
+					pr_err("%s:sec_set_param failed\n", __func__);
+					return ret;
+				} else {
+					pr_info("%s fan off \n", __func__);
+					sleep_mode = true;
+					if (is_hv_wireless_type(battery->cable_type)) {
+#if defined(CONFIG_CALC_TIME_TO_FULL)
+						battery->complete_timetofull = false;
+#endif
+						value.intval = WIRELESS_PAD_FAN_ON;
+						psy_do_property(battery->pdata->wireless_charger_name, set,
+									POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+						msleep(250);
+						value.intval = WIRELESS_PAD_FAN_OFF;
+						psy_do_property(battery->pdata->wireless_charger_name, set,
+							POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+
+						msleep(250);
+						value.intval = battery->pdata->sleep_mode_limit_current;
+						psy_do_property(battery->pdata->charger_name, set,
+								POWER_SUPPLY_PROP_CURRENT_MAX, value);
+						battery->input_current = value.intval;
+#if defined(CONFIG_CALC_TIME_TO_FULL)
+						queue_delayed_work(battery->monitor_wqueue, &battery->timetofull_work,
+								msecs_to_jiffies(5000));
+#endif
+						wake_lock(&battery->monitor_wake_lock);
+						queue_delayed_work(battery->monitor_wqueue, &battery->monitor_work, 0);
+					}
+				}
+			} else if (x == 2) {
+#if 0 //temp block
+				ret = sec_set_param(CM_OFFSET, '0');
+#endif
+				if (ret < 0) {
+					pr_err("%s: sec_set_param failed\n", __func__);
+					return ret;
+				} else {
+					sleep_mode = false;
+					pr_info("%s fan on \n", __func__);
+					if (is_hv_wireless_type(battery->cable_type)) {
+#if defined(CONFIG_CALC_TIME_TO_FULL)
+						battery->complete_timetofull = false;
+#endif
+						value.intval = WIRELESS_PAD_FAN_ON;
+						psy_do_property(battery->pdata->wireless_charger_name, set,
+									POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+
+						msleep(250);
+
+#if defined(CONFIG_CALC_TIME_TO_FULL)
+						queue_delayed_work(battery->monitor_wqueue, &battery->timetofull_work,
+								msecs_to_jiffies(5000));
+#endif
+						wake_lock(&battery->monitor_wake_lock);
+						queue_delayed_work(battery->monitor_wqueue, &battery->monitor_work, 0);
+					}
+				}
+			} else if (x == 3) {
+				pr_info("%s led off \n", __func__);
+				value.intval = WIRELESS_PAD_LED_OFF;
+				psy_do_property(battery->pdata->wireless_charger_name, set,
+								POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+			} else if (x == 4) {
+				pr_info("%s led on \n", __func__);
+				value.intval = WIRELESS_PAD_LED_ON;
+				psy_do_property(battery->pdata->wireless_charger_name, set,
+								POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+			} else {
+				dev_info(battery->dev, "%s: BATT_HV_WIRELESS_PAD_CTRL unknown command\n", __func__);
+				return -EINVAL;
+			}
+			ret = count;
+		}
+		break;
+	case BATT_TUNE_FLOAT_VOLTAGE:
+		sscanf(buf, "%d\n", &x);
+		pr_info("%s float voltage = %d mV",__func__, x);
+
+		if (x > 4000 && x <= 4400 ) {
+			value.intval = x;
+			psy_do_property(battery->pdata->charger_name, set,
+					POWER_SUPPLY_PROP_VOLTAGE_MAX, value);
+		}
+		break;
+	case BATT_TUNE_INPUT_CHARGE_CURRENT:
+		sscanf(buf, "%d\n", &x);
+		pr_info("%s input charge current = %d mA",__func__, x);
+
+		if (x > 0 && x <= 4000 ) {
+			for (i=0; i<POWER_SUPPLY_TYPE_MAX; i++)
+				battery->pdata->charging_current[i].input_current_limit = x;
+
+			value.intval = x;
+			psy_do_property(battery->pdata->charger_name, set,
+						POWER_SUPPLY_PROP_CURRENT_MAX, value);
+		}
+		break;
+	case BATT_TUNE_FAST_CHARGE_CURRENT:
+		sscanf(buf, "%d\n", &x);
+		pr_info("%s fast charge current = %d mA",__func__, x);
+		if (x > 0 && x <= 4000 ) {
+			for (i=0; i<POWER_SUPPLY_TYPE_MAX; i++)
+				battery->pdata->charging_current[i].fast_charging_current = x;
+
+			value.intval = x;
+				psy_do_property(battery->pdata->charger_name, set,
+					POWER_SUPPLY_PROP_CURRENT_AVG, value);
+		}
+		break;
+	case BATT_TUNE_UI_TERM_CURRENT_1ST:
+		sscanf(buf, "%d\n", &x);
+		pr_info("%s ui term current = %d mA",__func__, x);
+
+		if (x > 0 && x < 1000 ) {
+			for (i=0; i<POWER_SUPPLY_TYPE_MAX; i++)
+				battery->pdata->charging_current[i].full_check_current_1st = x;
+		}
+		break;
+	case BATT_TUNE_UI_TERM_CURRENT_2ND:
+		sscanf(buf, "%d\n", &x);
+		pr_info("%s ui term current = %d mA",__func__, x);
+
+		if (x > 0 && x < 1000 ) {
+			for (i=0; i<POWER_SUPPLY_TYPE_MAX; i++)
+				battery->pdata->charging_current[i].full_check_current_1st = x;
+		}
+		break;	
+	case BATT_TUNE_TEMP_HIGH_NORMAL:
+		sscanf(buf, "%d\n", &x);
+		pr_info("%s temp high normal block	= %d ",__func__, x);
+		if (x < 900 && x > -200)
+			battery->pdata->temp_high_threshold_normal = x;
+		break;
+	case BATT_TUNE_TEMP_HIGH_REC_NORMAL:
+		sscanf(buf, "%d\n", &x);
+		pr_info("%s temp high normal recover  = %d ",__func__, x);
+		if (x <900 && x > -200)
+			battery->pdata->temp_high_recovery_normal = x;
+		break;
+	case BATT_TUNE_TEMP_LOW_NORMAL:
+		sscanf(buf, "%d\n", &x);
+		pr_info("%s temp low normal block  = %d ",__func__, x);
+		if (x <900 && x > -200)
+			battery->pdata->temp_low_threshold_normal = x;
+		break;
+	case BATT_TUNE_TEMP_LOW_REC_NORMAL:
+		sscanf(buf, "%d\n", &x);
+		pr_info("%s temp low normal recover  = %d ",__func__, x);
+		if (x <900 && x > -200)
+			battery->pdata->temp_low_recovery_normal = x;
+		break;
+	case BATT_TUNE_CHG_TEMP_HIGH:
+		sscanf(buf, "%d\n", &x);
+		pr_info("%s chg_high_temp  = %d ",__func__, x);
+		if (x <900 && x > -200)
+			battery->pdata->chg_high_temp = x;
+		break;
+	case BATT_TUNE_CHG_TEMP_REC:
+		sscanf(buf, "%d\n", &x);
+		pr_info("%s chg_high_temp_recovery	= %d ",__func__, x);
+		if (x <900 && x > -200)
+			battery->pdata->chg_high_temp_recovery = x;
+		break;
+	case BATT_TUNE_CHG_LIMMIT_CURRENT:
+		sscanf(buf, "%d\n", &x);
+		pr_info("%s chg_charging_limit_current	= %d ",__func__, x);
+		if (x <3000 && x > 0)
+		{
+			battery->pdata->chg_charging_limit_current = x;
+			battery->pdata->charging_current[POWER_SUPPLY_TYPE_HV_ERR].input_current_limit= x;
+			battery->pdata->charging_current[POWER_SUPPLY_TYPE_HV_UNKNOWN].input_current_limit= x;
+			battery->pdata->charging_current[POWER_SUPPLY_TYPE_HV_MAINS].input_current_limit= x;
+		}
+		break;
+	case BATT_TUNE_COIL_TEMP_HIGH:
+		break;
+	case BATT_TUNE_COIL_TEMP_REC:
+		break;
+	case BATT_TUNE_COIL_LIMMIT_CURRENT:
+		sscanf(buf, "%d\n", &x);
+		pr_info("%s wpc_charging_limit_current	= %d ",__func__, x);
+		if (x <3000 && x > 0)
+		{
+			battery->pdata->charging_current[POWER_SUPPLY_TYPE_HV_ERR].input_current_limit= x;
+			battery->pdata->charging_current[POWER_SUPPLY_TYPE_HV_UNKNOWN].input_current_limit= x;
+			battery->pdata->charging_current[POWER_SUPPLY_TYPE_HV_MAINS].input_current_limit= x;
+		}
+		break;
+#if defined(CONFIG_UPDATE_BATTERY_DATA)
+	case BATT_UPDATE_DATA:
+		if (!battery->data_path && (count * sizeof(char)) < 256) {
+			battery->data_path = kzalloc((count * sizeof(char) + 1), GFP_KERNEL);
+			if (battery->data_path) {
+				sscanf(buf, "%s\n", battery->data_path);
+				cancel_delayed_work(&battery->batt_data_work);
+				wake_lock(&battery->batt_data_wake_lock);
+				queue_delayed_work(battery->monitor_wqueue,
+					&battery->batt_data_work, msecs_to_jiffies(100));
+			} else {
+				pr_info("%s: failed to alloc data_path buffer\n", __func__);
+			}
+		}
+		ret = count;
+		break;
+#endif
+	case BATT_MISC_EVENT:
+		break;
+	case BATT_EXT_DEV_CHG:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			pr_info("%s: Connect Ext Device : %d ",__func__, x);
+
+			switch (x) {
+				case EXT_DEV_NONE:
+					battery->wire_status = POWER_SUPPLY_TYPE_BATTERY;
+					value.intval = 0;
+					break;
+				case EXT_DEV_GAMEPAD_CHG:
+					battery->wire_status = POWER_SUPPLY_TYPE_MAINS;
+					value.intval = 0;
+					break;
+				case EXT_DEV_GAMEPAD_OTG:
+					battery->wire_status = POWER_SUPPLY_TYPE_OTG;
+					value.intval = 1;
+					break;
+				default:
+					break;
+			}
+
+			psy_do_property(battery->pdata->charger_name, set,
+					POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL,
+					value);
+
+			queue_delayed_work(battery->monitor_wqueue,
+					&battery->cable_work, 0);
+			ret = count;
+		}
+		break;
+	case BATT_WDT_CONTROL:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			pr_info("%s: Charger WDT Set : %d\n", __func__, x);
+			battery->wdt_kick_disable = x;
+		}
+		ret = count;
+		break;
+	case BATT_SWELLING_CONTROL:
+		if (sscanf(buf, "%10d\n", &x) == 1) {
+			if (x) {
+				pr_info("%s : 15TEST START!! SWELLING MODE DISABLE\n", __func__);
+				battery->skip_swelling = true;
+			} else {
+				pr_info("%s : 15TEST END!! SWELLING MODE END\n", __func__);
+				battery->skip_swelling = false;
+			}
+			ret = count;
+		}
+		break;
+	case MODE:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			value.intval = x;
+			psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_EXT_PROP_MULTI_CHARGER_MODE, value);
+			ret = count;
+		}
+		break;
+	case CHECK_PS_READY:
+		break;
+	case FACTORY_MODE_RELIEVE:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			value.intval = x;
+			psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION, value);
+			ret = count;
+		}
+		break;
+	case FACTORY_MODE_BYPASS:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			value.intval = x;
+			psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_AUTHENTIC, value);
+			ret = count;
+		}
+		break;
+	case NORMAL_MODE_BYPASS:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			value.intval = x;
+			psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_CURRENT_MEASURE, value);
+			ret = count;
+		}
+		break;
+	case FACTORY_VOLTAGE_REGULATION:
+		{
+			sscanf(buf, "%d\n", &x);
+			value.intval = x;
+			psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_EXT_PROP_FACTORY_VOLTAGE_REGULATION, value);
+
+			value.intval =
+				SEC_FUELGAUGE_CAPACITY_TYPE_RESET;
+			psy_do_property(battery->pdata->fuelgauge_name, set,
+					POWER_SUPPLY_PROP_CAPACITY, value);
+			dev_info(battery->dev,"do reset SOC\n");
+			/* update battery info */
+			sec_bat_get_battery_info(battery);
+		}
+		ret = count;
+		break;
+	case FACTORY_MODE_DISABLE:
+		if (sscanf(buf, "%10d\n", &x) == 1) {
+			value.intval = x;
+			psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_EXT_PROP_DISABLE_FACTORY_MODE, value);
+			ret = count;
+		}
+		break;
+#if defined(CONFIG_BATTERY_CISD)
+	case CISD_DATA:
+		{
+			int temp_data[CISD_DATA_MAX] = {0,};
+
+			if (sscanf(buf, "%10d, %10d, %10d, %10d, %10d, %10d, %10d, %10d, %10d, %10d, %10d, %10d, %10d, %10d, %10d, %10d, %10d, %10d, %10d, %10d, %10d, %10d, %10d, %10d, %10d, %10d, %10d, %10d, %10d, %10d, %10d, %10d, %10d, %10d, %10d, %10d, %10d, %10d, %10d, %10d\n",
+					&temp_data[0], &temp_data[1], &temp_data[2],
+					&temp_data[3], &temp_data[4], &temp_data[5],
+					&temp_data[6], &temp_data[7], &temp_data[8],
+					&temp_data[9], &temp_data[10], &temp_data[11],
+					&temp_data[12], &temp_data[13], &temp_data[14],
+					&temp_data[15], &temp_data[16], &temp_data[17],
+					&temp_data[18], &temp_data[19], &temp_data[20],
+					&temp_data[21], &temp_data[22], &temp_data[23],
+					&temp_data[24], &temp_data[25], &temp_data[26],
+					&temp_data[27], &temp_data[28], &temp_data[29],
+					&temp_data[30], &temp_data[31], &temp_data[32],
+					&temp_data[33], &temp_data[34], &temp_data[35],
+					&temp_data[36], &temp_data[37], &temp_data[38],
+					&temp_data[39]) <= CISD_DATA_MAX) {
+				struct cisd *pcisd = &battery->cisd;
+
+				for (i = 0; i < CISD_DATA_MAX; i++) {
+					if (i == CISD_DATA_CAP_PER_TIME ||
+						i == CISD_DATA_BATT_TEMP_MIN ||
+						i == CISD_DATA_CHG_TEMP_MIN ||
+						i == CISD_DATA_WPC_TEMP_MIN ||
+						i == CISD_DATA_CAP_MIN)
+						continue;
+
+					if (temp_data[i] < 0) {
+						temp_data[0] = -1;
+						break;
+					}
+				}
+
+				pr_info("%s: %s cisd data\n", __func__, ((temp_data[0] <= 0 || fg_reset) ? "init" : "update"));
+				if (temp_data[0] <= 0 || fg_reset) {
+					/* initialize data */
+					for (i = 0; i < CISD_DATA_MAX; i++)
+						battery->cisd.data[i] = 0;
+					fg_reset = 0;
+
+					pcisd->data[CISD_DATA_FULL_COUNT] = 1;
+					pcisd->data[CISD_DATA_CAP_ONCE] = 0;
+					pcisd->data[CISD_DATA_CAP_PER_TIME] = 0;
+					pcisd->data[CISD_DATA_RECHARGING_TIME] = 0x7FFFFFFF;
+					pcisd->data[CISD_DATA_BATT_TEMP_MAX] = -300;
+					pcisd->data[CISD_DATA_CHG_TEMP_MAX] = -300;
+					pcisd->data[CISD_DATA_WPC_TEMP_MAX] = -300;
+					pcisd->data[CISD_DATA_BATT_TEMP_MIN] = 1000;
+					pcisd->data[CISD_DATA_CHG_TEMP_MIN] = 1000;
+					pcisd->data[CISD_DATA_WPC_TEMP_MIN] = 1000;
+					pcisd->data[CISD_DATA_CAP_MIN] = 0xFFFF;
+				} else {
+					/* update data */
+					for (i = 0; i < CISD_DATA_MAX; i++)
+						pcisd->data[i] = temp_data[i];
+				}
+				ret = count;
+
+				wake_lock(&battery->monitor_wake_lock);
+				queue_delayed_work(battery->monitor_wqueue, &battery->monitor_work, 0);
+			}
+		}
+		break;
+	case CISD_DATA_JSON:
+		{
+			char tc;
+			struct cisd *pcisd = &battery->cisd;
+
+			if (sscanf(buf, "%1c\n", &tc) == 1) {
+				if (tc == 'c') {
+					for (i = 0; i < CISD_DATA_MAX; i++)
+						pcisd->data[i] = 0;
+
+					pcisd->data[CISD_DATA_CAP_ONCE] = 0;
+					pcisd->data[CISD_DATA_CAP_PER_TIME] = 0;
+					pcisd->data[CISD_DATA_RECHARGING_TIME] = 0x7FFFFFFF;
+					pcisd->data[CISD_DATA_BATT_TEMP_MAX] = -300;
+					pcisd->data[CISD_DATA_CHG_TEMP_MAX] = -300;
+					pcisd->data[CISD_DATA_WPC_TEMP_MAX] = -300;
+					pcisd->data[CISD_DATA_BATT_TEMP_MIN] = 1000;
+					pcisd->data[CISD_DATA_CHG_TEMP_MIN] = 1000;
+					pcisd->data[CISD_DATA_WPC_TEMP_MIN] = 1000;
+				}
+			}
+			ret = count;
+		}
+		break;
+	case CISD_WIRE_COUNT:
+		if (sscanf(buf, "%10d\n", &x) == 1) {
+			struct cisd *pcisd = &battery->cisd;
+			pr_info("%s: Wire Count : %d\n", __func__, x);
+			pcisd->data[CISD_DATA_WIRE_COUNT] = x;
+		}
+		ret = count;
+		break;
+	case CISD_DATA_EFS_PATH:
+		break;
+#endif
+	case SAFETY_TIMER_SET:
+		if (sscanf(buf, "%10d\n", &x) == 1) {
+			if (x) {
+				battery->safety_timer_set = true;
+			} else {
+				battery->safety_timer_set = false;
+			}
+			ret = count;
+		}
+		break;
+	case SAFETY_TIMER_INFO:
+		break;
+	case BATT_PRESENT:
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static int sec_bat_create_attrs(struct device *dev)
+{
+	unsigned long i = 0;
+	int rc = 0;
+
+	for (i = 0; i < ARRAY_SIZE(sec_battery_attrs); i++) {
+		rc = device_create_file(dev, &sec_battery_attrs[i]);
+		if (rc)
+			goto create_attrs_failed;
+	}
+	goto create_attrs_succeed;
+
+create_attrs_failed:
+	while (i--)
+		device_remove_file(dev, &sec_battery_attrs[i]);
+create_attrs_succeed:
+	return rc;
+}
+
+static int sec_bat_set_property(struct power_supply *psy,
+				enum power_supply_property psp,
+				const union power_supply_propval *val)
+{
+	struct sec_battery_info *battery =
+		container_of(psy, struct sec_battery_info, psy_bat);
+	int current_cable_type;
+	int full_check_type;
+	union power_supply_propval value;
+	enum power_supply_ext_property ext_psp = psp;
+
+	dev_dbg(battery->dev,
+		"%s: (%d,%d)\n", __func__, psp, val->intval);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		if (battery->charging_mode == SEC_BATTERY_CHARGING_1ST)
+			full_check_type = battery->pdata->full_check_type;
+		else
+			full_check_type = battery->pdata->full_check_type_2nd;
+		if ((full_check_type == SEC_BATTERY_FULLCHARGED_CHGINT) &&
+			(val->intval == POWER_SUPPLY_STATUS_FULL))
+			sec_bat_do_fullcharged(battery);
+		sec_bat_set_charging_status(battery, val->intval);
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		sec_bat_ovp_uvlo_result(battery, val->intval);
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		current_cable_type = val->intval;
+#if !defined(CONFIG_CCIC_NOTIFIER)
+		if ((battery->muic_cable_type != ATTACHED_DEV_SMARTDOCK_TA_MUIC)
+		    && ((current_cable_type == POWER_SUPPLY_TYPE_SMART_OTG) ||
+			(current_cable_type == POWER_SUPPLY_TYPE_SMART_NOTG)))
+			break;
+#endif
+
+		if (current_cable_type < 0) {
+			dev_info(battery->dev,
+					"%s: ignore event(%d)\n",
+					__func__, current_cable_type);
+		} else if (current_cable_type == POWER_SUPPLY_TYPE_OTG) {
+			battery->charging_mode = SEC_BATTERY_CHARGING_NONE;
+			battery->is_recharging = false;
+			sec_bat_set_charging_status(battery,
+					POWER_SUPPLY_STATUS_DISCHARGING);
+			battery->cable_type = current_cable_type;
+			wake_lock(&battery->monitor_wake_lock);
+			queue_delayed_work(battery->monitor_wqueue,
+					   &battery->monitor_work, 0);
+			break;
+		} else {
+			battery->wire_status = current_cable_type;
+			if ((battery->wire_status == POWER_SUPPLY_TYPE_BATTERY) &&
+				(battery->wc_status != SEC_WIRELESS_PAD_NONE) )
+				current_cable_type = POWER_SUPPLY_TYPE_WIRELESS;
+		}
+		dev_info(battery->dev,
+				"%s: current_cable(%d), wc_status(%d), wire_status(%d)\n",
+				__func__, current_cable_type, battery->wc_status,
+				battery->wire_status);
+
+		/* cable is attached or detached
+		 * if current_cable_type is minus value,
+		 * check cable by sec_bat_get_cable_type()
+		 * although SEC_BATTERY_CABLE_SOURCE_EXTERNAL is set
+		 * (0 is POWER_SUPPLY_TYPE_UNKNOWN)
+		 */
+		if ((current_cable_type >= 0) &&
+			(current_cable_type < SEC_SIZEOF_POWER_SUPPLY_TYPE) &&
+			(battery->pdata->cable_source_type &
+			SEC_BATTERY_CABLE_SOURCE_EXTERNAL)) {
+
+			wake_lock(&battery->cable_wake_lock);
+				queue_delayed_work(battery->monitor_wqueue,
+					&battery->cable_work,0);
+		} else {
+			if (sec_bat_get_cable_type(battery,
+						battery->pdata->cable_source_type)) {
+				wake_lock(&battery->cable_wake_lock);
+					queue_delayed_work(battery->monitor_wqueue,
+						&battery->cable_work,0);
+			}
+		}
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		battery->capacity = val->intval;
+		power_supply_changed(&battery->psy_bat);
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		/* If JIG is attached, the voltage is set as 1079 */
+		pr_info("%s : set to the battery history : (%d)\n",__func__, val->intval);
+		if (val->intval == 1079)	{
+			battery->voltage_now = 1079;
+			battery->voltage_avg = 1079;
+			power_supply_changed(&battery->psy_bat);
+		}
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+		queue_delayed_work(battery->monitor_wqueue, &battery->monitor_work, 0);
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		battery->present = val->intval;
+
+		wake_lock(&battery->monitor_wake_lock);
+		queue_delayed_work(battery->monitor_wqueue,
+				   &battery->monitor_work, 0);
+		break;
+#if defined(CONFIG_BATTERY_SWELLING)
+	case POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT:
+		break;
+#endif
+	case POWER_SUPPLY_PROP_INPUT_VOLTAGE_REGULATION:
+	case POWER_SUPPLY_PROP_CHARGE_COUNTER_SHADOW:
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL:
+		value.intval = val->intval;
+		pr_info("%s: CHGIN-OTG %s\n", __func__, value.intval > 0 ? "on" : "off");
+		psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL, value);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_UNO_CONTROL:
+		value.intval = val->intval;
+		pr_info("%s: WCIN-UNO %s\n", __func__, value.intval > 0 ? "on" : "off");
+		psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_CHARGE_UNO_CONTROL, value);
+		break;
+#if defined(CONFIG_UPDATE_BATTERY_DATA)
+	case POWER_SUPPLY_PROP_POWER_DESIGN:
+		sec_bat_parse_dt(battery->dev, battery);
+		break;
+#endif
+#if defined(CONFIG_BATTERY_CISD)
+	case POWER_SUPPLY_PROP_VOLTAGE_MIN:
+		pr_info("%s: Valert was occured! run monitor work for updating cisd data!\n", __func__);
+		battery->cisd.data[CISD_DATA_VALERT_COUNT]++;
+		wake_lock(&battery->monitor_wake_lock);
+		queue_delayed_work_on(0, battery->monitor_wqueue,
+			&battery->monitor_work, 0);
+		break;
+#endif
+#if !defined(CONFIG_SAMSUNG_BATTERY_ENG_TEST) && !defined(CONFIG_SEC_FACTORY)
+	case POWER_SUPPLY_PROP_SCOPE:
+		battery->block_water_event = val->intval;
+		break;
+#endif
+	case POWER_SUPPLY_PROP_MAX ... POWER_SUPPLY_EXT_PROP_MAX:
+		switch (ext_psp) {
+		case POWER_SUPPLY_EXT_PROP_AICL_CURRENT:
+			battery->aicl_current = val->intval;
+			battery->max_charge_power = battery->charge_power = battery->input_voltage * val->intval;
+			pr_info("%s: aicl : %dmA, %dmW)\n", __func__,
+				battery->aicl_current, battery->charge_power);
+#if defined(CONFIG_BATTERY_CISD)
+			battery->cisd.data[CISD_DATA_AICL_COUNT]++;
+#endif
+			break;
+		case POWER_SUPPLY_EXT_PROP_SYSOVLO:
+			if (battery->status != POWER_SUPPLY_STATUS_DISCHARGING) {
+				pr_info("%s: Vsys is ovlo !!\n", __func__);
+				battery->is_sysovlo = true;
+				battery->is_recharging = false;
+				battery->charging_mode = SEC_BATTERY_CHARGING_NONE;
+				battery->health = POWER_SUPPLY_HEALTH_VSYS_OVP;
+				sec_bat_set_current_event(battery, SEC_BAT_CURRENT_EVENT_VSYS_OVP, 0); 			
+				sec_bat_set_charging_status(battery, POWER_SUPPLY_STATUS_NOT_CHARGING);
+#if defined(CONFIG_BATTERY_CISD)
+				battery->cisd.data[CISD_VSYS_OVP]++;
+#endif
+#if defined(CONFIG_SEC_ABC)
+				sec_abc_send_event("MODULE=battery@ERROR=vsys_ovp");
+#endif
+				sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING_OFF);
+				wake_lock(&battery->monitor_wake_lock);
+				queue_delayed_work(battery->monitor_wqueue,
+						   &battery->monitor_work, 0);
+			}
+			break;
+		case POWER_SUPPLY_EXT_PROP_HV_DISABLE:
+			pr_info("HV wired charging mode is %s\n", (val->intval == CH_MODE_AFC_DISABLE_VAL ? "Disabled" : "Enabled"));
+			sec_bat_set_current_event(battery, SEC_BAT_CURRENT_EVENT_HV_DISABLE,
+				(val->intval == CH_MODE_AFC_DISABLE_VAL ? 0 : 1));
+			break;
+		case POWER_SUPPLY_EXT_PROP_VBAT_OVP:
+			if (battery->status != POWER_SUPPLY_STATUS_DISCHARGING) {
+				pr_info("%s: Vbat is ovlo !!\n", __func__);
+				battery->is_vbatovlo = true;
+				battery->is_recharging = false;
+				battery->charging_mode = SEC_BATTERY_CHARGING_NONE;
+				battery->health = POWER_SUPPLY_HEALTH_VBAT_OVP;
+				sec_bat_set_current_event(battery, SEC_BAT_CURRENT_EVENT_VBAT_OVP, 0); 
+				sec_bat_set_charging_status(battery, POWER_SUPPLY_STATUS_NOT_CHARGING);
+
+				sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING_OFF);
+				wake_lock(&battery->monitor_wake_lock);
+				queue_delayed_work(battery->monitor_wqueue,
+						   &battery->monitor_work, 0);
+			}
+			break;
+		case POWER_SUPPLY_EXT_PROP_USB_CONFIGURE:
+#if defined(CONFIG_CCIC_NOTIFIER)
+			if (battery->pdic_info.sink_status.rp_currentlvl > RP_CURRENT_LEVEL_DEFAULT)
+				return 0;
+#endif
+			pr_info("%s: usb configured %d\n", __func__, val->intval);
+			if (val->intval == USB_CURRENT_UNCONFIGURED) {
+				sec_bat_set_current_event(battery, SEC_BAT_CURRENT_EVENT_USB_100MA, 0);
+				sec_bat_set_current_event(battery, SEC_BAT_CURRENT_EVENT_USB_SUPER, 1);
+			} else if (val->intval == USB_CURRENT_HIGH_SPEED) {
+				sec_bat_set_misc_event(battery, BATT_MISC_EVENT_TIMEOUT_OPEN_TYPE, 1);
+				sec_bat_set_current_event(battery, (SEC_BAT_CURRENT_EVENT_USB_100MA | SEC_BAT_CURRENT_EVENT_USB_SUPER), 1);
+				sec_bat_change_default_current(battery, POWER_SUPPLY_TYPE_USB,
+						battery->pdata->default_usb_input_current,
+						battery->pdata->default_usb_charging_current);
+			} else if (val->intval == USB_CURRENT_SUPER_SPEED) {
+				sec_bat_set_misc_event(battery, BATT_MISC_EVENT_TIMEOUT_OPEN_TYPE, 1);
+				sec_bat_set_current_event(battery, SEC_BAT_CURRENT_EVENT_USB_100MA, 1);
+				sec_bat_set_current_event(battery, SEC_BAT_CURRENT_EVENT_USB_SUPER, 0);
+				sec_bat_change_default_current(battery, POWER_SUPPLY_TYPE_USB,
+						USB_CURRENT_SUPER_SPEED, USB_CURRENT_SUPER_SPEED);
+			}
+			sec_bat_set_charging_current(battery);
+			break;
+		default:
+			return -EINVAL;
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sec_bat_get_property(struct power_supply *psy,
+				enum power_supply_property psp,
+				union power_supply_propval *val)
+{
+	struct sec_battery_info *battery =
+		container_of(psy, struct sec_battery_info, psy_bat);
+	union power_supply_propval value = {0, };
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		if ((battery->health == POWER_SUPPLY_HEALTH_OVERVOLTAGE) ||
+			(battery->health == POWER_SUPPLY_HEALTH_UNDERVOLTAGE)) {
+				val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+		} else {
+			if ((battery->pdata->cable_check_type &
+				SEC_BATTERY_CABLE_CHECK_NOUSBCHARGE) &&
+				!lpcharge) {
+				switch (battery->cable_type) {
+				case POWER_SUPPLY_TYPE_USB:
+				case POWER_SUPPLY_TYPE_USB_DCP:
+				case POWER_SUPPLY_TYPE_USB_CDP:
+				case POWER_SUPPLY_TYPE_USB_ACA:
+					val->intval =
+						POWER_SUPPLY_STATUS_DISCHARGING;
+					return 0;
+				}
+			}
+#if defined(CONFIG_STORE_MODE)
+			if (battery->store_mode && !lpcharge &&
+					battery->cable_type != POWER_SUPPLY_TYPE_BATTERY &&
+					battery->status == POWER_SUPPLY_STATUS_DISCHARGING) {
+				val->intval = POWER_SUPPLY_STATUS_CHARGING;
+			} else
+#endif
+				val->intval = battery->status;
+		}
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+		if (battery->cable_type == POWER_SUPPLY_TYPE_BATTERY ||
+			battery->cable_type == POWER_SUPPLY_TYPE_MHL_USB_100) {
+			val->intval = POWER_SUPPLY_CHARGE_TYPE_NONE;
+		} else {
+			psy_do_property(battery->pdata->charger_name, get,
+				POWER_SUPPLY_PROP_CHARGE_TYPE, value);
+			if (value.intval == POWER_SUPPLY_CHARGE_TYPE_UNKNOWN)
+				/* if error in CHARGE_TYPE of charger
+				 * set CHARGE_TYPE as NONE
+				 */
+				val->intval = POWER_SUPPLY_CHARGE_TYPE_NONE;
+			else
+				val->intval = value.intval;
+		}
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = battery->health;
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = battery->present;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		if (is_hv_wireless_type(battery->cable_type)) {
+			if (sec_bat_hv_wc_normal_mode_check(battery))
+				val->intval = POWER_SUPPLY_TYPE_WIRELESS;
+			else
+				val->intval = POWER_SUPPLY_TYPE_HV_WIRELESS_ETX;
+		}
+		else if (battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK)
+			val->intval = POWER_SUPPLY_TYPE_WIRELESS;
+		else if (battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK_TA)
+			val->intval = POWER_SUPPLY_TYPE_WIRELESS;
+		else if (battery->cable_type == POWER_SUPPLY_TYPE_WIRELESS_STAND)
+			val->intval = POWER_SUPPLY_TYPE_WIRELESS;
+		else if (battery->cable_type == POWER_SUPPLY_TYPE_PMA_WIRELESS)
+			val->intval = POWER_SUPPLY_TYPE_WIRELESS;
+		else
+			val->intval = battery->cable_type;
+		pr_info("%s cable type = %d sleep_mode = %d\n", __func__, val->intval, sleep_mode);
+		break;
+	case POWER_SUPPLY_PROP_TECHNOLOGY:
+		val->intval = battery->pdata->technology;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+#ifdef CONFIG_SEC_FACTORY
+		psy_do_property(battery->pdata->fuelgauge_name, get,
+				POWER_SUPPLY_PROP_VOLTAGE_NOW, value);
+		battery->voltage_now = value.intval;
+		dev_err(battery->dev,
+			"%s: voltage now(%d)\n", __func__, battery->voltage_now);
+#endif
+		/* voltage value should be in uV */
+		val->intval = battery->voltage_now * 1000;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_AVG:
+#ifdef CONFIG_SEC_FACTORY
+		value.intval = SEC_BATTERY_VOLTAGE_AVERAGE;
+		psy_do_property(battery->pdata->fuelgauge_name, get,
+				POWER_SUPPLY_PROP_VOLTAGE_AVG, value);
+		battery->voltage_avg = value.intval;
+		dev_err(battery->dev,
+			"%s: voltage avg(%d)\n", __func__, battery->voltage_avg);
+#endif
+		/* voltage value should be in uV */
+		val->intval = battery->voltage_avg * 1000;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = battery->current_now;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+		val->intval = battery->current_avg;
+		break;
+	/* charging mode (differ from power supply) */
+	case POWER_SUPPLY_PROP_CHARGE_NOW:
+		val->intval = battery->charging_mode;
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		if (battery->pdata->fake_capacity) {
+			val->intval = 90;
+			pr_info("%s : capacity(%d)\n", __func__, val->intval);
+		} else {
+#if defined(CONFIG_SAMSUNG_BATTERY_ENG_TEST)
+			if (battery->status == POWER_SUPPLY_STATUS_FULL) {
+				if (battery->eng_not_full_status)
+					val->intval = battery->capacity;
+				else
+					val->intval = 100;
+			} else {
+				val->intval = battery->capacity;
+			}
+#else
+			if (battery->status == POWER_SUPPLY_STATUS_FULL)
+				val->intval = 100;
+			else
+				val->intval = battery->capacity;
+#endif
+		}
+		break;
+	case POWER_SUPPLY_PROP_TEMP:
+		val->intval = battery->temperature;
+		break;
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		val->intval = battery->temper_amb;
+		break;
+#if defined(CONFIG_CALC_TIME_TO_FULL)
+	case POWER_SUPPLY_PROP_TIME_TO_FULL_NOW:
+		if (battery->capacity == 100) {
+			val->intval = -1;
+			break;
+		}
+
+		if (((battery->status == POWER_SUPPLY_STATUS_CHARGING) ||
+			(battery->status == POWER_SUPPLY_STATUS_FULL && battery->capacity != 100)) &&
+			battery->complete_timetofull &&
+			!battery->swelling_mode)
+			val->intval = battery->timetofull;
+		else
+			val->intval = -1;
+		break;
+#endif
+#if defined(CONFIG_BATTERY_SWELLING)
+	case POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT:
+		if (battery->swelling_mode)
+			val->intval = 1;
+		else
+			val->intval = 0;
+		break;
+#endif
+	case POWER_SUPPLY_PROP_CHARGE_COUNTER_SHADOW:
+		val->intval = battery->wire_status;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL:
+	case POWER_SUPPLY_PROP_CHARGE_UNO_CONTROL:
+		break;
+	case POWER_SUPPLY_PROP_POWER_NOW:
+		val->intval = battery->charge_power;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int sec_usb_get_property(struct power_supply *psy,
+				enum power_supply_property psp,
+				union power_supply_propval *val)
+{
+	struct sec_battery_info *battery =
+		container_of(psy, struct sec_battery_info, psy_usb);
+
+	if (psp != POWER_SUPPLY_PROP_ONLINE)
+		return -EINVAL;
+
+	if ((battery->health == POWER_SUPPLY_HEALTH_OVERVOLTAGE) ||
+		(battery->health == POWER_SUPPLY_HEALTH_UNDERVOLTAGE)) {
+		val->intval = 0;
+		return 0;
+	}
+	/* Set enable=1 only if the USB charger is connected */
+	switch (battery->wire_status) {
+	case POWER_SUPPLY_TYPE_USB:
+	case POWER_SUPPLY_TYPE_USB_DCP:
+	case POWER_SUPPLY_TYPE_USB_CDP:
+	case POWER_SUPPLY_TYPE_USB_ACA:
+	case POWER_SUPPLY_TYPE_MHL_USB:
+	case POWER_SUPPLY_TYPE_MHL_USB_100:
+		val->intval = 1;
+		break;
+	case POWER_SUPPLY_TYPE_PDIC:
+	        val->intval = (battery->pd_usb_attached) ? 1:0;
+	        break;
+	default:
+		val->intval = 0;
+		break;
+	}
+
+	if (battery->slate_mode)
+		val->intval = 0;
+	return 0;
+}
+
+static int sec_ac_get_property(struct power_supply *psy,
+			       enum power_supply_property psp,
+			       union power_supply_propval *val)
+{
+	struct sec_battery_info *battery =
+		container_of(psy, struct sec_battery_info, psy_ac);
+	enum power_supply_ext_property ext_psp = psp;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		if ((battery->health == POWER_SUPPLY_HEALTH_OVERVOLTAGE) ||
+				(battery->health == POWER_SUPPLY_HEALTH_UNDERVOLTAGE)) {
+			val->intval = 0;
+			return 0;
+		}
+
+		/* Set enable=1 only if the AC charger is connected */
+		switch (battery->cable_type) {
+		case POWER_SUPPLY_TYPE_WIRELESS:
+		case POWER_SUPPLY_TYPE_MAINS:
+		case POWER_SUPPLY_TYPE_MISC:
+		case POWER_SUPPLY_TYPE_CARDOCK:
+		case POWER_SUPPLY_TYPE_UARTOFF:
+		case POWER_SUPPLY_TYPE_LAN_HUB:
+		case POWER_SUPPLY_TYPE_UNKNOWN:
+		case POWER_SUPPLY_TYPE_MHL_500:
+		case POWER_SUPPLY_TYPE_MHL_900:
+		case POWER_SUPPLY_TYPE_MHL_1500:
+		case POWER_SUPPLY_TYPE_MHL_2000:
+		case POWER_SUPPLY_TYPE_SMART_OTG:
+		case POWER_SUPPLY_TYPE_SMART_NOTG:
+		case POWER_SUPPLY_TYPE_HV_PREPARE_MAINS:
+		case POWER_SUPPLY_TYPE_HV_ERR:
+		case POWER_SUPPLY_TYPE_HV_UNKNOWN:
+		case POWER_SUPPLY_TYPE_HV_MAINS:
+		case POWER_SUPPLY_TYPE_HV_MAINS_12V:
+		case POWER_SUPPLY_TYPE_MDOCK_TA:
+		case POWER_SUPPLY_TYPE_HMT_CONNECTED:
+		case POWER_SUPPLY_TYPE_HMT_CHARGE:
+		case POWER_SUPPLY_TYPE_HV_MAINS_CHG_LIMIT:
+		case POWER_SUPPLY_TYPE_HV_QC20:
+		case POWER_SUPPLY_TYPE_HV_QC30:
+		case POWER_SUPPLY_TYPE_POGO:
+			val->intval = 1;
+			break;
+                case POWER_SUPPLY_TYPE_PDIC:
+                        val->intval = (battery->pd_usb_attached) ? 0:1;
+                        break;
+		default:
+			val->intval = 0;
+			break;
+		}
+		break;
+	case POWER_SUPPLY_PROP_TEMP:
+		val->intval = battery->chg_temp;
+		break;
+	case POWER_SUPPLY_PROP_MAX ... POWER_SUPPLY_EXT_PROP_MAX:
+		switch (ext_psp) {
+			case POWER_SUPPLY_EXT_PROP_WATER_DETECT:
+				if (battery->misc_event & (BATT_MISC_EVENT_UNDEFINED_RANGE_TYPE |
+						BATT_MISC_EVENT_UNDEFINED_RANGE_POGO)) {
+					val->intval = 1;
+					pr_info("%s: Water Detect\n", __func__);
+				} else {
+					val->intval = 0;
+				}
+				break;
+			default:
+				return -EINVAL;
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (lpcharge && ((battery->misc_event & BATT_MISC_EVENT_UNDEFINED_RANGE_TYPE) ||
+			(battery->pogo_status && (battery->misc_event & BATT_MISC_EVENT_UNDEFINED_RANGE_POGO)) ||
+			(battery->water_det && battery->pogo_status))) {
+		val->intval = 1;
+	}
+
+	return 0;
+}
+
+static int sec_wireless_get_property(struct power_supply *psy,
+			       enum power_supply_property psp,
+			       union power_supply_propval *val)
+{
+
+	struct sec_battery_info *battery =
+		container_of(psy, struct sec_battery_info, psy_wireless);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = battery->wc_status;
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = (battery->pdata->wireless_charger_name) ?
+			1 : 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sec_wireless_set_property(struct power_supply *psy,
+				enum power_supply_property psp,
+				const union power_supply_propval *val)
+{
+	struct sec_battery_info *battery =
+		container_of(psy, struct sec_battery_info, psy_wireless);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		battery->wc_status = val->intval;
+
+		wake_lock(&battery->cable_wake_lock);
+		queue_delayed_work(battery->monitor_wqueue,
+			&battery->cable_work, 0);
+		if (battery->wc_status == SEC_WIRELESS_PAD_NONE ||
+			battery->wc_status == SEC_WIRELESS_PAD_WPC_PACK ||
+			battery->wc_status == SEC_WIRELESS_PAD_WPC_PACK_TA ||
+			battery->wc_status == SEC_WIRELESS_PAD_VEHICLE) {
+			sec_bat_set_misc_event(battery, BATT_MISC_EVENT_WIRELESS_BACKPACK_TYPE,
+				(battery->wc_status == SEC_WIRELESS_PAD_NONE));
+		}
+#if defined(CONFIG_BATTERY_CISD)
+		if (val->intval != SEC_WIRELESS_PAD_NONE)
+			battery->cisd.data[CISD_DATA_WIRELESS_COUNT]++;
+#endif
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+#if defined(CONFIG_USE_POGO)
+static int sec_pogo_get_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		union power_supply_propval *val)
+{
+	struct sec_battery_info *battery =
+		container_of(psy, struct sec_battery_info, psy_pogo);
+
+	if (psp != POWER_SUPPLY_PROP_ONLINE)
+		return -EINVAL;
+
+	val->intval = battery->pogo_status;
+	pr_info("%s: POGO online : %d\n", __func__, val->intval);
+
+	return 0;
+}
+
+static int sec_pogo_set_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		const union power_supply_propval *val)
+{
+	struct sec_battery_info *battery =
+		container_of(psy, struct sec_battery_info, psy_pogo);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		battery->pogo_status = val->intval;
+
+		wake_lock(&battery->cable_wake_lock);
+		queue_delayed_work(battery->monitor_wqueue,
+				&battery->cable_work, 0);
+		pr_info("%s: pogo_status : %d\n", __func__, battery->pogo_status);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (battery->pogo_status && battery->water_det) {
+		pr_info("%s: Already Water detect\n", __func__);
+		sec_bat_set_misc_event(battery,
+				BATT_MISC_EVENT_UNDEFINED_RANGE_POGO, 0);
+	}
+
+	if (!battery->pogo_status &&
+			(battery->misc_event & BATT_MISC_EVENT_UNDEFINED_RANGE_POGO))
+		sec_bat_set_misc_event(battery,
+			BATT_MISC_EVENT_UNDEFINED_RANGE_POGO, 1);
+
+	return 0;
+}
+#endif
+
+static int sec_ps_set_property(struct power_supply *psy,
+				enum power_supply_property psp,
+				const union power_supply_propval *val)
+{
+	struct sec_battery_info *battery =
+		container_of(psy, struct sec_battery_info, psy_ps);
+	union power_supply_propval value;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		if (val->intval == 0 && battery->ps_enable == true) {
+			battery->ps_enable = false;
+			value.intval = val->intval;
+			psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL, value);
+		} else if ((val->intval == 1) && (battery->ps_enable == false) &&
+				(battery->ps_status == true)) {
+			battery->ps_enable = true;
+			value.intval = val->intval;
+			psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL, value);
+		} else {
+			dev_err(battery->dev,
+				"%s: invalid setting (%d)\n", __func__, val->intval);
+		}
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		if (val->intval == POWER_SUPPLY_TYPE_POWER_SHARING) {
+			battery->ps_status = true;
+			battery->ps_enable = true;
+			value.intval = battery->ps_enable;
+			psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL, value);
+		} else {
+			battery->ps_status = false;
+			battery->ps_enable = false;
+			value.intval = battery->ps_enable;
+			psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL, value);
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sec_ps_get_property(struct power_supply *psy,
+			       enum power_supply_property psp,
+			       union power_supply_propval *val)
+{
+	struct sec_battery_info *battery =
+		container_of(psy, struct sec_battery_info, psy_ps);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = (battery->ps_enable) ? 1 : 0;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = (battery->ps_status) ? 1 : 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static irqreturn_t sec_bat_irq_thread(int irq, void *irq_data)
+{
+	struct sec_battery_info *battery = irq_data;
+
+	dev_info(battery->dev, "%s: bat_irq occured_start\n", __func__);
+
+	if (battery->pdata->battery_check_type ==
+		SEC_BATTERY_CHECK_INT) {
+		if (battery->pdata->check_battery_callback)
+			battery->present = battery->pdata->check_battery_callback();
+
+		wake_lock(&battery->monitor_wake_lock);
+		queue_delayed_work_on(0, battery->monitor_wqueue, &battery->monitor_work, 0);
+	}
+
+	return IRQ_HANDLED;
+}
+
+#if defined(CONFIG_USB_TYPEC_MANAGER_NOTIFIER) || defined(CONFIG_MUIC_NOTIFIER)
+static int sec_bat_cable_check(struct sec_battery_info *battery,
+				muic_attached_dev_t attached_dev)
+{
+	int current_cable_type = -1;
+	union power_supply_propval val = {0, };
+
+	pr_info("[%s]ATTACHED(%d)\n", __func__, attached_dev);
+
+	switch (attached_dev)
+	{
+#if defined(CONFIG_USE_POGO)
+	case  ATTACHED_DEV_POGO_MUIC:
+		val.intval = 1;
+		psy_do_property(battery->pdata->charger_name, set,
+			POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT, val);
+	/* fallthrough */
+	case ATTACHED_DEV_CHARGING_POGO_VB_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_BATTERY;
+		break;
+#endif
+	case ATTACHED_DEV_JIG_UART_OFF_MUIC:
+	case ATTACHED_DEV_JIG_UART_ON_MUIC:
+		battery->is_jig_on = true;
+	case ATTACHED_DEV_UNDEFINED_RANGE_MUIC:
+	case ATTACHED_DEV_WATER_MUIC:
+	case ATTACHED_DEV_SMARTDOCK_MUIC:
+	case ATTACHED_DEV_DESKDOCK_MUIC:
+	case ATTACHED_DEV_JIG_USB_ON_MUIC:
+#if defined(CONFIG_SEC_FACTORY)
+#if defined(CONFIG_CHARGER_S2MU004) || defined(CONFIG_CHARGER_S2MU005)
+	case ATTACHED_DEV_CARKIT_MUIC:
+#endif
+#endif
+		current_cable_type = POWER_SUPPLY_TYPE_BATTERY;
+		break;
+	case ATTACHED_DEV_UNDEFINED_CHARGING_MUIC:
+#if !defined(CONFIG_TYPEB_WATERPROOF_MODEL)
+		current_cable_type = POWER_SUPPLY_TYPE_MAINS;
+#else
+		current_cable_type = POWER_SUPPLY_TYPE_BATTERY;
+#if defined(CONFIG_BATTERY_CISD)
+		battery->cisd.data[CISD_WATER_DETECT]++;
+#endif
+#endif
+		break;
+	case ATTACHED_DEV_OTG_MUIC:
+	case ATTACHED_DEV_JIG_UART_OFF_VB_OTG_MUIC:
+	case ATTACHED_DEV_HMT_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_OTG;
+		break;
+	case ATTACHED_DEV_USB_MUIC:
+	case ATTACHED_DEV_JIG_USB_OFF_MUIC:
+	case ATTACHED_DEV_SMARTDOCK_USB_MUIC:
+	case ATTACHED_DEV_UNOFFICIAL_ID_USB_MUIC:
+	case ATTACHED_DEV_TIMEOUT_OPEN_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_USB;
+		break;
+	case ATTACHED_DEV_JIG_UART_ON_VB_MUIC:
+	case ATTACHED_DEV_JIG_UART_OFF_VB_MUIC:
+	case ATTACHED_DEV_JIG_UART_OFF_VB_FG_MUIC:
+#if defined(CONFIG_CHARGER_SM5705)
+		current_cable_type = POWER_SUPPLY_TYPE_UARTOFF;
+#else
+		current_cable_type = factory_mode ? POWER_SUPPLY_TYPE_BATTERY :
+			POWER_SUPPLY_TYPE_UARTOFF;
+#endif
+#if !defined(CONFIG_SAMSUNG_BATTERY_ENG_TEST) && defined(CONFIG_TYPEB_WATERPROOF_MODEL)
+		current_cable_type = POWER_SUPPLY_TYPE_BATTERY;
+#endif
+#if defined(CONFIG_FUELGAUGE_S2MU004) && defined(CONFIG_TYPEB_WATERPROOF_MODEL)
+		val.intval = 0;
+		psy_do_property(battery->pdata->charger_name, set,
+			POWER_SUPPLY_EXT_PROP_ANDIG_IVR_SWITCH, val);
+#endif
+		if (battery->block_water_event) {
+			if (!(factory_mode))
+				current_cable_type = POWER_SUPPLY_TYPE_UARTOFF;
+			break;
+		}
+		break;
+#if 0
+	case ATTACHED_DEV_RDU_TA_MUIC:
+		battery->store_mode = true;
+#endif
+	case ATTACHED_DEV_TA_MUIC:
+	case ATTACHED_DEV_CARDOCK_MUIC:
+	case ATTACHED_DEV_DESKDOCK_VB_MUIC:
+	case ATTACHED_DEV_SMARTDOCK_TA_MUIC:
+	case ATTACHED_DEV_UNOFFICIAL_TA_MUIC:
+	case ATTACHED_DEV_UNOFFICIAL_ID_TA_MUIC:
+	case ATTACHED_DEV_UNOFFICIAL_ID_ANY_MUIC:
+	case ATTACHED_DEV_UNSUPPORTED_ID_VB_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_MAINS;
+		break;
+	case ATTACHED_DEV_AFC_CHARGER_5V_MUIC:
+	case ATTACHED_DEV_QC_CHARGER_5V_MUIC:
+	case ATTACHED_DEV_AFC_CHARGER_5V_DUPLI_MUIC:
+		if (is_hv_wire_type(battery->cable_type) && battery->chg_limit)
+			current_cable_type = POWER_SUPPLY_TYPE_HV_MAINS_CHG_LIMIT;
+		else
+			current_cable_type = POWER_SUPPLY_TYPE_MAINS;
+		break;
+	case ATTACHED_DEV_CDP_MUIC:
+	case ATTACHED_DEV_UNOFFICIAL_ID_CDP_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_USB_CDP;
+		break;
+	case ATTACHED_DEV_USB_LANHUB_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_LAN_HUB;
+		break;
+	case ATTACHED_DEV_CHARGING_CABLE_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_POWER_SHARING;
+		break;
+	case ATTACHED_DEV_AFC_CHARGER_PREPARE_MUIC:
+	case ATTACHED_DEV_QC_CHARGER_PREPARE_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_HV_PREPARE_MAINS;
+		break;
+	case ATTACHED_DEV_AFC_CHARGER_9V_MUIC:
+	case ATTACHED_DEV_QC_CHARGER_9V_MUIC:
+#if 0
+	case ATTACHED_DEV_AFC_CHARGER_9V_DUPLI_MUIC:
+#endif
+		current_cable_type = POWER_SUPPLY_TYPE_HV_MAINS;
+		break;
+#if defined(CONFIG_MUIC_HV_12V)
+	case ATTACHED_DEV_AFC_CHARGER_12V_MUIC:
+#if 0
+	case ATTACHED_DEV_AFC_CHARGER_12V_DUPLI_MUIC:
+#endif
+		current_cable_type = POWER_SUPPLY_TYPE_HV_MAINS_12V;
+		break;
+#endif
+	case ATTACHED_DEV_AFC_CHARGER_ERR_V_MUIC:
+#if 0
+	case ATTACHED_DEV_AFC_CHARGER_ERR_V_DUPLI_MUIC:
+#endif
+	case ATTACHED_DEV_QC_CHARGER_ERR_V_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_HV_ERR;
+#if defined(CONFIG_BATTERY_CISD)
+		battery->cisd.data[CISD_AFC_FAIL]++;
+#endif
+		break;
+	case ATTACHED_DEV_HV_ID_ERR_UNDEFINED_MUIC:
+	case ATTACHED_DEV_HV_ID_ERR_UNSUPPORTED_MUIC:
+	case ATTACHED_DEV_HV_ID_ERR_SUPPORTED_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_HV_UNKNOWN;
+#if defined(CONFIG_BATTERY_CISD)
+		battery->cisd.data[CISD_AFC_FAIL]++;
+#endif
+		break;
+	case ATTACHED_DEV_VZW_INCOMPATIBLE_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_UNKNOWN;
+		break;
+	default:
+		pr_err("%s: invalid type for charger:%d\n",
+			__func__, attached_dev);
+	}
+#ifndef CONFIG_FUELGAUGE_S2MU005
+	if (battery->is_jig_on && !battery->pdata->support_fgsrc_change)
+		psy_do_property(battery->pdata->fuelgauge_name, set,
+			POWER_SUPPLY_PROP_ENERGY_NOW, val);
+#endif
+#if defined(CONFIG_SEC_FACTORY)
+#if defined(CONFIG_CHARGER_S2MU004) || defined(CONFIG_CHARGER_S2MU005)
+	if (attached_dev == ATTACHED_DEV_JIG_USB_ON_MUIC
+		|| attached_dev == ATTACHED_DEV_CARKIT_MUIC
+#if defined(CONFIG_CHARGER_S2MU005)
+		|| attached_dev == ATTACHED_DEV_JIG_UART_OFF_MUIC
+		|| attached_dev == ATTACHED_DEV_JIG_UART_ON_MUIC
+		|| attached_dev == ATTACHED_DEV_JIG_USB_OFF_MUIC
+		|| attached_dev == ATTACHED_DEV_JIG_UART_OFF_VB_FG_MUIC
+		|| attached_dev == ATTACHED_DEV_UNDEFINED_RANGE_MUIC
+#endif
+		) {
+		val.intval = SEC_BAT_CHG_MODE_BUCK_OFF;
+		psy_do_property(battery->pdata->charger_name, set,
+			POWER_SUPPLY_PROP_CHARGING_ENABLED, val);
+	}
+#endif
+#endif
+
+/* s2mu005 : CHG 0xAF[7]=1 for SMPL issue, 0xAF[7]=0 for JIG case */
+#if defined(CONFIG_CHARGER_S2MU005) && !defined(CONFIG_SEC_FACTORY)
+	switch (attached_dev)
+	{
+	case ATTACHED_DEV_JIG_USB_ON_MUIC:
+		val.intval = SEC_BAT_CHG_MODE_BUCK_OFF;
+		psy_do_property(battery->pdata->charger_name, set,
+			POWER_SUPPLY_PROP_CHARGING_ENABLED, val);
+		val.intval = 1;
+		break;
+	case ATTACHED_DEV_JIG_UART_ON_MUIC:
+	case ATTACHED_DEV_JIG_UART_OFF_MUIC:
+	case ATTACHED_DEV_JIG_USB_OFF_MUIC:
+	case ATTACHED_DEV_JIG_UART_OFF_VB_MUIC:
+	case ATTACHED_DEV_JIG_UART_OFF_VB_FG_MUIC:
+		val.intval = 1;
+		break;
+	default:
+		val.intval = 0;
+		break;
+	}
+	psy_do_property(battery->pdata->charger_name, set,
+		POWER_SUPPLY_PROP_ENERGY_NOW, val);
+	pr_err("%s : 0xAF work-around execute! (%d)\n", __func__, val.intval);
+#endif
+
+	pr_info("%s: current_cable_type(%d), val(%d)\n", __func__, current_cable_type, val.intval);
+	return current_cable_type;
+}
+#endif
+
+#if defined(CONFIG_USB_TYPEC_MANAGER_NOTIFIER)
+#if defined(CONFIG_CCIC_NOTIFIER)
+static int sec_bat_get_pd_list_index(PDIC_SINK_STATUS *sink_status, struct sec_bat_pdic_list *pd_list)
+{
+	int i = 0;
+
+	for (i = 0; i < pd_list->max_pd_count; i++) {
+		if (pd_list->pd_info[i].pdo_index == sink_status->current_pdo_num)
+			return i;
+	}
+
+	return 0;
+}
+#endif
+
+static void sec_bat_set_rp_current(struct sec_battery_info *battery, int cable_type)
+{
+	if (battery->pdic_info.sink_status.rp_currentlvl == RP_CURRENT_LEVEL3) {
+		if (battery->current_event & SEC_BAT_CURRENT_EVENT_HV_DISABLE)
+			sec_bat_change_default_current(battery, cable_type,
+				battery->pdata->default_input_current, battery->pdata->default_charging_current);
+		else
+			sec_bat_change_default_current(battery, cable_type,
+				RP_CURRENT_RP3, battery->pdata->max_charging_current);
+	} else if (battery->pdic_info.sink_status.rp_currentlvl == RP_CURRENT_LEVEL2) {
+		sec_bat_change_default_current(battery, cable_type,
+			RP_CURRENT_RP2, RP_CURRENT_RP2);
+	} else if (battery->pdic_info.sink_status.rp_currentlvl == RP_CURRENT_LEVEL_DEFAULT) {
+		if (cable_type == POWER_SUPPLY_TYPE_USB) {
+			sec_bat_change_default_current(battery, cable_type,
+				battery->pdata->default_usb_input_current,
+				battery->pdata->default_usb_charging_current);
+		} else if (cable_type == POWER_SUPPLY_TYPE_MAINS) {
+			sec_bat_change_default_current(battery, cable_type,
+				battery->pdata->default_input_current,
+				battery->pdata->default_charging_current);
+		}
+	}
+	battery->aicl_current = 0;
+
+	pr_info("%s:(%d)\n", __func__, battery->pdic_info.sink_status.rp_currentlvl);
+	battery->max_charge_power = 0;
+	sec_bat_set_charging_current(battery);
+}
+
+static int make_pd_list(struct sec_battery_info *battery)
+{
+	int i, j, min, temp_voltage, temp_current, temp_index, max_current;
+	int pdo_power_limit, selected_pdo_voltage, selected_pdo_num;
+	bool voltage_flag;
+	int pd_list_index = 0;
+
+	pdo_power_limit = battery->base_charge_power * 1000;
+	selected_pdo_num = 0;
+	for (i=1; i<= battery->pdic_info.sink_status.available_pdo_num; i++)
+	{
+		if (battery->pdic_info.sink_status.power_list[i].max_voltage <
+			(battery->pdata->max_input_voltage + 1))
+		{
+			selected_pdo_voltage = battery->pdic_info.sink_status.power_list[i].max_voltage;
+			selected_pdo_num = i;
+			max_current =
+				battery->pdic_info.sink_status.power_list[i].max_current > 
+				battery->pdata->max_input_current ?
+				battery->pdata->max_input_current : battery->pdic_info.sink_status.power_list[i].max_current;
+			/* regulate input current, based on max power limit */
+			if ((pdo_power_limit/selected_pdo_voltage) <= max_current) {
+				battery->pdic_info.sink_status.power_list[i].max_current =
+					pdo_power_limit/selected_pdo_voltage;
+			} else {
+				battery->pdic_info.sink_status.power_list[i].max_current = max_current;
+			}
+
+			if (selected_pdo_num)
+			{
+				voltage_flag = false;
+				for(j = 0; j < pd_list_index; j++) { /* check same voltage index */
+					if (battery->pd_list.pd_info[j].input_voltage ==
+						battery->pdic_info.sink_status.power_list[selected_pdo_num].max_voltage) {
+						if (battery->pd_list.pd_info[j].input_current <
+							battery->pdic_info.sink_status.power_list[selected_pdo_num].max_current) {
+							battery->pd_list.pd_info[j].input_voltage =
+								battery->pdic_info.sink_status.power_list[selected_pdo_num].max_voltage;
+							battery->pd_list.pd_info[j].input_current = 
+								battery->pdic_info.sink_status.power_list[selected_pdo_num].max_current;
+							battery->pd_list.pd_info[j].pdo_index = selected_pdo_num;
+						}
+						voltage_flag = true;
+					}
+				}
+
+				if (!voltage_flag) {
+					battery->pd_list.pd_info[pd_list_index].input_voltage =
+						battery->pdic_info.sink_status.power_list[selected_pdo_num].max_voltage;
+					battery->pd_list.pd_info[pd_list_index].input_current = 
+						battery->pdic_info.sink_status.power_list[selected_pdo_num].max_current;
+					battery->pd_list.pd_info[pd_list_index].pdo_index = selected_pdo_num;
+					pd_list_index++;
+				}
+			}
+		}
+	}
+	pr_info("%s: total pd_list_index: %d\n", __func__, pd_list_index);
+	if (pd_list_index <= 0) {
+		pr_info("%s : PDO list is empty!!\n", __func__);
+		return 0;
+	}
+
+	for (i = 0; i < pd_list_index - 1; i++) {
+		min = i;
+		for (j = i + 1; j < pd_list_index; j++) {
+			if (battery->pd_list.pd_info[j].input_voltage <
+				battery->pd_list.pd_info[min].input_voltage)
+				min = j;
+		}
+		temp_voltage = battery->pd_list.pd_info[i].input_voltage;
+		battery->pd_list.pd_info[i].input_voltage =
+			battery->pd_list.pd_info[min].input_voltage;
+		battery->pd_list.pd_info[min].input_voltage = temp_voltage;
+		temp_current = battery->pd_list.pd_info[i].input_current;
+		battery->pd_list.pd_info[i].input_current =
+			battery->pd_list.pd_info[min].input_current;
+		battery->pd_list.pd_info[min].input_current = temp_current;
+		temp_index = battery->pd_list.pd_info[i].pdo_index;
+		battery->pd_list.pd_info[i].pdo_index =
+			battery->pd_list.pd_info[min].pdo_index;
+		battery->pd_list.pd_info[min].pdo_index = temp_index;
+	}
+	for(i = 0; i < pd_list_index; i++) {
+		pr_info("%s: Made pd_list[%d], voltage : %d, current : %d, index : %d\n", __func__, i,
+		battery->pd_list.pd_info[i].input_voltage,
+		battery->pd_list.pd_info[i].input_current,
+		battery->pd_list.pd_info[i].pdo_index);
+	}
+	battery->pd_list.max_pd_count = pd_list_index;
+	battery->max_charge_power = battery->pdic_info.sink_status.power_list[ \
+		battery->pd_list.pd_info[pd_list_index-1].pdo_index].max_voltage * \
+		battery->pdic_info.sink_status.power_list[battery->pd_list.pd_info[ \
+		pd_list_index-1].pdo_index].max_current / 1000;
+	battery->pd_max_charge_power = battery->max_charge_power;
+
+	if (battery->pdic_info.sink_status.selected_pdo_num == battery->pd_list.pd_info[pd_list_index-1].pdo_index) {
+		battery->pd_list.now_pd_index = pd_list_index - 1;
+		battery->pdic_ps_rdy = true;
+		dev_info(battery->dev, "%s: battery->pdic_ps_rdy(%d)\n", __func__, battery->pdic_ps_rdy);
+	} else {
+		battery->pdic_ps_rdy = false;
+		select_pdo(battery->pd_list.pd_info[pd_list_index-1].pdo_index);
+	}
+
+	return battery->pd_list.max_pd_count;
+}
+
+static int usb_typec_handle_notification(struct notifier_block *nb,
+		unsigned long action, void *data)
+{
+	const char *cmd;
+	int cable_type, i = 0, current_pdo = 0,  event = BATT_MISC_EVENT_UNDEFINED_RANGE_TYPE;
+	struct sec_battery_info *battery =
+			container_of(nb, struct sec_battery_info, usb_typec_nb);
+	CC_NOTI_ATTACH_TYPEDEF usb_typec_info = *(CC_NOTI_ATTACH_TYPEDEF *)data;
+
+	dev_info(battery->dev, "%s: action (%ld) dump(0x%01x, 0x%01x, 0x%02x, 0x%04x, 0x%04x, 0x%04x)\n",
+		__func__, action, usb_typec_info.src, usb_typec_info.dest, usb_typec_info.id,
+		usb_typec_info.attach, usb_typec_info.rprd, usb_typec_info.cable_type);
+
+	if (usb_typec_info.dest != CCIC_NOTIFY_DEV_BATTERY || factory_mode == 2) {
+		dev_info(battery->dev, "%s: skip handler dest(%d)\n",
+			__func__, usb_typec_info.dest);
+		return 0;
+	}
+
+	switch (usb_typec_info.id) {
+	case CCIC_NOTIFY_ID_WATER:
+#if defined(CONFIG_USE_POGO)
+		switch (usb_typec_info.attach) {
+		case MUIC_NOTIFY_CMD_ATTACH:
+			battery->water_det = 1;
+			break;
+		case MUIC_NOTIFY_CMD_DETACH:
+			battery->water_det = 0;
+			break;
+		}
+		pr_info("%s: Battery Water Det : %d\n", __func__, battery->water_det);
+#endif
+	case CCIC_NOTIFY_ID_ATTACH:
+		switch (usb_typec_info.attach) {
+		case MUIC_NOTIFY_CMD_DETACH:
+		case MUIC_NOTIFY_CMD_LOGICALLY_DETACH:
+			cmd = "DETACH";
+			battery->is_jig_on = false;
+			battery->pd_usb_attached = false;
+			cable_type = POWER_SUPPLY_TYPE_BATTERY;
+			battery->muic_cable_type = ATTACHED_DEV_NONE_MUIC;
+			battery->pdic_info.sink_status.rp_currentlvl = RP_CURRENT_LEVEL_NONE;
+			battery->pdata->charging_current[POWER_SUPPLY_TYPE_MAINS].input_current_limit =
+				battery->pdata->charging_current[POWER_SUPPLY_TYPE_UNKNOWN].input_current_limit;
+			battery->pdata->charging_current[POWER_SUPPLY_TYPE_MAINS].fast_charging_current =
+				battery->pdata->charging_current[POWER_SUPPLY_TYPE_UNKNOWN].fast_charging_current;
+			break;
+		case MUIC_NOTIFY_CMD_ATTACH:
+		case MUIC_NOTIFY_CMD_LOGICALLY_ATTACH:
+			/* Skip notify from MUIC if PD Charger is already attached */
+			if (battery->cable_type == POWER_SUPPLY_TYPE_PDIC)
+				return 0;
+			cmd = "ATTACH";
+			battery->muic_cable_type = usb_typec_info.cable_type;
+			cable_type = sec_bat_cable_check(battery, battery->muic_cable_type);
+			if (battery->cable_type != cable_type &&
+				battery->pdic_info.sink_status.rp_currentlvl >= RP_CURRENT_LEVEL_DEFAULT &&
+				(cable_type == POWER_SUPPLY_TYPE_USB || cable_type == POWER_SUPPLY_TYPE_MAINS)) {
+				sec_bat_set_rp_current(battery, cable_type);
+			} else if ((struct pdic_notifier_struct *)usb_typec_info.pd != NULL &&
+				(*(struct pdic_notifier_struct *)usb_typec_info.pd).event == PDIC_NOTIFY_EVENT_CCIC_ATTACH &&
+				(*(struct pdic_notifier_struct *)usb_typec_info.pd).sink_status.rp_currentlvl >= RP_CURRENT_LEVEL_DEFAULT &&
+				(cable_type == POWER_SUPPLY_TYPE_USB || cable_type == POWER_SUPPLY_TYPE_MAINS)) {
+				battery->pdic_info.sink_status.rp_currentlvl =
+					(*(struct pdic_notifier_struct *)usb_typec_info.pd).sink_status.rp_currentlvl;
+				sec_bat_set_rp_current(battery, cable_type);
+			}
+			break;
+		default:
+			cmd = "ERROR";
+			cable_type = -1;
+			battery->muic_cable_type = usb_typec_info.cable_type;
+			break;
+		}
+		battery->pdic_attach = false;
+		battery->pdic_ps_rdy = false;
+		battery->rp_attach = false;
+#if defined(CONFIG_AFC_CHARGER_MODE)
+		if (battery->muic_cable_type == ATTACHED_DEV_QC_CHARGER_9V_MUIC ||
+			battery->muic_cable_type == ATTACHED_DEV_QC_CHARGER_ERR_V_MUIC)
+			battery->hv_chg_name = "QC";
+		else if (battery->muic_cable_type == ATTACHED_DEV_AFC_CHARGER_9V_MUIC ||
+#if 0
+			battery->muic_cable_type == ATTACHED_DEV_AFC_CHARGER_9V_DUPLI_MUIC ||
+#endif
+			battery->muic_cable_type == ATTACHED_DEV_AFC_CHARGER_ERR_V_MUIC ||
+			battery->muic_cable_type == ATTACHED_DEV_AFC_CHARGER_ERR_V_DUPLI_MUIC)
+			battery->hv_chg_name = "AFC";
+#if defined(CONFIG_MUIC_HV_12V)
+		else if (battery->muic_cable_type == ATTACHED_DEV_AFC_CHARGER_12V_MUIC ||
+			battery->muic_cable_type == ATTACHED_DEV_AFC_CHARGER_12V_DUPLI_MUIC)
+			battery->hv_chg_name = "12V";
+#endif
+		else
+			battery->hv_chg_name = "NONE";
+#endif
+		break;
+	case CCIC_NOTIFY_ID_POWER_STATUS:
+		cmd = "ATTACH";
+		if ((*(struct pdic_notifier_struct *)usb_typec_info.pd).event == PDIC_NOTIFY_EVENT_CCIC_ATTACH) {
+			battery->pdic_info.sink_status.rp_currentlvl =
+				(*(struct pdic_notifier_struct *)usb_typec_info.pd).sink_status.rp_currentlvl;
+			dev_info(battery->dev, "%s: battery->rp_currentlvl(%d)\n", __func__, battery->pdic_info.sink_status.rp_currentlvl);
+			if (battery->wire_status == POWER_SUPPLY_TYPE_USB || battery->wire_status == POWER_SUPPLY_TYPE_MAINS) {
+				cable_type = battery->wire_status;
+				battery->chg_limit = false;
+				sec_bat_set_rp_current(battery, cable_type);
+				goto skip_cable_check;
+			}
+			return 0;
+		}
+		if ((*(struct pdic_notifier_struct *)usb_typec_info.pd).event == PDIC_NOTIFY_EVENT_PD_SINK_CAP)
+			battery->pdic_attach = false;
+		if (!battery->pdic_attach) {
+			battery->pdic_info = *(struct pdic_notifier_struct *)usb_typec_info.pd;
+			battery->pd_list.now_pd_index = 0;
+		} else {
+			battery->pdic_info.sink_status.current_pdo_num =
+				(*(struct pdic_notifier_struct *)usb_typec_info.pd).sink_status.current_pdo_num;
+			battery->pd_list.now_pd_index = sec_bat_get_pd_list_index(&battery->pdic_info.sink_status,
+				&battery->pd_list);
+			battery->pdic_ps_rdy = true;
+			dev_info(battery->dev, "%s: battery->pdic_ps_rdy(%d)\n", __func__, battery->pdic_ps_rdy);
+		}
+		current_pdo = battery->pdic_info.sink_status.current_pdo_num;
+		cable_type = POWER_SUPPLY_TYPE_PDIC;
+		battery->muic_cable_type = ATTACHED_DEV_NONE_MUIC;
+#if defined(CONFIG_AFC_CHARGER_MODE)
+		battery->hv_chg_name = "PDIC";
+#endif
+		battery->input_voltage =
+				battery->pdic_info.sink_status.power_list[current_pdo].max_voltage / 1000;
+		dev_info(battery->dev, "%s: available pdo : %d, current pdo : %d\n", __func__,
+			battery->pdic_info.sink_status.available_pdo_num, current_pdo);
+
+		for (i=1; i<= battery->pdic_info.sink_status.available_pdo_num; i++) {
+			pr_info("%s: power_list[%d], voltage : %d, current : %d, power : %d\n", __func__, i,
+				battery->pdic_info.sink_status.power_list[i].max_voltage,
+				battery->pdic_info.sink_status.power_list[i].max_current,
+				battery->pdic_info.sink_status.power_list[i].max_voltage *
+				battery->pdic_info.sink_status.power_list[i].max_current);
+		}
+		if (!battery->pdic_attach) {
+			if(make_pd_list(battery) <= 0)
+				goto skip_cable_work;
+		}
+		battery->pdic_attach = true;
+		break;
+	case CCIC_NOTIFY_ID_USB:
+		if(usb_typec_info.cable_type == PD_USB_TYPE)
+			battery->pd_usb_attached = true;
+		dev_info(battery->dev, "%s: CCIC_NOTIFY_ID_USB: %d\n",__func__, battery->pd_usb_attached);
+		wake_lock(&battery->monitor_wake_lock);
+		queue_delayed_work(battery->monitor_wqueue, &battery->monitor_work, 0);
+		return 0;
+	default:
+		cmd = "ERROR";
+		cable_type = -1;
+		battery->muic_cable_type = ATTACHED_DEV_NONE_MUIC;
+#if defined(CONFIG_AFC_CHARGER_MODE)		
+		battery->hv_chg_name = "NONE";
+#endif
+		break;
+	}
+
+skip_cable_check:
+#if defined(CONFIG_USE_POGO)
+	if (battery->muic_cable_type != ATTACHED_DEV_POGO_MUIC) {
+		union power_supply_propval value;
+		dev_info(battery->dev, "%s: turn off external boost\n", __func__);
+		value.intval = 0;
+		psy_do_property(battery->pdata->charger_name, set,
+			POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT, value);
+	}
+
+	event = usb_typec_info.src == CCIC_NOTIFY_DEV_MUIC ?
+		BATT_MISC_EVENT_UNDEFINED_RANGE_POGO :
+		BATT_MISC_EVENT_UNDEFINED_RANGE_TYPE;
+#endif
+
+	sec_bat_set_misc_event(battery, event,
+		(battery->muic_cable_type != ATTACHED_DEV_UNDEFINED_CHARGING_MUIC) &&
+		(battery->muic_cable_type != ATTACHED_DEV_WATER_MUIC) &&
+		(battery->muic_cable_type != ATTACHED_DEV_UNDEFINED_RANGE_MUIC) &&
+		(((battery->muic_cable_type != ATTACHED_DEV_POGO_MUIC) &&
+		(battery->muic_cable_type != ATTACHED_DEV_CHARGING_POGO_VB_MUIC)) ||
+		!battery->water_det));
+
+	/* showing charging icon and noti(no sound, vi, haptic) only
+	   if slow insertion is detected by MUIC */
+	sec_bat_set_misc_event(battery, BATT_MISC_EVENT_TIMEOUT_OPEN_TYPE,
+		(battery->muic_cable_type != ATTACHED_DEV_TIMEOUT_OPEN_MUIC));
+
+	if (cable_type < 0 || cable_type > SEC_SIZEOF_POWER_SUPPLY_TYPE) {
+		dev_info(battery->dev, "%s: ignore event(%d)\n",
+			__func__, battery->muic_cable_type);
+		goto skip_cable_work;
+	} else if ((cable_type == POWER_SUPPLY_TYPE_UNKNOWN) &&
+		   (battery->status != POWER_SUPPLY_STATUS_DISCHARGING)) {
+		battery->cable_type = cable_type;
+		wake_lock(&battery->monitor_wake_lock);
+		queue_delayed_work(battery->monitor_wqueue, &battery->monitor_work, 0);
+		dev_info(battery->dev, "%s: UNKNOWN cable plugin\n", __func__);
+		goto skip_cable_work;
+	}
+	battery->wire_status = cable_type;
+
+	wake_lock(&battery->cable_wake_lock);
+	cancel_delayed_work(&battery->cable_work);
+	if (cable_type == POWER_SUPPLY_TYPE_HV_PREPARE_MAINS)
+		queue_delayed_work(battery->monitor_wqueue,
+				&battery->cable_work, msecs_to_jiffies(battery->prepare_afc_delay));
+	else
+		queue_delayed_work(battery->monitor_wqueue,
+				&battery->cable_work, 0);
+skip_cable_work:
+	dev_info(battery->dev, "%s: CMD[%s], CABLE_TYPE[%d]\n", __func__, cmd, cable_type);
+	return 0;
+}
+#else
+#if defined(CONFIG_CCIC_NOTIFIER)
+static int batt_pdic_handle_notification(struct notifier_block *nb,
+		unsigned long action, void *data)
+{
+	const char *cmd;
+	struct sec_battery_info *battery =
+		container_of(nb, struct sec_battery_info,
+				pdic_nb);
+	battery->pdic_info = *(struct pdic_notifier_struct *)data;
+
+	mutex_lock(&battery->batt_handlelock);
+	pr_info("%s: pdic_event: %d\n", __func__, battery->pdic_info.event);
+
+	switch (battery->pdic_info.event) {
+		int i, selected_pdo;
+
+		case PDIC_NOTIFY_EVENT_DETACH:
+			cmd = "DETACH";
+			battery->pdic_attach = false;
+			if (battery->wire_status == POWER_SUPPLY_TYPE_PDIC) {
+				battery->wire_status = POWER_SUPPLY_TYPE_BATTERY;
+				wake_lock(&battery->cable_wake_lock);
+				queue_delayed_work(battery->monitor_wqueue,
+						&battery->cable_work, 0);
+			}
+			break;
+		case PDIC_NOTIFY_EVENT_CCIC_ATTACH:
+			cmd = "ATTACH";
+			break;
+		case PDIC_NOTIFY_EVENT_PD_SINK:
+			selected_pdo = battery->pdic_info.sink_status.selected_pdo_num;
+			cmd = "ATTACH";
+			battery->wire_status = POWER_SUPPLY_TYPE_PDIC;
+			battery->pdic_attach = true;
+			battery->input_voltage =
+				battery->pdic_info.sink_status.power_list[selected_pdo].max_voltage / 1000;
+
+			pr_info("%s: total pdo : %d, selected pdo : %d\n", __func__,
+					battery->pdic_info.sink_status.available_pdo_num, selected_pdo);
+			for (i=1; i<= battery->pdic_info.sink_status.available_pdo_num; i++)
+			{
+				pr_info("%s: power_list[%d], voltage : %d, current : %d, power : %d\n", __func__, i,
+						battery->pdic_info.sink_status.power_list[i].max_voltage,
+						battery->pdic_info.sink_status.power_list[i].max_current,
+						battery->pdic_info.sink_status.power_list[i].max_voltage *
+						battery->pdic_info.sink_status.power_list[i].max_current);
+			}
+			wake_lock(&battery->cable_wake_lock);
+			queue_delayed_work(battery->monitor_wqueue,
+					&battery->cable_work, 0);
+			break;
+		case PDIC_NOTIFY_EVENT_PD_SOURCE:
+			cmd = "ATTACH";
+			break;
+		default:
+			cmd = "ERROR";
+			break;
+	}
+	pr_info("%s: CMD=%s, cable_type : %d\n", __func__, cmd, battery->cable_type);
+	mutex_unlock(&battery->batt_handlelock);
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_MUIC_NOTIFIER)
+static int batt_handle_notification(struct notifier_block *nb,
+		unsigned long action, void *data)
+{
+	const char *cmd;
+	int cable_type;
+	struct sec_battery_info *battery =
+		container_of(nb, struct sec_battery_info,
+			     batt_nb);
+	union power_supply_propval value;
+#if defined(CONFIG_CCIC_NOTIFIER) && defined(CONFIG_USB_TYPEC_MANAGER_NOTIFIER)
+	CC_NOTI_ATTACH_TYPEDEF *p_noti = (CC_NOTI_ATTACH_TYPEDEF *)data;
+	muic_attached_dev_t attached_dev = p_noti->cable_type;
+#else
+	muic_attached_dev_t attached_dev = *(muic_attached_dev_t *)data;
+#endif
+	bool block_water_event = true;
+
+	mutex_lock(&battery->batt_handlelock);
+	switch (action) {
+	case MUIC_NOTIFY_CMD_DETACH:
+	case MUIC_NOTIFY_CMD_LOGICALLY_DETACH:
+		cmd = "DETACH";
+		battery->is_jig_on = false;
+		cable_type = POWER_SUPPLY_TYPE_BATTERY;
+		battery->muic_cable_type = ATTACHED_DEV_NONE_MUIC;
+		break;
+	case MUIC_NOTIFY_CMD_ATTACH:
+	case MUIC_NOTIFY_CMD_LOGICALLY_ATTACH:
+		cmd = "ATTACH";
+		cable_type = sec_bat_cable_check(battery, attached_dev);
+		battery->muic_cable_type = attached_dev;
+		break;
+	default:
+		cmd = "ERROR";
+		cable_type = -1;
+		battery->muic_cable_type = ATTACHED_DEV_NONE_MUIC;
+		break;
+	}
+#if defined(CONFIG_USE_POGO)
+	if (battery->muic_cable_type != ATTACHED_DEV_POGO_MUIC) {
+		dev_info(battery->dev, "%s: turn off external boost\n", __func__);
+		value.intval = 0;
+		psy_do_property(battery->pdata->charger_name, set,
+			POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT, value);
+	}
+#endif
+
+#if !defined(CONFIG_SAMSUNG_BATTERY_ENG_TEST) && !defined(CONFIG_SEC_FACTORY) && defined(CONFIG_TYPEB_WATERPROOF_MODEL)
+	block_water_event = (battery->block_water_event) ||
+		((battery->muic_cable_type != ATTACHED_DEV_JIG_UART_ON_VB_MUIC) &&
+		(battery->muic_cable_type != ATTACHED_DEV_JIG_USB_ON_MUIC) &&
+		(battery->muic_cable_type != ATTACHED_DEV_JIG_UART_OFF_VB_MUIC) &&
+		(battery->muic_cable_type != ATTACHED_DEV_JIG_UART_OFF_VB_FG_MUIC));
+#endif
+	block_water_event &= (battery->muic_cable_type != ATTACHED_DEV_WATER_MUIC) &&
+		(battery->muic_cable_type != ATTACHED_DEV_UNDEFINED_RANGE_MUIC);
+	sec_bat_set_misc_event(battery, BATT_MISC_EVENT_UNDEFINED_RANGE_TYPE, block_water_event);
+
+#if defined(CONFIG_CCIC_NOTIFIER)
+	/* If PD cable is already attached, return this function */
+	if (battery->pdic_attach) {
+		dev_info(battery->dev, "%s: ignore event pdic attached(%d)\n",
+			__func__, battery->pdic_attach);
+		mutex_unlock(&battery->batt_handlelock);
+		return 0;
+	}
+#endif
+
+	if (attached_dev == ATTACHED_DEV_MHL_MUIC) {
+		mutex_unlock(&battery->batt_handlelock);
+		return 0;
+	}
+
+	if (cable_type < 0) {
+		dev_info(battery->dev, "%s: ignore event(%d)\n",
+			__func__, cable_type);
+	} else if (cable_type == POWER_SUPPLY_TYPE_POWER_SHARING) {
+		battery->ps_status = true;
+		battery->ps_enable = true;
+		battery->wire_status = cable_type;
+		dev_info(battery->dev, "%s: power sharing cable plugin\n", __func__);
+	} else if (cable_type == POWER_SUPPLY_TYPE_WIRELESS) {
+		battery->wc_status = SEC_WIRELESS_PAD_WPC;
+	} else if (cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK) {
+		battery->wc_status = SEC_WIRELESS_PAD_WPC_PACK;
+	} else if (cable_type == POWER_SUPPLY_TYPE_WIRELESS_PACK_TA) {
+		battery->wc_status = SEC_WIRELESS_PAD_WPC_PACK_TA;
+	} else if (cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS) {
+		battery->wc_status = SEC_WIRELESS_PAD_WPC_HV;
+	} else if (cable_type == POWER_SUPPLY_TYPE_WIRELESS_STAND) {
+		battery->wc_status = SEC_WIRELESS_PAD_WPC_STAND;
+	} else if (cable_type == POWER_SUPPLY_TYPE_WIRELESS_HV_STAND) {
+		battery->wc_status = SEC_WIRELESS_PAD_WPC_STAND_HV;	
+	} else if (cable_type == POWER_SUPPLY_TYPE_PMA_WIRELESS) {
+		battery->wc_status = SEC_WIRELESS_PAD_PMA;
+	} else if ((cable_type == POWER_SUPPLY_TYPE_UNKNOWN) &&
+		   (battery->status != POWER_SUPPLY_STATUS_DISCHARGING)) {
+		battery->cable_type = cable_type;
+		wake_lock(&battery->monitor_wake_lock);
+		queue_delayed_work(battery->monitor_wqueue, &battery->monitor_work, 0);
+		dev_info(battery->dev,
+			"%s: UNKNOWN cable plugin\n", __func__);
+		mutex_unlock(&battery->batt_handlelock);
+		return 0;
+	} else {
+		battery->wire_status = cable_type;
+		if ((battery->wire_status == POWER_SUPPLY_TYPE_BATTERY)	&&
+			(battery->wc_status) && (!battery->ps_status))
+			cable_type = POWER_SUPPLY_TYPE_WIRELESS;
+	}
+	dev_info(battery->dev,
+			"%s: current_cable(%d), wc_status(%d), wire_status(%d)\n",
+			__func__, cable_type, battery->wc_status,
+			battery->wire_status);
+
+	mutex_unlock(&battery->batt_handlelock);
+	if (attached_dev == ATTACHED_DEV_USB_LANHUB_MUIC) {
+		if (!strcmp(cmd, "ATTACH")) {
+			value.intval = true;
+			psy_do_property(battery->pdata->charger_name, set,
+					POWER_SUPPLY_PROP_CHARGE_POWERED_OTG_CONTROL,
+					value);
+			dev_info(battery->dev,
+				"%s: Powered OTG cable attached\n", __func__);
+		} else {
+			value.intval = false;
+			psy_do_property(battery->pdata->charger_name, set,
+					POWER_SUPPLY_PROP_CHARGE_POWERED_OTG_CONTROL,
+					value);
+			dev_info(battery->dev,
+				"%s: Powered OTG cable detached\n", __func__);
+		}
+	}
+
+#if defined(CONFIG_AFC_CHARGER_MODE)
+	if (!strcmp(cmd, "ATTACH")) {
+		if ((battery->muic_cable_type >= ATTACHED_DEV_QC_CHARGER_PREPARE_MUIC) &&
+		    (battery->muic_cable_type <= ATTACHED_DEV_QC_CHARGER_9V_MUIC)) {
+			battery->hv_chg_name = "QC";
+		} else if ((battery->muic_cable_type >= ATTACHED_DEV_AFC_CHARGER_PREPARE_MUIC) &&
+			 (battery->muic_cable_type <= ATTACHED_DEV_AFC_CHARGER_ERR_V_DUPLI_MUIC)) {
+			battery->hv_chg_name = "AFC";
+#if defined(CONFIG_MUIC_HV_12V)
+		} else if (battery->muic_cable_type == ATTACHED_DEV_AFC_CHARGER_12V_MUIC ||
+			battery->muic_cable_type == ATTACHED_DEV_AFC_CHARGER_12V_DUPLI_MUIC) {
+			battery->hv_chg_name = "12V";
+#endif
+		} else
+			battery->hv_chg_name = "NONE";
+	} else {
+			battery->hv_chg_name = "NONE";
+	}
+
+	pr_info("%s : HV_CHARGER_NAME(%s)\n",
+		__func__, battery->hv_chg_name);
+#endif
+
+	if ((cable_type >= 0) &&
+	    cable_type <= SEC_SIZEOF_POWER_SUPPLY_TYPE) {
+		if (cable_type == POWER_SUPPLY_TYPE_POWER_SHARING) {
+			value.intval = battery->ps_enable;
+			psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL, value);
+			wake_lock(&battery->monitor_wake_lock);
+			queue_delayed_work(battery->monitor_wqueue, &battery->monitor_work, 0);
+		} else if ((cable_type == POWER_SUPPLY_TYPE_BATTERY) && (battery->ps_status)) {
+			if (battery->ps_enable) {
+				battery->ps_enable = false;
+				value.intval = battery->ps_enable;
+				psy_do_property(battery->pdata->charger_name, set,
+					POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL, value);
+			}
+			battery->ps_status = false;
+			wake_lock(&battery->monitor_wake_lock);
+			queue_delayed_work(battery->monitor_wqueue, &battery->monitor_work, 0);
+		} else if (cable_type != battery->cable_type) {
+			wake_lock(&battery->cable_wake_lock);
+			queue_delayed_work(battery->monitor_wqueue,
+					   &battery->cable_work, 0);
+		} else {
+			dev_info(battery->dev,
+				"%s: Cable is Not Changed(%d)\n",
+				__func__, battery->cable_type);
+		}
+	}
+
+	pr_info("%s: CMD=%s, attached_dev=%d\n", __func__, cmd, attached_dev);
+
+	return 0;
+}
+#endif /* CONFIG_MUIC_NOTIFIER */
+#endif
+
+#if defined(CONFIG_VBUS_NOTIFIER)
+static int vbus_handle_notification(struct notifier_block *nb,
+		unsigned long action, void *data)
+{
+	vbus_status_t vbus_status = *(vbus_status_t *)data;
+	struct sec_battery_info *battery =
+		container_of(nb, struct sec_battery_info,
+			     vbus_nb);
+	union power_supply_propval value = {0, };
+
+	mutex_lock(&battery->batt_handlelock);
+	if (battery->muic_cable_type == ATTACHED_DEV_HMT_MUIC &&
+		battery->muic_vbus_status != vbus_status &&
+		battery->muic_vbus_status == STATUS_VBUS_HIGH &&
+		vbus_status == STATUS_VBUS_LOW) {
+		msleep(500);
+		value.intval = true;
+		psy_do_property(battery->pdata->charger_name, set,
+				POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL,
+				value);
+		dev_info(battery->dev,
+			"%s: changed to OTG cable attached\n", __func__);
+
+		battery->wire_status = POWER_SUPPLY_TYPE_OTG;
+		wake_lock(&battery->cable_wake_lock);
+		queue_delayed_work(battery->monitor_wqueue, &battery->cable_work, 0);
+	}
+	pr_info("%s: action=%d, vbus_status=%d\n", __func__, (int)action, vbus_status);
+	mutex_unlock(&battery->batt_handlelock);
+	battery->muic_vbus_status = vbus_status;
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_OF
+static int sec_bat_parse_dt(struct device *dev,
+		struct sec_battery_info *battery)
+{
+	struct device_node *np = dev->of_node;
+	sec_battery_platform_data_t *pdata = battery->pdata;
+	int ret = 0, len = 0;
+	unsigned int i = 0;
+	const u32 *p;
+	u32 temp = 0;
+
+	if (!np) {
+		pr_info("%s: np NULL\n", __func__);
+		return 1;
+	}
+
+	ret = of_property_read_u32(np,
+				   "battery,expired_time", &temp);
+	if (ret) {
+		pr_info("expired time is empty\n");
+		pdata->expired_time = 3 * 60 * 60;
+	} else {
+		pdata->expired_time = (unsigned int) temp;
+	}
+	pdata->expired_time *= 1000;
+	battery->expired_time = pdata->expired_time;
+
+	ret = of_property_read_u32(np,
+				   "battery,recharging_expired_time", &temp);
+	if (ret) {
+		pr_info("expired time is empty\n");
+		pdata->recharging_expired_time = 90 * 60;
+	} else {
+		pdata->recharging_expired_time = (unsigned int) temp;
+	}
+	pdata->recharging_expired_time *= 1000;
+
+	ret = of_property_read_u32(np,
+				   "battery,standard_curr", &pdata->standard_curr);
+	if (ret) {
+		pr_info("standard_curr is empty\n");
+		pdata->standard_curr = 2150;
+	}
+
+	ret = of_property_read_string(np,
+		"battery,vendor", (char const **)&pdata->vendor);
+	if (ret)
+		pr_info("%s: Vendor is Empty\n", __func__);
+
+	ret = of_property_read_string(np,
+		"battery,charger_name", (char const **)&pdata->charger_name);
+	if (ret)
+		pr_info("%s: Charger name is Empty\n", __func__);
+
+	ret = of_property_read_string(np,
+		"battery,fuelgauge_name", (char const **)&pdata->fuelgauge_name);
+	if (ret)
+		pr_info("%s: Fuelgauge name is Empty\n", __func__);
+
+#if defined(CONFIG_SEC_FACTORY) && (defined(CONFIG_FUELGAUGE_S2MU004) || defined(CONFIG_FUELGAUGE_S2MU005))
+	ret = of_property_read_string(np,
+		"battery,fgsrc_switch_name", (char const **)&pdata->fgsrc_switch_name);
+	if (ret) {
+		pdata->support_fgsrc_change = false;
+		pr_info("%s: fgsrc_switch_name is Empty\n", __func__);
+	}
+	else
+		pdata->support_fgsrc_change = true;
+#else
+	ret = of_property_read_string(np,
+		"battery,fgsrc_switch_name", (char const **)&pdata->fgsrc_switch_name);
+	if (ret) {
+		pdata->support_fgsrc_change = false;
+		pr_info("%s: fgsrc_switch_name is Empty\n", __func__);
+	}
+	else
+		pdata->support_fgsrc_change = true;
+#endif
+
+	ret = of_property_read_string(np,
+		"battery,wireless_charger_name", (char const **)&pdata->wireless_charger_name);
+	if (ret)
+		pr_info("%s: Wireless charger name is Empty\n", __func__);
+
+	ret = of_property_read_string(np,
+		"battery,chip_vendor", (char const **)&pdata->chip_vendor);
+	if (ret)
+		pr_info("%s: Chip vendor is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,technology",
+		&pdata->technology);
+	if (ret)
+		pr_info("%s : technology is Empty\n", __func__);
+
+	ret = of_property_read_u32(np,
+		"battery,wireless_cc_cv", &pdata->wireless_cc_cv);
+
+	pdata->fake_capacity = of_property_read_bool(np,
+						     "battery,fake_capacity");
+	if (factory_mode == 2)
+		pdata->fake_capacity = true;
+
+	p = of_get_property(np, "battery,polling_time", &len);
+	if (!p)
+		return 1;
+
+	len = len / sizeof(u32);
+	pdata->polling_time = kzalloc(sizeof(*pdata->polling_time) * len, GFP_KERNEL);
+	ret = of_property_read_u32_array(np, "battery,polling_time",
+					 pdata->polling_time, len);
+	if (ret)
+		pr_info("%s : battery,polling_time is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,thermal_source",
+		&pdata->thermal_source);
+	if (ret)
+		pr_info("%s : Thermal source is Empty\n", __func__);
+
+	if (pdata->thermal_source == SEC_BATTERY_THERMAL_SOURCE_ADC) {
+		p = of_get_property(np, "battery,temp_table_adc", &len);
+		if (!p)
+			return 1;
+
+		len = len / sizeof(u32);
+
+		pdata->temp_adc_table_size = len;
+		pdata->temp_amb_adc_table_size = len;
+
+		pdata->temp_adc_table =
+			kzalloc(sizeof(sec_bat_adc_table_data_t) *
+				pdata->temp_adc_table_size, GFP_KERNEL);
+		pdata->temp_amb_adc_table =
+			kzalloc(sizeof(sec_bat_adc_table_data_t) *
+				pdata->temp_adc_table_size, GFP_KERNEL);
+
+		for (i = 0; i < pdata->temp_adc_table_size; i++) {
+			ret = of_property_read_u32_index(np,
+					 "battery,temp_table_adc", i, &temp);
+			pdata->temp_adc_table[i].adc = (int)temp;
+			if (ret)
+				pr_info("%s : Temp_adc_table(adc) is Empty\n",
+					__func__);
+
+			ret = of_property_read_u32_index(np,
+							 "battery,temp_table_data", i, &temp);
+			pdata->temp_adc_table[i].data = (int)temp;
+			if (ret)
+				pr_info("%s : Temp_adc_table(data) is Empty\n",
+					__func__);
+
+			ret = of_property_read_u32_index(np,
+							 "battery,temp_table_adc", i, &temp);
+			pdata->temp_amb_adc_table[i].adc = (int)temp;
+			if (ret)
+				pr_info("%s : Temp_amb_adc_table(adc) is Empty\n",
+					__func__);
+
+			ret = of_property_read_u32_index(np,
+							 "battery,temp_table_data", i, &temp);
+			pdata->temp_amb_adc_table[i].data = (int)temp;
+			if (ret)
+				pr_info("%s : Temp_amb_adc_table(data) is Empty\n",
+					__func__);
+		}
+	}
+	ret = of_property_read_u32(np, "battery,usb_thermal_source",
+		&pdata->usb_thermal_source);
+	if (ret)
+		pr_info("%s : usb_thermal_source is Empty\n", __func__);
+
+	if(pdata->usb_thermal_source) {
+		p = of_get_property(np, "battery,usb_temp_table_adc", &len);
+		if (!p)
+			return 1;
+
+		len = len / sizeof(u32);
+
+		pdata->usb_temp_adc_table_size = len;
+
+		pdata->usb_temp_adc_table =
+			kzalloc(sizeof(sec_bat_adc_table_data_t) *
+				pdata->usb_temp_adc_table_size, GFP_KERNEL);
+
+		for(i = 0; i < pdata->usb_temp_adc_table_size; i++) {
+			ret = of_property_read_u32_index(np,
+							 "battery,usb_temp_table_adc", i, &temp);
+			pdata->usb_temp_adc_table[i].adc = (int)temp;
+			if (ret)
+				pr_info("%s : Usb_Temp_adc_table(adc) is Empty\n",
+					__func__);
+
+			ret = of_property_read_u32_index(np,
+							 "battery,usb_temp_table_data", i, &temp);
+			pdata->usb_temp_adc_table[i].data = (int)temp;
+			if (ret)
+				pr_info("%s : Usb_Temp_adc_table(data) is Empty\n",
+					__func__);
+		}
+	}
+
+#if defined(CONFIG_XADC_SHARE_BATT_WITH_USB_THM)
+	ret = pdata->xadc_mux_sel_pin = of_get_named_gpio(np, "battery,xadc_mux_sel_pin", 0);
+	if (ret < 0) {
+		pr_info("%s : can't get xadc_mux_sel_pin\n", __func__);
+	}
+#endif
+	
+	ret = of_property_read_u32(np, "battery,chg_thermal_source",
+		&pdata->chg_thermal_source);
+	if (ret)
+		pr_info("%s : chg_thermal_source is Empty\n", __func__);
+
+	if (pdata->chg_thermal_source == SEC_CHARGER_THERMAL_SOURCE_ADC) {
+		p = of_get_property(np, "battery,chg_temp_table_adc", &len);
+		if (!p)
+			return 1;
+
+		len = len / sizeof(u32);
+
+		pdata->chg_temp_adc_table_size = len;
+
+		pdata->chg_temp_adc_table =
+			kzalloc(sizeof(sec_bat_adc_table_data_t) *
+				pdata->chg_temp_adc_table_size, GFP_KERNEL);
+
+		for (i = 0; i < pdata->chg_temp_adc_table_size; i++) {
+			ret = of_property_read_u32_index(np,
+							 "battery,chg_temp_table_adc", i, &temp);
+			pdata->chg_temp_adc_table[i].adc = (int)temp;
+			if (ret)
+				pr_info("%s : CHG_Temp_adc_table(adc) is Empty\n",
+					__func__);
+
+			ret = of_property_read_u32_index(np,
+							 "battery,chg_temp_table_data", i, &temp);
+			pdata->chg_temp_adc_table[i].data = (int)temp;
+			if (ret)
+				pr_info("%s : CHG_Temp_adc_table(data) is Empty\n",
+					__func__);
+		}
+	}
+
+	ret = of_property_read_u32(np, "battery,wpc_thermal_source",
+		&pdata->wpc_thermal_source);
+	if (ret)
+		pr_info("%s : wpc_thermal_source is Empty\n", __func__);
+
+	if (pdata->wpc_thermal_source) {
+		p = of_get_property(np, "battery,wpc_temp_table_adc", &len);
+		if (!p) {
+			pr_info("%s : wpc_temp_table_adc(adc) is Empty\n",__func__);
+		} else {
+			len = len / sizeof(u32);
+
+			pdata->wpc_temp_adc_table_size = len;
+
+			pdata->wpc_temp_adc_table =
+				kzalloc(sizeof(sec_bat_adc_table_data_t) *
+					pdata->wpc_temp_adc_table_size, GFP_KERNEL);
+
+			for (i = 0; i < pdata->wpc_temp_adc_table_size; i++) {
+				ret = of_property_read_u32_index(np,
+								 "battery,wpc_temp_table_adc", i, &temp);
+				pdata->wpc_temp_adc_table[i].adc = (int)temp;
+				if (ret)
+					pr_info("%s : WPC_Temp_adc_table(adc) is Empty\n",
+						__func__);
+
+				ret = of_property_read_u32_index(np,
+								 "battery,wpc_temp_table_data", i, &temp);
+				pdata->wpc_temp_adc_table[i].data = (int)temp;
+				if (ret)
+					pr_info("%s : WPC_Temp_adc_table(data) is Empty\n",
+						__func__);
+			}
+		}
+	}
+
+	ret = of_property_read_u32(np, "battery,slave_thermal_source",
+		&pdata->slave_thermal_source);
+	if (ret)
+		pr_info("%s : slave_thermal_source is Empty\n", __func__);
+
+	if (pdata->slave_thermal_source) {
+		p = of_get_property(np, "battery,slave_chg_temp_table_adc", &len);
+		if (!p)
+			return 1;
+
+		len = len / sizeof(u32);
+
+		pdata->slave_chg_temp_adc_table_size = len;
+
+		pdata->slave_chg_temp_adc_table =
+			kzalloc(sizeof(sec_bat_adc_table_data_t) *
+				pdata->slave_chg_temp_adc_table_size, GFP_KERNEL);
+
+		for (i = 0; i < pdata->slave_chg_temp_adc_table_size; i++) {
+			ret = of_property_read_u32_index(np,
+							 "battery,slave_chg_temp_table_adc", i, &temp);
+			pdata->slave_chg_temp_adc_table[i].adc = (int)temp;
+			if (ret)
+				pr_info("%s : slave_chg_temp_adc_table(adc) is Empty\n",
+					__func__);
+
+			ret = of_property_read_u32_index(np,
+							 "battery,slave_chg_temp_table_data", i, &temp);
+			pdata->slave_chg_temp_adc_table[i].data = (int)temp;
+			if (ret)
+				pr_info("%s : slave_chg_temp_adc_table(data) is Empty\n",
+					__func__);
+		}
+	}
+	ret = of_property_read_u32(np, "battery,slave_chg_temp_check",
+		&pdata->slave_chg_temp_check);
+	if (ret)
+		pr_info("%s : slave_chg_temp_check is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,chg_temp_check",
+		&pdata->chg_temp_check);
+	if (ret)
+		pr_info("%s : chg_temp_check is Empty\n", __func__);
+
+	if (pdata->chg_temp_check) {
+		ret = of_property_read_u32(np, "battery,chg_heating_prevention_method",
+			&pdata->chg_heating_prevention_method);
+		if (ret)
+			pr_info("%s : chg_heating_prevention_method is Empty\n", __func__);
+		
+		ret = of_property_read_u32(np, "battery,chg_12v_high_temp",
+					   &temp);
+		pdata->chg_12v_high_temp = (int)temp;
+		if (ret)
+			pr_info("%s : chg_12v_high_temp is Empty\n", __func__);
+
+		ret = of_property_read_u32(np, "battery,chg_high_temp",
+					   &temp);
+		pdata->chg_high_temp = (int)temp;
+		if (ret)
+			pr_info("%s : chg_high_temp is Empty\n", __func__);
+
+		ret = of_property_read_u32(np, "battery,chg_high_temp_recovery",
+					   &temp);
+		pdata->chg_high_temp_recovery = (int)temp;
+		if (ret)
+			pr_info("%s : chg_temp_recovery is Empty\n", __func__);
+
+		ret = of_property_read_u32(np, "battery,chg_charging_limit_current",
+					   &pdata->chg_charging_limit_current);
+		if (ret)
+			pr_info("%s : chg_charging_limit_current is Empty\n", __func__);
+
+		ret = of_property_read_u32(np, "battery,mix_high_temp",
+					   &temp);
+		pdata->mix_high_temp = (int)temp;
+		if (ret)
+			pr_info("%s : mix_high_temp is Empty\n", __func__);
+
+		ret = of_property_read_u32(np, "battery,mix_high_chg_temp",
+					   &temp);
+		pdata->mix_high_chg_temp = (int)temp;
+		if (ret)
+			pr_info("%s : mix_high_chg_temp is Empty\n", __func__);
+
+		ret = of_property_read_u32(np, "battery,mix_high_temp_recovery",
+					   &temp);
+		pdata->mix_high_temp_recovery = (int)temp;
+		if (ret)
+			pr_info("%s : mix_high_temp_recovery is Empty\n", __func__);
+	}
+
+	ret = of_property_read_u32(np, "battery,wpc_temp_check",
+		&pdata->wpc_temp_check);
+	if (ret)
+		pr_info("%s : wpc_temp_check is Empty\n", __func__);
+
+	if (pdata->wpc_temp_check) {
+		p = of_get_property(np, "battery,wpc_high_temp", &len);
+		if (!p)
+			return 1;
+
+		len = len / sizeof(u32);
+		pdata->wpc_high_temp_size = len;
+		pdata->wpc_high_temp = kzalloc(sizeof(unsigned int) * len, GFP_KERNEL);
+		pdata->wpc_high_temp_recovery = kzalloc(sizeof(unsigned int) * len, GFP_KERNEL);
+		pdata->wpc_charging_limit_current = kzalloc(sizeof(unsigned int) * len, GFP_KERNEL);
+		if (!pdata->wpc_high_temp ||
+			!pdata->wpc_high_temp_recovery ||
+			!pdata->wpc_charging_limit_current)
+			return 1;
+		
+		for (i = 0; i < len; i++) {
+			ret = of_property_read_u32_index(np,
+				"battery,wpc_high_temp", i, &temp);
+			pdata->wpc_high_temp[i] = (int)temp;
+			if (ret)
+				pr_info("%s : wpc_high_temp is Empty\n", __func__);
+
+			ret = of_property_read_u32_index(np,
+				"battery,wpc_high_temp_recovery", i, &temp);
+			pdata->wpc_high_temp_recovery[i] = (int)temp;
+			if (ret)
+				pr_info("%s : wpc_high_temp_recovery is Empty\n", __func__);
+
+			ret = of_property_read_u32_index(np,
+				"battery,wpc_charging_limit_current", i, &temp);
+			pdata->wpc_charging_limit_current[i] = (int)temp;
+			if (ret)
+				pr_info("%s : wpc_charging_limit_current is Empty\n", __func__);
+		}
+
+		pr_info("%s: wpc_high_temp_size(%d)\n", __func__, pdata->wpc_high_temp_size);
+		for (i = 0; i < len; i++) {
+			pr_info("%s: index(%d) - wpc_high_temp(%d), wpc_high_temp_recovery(%d), wpc_charging_limit_current(%d)\n",
+				__func__, i,
+				pdata->wpc_high_temp[i],
+				pdata->wpc_high_temp_recovery[i],
+				pdata->wpc_charging_limit_current[i]);
+		}
+
+		ret = of_property_read_u32(np, "battery,wpc_heat_temp_recovery",
+					   &temp);
+		pdata->wpc_heat_temp_recovery = (int)temp;
+		if (ret)
+			pr_info("%s : wpc_heat_temp_recovery is Empty\n", __func__);
+
+		ret = of_property_read_u32(np, "battery,wpc_hv_lcd_on_input_limit_current",
+				   &pdata->wpc_hv_lcd_on_input_limit_current);
+		if (ret)
+			pr_info("%s : wpc_hv_lcd_on_input_limit_current is Empty\n", __func__);
+
+		ret = of_property_read_u32(np, "battery,wpc_lcd_on_high_temp",
+					   &pdata->wpc_lcd_on_high_temp);
+		if (ret)
+			pr_info("%s : wpc_lcd_on_high_temp is Empty\n", __func__);
+
+		ret = of_property_read_u32(np, "battery,wpc_lcd_on_high_temp_rec",
+					   &pdata->wpc_lcd_on_high_temp_rec);
+		if (ret)
+			pr_info("%s : wpc_lcd_on_high_temp_rec is Empty\n", __func__);
+	}
+
+	ret = of_property_read_u32(np, "battery,wc_full_input_limit_current",
+		&pdata->wc_full_input_limit_current);
+	if (ret)
+		pr_info("%s : wc_full_input_limit_current is Empty\n", __func__);	
+
+	ret = of_property_read_u32(np, "battery,wc_heating_input_limit_current",
+		&pdata->wc_heating_input_limit_current);
+	if (ret)
+		pr_info("%s : wc_heating_input_limit_current is Empty\n", __func__);	
+
+	ret = of_property_read_u32(np, "battery,wc_heating_time",
+		&pdata->wc_heating_time);
+	if (ret)
+		pr_info("%s : wc_heating_time is Empty\n", __func__);	
+
+	ret = of_property_read_u32(np, "battery,wc_cv_current",
+		&pdata->wc_cv_current);
+	if (ret)
+		pr_info("%s : wc_cv_current is Empty\n", __func__);	
+
+	ret = of_property_read_u32(np, "battery,wc_cv_pack_current",
+		&pdata->wc_cv_pack_current);
+	if (ret) {
+		pr_info("%s : wc_cv_pack_current is Empty\n", __func__);
+		pdata->wc_cv_pack_current = 500;
+	}
+
+	ret = of_property_read_u32(np, "battery,sleep_mode_limit_current",
+			&pdata->sleep_mode_limit_current);
+	if (ret)
+		pr_info("%s : sleep_mode_limit_current is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,inbat_voltage",
+			&pdata->inbat_voltage);
+	if (ret)
+		pr_info("%s : inbat_voltage is Empty\n", __func__);
+
+	if (pdata->inbat_voltage) {
+		p = of_get_property(np, "battery,inbat_voltage_table_adc", &len);
+		if (!p)
+			return 1;
+
+		len = len / sizeof(u32);
+
+		pdata->inbat_adc_table_size = len;
+
+		pdata->inbat_adc_table =
+			kzalloc(sizeof(sec_bat_adc_table_data_t) *
+					pdata->inbat_adc_table_size, GFP_KERNEL);
+
+		for (i = 0; i < pdata->inbat_adc_table_size; i++) {
+			ret = of_property_read_u32_index(np,
+							 "battery,inbat_voltage_table_adc", i, &temp);
+			pdata->inbat_adc_table[i].adc = (int)temp;
+			if (ret)
+				pr_info("%s : inbat_adc_table(adc) is Empty\n",
+						__func__);
+
+			ret = of_property_read_u32_index(np,
+							 "battery,inbat_voltage_table_data", i, &temp);
+			pdata->inbat_adc_table[i].data = (int)temp;
+			if (ret)
+				pr_info("%s : inbat_adc_table(data) is Empty\n",
+						__func__);
+		}
+	}
+
+	p = of_get_property(np, "battery,input_current_limit", &len);
+	if (!p)
+		return 1;
+
+	len = len / sizeof(u32);
+
+	pdata->charging_current =
+		kzalloc(sizeof(sec_charging_current_t) * len,
+			GFP_KERNEL);
+
+	for (i = 0; i < len; i++) {
+		ret = of_property_read_u32_index(np,
+			 "battery,input_current_limit", i,
+			 &pdata->charging_current[i].input_current_limit);
+		if (ret)
+			pr_info("%s : Input_current_limit is Empty\n",
+				__func__);
+
+		ret = of_property_read_u32_index(np,
+			 "battery,fast_charging_current", i,
+			 &pdata->charging_current[i].fast_charging_current);
+		if (ret)
+			pr_info("%s : Fast charging current is Empty\n",
+				__func__);
+
+		ret = of_property_read_u32_index(np,
+			 "battery,full_check_current_1st", i,
+			 &pdata->charging_current[i].full_check_current_1st);
+		if (ret)
+			pr_info("%s : Full check current 1st is Empty\n",
+				__func__);
+
+		ret = of_property_read_u32_index(np,
+			 "battery,full_check_current_2nd", i,
+			 &pdata->charging_current[i].full_check_current_2nd);
+		if (ret)
+			pr_info("%s : Full check current 2nd is Empty\n",
+				__func__);
+	}
+	pdata->default_usb_input_current = pdata->charging_current[POWER_SUPPLY_TYPE_USB].input_current_limit;
+	pdata->default_usb_charging_current = pdata->charging_current[POWER_SUPPLY_TYPE_USB].fast_charging_current;
+	pdata->default_input_current = pdata->charging_current[POWER_SUPPLY_TYPE_MAINS].input_current_limit;
+	pdata->default_charging_current = pdata->charging_current[POWER_SUPPLY_TYPE_MAINS].fast_charging_current;
+#ifdef CONFIG_SEC_FACTORY
+	ret = of_property_read_u32(np, "battery,factory_fast_charging_current",
+		&temp);
+	if (ret) {
+		pr_info("%s : factory_fast_charging_current is Empty\n", __func__);
+		pdata->charging_current[POWER_SUPPLY_TYPE_MAINS].fast_charging_current = 1500;
+		pdata->charging_current[POWER_SUPPLY_TYPE_UNKNOWN].fast_charging_current = 1500;
+	} else {
+		pdata->charging_current[POWER_SUPPLY_TYPE_MAINS].fast_charging_current = (int)temp;
+		pdata->charging_current[POWER_SUPPLY_TYPE_UNKNOWN].fast_charging_current = (int)temp;
+	}
+#endif
+	ret = of_property_read_u32(np, "battery,pre_afc_input_current",
+		&pdata->pre_afc_input_current);
+	if (ret) {
+		pr_info("%s : pre_afc_input_current is Empty\n", __func__);
+		pdata->pre_afc_input_current = 1000;
+	}
+
+	ret = of_property_read_u32(np, "battery,pre_afc_work_delay",
+			&pdata->pre_afc_work_delay);
+	if (ret) {
+		pr_info("%s : pre_afc_work_delay is Empty\n", __func__);
+		pdata->pre_afc_work_delay = 2000;
+	}
+
+	ret = of_property_read_u32(np, "battery,pre_wc_afc_input_current",
+		&pdata->pre_wc_afc_input_current);
+	if (ret) {
+		pr_info("%s : pre_wc_afc_input_current is Empty\n", __func__);
+		pdata->pre_wc_afc_input_current = 480; /* wc input default */
+	}
+
+	ret = of_property_read_u32(np, "battery,store_mode_afc_input_current",
+		&pdata->store_mode_afc_input_current);
+	if (ret) {
+		pr_info("%s : store_mode_afc_input_current is Empty\n", __func__);
+		pdata->store_mode_afc_input_current = 440;
+	}
+
+	ret = of_property_read_u32(np, "battery,store_mode_hv_wireless_input_current",
+		&pdata->store_mode_hv_wireless_input_current);
+	if (ret) {
+		pr_info("%s : store_mode_hv_wireless_input_current is Empty\n", __func__);
+		pdata->store_mode_hv_wireless_input_current = 400;
+	}
+
+	ret = of_property_read_u32(np, "battery,adc_check_count",
+		&pdata->adc_check_count);
+	if (ret)
+		pr_info("%s : Adc check count is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,temp_adc_type",
+		&pdata->temp_adc_type);
+	if (ret)
+		pr_info("%s : Temp adc type is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,cable_check_type",
+		&pdata->cable_check_type);
+	if (ret)
+		pr_info("%s : Cable check type is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,cable_source_type",
+		&pdata->cable_source_type);
+	if (ret)
+		pr_info("%s : Cable source type is Empty\n", __func__);
+	ret = of_property_read_u32(np, "battery,polling_type",
+		&pdata->polling_type);
+	if (ret)
+		pr_info("%s : Polling type is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,monitor_initial_count",
+		&pdata->monitor_initial_count);
+	if (ret)
+		pr_info("%s : Monitor initial count is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,battery_check_type",
+		&pdata->battery_check_type);
+	if (ret)
+		pr_info("%s : Battery check type is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,check_count",
+		&pdata->check_count);
+	if (ret)
+		pr_info("%s : Check count is Empty\n", __func__);
+
+	pdata->bat_irq_gpio = of_get_named_gpio(np, "battery,bat_irq_gpio", 0);
+	pr_info("%s : bat_irq_gpio = %d\n", __func__, pdata->bat_irq_gpio);
+
+	ret = of_property_read_u32(np, "battery,bat_irq_attr", &pdata->bat_irq_attr);
+	if(ret)
+		pr_info("%s : bat_irq_attr is Empty, irq_attr\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,check_adc_max",
+		&pdata->check_adc_max);
+	if (ret)
+		pr_info("%s : Check adc max is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,check_adc_min",
+		&pdata->check_adc_min);
+	if (ret)
+		pr_info("%s : Check adc min is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,ovp_uvlo_check_type",
+		&pdata->ovp_uvlo_check_type);
+	if (ret)
+		pr_info("%s : Ovp Uvlo check type is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,temp_check_type",
+		&pdata->temp_check_type);
+	if (ret)
+		pr_info("%s : Temp check type is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,temp_check_count",
+		&pdata->temp_check_count);
+	if (ret)
+		pr_info("%s : Temp check count is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,temp_highlimit_threshold_normal",
+				   &temp);
+	pdata->temp_highlimit_threshold_normal =  (int)temp;
+	if (ret)
+		pr_info("%s : Temp highlimit threshold normal is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,temp_highlimit_recovery_normal",
+				   &temp);
+	pdata->temp_highlimit_recovery_normal =  (int)temp;
+	if (ret)
+		pr_info("%s : Temp highlimit recovery normal is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,temp_high_threshold_normal",
+				   &temp);
+	pdata->temp_high_threshold_normal =  (int)temp;
+	if (ret)
+		pr_info("%s : Temp high threshold normal is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,temp_high_recovery_normal",
+				   &temp);
+	pdata->temp_high_recovery_normal =  (int)temp;
+	if (ret)
+		pr_info("%s : Temp high recovery normal is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,temp_low_threshold_normal",
+				   &temp);
+	pdata->temp_low_threshold_normal =  (int)temp;
+	if (ret)
+		pr_info("%s : Temp low threshold normal is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,temp_low_recovery_normal",
+				   &temp);
+	pdata->temp_low_recovery_normal =  (int)temp;
+	if (ret)
+		pr_info("%s : Temp low recovery normal is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,temp_highlimit_threshold_lpm",
+				   &temp);
+	pdata->temp_highlimit_threshold_lpm = (int)temp;
+	if (ret)
+		pr_info("%s : Temp highlimit threshold lpm is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,temp_highlimit_recovery_lpm",
+				   &temp);
+	pdata->temp_highlimit_recovery_lpm = (int)temp;
+	if (ret)
+		pr_info("%s : Temp highlimit recovery lpm is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,temp_high_threshold_lpm",
+				   &temp);
+	pdata->temp_high_threshold_lpm = (int)temp;
+	if (ret)
+		pr_info("%s : Temp high threshold lpm is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,temp_high_recovery_lpm",
+				   &temp);
+	pdata->temp_high_recovery_lpm = (int)temp;
+	if (ret)
+		pr_info("%s : Temp high recovery lpm is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,temp_low_threshold_lpm",
+				   &temp);
+	pdata->temp_low_threshold_lpm = (int)temp;
+	if (ret)
+		pr_info("%s : Temp low threshold lpm is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,temp_low_recovery_lpm",
+				   &temp);
+	pdata->temp_low_recovery_lpm = (int)temp;
+	if (ret)
+		pr_info("%s : Temp low recovery lpm is Empty\n", __func__);
+
+	pr_info("%s : HIGHLIMIT_THRESHOLD_NOLMAL(%d), HIGHLIMIT_RECOVERY_NORMAL(%d)\n"
+		"HIGH_THRESHOLD_NORMAL(%d), HIGH_RECOVERY_NORMAL(%d) LOW_THRESHOLD_NORMAL(%d), LOW_RECOVERY_NORMAL(%d)\n"
+		"HIGHLIMIT_THRESHOLD_LPM(%d), HIGHLIMIT_RECOVERY_LPM(%d)\n"
+		"HIGH_THRESHOLD_LPM(%d), HIGH_RECOVERY_LPM(%d) LOW_THRESHOLD_LPM(%d), LOW_RECOVERY_LPM(%d)\n",
+		__func__,
+		pdata->temp_highlimit_threshold_normal, pdata->temp_highlimit_recovery_normal,
+		pdata->temp_high_threshold_normal, pdata->temp_high_recovery_normal,
+		pdata->temp_low_threshold_normal, pdata->temp_low_recovery_normal,
+		pdata->temp_highlimit_threshold_lpm, pdata->temp_highlimit_recovery_lpm,
+		pdata->temp_high_threshold_lpm, pdata->temp_high_recovery_lpm,
+		pdata->temp_low_threshold_lpm, pdata->temp_low_recovery_lpm);
+
+	ret = of_property_read_u32(np, "battery,full_check_type",
+		&pdata->full_check_type);
+	if (ret)
+		pr_info("%s : Full check type is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,full_check_type_2nd",
+		&pdata->full_check_type_2nd);
+	if (ret)
+		pr_info("%s : Full check type 2nd is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,full_check_count",
+		&pdata->full_check_count);
+	if (ret)
+		pr_info("%s : Full check count is Empty\n", __func__);
+
+        ret = of_property_read_u32(np, "battery,chg_gpio_full_check",
+                &pdata->chg_gpio_full_check);
+	if (ret)
+		pr_info("%s : Chg gpio full check is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,chg_polarity_full_check",
+		&pdata->chg_polarity_full_check);
+	if (ret)
+		pr_info("%s : Chg polarity full check is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,full_condition_type",
+		&pdata->full_condition_type);
+	if (ret)
+		pr_info("%s : Full condition type is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,full_condition_soc",
+		&pdata->full_condition_soc);
+	if (ret)
+		pr_info("%s : Full condition soc is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,full_condition_vcell",
+		&pdata->full_condition_vcell);
+	if (ret)
+		pr_info("%s : Full condition vcell is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,recharge_check_count",
+		&pdata->recharge_check_count);
+	if (ret)
+		pr_info("%s : Recharge check count is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,recharge_condition_type",
+		&pdata->recharge_condition_type);
+	if (ret)
+		pr_info("%s : Recharge condition type is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,recharge_condition_soc",
+		&pdata->recharge_condition_soc);
+	if (ret)
+		pr_info("%s : Recharge condition soc is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,recharge_condition_vcell",
+		&pdata->recharge_condition_vcell);
+	if (ret)
+		pr_info("%s : Recharge condition vcell is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,charging_total_time",
+		(unsigned int *)&pdata->charging_total_time);
+	if (ret)
+		pr_info("%s : Charging total time is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,hv_charging_total_time",
+		(unsigned int *)&pdata->hv_charging_total_time);
+	if (ret) {
+		pdata->hv_charging_total_time = 3 * 60 * 60;
+		pr_info("%s : HV Charging total time is %d\n",
+			__func__, pdata->hv_charging_total_time);
+	}
+
+	ret = of_property_read_u32(np, "battery,normal_charging_total_time",
+		(unsigned int *)&pdata->normal_charging_total_time);
+	if (ret) {
+		pdata->normal_charging_total_time = 5 * 60 * 60;
+		pr_info("%s : Normal(WC) Charging total time is %d\n",
+			__func__, pdata->normal_charging_total_time);
+	}
+
+	ret = of_property_read_u32(np, "battery,usb_charging_total_time",
+		(unsigned int *)&pdata->usb_charging_total_time);
+	if (ret) {
+		pdata->usb_charging_total_time = 10 * 60 * 60;
+		pr_info("%s : USB Charging total time is %d\n",
+			__func__, pdata->usb_charging_total_time);
+	}
+
+	ret = of_property_read_u32(np, "battery,recharging_total_time",
+		(unsigned int *)&pdata->recharging_total_time);
+	if (ret)
+		pr_info("%s : Recharging total time is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,charging_reset_time",
+		(unsigned int *)&pdata->charging_reset_time);
+	if (ret)
+		pr_info("%s : Charging reset time is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,charging_reset_time",
+		(unsigned int *)&pdata->charging_reset_time);
+	if (ret)
+		pr_info("%s : Charging reset time is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,chg_float_voltage",
+		(unsigned int *)&pdata->chg_float_voltage);
+	if (ret) {
+		pr_info("%s: chg_float_voltage is Empty\n", __func__);
+
+#if defined(CONFIG_HUNDREDMICRO_PRECISION_FG)
+		pdata->chg_float_voltage = 43500;
+#else
+		pdata->chg_float_voltage = 4350;
+#endif
+	}
+
+	ret = of_property_read_u32(np, "battery,chg_float_voltage_conv",
+				   &pdata->chg_float_voltage_conv);
+	if (ret) {
+		pr_info("%s: chg_float_voltage_conv is Empty\n", __func__);
+		pdata->chg_float_voltage_conv = 1;
+	}
+
+#if defined(CONFIG_BATTERY_SWELLING)
+	ret = of_property_read_u32(np, "battery,chg_float_voltage",
+		(unsigned int *)&pdata->swelling_normal_float_voltage);
+	if (ret)
+		pr_info("%s: chg_float_voltage is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,swelling_high_temp_block",
+				   &temp);
+	pdata->swelling_high_temp_block = (int)temp;
+	if (ret)
+		pr_info("%s: swelling high temp block is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,swelling_high_temp_recov",
+				   &temp);
+	pdata->swelling_high_temp_recov = (int)temp;
+	if (ret)
+		pr_info("%s: swelling high temp recovery is Empty\n", __func__);
+
+	ret = of_property_read_u32(np, "battery,swelling_low_temp_2step_mode",
+				   &pdata->swelling_low_temp_2step_mode);
+	if (ret) {
+		pdata->swelling_low_temp_2step_mode = 0;
+		pr_info("%s: swelling_low_temp_2step_mode is Empty\n", __func__);
+	}
+
+	if(pdata->swelling_low_temp_2step_mode) {
+		ret = of_property_read_u32(np, "battery,swelling_low_temp_block_1st",
+				   &temp);
+		pdata->swelling_low_temp_block_1st = (int)temp;
+		if (ret)
+			pr_info("%s: swelling low temp block is Empty\n", __func__);
+
+		ret = of_property_read_u32(np, "battery,swelling_low_temp_recov_1st",
+				   &temp);
+		pdata->swelling_low_temp_recov_1st = (int)temp;
+		if (ret)
+			pr_info("%s: swelling low temp recovery is Empty\n", __func__);
+		
+		ret = of_property_read_u32(np, "battery,swelling_low_temp_block_2nd",
+				   &temp);
+		pdata->swelling_low_temp_block_2nd = (int)temp;
+		if (ret)
+			pr_info("%s: swelling low temp block is Empty\n", __func__);
+
+		ret = of_property_read_u32(np, "battery,swelling_low_temp_recov_2nd",
+				   &temp);
+		pdata->swelling_low_temp_recov_2nd = (int)temp;
+		if (ret)
+			pr_info("%s: swelling low temp recovery is Empty\n", __func__);
+	}
+	else {
+		ret = of_property_read_u32(np, "battery,swelling_low_temp_block",
+				   &temp);
+		pdata->swelling_low_temp_block_1st = (int)temp;
+		pdata->swelling_low_temp_block_2nd = (int)temp;
+		if (ret)
+			pr_info("%s: swelling low temp block is Empty\n", __func__);
+
+		ret = of_property_read_u32(np, "battery,swelling_low_temp_recov",
+				   &temp);
+		pdata->swelling_low_temp_recov_1st = (int)temp;
+		pdata->swelling_low_temp_recov_2nd = (int)temp;
+		if (ret)
+			pr_info("%s: swelling low temp recovery is Empty\n", __func__);	
+	}
+
+	ret = of_property_read_u32(np, "battery,swelling_low_temp_additional",
+				   &temp);
+	pdata->swelling_low_temp_additional = (int)temp;
+	if (ret) {
+		pr_info("%s: swelling low temp additional is Empty\n", __func__);
+		pdata->swelling_low_temp_additional = 50;
+	}
+
+	ret = of_property_read_u32(np, "battery,swelling_low_temp_current", 
+					&pdata->swelling_low_temp_current);
+	if (ret) {
+		pr_info("%s: swelling_low_temp_current is Empty, Default value 600mA \n", __func__);
+		pdata->swelling_low_temp_current = 600;
+	}
+
+	ret = of_property_read_u32(np, "battery,swelling_low_temp_additional_current", 
+					&pdata->swelling_low_temp_additional_current);
+	if (ret) {
+		pr_info("%s: swelling_low_temp_additional_current is Empty, Default value 600mA \n", __func__);
+		pdata->swelling_low_temp_additional_current = 600;
+	}
+
+	ret = of_property_read_u32(np, "battery,swelling_low_temp_topoff", 
+					&pdata->swelling_low_temp_topoff);
+	if (ret) {
+		pr_info("%s: swelling_low_temp_topoff is Empty, Default value 200mA \n", __func__);
+		pdata->swelling_low_temp_topoff = 200;
+	}
+
+	ret = of_property_read_u32(np, "battery,swelling_high_temp_current", 
+					&pdata->swelling_high_temp_current);
+	if (ret) {
+		pr_info("%s: swelling_low_temp_current is Empty, Default value 1300mA \n", __func__);
+		pdata->swelling_high_temp_current = 1300;
+	}
+
+	ret = of_property_read_u32(np, "battery,swelling_high_temp_topoff", 
+					&pdata->swelling_high_temp_topoff);
+	if (ret) {
+		pr_info("%s: swelling_high_temp_topoff is Empty, Default value 200mA \n", __func__);
+		pdata->swelling_high_temp_topoff = 200;
+	}
+
+	ret = of_property_read_u32(np, "battery,swelling_drop_float_voltage",
+		(unsigned int *)&pdata->swelling_drop_float_voltage);
+	if (ret) {
+		pr_info("%s: swelling drop float voltage is Empty, Default value 4250mV \n", __func__);
+		pdata->swelling_drop_float_voltage = 4250;
+	}
+
+	ret = of_property_read_u32(np, "battery,swelling_high_rechg_voltage",
+		(unsigned int *)&pdata->swelling_high_rechg_voltage);
+	if (ret) {
+		pr_info("%s: swelling_high_rechg_voltage is Empty\n", __func__);
+		pdata->swelling_high_rechg_voltage = 4150;
+	}
+
+	ret = of_property_read_u32(np, "battery,swelling_low_rechg_voltage",
+		(unsigned int *)&pdata->swelling_low_rechg_voltage);
+	if (ret) {
+		pr_info("%s: swelling_low_rechg_voltage is Empty\n", __func__);
+				pdata->swelling_low_rechg_voltage = 4000;
+	}
+
+	pr_info("%s : SWELLING_HIGH_TEMP(%d) SWELLING_HIGH_TEMP_RECOVERY(%d)\n"
+		"SWELLING_LOW_TEMP_1st(%d) SWELLING_LOW_TEMP_RECOVERY_1st(%d) "
+		"SWELLING_LOW_TEMP_2nd(%d) SWELLING_LOW_TEMP_RECOVERY_2nd(%d) "
+		"SWELLING_LOW_TEMP_ADDITIONAL(%d) "
+		"SWELLING_LOW_CURRENT(%d, %d), SWELLING_HIGH_CURRENT(%d, %d)\n",
+		__func__, pdata->swelling_high_temp_block, pdata->swelling_high_temp_recov,
+		pdata->swelling_low_temp_block_1st, pdata->swelling_low_temp_recov_1st,
+		pdata->swelling_low_temp_block_2nd, pdata->swelling_low_temp_recov_2nd,
+		pdata->swelling_low_temp_additional,
+		pdata->swelling_low_temp_current, pdata->swelling_low_temp_topoff,
+		pdata->swelling_high_temp_current, pdata->swelling_high_temp_topoff);
+#endif
+
+#if defined(CONFIG_CALC_TIME_TO_FULL)
+	ret = of_property_read_u32(np, "battery,ttf_hv_12v_charge_current", 
+					&pdata->ttf_hv_12v_charge_current);
+	if (ret) {
+		pdata->ttf_hv_12v_charge_current =
+			pdata->charging_current[POWER_SUPPLY_TYPE_HV_MAINS_12V].fast_charging_current;
+		pr_info("%s: ttf_hv_12v_charge_current is Empty, Defualt value %d \n",
+			__func__, pdata->ttf_hv_12v_charge_current);
+	}
+	ret = of_property_read_u32(np, "battery,ttf_hv_charge_current", 
+					&pdata->ttf_hv_charge_current);
+	if (ret) {
+		pdata->ttf_hv_charge_current =
+			pdata->charging_current[POWER_SUPPLY_TYPE_HV_MAINS].fast_charging_current;
+		pr_info("%s: ttf_hv_charge_current is Empty, Defualt value %d \n",
+			__func__, pdata->ttf_hv_charge_current);
+	}
+
+	ret = of_property_read_u32(np, "battery,ttf_hv_wireless_charge_current", 
+					&pdata->ttf_hv_wireless_charge_current);
+	if (ret) {
+		pr_info("%s: ttf_hv_wireless_charge_current is Empty, Defualt value 0 \n", __func__);
+		pdata->ttf_hv_wireless_charge_current =
+			pdata->charging_current[POWER_SUPPLY_TYPE_HV_WIRELESS].fast_charging_current - 300;
+	}
+
+	ret = of_property_read_u32(np, "battery,ttf_wireless_charge_current", 
+					&pdata->ttf_wireless_charge_current);
+	if (ret) {
+		pr_info("%s: ttf_wireless_charge_current is Empty, Defualt value 0 \n", __func__);
+		pdata->ttf_wireless_charge_current =
+			pdata->charging_current[POWER_SUPPLY_TYPE_WIRELESS].input_current_limit;
+	}
+#endif
+
+#if defined(CONFIG_WIRELESS_FIRMWARE_UPDATE)
+	/* wpc_det */
+	ret = pdata->wpc_det = of_get_named_gpio(np, "battery,wpc_det", 0);
+	if (ret < 0) {
+		pr_info("%s : can't get wpc_det\n", __func__);
+	}
+#endif
+
+	/* wpc_en */
+	ret = pdata->wpc_en = of_get_named_gpio(np, "battery,wpc_en", 0);
+	if (ret < 0) {
+		pr_info("%s : can't get wpc_en\n", __func__);
+		pdata->wpc_en = 0;
+	}
+	/* thm_mux */
+	ret = pdata->thm_mux = of_get_named_gpio(np, "battery,thm_mux", 0);
+	if (ret < 0) {
+		pr_info("%s : can't get thm_mux\n", __func__);
+	}
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	p = of_get_property(np, "battery,age_data", &len);
+	if (p) {
+		battery->pdata->num_age_step = len / sizeof(sec_age_data_t);
+		battery->pdata->age_data = kzalloc(len, GFP_KERNEL);
+		ret = of_property_read_u32_array(np, "battery,age_data",
+				 (u32 *)battery->pdata->age_data, len/sizeof(u32));
+		if (ret) {
+			pr_err("%s: [Long life] failed to read battery->pdata->age_data: %d\n",
+					__func__, ret);
+			kfree(battery->pdata->age_data);
+			battery->pdata->age_data = NULL;
+			battery->pdata->num_age_step = 0;
+		}
+		pr_err("%s: [Long life]  num_age_step : %d\n", __func__, battery->pdata->num_age_step);
+#if defined(CONFIG_BATTERY_AGE_FORECAST_B2B)
+		for (len = 0; len < battery->pdata->num_age_step; ++len) {
+			pr_err("[%d/%d]cycle:%d, float:%d, full_v:%d, recharge_v:%d, soc:%d, max_c:%d\n",
+				len, battery->pdata->num_age_step-1,
+				battery->pdata->age_data[len].cycle,
+				battery->pdata->age_data[len].float_voltage,
+				battery->pdata->age_data[len].full_condition_vcell,
+				battery->pdata->age_data[len].recharge_condition_vcell,
+				battery->pdata->age_data[len].full_condition_soc,
+				battery->pdata->age_data[len].max_charging_current);
+		}
+#else
+		for (len = 0; len < battery->pdata->num_age_step; ++len) {
+			pr_err("[%d/%d]cycle:%d, float:%d, full_v:%d, recharge_v:%d, soc:%d\n",
+				len, battery->pdata->num_age_step-1,
+				battery->pdata->age_data[len].cycle,
+				battery->pdata->age_data[len].float_voltage,
+				battery->pdata->age_data[len].full_condition_vcell,
+				battery->pdata->age_data[len].recharge_condition_vcell,
+				battery->pdata->age_data[len].full_condition_soc);
+		}
+#endif
+	} else {
+		battery->pdata->num_age_step = 0;
+		pr_err("%s: [Long life]  there is not age_data\n", __func__);
+	}
+#endif
+
+	ret = of_property_read_u32(np, "battery,siop_event_check_type",
+			&pdata->siop_event_check_type);
+	ret = of_property_read_u32(np, "battery,siop_call_cc_current",
+			&pdata->siop_call_cc_current);
+	ret = of_property_read_u32(np, "battery,siop_call_cv_current",
+			&pdata->siop_call_cv_current);
+
+	ret = of_property_read_u32(np, "battery,siop_input_limit_current",
+			&pdata->siop_input_limit_current);
+	if (ret)
+		pdata->siop_input_limit_current = SIOP_INPUT_LIMIT_CURRENT;
+
+	ret = of_property_read_u32(np, "battery,siop_charging_limit_current",
+			&pdata->siop_charging_limit_current);
+	if (ret)
+		pdata->siop_charging_limit_current = SIOP_CHARGING_LIMIT_CURRENT;
+
+	ret = of_property_read_u32(np, "battery,siop_hv_12v_input_limit_current",
+			&pdata->siop_hv_12v_input_limit_current);
+	if (ret)
+		pdata->siop_hv_12v_input_limit_current = SIOP_HV_12V_INPUT_LIMIT_CURRENT;
+
+	ret = of_property_read_u32(np, "battery,siop_hv_12v_charging_limit_current",
+			&pdata->siop_hv_12v_charging_limit_current);
+	if (ret)
+		pdata->siop_hv_12v_charging_limit_current = SIOP_HV_12V_CHARGING_LIMIT_CURRENT;
+
+	ret = of_property_read_u32(np, "battery,siop_hv_input_limit_current",
+			&pdata->siop_hv_input_limit_current);
+	if (ret)
+		pdata->siop_hv_input_limit_current = SIOP_HV_INPUT_LIMIT_CURRENT;
+
+	ret = of_property_read_u32(np, "battery,siop_hv_charging_limit_current",
+			&pdata->siop_hv_charging_limit_current);
+	if (ret)
+		pdata->siop_hv_charging_limit_current = SIOP_HV_CHARGING_LIMIT_CURRENT;
+
+	ret = of_property_read_u32(np, "battery,siop_wireless_input_limit_current",
+			&pdata->siop_wireless_input_limit_current);
+	if (ret)
+		pdata->siop_wireless_input_limit_current = SIOP_WIRELESS_INPUT_LIMIT_CURRENT;
+
+	ret = of_property_read_u32(np, "battery,siop_wireless_charging_limit_current",
+			&pdata->siop_wireless_charging_limit_current);
+	if (ret)
+		pdata->siop_wireless_charging_limit_current = SIOP_WIRELESS_CHARGING_LIMIT_CURRENT;
+
+	ret = of_property_read_u32(np, "battery,siop_hv_wireless_input_limit_current",
+			&pdata->siop_hv_wireless_input_limit_current);
+	if (ret)
+		pdata->siop_hv_wireless_input_limit_current = SIOP_HV_WIRELESS_INPUT_LIMIT_CURRENT;
+
+	ret = of_property_read_u32(np, "battery,siop_hv_wireless_charging_limit_current",
+			&pdata->siop_hv_wireless_charging_limit_current);
+	if (ret)
+		pdata->siop_hv_wireless_charging_limit_current = SIOP_HV_WIRELESS_CHARGING_LIMIT_CURRENT;
+
+	ret = of_property_read_u32(np, "battery,minimum_charging_current_by_siop_0", &pdata->minimum_charging_current_by_siop_0);
+	if (ret) {
+		pr_info("%s : minimum_charging_current_by_siop_0 is Empty\n", __func__);
+		pdata->minimum_charging_current_by_siop_0 = 0;
+	}
+
+	ret = of_property_read_u32(np, "battery,max_input_voltage",
+			&pdata->max_input_voltage);
+	if (ret)
+		pdata->max_input_voltage = 12000;
+
+	ret = of_property_read_u32(np, "battery,max_input_current",
+			&pdata->max_input_current);
+	if (ret)
+		pdata->max_input_current = 3000;
+
+	pr_info("%s: vendor : %s, technology : %d, cable_check_type : %d\n"
+		"cable_source_type : %d, event_waiting_time : %d\n"
+		"polling_type : %d, initial_count : %d, check_count : %d\n"
+		"check_adc_max : %d, check_adc_min : %d\n"
+		"ovp_uvlo_check_type : %d, thermal_source : %d, chg_thermal_source : %d\n"
+		"temp_check_type : %d, temp_check_count : %d\n"
+		"chg_heating_prevention_method : %d\n",
+		__func__,
+		pdata->vendor, pdata->technology,pdata->cable_check_type,
+		pdata->cable_source_type, pdata->event_waiting_time,
+		pdata->polling_type, pdata->monitor_initial_count,
+		pdata->check_count, pdata->check_adc_max, pdata->check_adc_min,
+		pdata->ovp_uvlo_check_type, pdata->thermal_source, pdata->chg_thermal_source,
+		pdata->temp_check_type, pdata->temp_check_count,
+		pdata->chg_heating_prevention_method);
+
+	ret = of_property_read_u32(np, "battery,prepare_afc_delay",
+			&battery->prepare_afc_delay);
+	if (ret)
+		battery->prepare_afc_delay = 500;
+
+#if defined(CONFIG_STEP_CHARGING)
+	sec_step_charging_init(battery, dev);
+#else
+	ret = of_property_read_u32(np, "battery,base_charge_power",
+			&battery->base_charge_power);
+	if (ret)
+		battery->base_charge_power = 10000;
+
+	ret = of_property_read_u32(np, "battery,max_charging_current",
+			&pdata->max_charging_current);
+	if (ret)
+		pdata->max_charging_current = 
+			pdata->charging_current[POWER_SUPPLY_TYPE_MAINS].fast_charging_current;
+#endif
+	ret = of_property_read_u32(np, "battery,pd_current_efficiency",
+			&battery->pd_current_efficiency);
+	if (ret)
+		battery->pd_current_efficiency = 90;
+
+#if defined(CONFIG_BATTERY_CISD)
+	ret = of_property_read_u32(np, "battery,cisd_max_voltage_thr",
+        &pdata->max_voltage_thr);
+    if (ret) {
+        pr_info("%s : cisd_max_voltage_thr is Empty\n", __func__);
+        pdata->max_voltage_thr = 4400;
+    }
+
+	ret = of_property_read_string(np,
+		"battery,cisd_data_efs_path", (char const **)&pdata->cisd_data_efs_path);
+	if (ret) {
+		pr_info("%s: cisd_data_efs_path is Empty.\n", __func__);
+	}
+#endif
+	return 0;
+}
+#endif
+
+#if !defined(CONFIG_MUIC_NOTIFIER)
+static void cable_initial_check(struct sec_battery_info *battery)
+{
+	union power_supply_propval value;
+
+	pr_info("%s : current_cable_type : (%d)\n", __func__, battery->cable_type);
+
+	if (POWER_SUPPLY_TYPE_BATTERY !=  battery->cable_type) {
+		if (battery->cable_type == POWER_SUPPLY_TYPE_POWER_SHARING) {
+			value.intval =  battery->cable_type;
+			psy_do_property("ps", set,
+					POWER_SUPPLY_PROP_ONLINE, value);
+		} else {
+			value.intval =  battery->cable_type;
+			psy_do_property("battery", set,
+					POWER_SUPPLY_PROP_ONLINE, value);
+		}
+	} else {
+		psy_do_property(battery->pdata->charger_name, get,
+				POWER_SUPPLY_PROP_ONLINE, value);
+		if (value.intval == POWER_SUPPLY_TYPE_WIRELESS) {
+			value.intval = 1;
+			psy_do_property("wireless", set,
+				POWER_SUPPLY_PROP_ONLINE, value);
+		}
+	}
+}
+#endif
+
+static void sec_bat_init_chg_work(struct work_struct *work)
+{
+	struct sec_battery_info *battery = container_of(work,
+				struct sec_battery_info, init_chg_work.work);
+
+	if (battery->cable_type == POWER_SUPPLY_TYPE_BATTERY &&
+		!(battery->misc_event & BATT_MISC_EVENT_UNDEFINED_RANGE_TYPE)) {
+		pr_info("%s: disable charging\n", __func__);
+		sec_bat_set_charge(battery, SEC_BAT_CHG_MODE_CHARGING_OFF);
+	}
+}
+
+static int sec_battery_probe(struct platform_device *pdev)
+{
+	sec_battery_platform_data_t *pdata = NULL;
+	struct sec_battery_info *battery;
+	int ret = 0;
+#ifndef CONFIG_OF
+	int i;
+#endif
+
+	union power_supply_propval value = {0, };
+
+	dev_dbg(&pdev->dev,
+		"%s: SEC Battery Driver Loading\n", __func__);
+
+	battery = kzalloc(sizeof(*battery), GFP_KERNEL);
+	if (!battery)
+		return -ENOMEM;
+
+	if (pdev->dev.of_node) {
+		pdata = devm_kzalloc(&pdev->dev,
+				sizeof(sec_battery_platform_data_t),
+				GFP_KERNEL);
+		if (!pdata) {
+			dev_err(&pdev->dev, "Failed to allocate memory\n");
+			ret = -ENOMEM;
+			goto err_bat_free;
+		}
+
+		battery->pdata = pdata;
+		if (sec_bat_parse_dt(&pdev->dev, battery)) {
+			dev_err(&pdev->dev,
+				"%s: Failed to get battery dt\n", __func__);
+			ret = -EINVAL;
+			goto err_bat_free;
+		}
+	} else {
+		pdata = dev_get_platdata(&pdev->dev);
+		battery->pdata = pdata;
+	}
+
+	platform_set_drvdata(pdev, battery);
+
+	battery->dev = &pdev->dev;
+
+	mutex_init(&battery->adclock);
+	mutex_init(&battery->iolock);
+	mutex_init(&battery->misclock);
+	mutex_init(&battery->batt_handlelock);
+	mutex_init(&battery->current_eventlock);
+
+	dev_dbg(battery->dev, "%s: ADC init\n", __func__);
+
+#ifdef CONFIG_OF
+	adc_init(pdev, battery);
+#else
+	for (i = 0; i < SEC_BAT_ADC_CHANNEL_NUM; i++)
+		adc_init(pdev, pdata, i);
+#endif
+	wake_lock_init(&battery->monitor_wake_lock, WAKE_LOCK_SUSPEND,
+		       "sec-battery-monitor");
+	wake_lock_init(&battery->cable_wake_lock, WAKE_LOCK_SUSPEND,
+		       "sec-battery-cable");
+	wake_lock_init(&battery->vbus_wake_lock, WAKE_LOCK_SUSPEND,
+		       "sec-battery-vbus");
+	wake_lock_init(&battery->afc_wake_lock, WAKE_LOCK_SUSPEND,
+		       "sec-battery-afc");
+	wake_lock_init(&battery->siop_wake_lock, WAKE_LOCK_SUSPEND,
+		       "sec-battery-siop");
+	wake_lock_init(&battery->siop_level_wake_lock, WAKE_LOCK_SUSPEND,
+			"sec-battery-siop_level");
+	wake_lock_init(&battery->siop_event_wake_lock, WAKE_LOCK_SUSPEND,
+			"sec-battery-siop_event");
+	wake_lock_init(&battery->wc_headroom_wake_lock, WAKE_LOCK_SUSPEND,
+			"sec-battery-wc_headroom");
+#if defined(CONFIG_UPDATE_BATTERY_DATA)
+	wake_lock_init(&battery->batt_data_wake_lock, WAKE_LOCK_SUSPEND,
+			"sec-battery-update-data");
+#endif
+
+	/* initialization of battery info */
+	sec_bat_set_charging_status(battery,
+			POWER_SUPPLY_STATUS_DISCHARGING);
+	battery->health = POWER_SUPPLY_HEALTH_GOOD;
+	battery->present = true;
+	battery->is_jig_on = false;
+	battery->wdt_kick_disable = 0;
+
+	battery->polling_count = 1;	/* initial value = 1 */
+	battery->polling_time = pdata->polling_time[
+		SEC_BATTERY_POLLING_TIME_DISCHARGING];
+	battery->polling_in_sleep = false;
+	battery->polling_short = false;
+
+	battery->check_count = 0;
+	battery->check_adc_count = 0;
+	battery->check_adc_value = 0;
+
+	battery->input_current = 0;
+	battery->charging_current = 0;
+	battery->topoff_current = 0;
+	battery->wpc_vout_level = WIRELESS_VOUT_9V;
+	battery->charging_start_time = 0;
+	battery->charging_passed_time = 0;
+	battery->wc_heating_start_time = 0;
+	battery->wc_heating_passed_time = 0;
+	battery->charging_next_time = 0;
+	battery->charging_fullcharged_time = 0;
+	battery->siop_level = 100;
+	battery->siop_event = 0;
+	battery->wc_enable = 1;
+	battery->wc_enable_cnt = 0;
+	battery->wc_enable_cnt_value = 3;
+#if defined(CONFIG_SAMSUNG_BATTERY_ENG_TEST)
+	battery->stability_test = 0;
+	battery->eng_not_full_status = 0;
+#endif
+	battery->ps_enable = false;
+	battery->wc_status = SEC_WIRELESS_PAD_NONE;
+	battery->wc_cv_mode = false;
+	battery->wire_status = POWER_SUPPLY_TYPE_BATTERY;
+
+#if defined(CONFIG_BATTERY_SWELLING)
+	battery->swelling_mode = SWELLING_MODE_NONE;
+#endif
+	battery->charging_block = true;
+	battery->chg_limit = false;
+	battery->mix_limit = false;
+	battery->usb_temp = 0;
+
+	sec_bat_set_current_event(battery, SEC_BAT_CURRENT_EVENT_USB_100MA, 0);
+
+	battery->temp_highlimit_threshold =
+		pdata->temp_highlimit_threshold_normal;
+	battery->temp_highlimit_recovery =
+		pdata->temp_highlimit_recovery_normal;
+	battery->temp_high_threshold =
+		pdata->temp_high_threshold_normal;
+	battery->temp_high_recovery =
+		pdata->temp_high_recovery_normal;
+	battery->temp_low_recovery =
+		pdata->temp_low_recovery_normal;
+	battery->temp_low_threshold =
+		pdata->temp_low_threshold_normal;
+
+	battery->charging_mode = SEC_BATTERY_CHARGING_NONE;
+	battery->is_recharging = false;
+	battery->cable_type = POWER_SUPPLY_TYPE_BATTERY;
+	battery->test_mode = 0;
+	battery->factory_mode = false;
+	battery->store_mode = false;
+	battery->slate_mode = false;
+	battery->is_hc_usb = false;
+	battery->pdic_attach = false;
+	battery->pdic_ps_rdy = false;
+	battery->rp_attach = false;
+
+	battery->safety_timer_set = true;
+	battery->stop_timer = false;
+	battery->prev_safety_time = 0;
+	battery->lcd_status = false;
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	battery->batt_cycle = -1;
+	battery->pdata->age_step = 0;
+#endif
+
+	battery->health_change = false;
+#if defined(CONFIG_DCM_JPN_CONCEPT_FG_CYCLE_CHECK)
+	battery->fg_cycle_check_value = 2000;
+#endif
+
+#if 0
+	if (charging_night_mode == 49)
+		sleep_mode = true;
+	else
+		sleep_mode = false;
+#endif
+
+	/* Check High Voltage charging option for wired charging */
+	if (get_afc_mode() == CH_MODE_AFC_DISABLE_VAL) {
+		pr_info("HV wired charging mode is disabled\n");
+		sec_bat_set_current_event(battery,
+			SEC_BAT_CURRENT_EVENT_HV_DISABLE, 0);
+	}
+
+	if (battery->pdata->charger_name == NULL)
+		battery->pdata->charger_name = "sec-charger";
+	if (battery->pdata->fuelgauge_name == NULL)
+		battery->pdata->fuelgauge_name = "sec-fuelgauge";
+
+	battery->psy_bat.name = "battery",
+	battery->psy_bat.type = POWER_SUPPLY_TYPE_BATTERY,
+	battery->psy_bat.properties = sec_battery_props,
+	battery->psy_bat.num_properties = ARRAY_SIZE(sec_battery_props),
+	battery->psy_bat.get_property = sec_bat_get_property,
+	battery->psy_bat.set_property = sec_bat_set_property,
+	battery->psy_usb.name = "usb",
+	battery->psy_usb.type = POWER_SUPPLY_TYPE_USB,
+	battery->psy_usb.supplied_to = supply_list,
+	battery->psy_usb.num_supplicants = ARRAY_SIZE(supply_list),
+	battery->psy_usb.properties = sec_power_props,
+	battery->psy_usb.num_properties = ARRAY_SIZE(sec_power_props),
+	battery->psy_usb.get_property = sec_usb_get_property,
+	battery->psy_ac.name = "ac",
+	battery->psy_ac.type = POWER_SUPPLY_TYPE_MAINS,
+	battery->psy_ac.supplied_to = supply_list,
+	battery->psy_ac.num_supplicants = ARRAY_SIZE(supply_list),
+	battery->psy_ac.properties = sec_ac_props,
+	battery->psy_ac.num_properties = ARRAY_SIZE(sec_ac_props),
+	battery->psy_ac.get_property = sec_ac_get_property;
+	battery->psy_wireless.name = "wireless",
+	battery->psy_wireless.type = POWER_SUPPLY_TYPE_WIRELESS,
+	battery->psy_wireless.supplied_to = supply_list,
+	battery->psy_wireless.num_supplicants = ARRAY_SIZE(supply_list),
+	battery->psy_wireless.properties = sec_wireless_props,
+	battery->psy_wireless.num_properties = ARRAY_SIZE(sec_wireless_props),
+	battery->psy_wireless.get_property = sec_wireless_get_property;
+	battery->psy_wireless.set_property = sec_wireless_set_property;
+	battery->psy_ps.name = "ps",
+	battery->psy_ps.type = POWER_SUPPLY_TYPE_POWER_SHARING,
+	battery->psy_ps.supplied_to = supply_list,
+	battery->psy_ps.num_supplicants = ARRAY_SIZE(supply_list),
+	battery->psy_ps.properties = sec_ps_props,
+	battery->psy_ps.num_properties = ARRAY_SIZE(sec_ps_props),
+	battery->psy_ps.get_property = sec_ps_get_property;
+	battery->psy_ps.set_property = sec_ps_set_property;
+#if defined(CONFIG_USE_POGO)
+	battery->psy_pogo.name = "pogo";
+	battery->psy_pogo.type = POWER_SUPPLY_TYPE_POGO;
+	battery->psy_pogo.supplied_to = supply_list;
+	battery->psy_pogo.num_supplicants = ARRAY_SIZE(supply_list);
+	battery->psy_pogo.properties = sec_power_props;
+	battery->psy_pogo.num_properties = ARRAY_SIZE(sec_power_props);
+	battery->psy_pogo.get_property = sec_pogo_get_property;
+	battery->psy_pogo.set_property = sec_pogo_set_property;
+#endif
+
+#if !defined(CONFIG_SAMSUNG_BATTERY_ENG_TEST) && !defined(CONFIG_SEC_FACTORY)
+	battery->block_water_event = !(get_switch_sel() & SWITCH_SEL_RUSTPROOF_MASK) ? 0 : 1;
+	pr_info("%s: init block_water_event = %d\n", __func__, battery->block_water_event);
+#endif
+
+	/* create work queue */
+	battery->monitor_wqueue =
+		create_singlethread_workqueue(dev_name(&pdev->dev));
+	if (!battery->monitor_wqueue) {
+		dev_err(battery->dev,
+			"%s: Fail to Create Workqueue\n", __func__);
+		goto err_irq;
+	}
+
+	INIT_DELAYED_WORK(&battery->monitor_work, sec_bat_monitor_work);
+	INIT_DELAYED_WORK(&battery->cable_work, sec_bat_cable_work);
+#if defined(CONFIG_CALC_TIME_TO_FULL)
+	INIT_DELAYED_WORK(&battery->timetofull_work, sec_bat_time_to_full_work);
+#endif
+#if defined(CONFIG_ENABLE_100MA_CHARGING_BEFORE_USB_CONFIGURED)
+	INIT_DELAYED_WORK(&battery->slowcharging_work, sec_bat_check_slowcharging_work);
+#endif
+	INIT_DELAYED_WORK(&battery->afc_work, sec_bat_afc_work);
+	INIT_DELAYED_WORK(&battery->siop_work, sec_bat_siop_work);
+	INIT_DELAYED_WORK(&battery->siop_event_work, sec_bat_siop_event_work);
+	INIT_DELAYED_WORK(&battery->siop_level_work, sec_bat_siop_level_work);
+	INIT_DELAYED_WORK(&battery->wc_headroom_work, sec_bat_wc_headroom_work);
+#if defined(CONFIG_WIRELESS_FIRMWARE_UPDATE)
+	INIT_DELAYED_WORK(&battery->fw_init_work, sec_bat_fw_init_work);
+#endif
+#if defined(CONFIG_UPDATE_BATTERY_DATA)
+	INIT_DELAYED_WORK(&battery->batt_data_work, sec_bat_update_data_work);
+#endif
+	INIT_DELAYED_WORK(&battery->init_chg_work, sec_bat_init_chg_work);
+
+	switch (pdata->polling_type) {
+	case SEC_BATTERY_MONITOR_WORKQUEUE:
+		INIT_DELAYED_WORK(&battery->polling_work,
+			sec_bat_polling_work);
+		break;
+	case SEC_BATTERY_MONITOR_ALARM:
+		battery->last_poll_time = ktime_get_boottime();
+		alarm_init(&battery->polling_alarm, ALARM_BOOTTIME,
+			sec_bat_alarm);
+		break;
+	default:
+		break;
+	}
+
+#if defined(CONFIG_BATTERY_CISD)
+	sec_battery_cisd_init(battery);
+#endif
+
+#if defined(CONFIG_USE_POGO)
+	ret = power_supply_register(&pdev->dev, &battery->psy_pogo);
+	if (ret) {
+		dev_err(battery->dev,
+				"%s: Failed to Register psy_pogo\n", __func__);
+		goto err_supply_unreg_pogo;
+	}
+#endif
+
+	/* init power supplier framework */
+	ret = power_supply_register(&pdev->dev, &battery->psy_ps);
+	if (ret) {
+		dev_err(battery->dev,
+			"%s: Failed to Register psy_ps\n", __func__);
+		goto err_workqueue;
+	}
+
+	ret = power_supply_register(&pdev->dev, &battery->psy_wireless);
+	if (ret) {
+		dev_err(battery->dev,
+			"%s: Failed to Register psy_wireless\n", __func__);
+		goto err_supply_unreg_ps;
+	}
+
+	ret = power_supply_register(&pdev->dev, &battery->psy_usb);
+	if (ret) {
+		dev_err(battery->dev,
+			"%s: Failed to Register psy_usb\n", __func__);
+		goto err_supply_unreg_wireless;
+	}
+
+	ret = power_supply_register(&pdev->dev, &battery->psy_ac);
+	if (ret) {
+		dev_err(battery->dev,
+			"%s: Failed to Register psy_ac\n", __func__);
+		goto err_supply_unreg_usb;
+	}
+
+	ret = power_supply_register(&pdev->dev, &battery->psy_bat);
+	if (ret) {
+		dev_err(battery->dev,
+			"%s: Failed to Register psy_bat\n", __func__);
+		goto err_supply_unreg_ac;
+	}
+
+	if (battery->pdata->bat_irq_gpio > 0) {
+		battery->pdata->bat_irq = gpio_to_irq(battery->pdata->bat_irq_gpio);
+		dev_info(battery->dev,
+					"%s: irq = %d\n", __func__, battery->pdata->bat_irq);
+		if (battery->pdata->bat_irq > 0) {
+			ret = request_threaded_irq(battery->pdata->bat_irq,
+				NULL, sec_bat_irq_thread,
+				battery->pdata->bat_irq_attr
+				| IRQF_ONESHOT,
+				"battery-irq", battery);
+			if (ret) {
+				dev_err(battery->dev, "%s: Failed to Request IRQ (bat_int)\n", __func__);
+				goto err_supply_unreg_bat;
+			}
+
+			ret = enable_irq_wake(battery->pdata->bat_irq);
+			if (ret < 0)
+				dev_err(battery->dev,
+					"%s: Failed to Enable Wakeup Source(%d)(bat_int)\n",
+					__func__, ret);
+		}
+	}
+
+	ret = sec_bat_create_attrs(battery->psy_bat.dev);
+	if (ret) {
+		dev_err(battery->dev,
+			"%s : Failed to create_attrs\n", __func__);
+		goto err_req_irq;
+	}
+
+	/* initialize battery level*/
+	value.intval = 0;
+	psy_do_property(battery->pdata->fuelgauge_name, get,
+			POWER_SUPPLY_PROP_CAPACITY, value);
+	battery->capacity = value.intval;
+
+#if defined(CONFIG_WIRELESS_FIRMWARE_UPDATE)
+	/* queue_delayed_work(battery->monitor_wqueue, &battery->fw_init_work, 0); */
+#endif
+
+	value.intval = 0;
+	psy_do_property(battery->pdata->wireless_charger_name, set,
+					POWER_SUPPLY_PROP_CHARGE_TYPE, value);
+
+#if defined(CONFIG_STORE_MODE) && !defined(CONFIG_SEC_FACTORY)
+	battery->store_mode = true;
+#endif
+
+#if defined(CONFIG_USB_TYPEC_MANAGER_NOTIFIER)
+	battery->pdic_info.sink_status.rp_currentlvl = RP_CURRENT_LEVEL_NONE;
+	manager_notifier_register(&battery->usb_typec_nb,
+		usb_typec_handle_notification, MANAGER_NOTIFY_CCIC_BATTERY);
+#else
+#if defined(CONFIG_MUIC_NOTIFIER)
+	muic_notifier_register(&battery->batt_nb,
+	       batt_handle_notification, MUIC_NOTIFY_DEV_CHARGER);
+#else
+	cable_initial_check(battery);
+#endif
+#if defined(CONFIG_CCIC_NOTIFIER)
+	pr_info("%s: Registering PDIC_NOTIFY.\n", __func__);
+	pdic_notifier_register(&battery->pdic_nb,
+		batt_pdic_handle_notification, PDIC_NOTIFY_DEV_BATTERY);
+#endif
+#endif
+#if defined(CONFIG_VBUS_NOTIFIER)
+	vbus_notifier_register(&battery->vbus_nb,
+		vbus_handle_notification, VBUS_NOTIFY_DEV_CHARGER);
+#endif
+
+	value.intval = true;
+	psy_do_property(battery->pdata->charger_name, set,
+		POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX, value);
+
+	if ((battery->cable_type == POWER_SUPPLY_TYPE_BATTERY) ||
+			(battery->cable_type == POWER_SUPPLY_TYPE_HV_PREPARE_MAINS)) {
+		queue_delayed_work(battery->monitor_wqueue, &battery->init_chg_work, 0);
+
+		dev_info(&pdev->dev,
+				"%s: SEC Battery Driver Monitorwork\n", __func__);
+		wake_lock(&battery->monitor_wake_lock);
+		queue_delayed_work(battery->monitor_wqueue, &battery->monitor_work, 0);
+	}
+
+	if (battery->pdata->check_battery_callback)
+		battery->present = battery->pdata->check_battery_callback();
+
+	dev_info(battery->dev,
+		"%s: SEC Battery Driver Loaded\n", __func__);
+	return 0;
+
+err_req_irq:
+	if (battery->pdata->bat_irq)
+		free_irq(battery->pdata->bat_irq, battery);
+err_supply_unreg_bat:
+	power_supply_unregister(&battery->psy_bat);
+err_supply_unreg_ac:
+	power_supply_unregister(&battery->psy_ac);
+err_supply_unreg_usb:
+	power_supply_unregister(&battery->psy_usb);
+err_supply_unreg_wireless:
+	power_supply_unregister(&battery->psy_wireless);
+err_supply_unreg_ps:
+	power_supply_unregister(&battery->psy_ps);
+#if defined(CONFIG_USE_POGO)
+err_supply_unreg_pogo:
+	power_supply_unregister(&battery->psy_pogo);
+#endif
+err_workqueue:
+	destroy_workqueue(battery->monitor_wqueue);
+err_irq:
+	wake_lock_destroy(&battery->monitor_wake_lock);
+	wake_lock_destroy(&battery->cable_wake_lock);
+	wake_lock_destroy(&battery->vbus_wake_lock);
+	wake_lock_destroy(&battery->afc_wake_lock);
+	wake_lock_destroy(&battery->siop_wake_lock);
+	wake_lock_destroy(&battery->siop_level_wake_lock);
+	wake_lock_destroy(&battery->siop_event_wake_lock);
+	wake_lock_destroy(&battery->wc_headroom_wake_lock);
+#if defined(CONFIG_UPDATE_BATTERY_DATA)
+	wake_lock_destroy(&battery->batt_data_wake_lock);
+#endif
+	mutex_destroy(&battery->adclock);
+	mutex_destroy(&battery->iolock);
+	mutex_destroy(&battery->misclock);
+	mutex_destroy(&battery->batt_handlelock);
+	mutex_destroy(&battery->current_eventlock);
+	kfree(pdata);
+err_bat_free:
+	kfree(battery);
+
+	return ret;
+}
+
+static int __devexit sec_battery_remove(struct platform_device *pdev)
+{
+	struct sec_battery_info *battery = platform_get_drvdata(pdev);
+#ifndef CONFIG_OF
+	int i;
+#endif
+
+	dev_dbg(battery->dev, "%s: Start\n", __func__);
+
+	switch (battery->pdata->polling_type) {
+	case SEC_BATTERY_MONITOR_WORKQUEUE:
+		cancel_delayed_work(&battery->polling_work);
+		break;
+	case SEC_BATTERY_MONITOR_ALARM:
+		alarm_cancel(&battery->polling_alarm);
+		break;
+	default:
+		break;
+	}
+
+	flush_workqueue(battery->monitor_wqueue);
+	destroy_workqueue(battery->monitor_wqueue);
+	wake_lock_destroy(&battery->monitor_wake_lock);
+	wake_lock_destroy(&battery->cable_wake_lock);
+	wake_lock_destroy(&battery->vbus_wake_lock);
+	wake_lock_destroy(&battery->afc_wake_lock);
+	wake_lock_destroy(&battery->siop_wake_lock);
+	wake_lock_destroy(&battery->siop_level_wake_lock);
+	wake_lock_destroy(&battery->siop_event_wake_lock);
+	mutex_destroy(&battery->adclock);
+	mutex_destroy(&battery->iolock);
+	mutex_destroy(&battery->misclock);
+	mutex_destroy(&battery->batt_handlelock);
+	mutex_destroy(&battery->current_eventlock);
+#ifdef CONFIG_OF
+	adc_exit(battery);
+#else
+	for (i = 0; i < SEC_BAT_ADC_CHANNEL_NUM; i++)
+		adc_exit(battery->pdata, i);
+#endif
+	power_supply_unregister(&battery->psy_ps);
+	power_supply_unregister(&battery->psy_wireless);
+	power_supply_unregister(&battery->psy_ac);
+	power_supply_unregister(&battery->psy_usb);
+	power_supply_unregister(&battery->psy_bat);
+
+	dev_dbg(battery->dev, "%s: End\n", __func__);
+	kfree(battery);
+
+	return 0;
+}
+
+static int sec_battery_prepare(struct device *dev)
+{
+	struct sec_battery_info *battery
+		= dev_get_drvdata(dev);
+
+	dev_dbg(battery->dev, "%s: Start\n", __func__);
+
+	switch (battery->pdata->polling_type) {
+	case SEC_BATTERY_MONITOR_WORKQUEUE:
+		cancel_delayed_work(&battery->polling_work);
+		break;
+	case SEC_BATTERY_MONITOR_ALARM:
+		alarm_cancel(&battery->polling_alarm);
+		break;
+	default:
+		break;
+	}
+	cancel_delayed_work_sync(&battery->monitor_work);
+
+	battery->polling_in_sleep = true;
+
+	sec_bat_set_polling(battery);
+
+	/* cancel work for polling
+	 * that is set in sec_bat_set_polling()
+	 * no need for polling in sleep
+	 */
+	if (battery->pdata->polling_type ==
+		SEC_BATTERY_MONITOR_WORKQUEUE)
+		cancel_delayed_work(&battery->polling_work);
+
+	dev_dbg(battery->dev, "%s: End\n", __func__);
+
+	return 0;
+}
+
+static int sec_battery_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int sec_battery_resume(struct device *dev)
+{
+	return 0;
+}
+
+static void sec_battery_complete(struct device *dev)
+{
+	struct sec_battery_info *battery
+		= dev_get_drvdata(dev);
+
+	dev_dbg(battery->dev, "%s: Start\n", __func__);
+
+	/* cancel current alarm and reset after monitor work */
+	if (battery->pdata->polling_type == SEC_BATTERY_MONITOR_ALARM)
+		alarm_cancel(&battery->polling_alarm);
+
+	wake_lock(&battery->monitor_wake_lock);
+	queue_delayed_work(battery->monitor_wqueue,
+		&battery->monitor_work, 0);
+
+	dev_dbg(battery->dev, "%s: End\n", __func__);
+
+	return;
+}
+
+static void sec_battery_shutdown(struct device *dev)
+{
+	struct sec_battery_info *battery
+		= dev_get_drvdata(dev);
+
+	switch (battery->pdata->polling_type) {
+	case SEC_BATTERY_MONITOR_WORKQUEUE:
+		cancel_delayed_work(&battery->polling_work);
+		break;
+	case SEC_BATTERY_MONITOR_ALARM:
+		alarm_cancel(&battery->polling_alarm);
+		break;
+	default:
+		break;
+	}
+}
+
+#ifdef CONFIG_OF
+static struct of_device_id sec_battery_dt_ids[] = {
+	{ .compatible = "samsung,sec-battery" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, sec_battery_dt_ids);
+#endif /* CONFIG_OF */
+
+static const struct dev_pm_ops sec_battery_pm_ops = {
+	.prepare = sec_battery_prepare,
+	.suspend = sec_battery_suspend,
+	.resume = sec_battery_resume,
+	.complete = sec_battery_complete,
+};
+
+static struct platform_driver sec_battery_driver = {
+	.driver = {
+		   .name = "sec-battery",
+		   .owner = THIS_MODULE,
+		   .pm = &sec_battery_pm_ops,
+		   .shutdown = sec_battery_shutdown,
+#ifdef CONFIG_OF
+		.of_match_table = sec_battery_dt_ids,
+#endif
+	},
+	.probe = sec_battery_probe,
+	.remove = sec_battery_remove,
+};
+
+static int __init sec_battery_init(void)
+{
+	return platform_driver_register(&sec_battery_driver);
+}
+
+static void __exit sec_battery_exit(void)
+{
+	platform_driver_unregister(&sec_battery_driver);
+}
+
+late_initcall(sec_battery_init);
+module_exit(sec_battery_exit);
+
+MODULE_DESCRIPTION("Samsung Battery Driver");
+MODULE_AUTHOR("Samsung Electronics");
+MODULE_LICENSE("GPL");
diff -Naur linux-3.18.14/drivers/battery_v2/sec_battery_data.c samsung/drivers/battery_v2/sec_battery_data.c
--- linux-3.18.14/drivers/battery_v2/sec_battery_data.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/sec_battery_data.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,435 @@
+/*
+ *  sec_battery_data.c
+ *  Samsung Mobile Battery Driver
+ *
+ *  Copyright (C) 2012 Samsung Electronics
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/of.h>
+#include <linux/power_supply.h>
+
+enum battery_data_type {
+	BATTERY_DATA_TYPE_NONE = 0,
+	BATTERY_DATA_TYPE_INFO,
+	BATTERY_DATA_TYPE_VALUE,
+	BATTERY_DATA_TYPE_STRING,
+};
+
+enum battery_data_flag {
+	BATTERY_DATA_FLAG_NONE = 0,
+	BATTERY_DATA_FLAG_ADD,
+	BATTERY_DATA_FLAG_REMOVE,
+	BATTERY_DATA_FLAG_EDIT,
+};
+
+#define CHECK_ERROR_DATA(logical_test, return_value, error_value, action) { \
+	if (logical_test) { \
+		return_value = error_value; \
+		pr_err("%s: error!!! (ret = %d)\n", __func__, error_value); \
+		action; \
+	} else { \
+		return_value = 0; \
+	} \
+}
+
+#define NODE_NAME_SIZE		32
+#define PROPERTY_SIZE		68
+#define MAX_VALUE_SIZE		(5 * 1024)
+
+struct battery_data_info {
+	int version;
+	int hw_rev;
+	int prop_count;
+	int value_length;
+};
+
+struct battery_data {
+	unsigned int type;
+	unsigned int flag;
+	char node_name[NODE_NAME_SIZE];
+	char property[PROPERTY_SIZE];
+	unsigned int length;
+};
+
+struct battery_property {
+	struct property *property;
+	unsigned int type;
+	unsigned int flag;
+	char *new_value;
+	char *old_value;
+	int new_length;
+	int old_length;
+	struct battery_property *next;
+};
+
+struct battery_node {
+	char name[NODE_NAME_SIZE];
+	struct device_node *np;
+	struct battery_node *next;
+	struct battery_property *start_prop;
+};
+
+static struct battery_node *get_battery_node(
+					struct battery_node **start_node, char *name)
+{
+	struct battery_node *batt_node = NULL;
+	struct battery_node *temp_node = NULL;
+
+	if (name == NULL) {
+		pr_err("%s: name is invalid!!\n", __func__);
+		return NULL;
+	}
+
+	batt_node = *start_node;
+	while (batt_node) {
+		if (!strcmp(batt_node->name, name)) {
+			return batt_node;
+		} else {
+			temp_node = batt_node;
+			batt_node = batt_node->next;
+		}
+	}
+
+	batt_node = kzalloc(sizeof(struct battery_node), GFP_KERNEL);
+	if (!batt_node) {
+		pr_err("%s: nomem!!\n", __func__);
+		return NULL;
+	}
+	batt_node->np = of_find_node_by_name(NULL, name);
+	if (IS_ERR_OR_NULL(batt_node->np)) {
+		pr_err("%s: failed to find node(name=%s)\n", __func__, name);
+		kfree(batt_node);
+		return NULL;
+	}
+	strcpy(batt_node->name, name);
+	if (temp_node)
+		temp_node->next = batt_node;
+	batt_node->start_prop = NULL;
+	if (*start_node == NULL) *start_node = batt_node;
+	pr_info("%s: add battery_node(name = %s)\n", __func__, name);
+	return batt_node;
+}
+
+static int add_battery_property(	struct battery_node *batt_node,
+									struct battery_property *batt_prop)
+{
+	struct battery_property *start_prop = NULL;
+	struct battery_property *temp_prop = NULL;
+
+	if (!batt_node || !batt_prop) {
+		return -ENODATA;
+	}
+
+	start_prop = batt_node->start_prop;
+	while (start_prop) {
+		if (!strcmp(start_prop->property->name, batt_prop->property->name)) {
+			return 0;
+		} else {
+			temp_prop = start_prop;
+			start_prop = start_prop->next;
+		}
+	}
+
+	if (!temp_prop)
+		batt_node->start_prop = batt_prop;
+	else {
+		temp_prop->next = batt_prop;
+	}
+	return 0;
+}
+
+static void change_battery_pdata(
+				struct battery_node *start_node, bool is_valid)
+{
+	struct battery_node *temp_node = NULL;
+
+	temp_node = start_node;
+	pr_info("%s: start update(%d)\n", __func__, is_valid);
+	while (is_valid && temp_node) {
+		struct battery_property *batt_prop = NULL;
+		struct power_supply *psy = NULL;
+		union power_supply_propval value;
+		
+		batt_prop = temp_node->start_prop;
+		while (batt_prop) {
+			if (batt_prop->flag != BATTERY_DATA_FLAG_REMOVE) {
+				batt_prop->property->value = batt_prop->new_value;
+				batt_prop->property->length = batt_prop->new_length;
+			}
+			batt_prop = batt_prop->next;
+		}
+		
+		psy = power_supply_get_by_name(start_node->name);
+		if (psy) {
+			value.intval = 0;
+			psy->set_property(psy, POWER_SUPPLY_PROP_POWER_DESIGN, &value);
+		}
+
+		temp_node = temp_node->next;
+	}
+
+	pr_info("%s: release battery pdata\n", __func__);
+	while (start_node) {
+		struct battery_property *temp_batt_prop = NULL;
+		struct battery_property *batt_prop = NULL;
+
+		batt_prop = start_node->start_prop;
+		while (batt_prop) {
+			switch (batt_prop->flag) {
+			case BATTERY_DATA_FLAG_REMOVE:
+				pr_debug("%s: re-set property(ret=%d, flag=%d, name=%s)\n",
+					__func__, of_add_property(start_node->np, batt_prop->property),
+					batt_prop->flag, batt_prop->property->name);
+				break;
+			case BATTERY_DATA_FLAG_EDIT:
+				pr_debug("%s: re-set property(type=%d, flag=%d, name=%s)\n",
+					__func__, batt_prop->type,
+					batt_prop->flag, batt_prop->property->name);
+				if (!is_valid) {
+					kfree(batt_prop->new_value);
+				} else {
+					/* In normal case, String type should not free. */
+					if (batt_prop->type != BATTERY_DATA_TYPE_STRING) {
+						batt_prop->property->value = batt_prop->old_value;
+						batt_prop->property->length = batt_prop->old_length;
+						kfree(batt_prop->new_value);
+					}
+				}
+				break;
+			case BATTERY_DATA_FLAG_ADD:
+				pr_debug("%s: re-set property(ret=%d, flag=%d, name=%s)\n",
+					__func__, of_remove_property(start_node->np, batt_prop->property),
+					batt_prop->flag, batt_prop->property->name);
+				if (batt_prop->new_value &&	(!is_valid || batt_prop->type != BATTERY_DATA_TYPE_STRING)) {
+					kfree(batt_prop->new_value);
+				}
+				kfree(batt_prop->property->name);
+				kfree(batt_prop->property);
+				break;
+			}
+
+			temp_batt_prop = batt_prop;
+			batt_prop = batt_prop->next;
+			kfree(temp_batt_prop);
+		}
+
+		temp_node = start_node;
+		start_node = start_node->next;
+		kfree(temp_node);
+	}
+}
+
+static int sec_battery_check_info(struct file *fp,
+						struct battery_data_info *batt_info)
+{
+	struct device_node *np;
+	struct battery_data batt_data;
+	int dt_version, hw_rev, hw_rev_end;
+	int ret = 0, read_size;
+
+	read_size = fp->f_op->read(fp, (char*)&batt_data, sizeof(struct battery_data), &fp->f_pos);
+	CHECK_ERROR_DATA((read_size <= 0), ret, (-ENODATA), goto finish_check_info);
+	CHECK_ERROR_DATA((batt_data.type != BATTERY_DATA_TYPE_INFO), ret, (-EINVAL), goto finish_check_info);
+
+	read_size = fp->f_op->read(fp, (char*)batt_info, sizeof(struct battery_data_info), &fp->f_pos);
+	CHECK_ERROR_DATA((read_size <= 0 || read_size != batt_data.length), ret, (-ENODATA), goto finish_check_info);
+	CHECK_ERROR_DATA(
+		(batt_info->version < 0 || batt_info->hw_rev < 0 || batt_info->prop_count <= 0) ||
+		(batt_info->value_length < 0 || batt_info->value_length > MAX_VALUE_SIZE),
+		ret, (-EINVAL), goto finish_check_info);
+
+	np = of_find_node_by_name(NULL, batt_data.node_name);
+	ret = of_property_read_u32(np, "battery,batt_data_version", &dt_version);
+	if (ret) {
+		pr_info("%s : batt_data_version is Empty\n", __func__);
+		dt_version = 0;
+	}
+
+	np = of_find_all_nodes(NULL);
+	ret = of_property_read_u32(np, "model_info-hw_rev", &hw_rev);
+	if (ret) {
+		pr_info("%s: model_info-hw_rev is Empty\n", __func__);
+		hw_rev = 0;
+	}
+	ret = of_property_read_u32(np, "model_info-hw_rev_end", &hw_rev_end);
+	if (ret) {
+		pr_info("%s: model_info-hw_rev_end is Empty\n", __func__);
+		hw_rev_end = 99;
+	}
+
+	ret = (batt_info->version < dt_version) ? -1 :
+		((batt_info->hw_rev > hw_rev_end || batt_info->hw_rev < hw_rev) ? -2 : 0);
+
+	pr_info("%s: check info(ret=%d), version(%d <-> %d), hw_rev(%d ~ %d <-> %d), prop_count(%d), value_length(%d)\n",
+		__func__, ret,
+		dt_version, batt_info->version,
+		hw_rev, hw_rev_end, batt_info->hw_rev,
+		batt_info->prop_count, batt_info->value_length);
+
+finish_check_info:
+	return ret;
+}
+
+static int sec_battery_check_none(struct file *fp)
+{
+	struct battery_data batt_data;
+	int ret = 0, read_size;
+
+	read_size = fp->f_op->read(fp, (char*)&batt_data, sizeof(struct battery_data), &fp->f_pos);
+	CHECK_ERROR_DATA((read_size <= 0), ret, (-ENODATA), goto finish_check_none);
+
+	if (batt_data.type != BATTERY_DATA_TYPE_NONE) {
+		pr_info("%s: invalid type(%d)\n", __func__, batt_data.type);
+		ret = -EINVAL;
+	}
+
+finish_check_none:
+	return ret;
+}
+
+static char *sec_battery_check_value(struct file *fp,
+			struct battery_data_info *batt_info, struct battery_data *batt_data)
+{
+	char *temp_buf = NULL;
+	int read_size;
+
+	if (batt_data->length < 0 || batt_data->length > batt_info->value_length) {
+		pr_info("%s: length(%d) of data is invalid\n", __func__, batt_data->length);
+		return NULL;
+	} else if (batt_data->length == 0) {
+		pr_info("%s: skip alloc buffer(length=%d)\n", __func__, batt_data->length);
+		return NULL;
+	}
+
+	temp_buf = kzalloc(batt_data->length, GFP_KERNEL);
+	if (temp_buf) {
+		read_size = fp->f_op->read(fp, temp_buf, batt_data->length, &fp->f_pos);
+		if (read_size <= 0) {
+			pr_info("%s: failed to read value\n", __func__);
+			kfree(temp_buf);
+			temp_buf = NULL;
+		}
+	}
+
+	return temp_buf;
+}
+
+int sec_battery_update_data(const char* file_path)
+{
+	struct battery_node *batt_node = NULL;
+	struct battery_node *temp_node = NULL;
+	struct property *batt_property = NULL;
+	struct battery_data_info batt_info;
+	struct battery_property *batt_prop;
+	struct battery_data batt_data;
+	struct file* fp = NULL;
+	char *temp_buf = NULL;
+	int length, read_size;
+	int ret = 0;
+
+	fp = filp_open(file_path, O_RDONLY, 0);
+	CHECK_ERROR_DATA(IS_ERR(fp), ret, (int)(PTR_ERR(fp)), goto err_filp_open);
+
+	ret = sec_battery_check_info(fp, &batt_info);
+	CHECK_ERROR_DATA((ret), ret, (-EINVAL), goto skip_check_data);
+
+	while (batt_info.prop_count-- > 0) {
+		read_size = fp->f_op->read(fp, (char*)&batt_data, sizeof(struct battery_data), &fp->f_pos);
+		CHECK_ERROR_DATA((read_size <= 0), ret, (-ENODATA), goto finish_update_data);
+		pr_debug("%s: read batt_data(type=%d, flag=%d, node_name=%s, property=%s, length=%d)\n",
+			__func__, batt_data.type, batt_data.flag, batt_data.node_name, batt_data.property, batt_data.length);
+
+		temp_node = get_battery_node(&batt_node, batt_data.node_name);
+		CHECK_ERROR_DATA((!temp_node), ret, (-ENODEV), goto finish_update_data);
+
+		batt_prop = kzalloc(sizeof(struct battery_property), GFP_KERNEL);
+		CHECK_ERROR_DATA((!batt_prop), ret, (-ENOMEM), goto finish_update_data);
+
+		batt_property = of_find_property(temp_node->np, batt_data.property, &length);
+		switch (batt_data.flag) {
+		case BATTERY_DATA_FLAG_ADD:
+			if (IS_ERR_OR_NULL(batt_property)) {
+				temp_buf = sec_battery_check_value(fp, &batt_info, &batt_data);
+				CHECK_ERROR_DATA((!temp_buf && batt_data.length != 0), ret, (-ENOMEM),
+					{kfree(batt_prop); goto finish_update_data;});
+
+				batt_property = kzalloc(sizeof(struct property), GFP_KERNEL);
+				CHECK_ERROR_DATA((!batt_property), ret, (-ENOMEM),
+					{kfree(batt_prop); kfree(temp_buf); goto finish_update_data;});
+
+				batt_property->name = kzalloc(PROPERTY_SIZE, GFP_KERNEL);
+				CHECK_ERROR_DATA((!batt_property->name), ret, (-ENOMEM),
+					{kfree(batt_prop); kfree(temp_buf); kfree(batt_property); goto finish_update_data;});
+
+				memcpy(batt_property->name, batt_data.property, PROPERTY_SIZE);
+				ret = of_add_property(temp_node->np, batt_property);
+				CHECK_ERROR_DATA((ret), ret, ret,
+					{kfree(batt_prop); kfree(temp_buf); kfree(batt_property->name); kfree(batt_property); goto finish_update_data;});
+			} else {
+				pr_info("%s: invalid data(name=%s, property=%s, flag=%d)\n",
+					__func__, batt_data.node_name, batt_data.property, batt_data.flag);
+				ret = -EINVAL;
+				kfree(batt_prop);
+				goto finish_update_data;
+			}
+			break;
+		case BATTERY_DATA_FLAG_EDIT:
+			if (!IS_ERR_OR_NULL(batt_property)) {
+				temp_buf = sec_battery_check_value(fp, &batt_info, &batt_data);
+				CHECK_ERROR_DATA((!temp_buf), ret, (-ENOMEM),
+					{kfree(batt_prop); goto finish_update_data;});
+			} else {
+				pr_info("%s: invalid data(name=%s, property=%s, flag=%d)\n",
+					__func__, batt_data.node_name, batt_data.property, batt_data.flag);
+				ret = -EINVAL;
+				kfree(batt_prop);
+				goto finish_update_data;
+			}
+			break;
+		case BATTERY_DATA_FLAG_REMOVE:
+			if (!IS_ERR_OR_NULL(batt_property)) {
+				temp_buf = NULL;
+
+				ret = of_remove_property(temp_node->np, batt_property);
+				CHECK_ERROR_DATA((ret), ret, ret, {kfree(batt_prop); goto finish_update_data;});
+			} else {
+				pr_info("%s: invalid data(name=%s, property=%s, flag=%d)\n",
+					__func__, batt_data.node_name, batt_data.property, batt_data.flag);
+				ret = -EINVAL;
+				kfree(batt_prop);
+				goto finish_update_data;
+			}
+			break;
+		default:
+			pr_info("%s: invalid flag(%d)\n", __func__, batt_data.flag);
+			ret = -EINVAL;
+			kfree(batt_prop);
+			goto finish_update_data;
+		}
+
+		batt_prop->property = batt_property;
+		batt_prop->type = batt_data.type;
+		batt_prop->flag = batt_data.flag;
+		batt_prop->new_value = temp_buf;
+		batt_prop->old_value = batt_property->value;
+		batt_prop->new_length = batt_data.length;
+		batt_prop->old_length = batt_property->length;
+		add_battery_property(temp_node, batt_prop);
+	}
+	ret = sec_battery_check_none(fp);
+
+finish_update_data:
+	change_battery_pdata(batt_node, (ret == 0));
+skip_check_data:
+	filp_close(fp, NULL);
+err_filp_open:
+	return ret;
+}
diff -Naur linux-3.18.14/drivers/battery_v2/sec_cisd.c samsung/drivers/battery_v2/sec_cisd.c
--- linux-3.18.14/drivers/battery_v2/sec_cisd.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/sec_cisd.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,328 @@
+/*
+ *  sec_cisd.c
+ *  Samsung Mobile Battery Driver
+ *
+ *  Copyright (C) 2012 Samsung Electronics
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include "include/sec_battery.h"
+#include "include/sec_cisd.h"
+
+#if defined(CONFIG_SEC_ABC)
+#include <linux/sti/abc_common.h>
+#endif
+
+bool sec_bat_cisd_check(struct sec_battery_info *battery)
+{
+	union power_supply_propval incur_val = {0, };
+	union power_supply_propval chgcur_val = {0, };
+	union power_supply_propval capcurr_val = {0, };
+	union power_supply_propval vbat_val = {0, };
+	struct cisd *pcisd = &battery->cisd;
+	struct timespec now_ts;
+	bool ret = false;
+	static int prev_fullcap_rep;
+
+	if (battery->factory_mode || battery->is_jig_on) {
+		dev_dbg(battery->dev, "%s: No need to check in factory mode\n",
+			__func__);
+		return ret;
+	}
+
+	if ((battery->status == POWER_SUPPLY_STATUS_CHARGING) ||
+		(battery->status == POWER_SUPPLY_STATUS_FULL)) {
+		/* charging */
+		/* check abnormal vbat */
+		pcisd->ab_vbat_check_count = battery->voltage_now > pcisd->max_voltage_thr ?
+				pcisd->ab_vbat_check_count + 1 : 0;
+		
+		if ((pcisd->ab_vbat_check_count >= pcisd->ab_vbat_max_count) &&
+			!(pcisd->state & CISD_STATE_OVER_VOLTAGE)) {
+			dev_info(battery->dev, "%s : [CISD] Battery Over Voltage Protction !! vbat(%d)mV\n",
+				 __func__, battery->voltage_now);
+			vbat_val.intval = true;
+			psy_do_property("battery", set, POWER_SUPPLY_EXT_PROP_VBAT_OVP,
+					vbat_val);
+			pcisd->data[CISD_DATA_OVER_VOLTAGE]++;
+			pcisd->state |= CISD_STATE_OVER_VOLTAGE;
+#if defined(CONFIG_SEC_ABC)
+			sec_abc_send_event("MODULE=battery@ERROR=over_voltage");
+#endif
+		}
+
+		/* get actual input current */
+		psy_do_property(battery->pdata->charger_name, get,
+			POWER_SUPPLY_PROP_CURRENT_AVG, incur_val);
+
+		/* get actual charging current */
+		psy_do_property(battery->pdata->charger_name, get,
+			POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT, chgcur_val);
+
+		dev_info(battery->dev, "%s: [CISD] iavg: %d, incur: %d, chgcur: %d,\n"
+			"cc_T: %ld, lcd_off_T: %ld, passed_T: %ld, full_T: %ld, chg_end_T: %ld, cisd: 0x%x\n",__func__,
+			battery->current_avg, incur_val.intval, chgcur_val.intval,
+			pcisd->cc_start_time, pcisd->lcd_off_start_time, battery->charging_passed_time,
+			battery->charging_fullcharged_time, pcisd->charging_end_time, pcisd->state);
+
+		if (is_cisd_check_type(battery->cable_type) && incur_val.intval > pcisd->current_max_thres &&
+			chgcur_val.intval > pcisd->charging_current_thres && battery->current_now > 0 &&
+			battery->siop_level == 100 && battery->charging_mode == SEC_BATTERY_CHARGING_1ST) {
+			/* Not entered to Full after latest lcd off charging even though 270 min passed */
+			if (pcisd->lcd_off_start_time <= 0) {
+				pcisd->lcd_off_start_time = battery->charging_passed_time;
+			}
+
+			/* Not entered to Full with charging current greater than latest 1000mA even though 60 min passed */
+			if (battery->current_avg < pcisd->current_avg_thres && pcisd->cc_start_time <= 0) {
+				pcisd->cc_start_time = battery->charging_passed_time;
+			} else if (battery->current_avg >= 1000 && pcisd->cc_start_time) {
+				pcisd->state &= ~CISD_STATE_LEAK_B;
+				pcisd->cc_start_time = 0;
+			}
+		} else {
+			pcisd->state &= ~CISD_STATE_LEAK_A;
+			pcisd->state &= ~CISD_STATE_LEAK_B;
+			pcisd->cc_start_time = 0;
+			pcisd->lcd_off_start_time = 0;
+		}
+
+		if (is_cisd_check_type(battery->cable_type) && battery->siop_level == 100 &&
+			battery->current_now > 0 && battery->charging_mode == SEC_BATTERY_CHARGING_2ND) {
+			if (pcisd->full_start_time <= 0) {
+				pcisd->full_start_time = battery->charging_passed_time;
+			}
+		} else {
+			pcisd->state &= ~CISD_STATE_LEAK_C;
+			pcisd->full_start_time = 0;
+		}
+
+		if (is_cisd_check_type(battery->cable_type) && battery->siop_level == 100 &&
+			battery->current_now >= 0 && ((battery->status == POWER_SUPPLY_STATUS_FULL &&
+		    battery->charging_mode == SEC_BATTERY_CHARGING_NONE) || battery->is_recharging)) {
+			now_ts = ktime_to_timespec(ktime_get_boottime());
+			dev_info(battery->dev, "%s: cisd - leakage D Test(now time = %ld)\n", __func__, ((unsigned long)now_ts.tv_sec));
+			if (pcisd->charging_end_time <= 0)
+				pcisd->charging_end_time = now_ts.tv_sec;
+		} else {
+			pcisd->state &= ~CISD_STATE_LEAK_D;
+			pcisd->recharge_count = 0;
+			pcisd->charging_end_time = 0;
+		}
+
+		if (battery->siop_level != 100 ||
+			battery->current_now < 0 || (battery->status != POWER_SUPPLY_STATUS_FULL)) {
+			pcisd->state &= ~(CISD_STATE_LEAK_E|CISD_STATE_LEAK_F|CISD_STATE_LEAK_G);
+			dev_info(battery->dev, "%s: cisd - clear EFG\n", __func__);
+			pcisd->recharge_count_2 = 0;
+			pcisd->charging_end_time_2 = 0;
+		}
+
+		now_ts = ktime_to_timespec(ktime_get_boottime());
+		/* check cisd leak case */
+		if ((!(pcisd->state & CISD_STATE_LEAK_A) && !(pcisd->state & CISD_STATE_LEAK_B)) &&
+			pcisd->lcd_off_start_time &&
+			battery->charging_passed_time - pcisd->lcd_off_start_time > pcisd->lcd_off_delay_time) {
+			pcisd->state |= CISD_STATE_LEAK_A;
+			pcisd->data[CISD_DATA_LEAKAGE_A]++;
+		} else if (!(pcisd->state & CISD_STATE_LEAK_B) && pcisd->cc_start_time &&
+			battery->charging_passed_time - pcisd->cc_start_time > pcisd->cc_delay_time) {
+			pcisd->state |= CISD_STATE_LEAK_B;
+			pcisd->data[CISD_DATA_LEAKAGE_B]++;
+		} else if (!(pcisd->state & CISD_STATE_LEAK_C) && pcisd->full_start_time &&
+			battery->charging_passed_time - pcisd->full_start_time > pcisd->full_delay_time) {
+			pcisd->state |= CISD_STATE_LEAK_C;
+			pcisd->data[CISD_DATA_LEAKAGE_C]++;
+		} else if (!(pcisd->state & CISD_STATE_LEAK_D) && pcisd->recharge_count >= pcisd->recharge_count_thres) {
+			dev_info(battery->dev, "%s: cisd - leakage D Test(now time = %ld)\n", __func__, ((unsigned long)now_ts.tv_sec));
+			if ((unsigned long)now_ts.tv_sec - pcisd->charging_end_time <= pcisd->recharge_delay_time) {
+				pcisd->state |= CISD_STATE_LEAK_D;
+				pcisd->data[CISD_DATA_LEAKAGE_D]++;
+			}
+		}
+		
+		if (!(pcisd->state & (CISD_STATE_LEAK_E|CISD_STATE_LEAK_F|CISD_STATE_LEAK_G))
+			&& pcisd->charging_end_time_2 > 0 && pcisd->recharge_count_2 > 0) {
+			if ((unsigned long)now_ts.tv_sec - pcisd->charging_end_time_2 <= pcisd->leakage_e_time) {
+				dev_info(battery->dev, "%s: cisd - leakage E Test(now time = %ld)\n", __func__, ((unsigned long)now_ts.tv_sec));
+				pcisd->state |= CISD_STATE_LEAK_E;
+				pcisd->data[CISD_DATA_LEAKAGE_E]++;
+				pcisd->recharge_count_2 = 0;
+				pcisd->charging_end_time_2 = 0;
+			} else if ((unsigned long)now_ts.tv_sec - pcisd->charging_end_time_2 <= pcisd->leakage_f_time) {
+				dev_info(battery->dev, "%s: cisd - leakage F Test(now time = %ld)\n", __func__, ((unsigned long)now_ts.tv_sec));
+				pcisd->state |= CISD_STATE_LEAK_F;
+				pcisd->data[CISD_DATA_LEAKAGE_F]++;
+				pcisd->recharge_count_2 = 0;
+				pcisd->charging_end_time_2 = 0;
+			} else if ((unsigned long)now_ts.tv_sec - pcisd->charging_end_time_2 <= pcisd->leakage_g_time) {
+				dev_info(battery->dev, "%s: cisd - leakage G Test(now time = %ld)\n", __func__, ((unsigned long)now_ts.tv_sec));
+				pcisd->state |= CISD_STATE_LEAK_G;
+				pcisd->data[CISD_DATA_LEAKAGE_G]++;
+				pcisd->recharge_count_2 = 0;
+				pcisd->charging_end_time_2 = 0;
+			}
+		}
+
+		dev_info(battery->dev, "%s: [CISD] iavg: %d, incur: %d, chgcur: %d,\n"
+			"cc_T: %ld, lcd_off_T: %ld, passed_T: %ld, full_T: %ld, chg_end_T: %ld, recnt: %d, cisd: 0x%x\n",__func__,
+			battery->current_avg, incur_val.intval, chgcur_val.intval,
+			pcisd->cc_start_time, pcisd->lcd_off_start_time, battery->charging_passed_time,
+			battery->charging_fullcharged_time, pcisd->charging_end_time, pcisd->recharge_count, pcisd->state);
+
+		pcisd->state &= ~CISD_STATE_CAP_OVERFLOW;
+
+		capcurr_val.intval = SEC_BATTERY_CAPACITY_CURRENT;
+		psy_do_property(battery->pdata->fuelgauge_name, get,
+			POWER_SUPPLY_PROP_ENERGY_NOW, capcurr_val);
+
+		if (capcurr_val.intval >= pcisd->capacity_now && capcurr_val.intval > pcisd->overflow_cap_thr &&
+			pcisd->overflow_start_time <= 0) {
+			now_ts = ktime_to_timespec(ktime_get_boottime());
+			pcisd->overflow_start_time = now_ts.tv_sec;
+		}
+	} else  {
+		/* discharging */
+		if (battery->status == POWER_SUPPLY_STATUS_NOT_CHARGING) {
+			/* check abnormal vbat */
+			pcisd->ab_vbat_check_count = battery->voltage_now > pcisd->max_voltage_thr ?
+				pcisd->ab_vbat_check_count + 1 : 0;
+
+			if ((pcisd->ab_vbat_check_count >= pcisd->ab_vbat_max_count) &&
+					!(pcisd->state & CISD_STATE_OVER_VOLTAGE)) {
+				pcisd->data[CISD_DATA_OVER_VOLTAGE]++;
+				pcisd->state |= CISD_STATE_OVER_VOLTAGE;
+#if defined(CONFIG_SEC_ABC)
+				sec_abc_send_event("MODULE=battery@ERROR=over_voltage");
+#endif
+			}
+		}
+
+		pcisd->state &= ~(CISD_STATE_LEAK_A|CISD_STATE_LEAK_B|CISD_STATE_LEAK_C|CISD_STATE_LEAK_D|CISD_STATE_LEAK_E|CISD_STATE_LEAK_F|CISD_STATE_LEAK_G);
+
+		now_ts = ktime_to_timespec(ktime_get_boottime());
+		capcurr_val.intval = SEC_BATTERY_CAPACITY_FULL;
+		psy_do_property(battery->pdata->fuelgauge_name, get,
+			POWER_SUPPLY_PROP_ENERGY_NOW, capcurr_val);
+		if (capcurr_val.intval == -1) {
+			dev_info(battery->dev, "%s: [CISD] FG I2C fail. skip cisd check \n", __func__);
+			return ret;
+		}
+
+		if (!(pcisd->state & CISD_STATE_CAP_OVERFLOW) &&
+			(capcurr_val.intval != prev_fullcap_rep)) {
+			if (capcurr_val.intval > pcisd->err_cap_high_thr) {
+				pcisd->state |= CISD_STATE_CAP_OVERFLOW;
+				pcisd->data[CISD_DATA_ERRCAP_HIGH] += 1;
+				prev_fullcap_rep = capcurr_val.intval;
+			} else if (capcurr_val.intval > pcisd->err_cap_low_thr) {
+				pcisd->state |= CISD_STATE_CAP_OVERFLOW;
+				pcisd->data[CISD_DATA_ERRCAP_LOW] += 1;
+				prev_fullcap_rep = capcurr_val.intval;
+			}
+		}
+
+		if (pcisd->overflow_start_time > 0 && capcurr_val.intval > pcisd->overflow_cap_thr) {
+			if ((capcurr_val.intval - pcisd->overflow_cap_thr) * 3600 /
+				(now_ts.tv_sec - pcisd->overflow_start_time) > pcisd->data[CISD_DATA_CAP_PER_TIME])
+				pcisd->data[CISD_DATA_CAP_PER_TIME] = (capcurr_val.intval - pcisd->overflow_cap_thr) * 3600 /
+					(now_ts.tv_sec - pcisd->overflow_start_time);
+		}
+
+		pcisd->data[CISD_DATA_CAP_ONCE] = capcurr_val.intval > pcisd->data[CISD_DATA_CAP_ONCE] ?
+			capcurr_val.intval : pcisd->data[CISD_DATA_CAP_ONCE];
+		pcisd->capacity_now = capcurr_val.intval;
+		pcisd->overflow_cap_thr = capcurr_val.intval > 3850 ? capcurr_val.intval : 3850;
+		pcisd->overflow_start_time = 0;
+
+		if (capcurr_val.intval > pcisd->data[CISD_DATA_CAP_MAX])
+			pcisd->data[CISD_DATA_CAP_MAX] = capcurr_val.intval;
+		if (capcurr_val.intval < pcisd->data[CISD_DATA_CAP_MIN])
+			pcisd->data[CISD_DATA_CAP_MIN] = capcurr_val.intval;
+	}
+
+	pr_info("cisd - stt:%d, cp:%d/%d, cpmm:%d/%d/%d, dcpt:%d, ovc:%d, rct:%d\n",
+		pcisd->state, pcisd->curr_cap_max, pcisd->err_cap_max_thrs, pcisd->data[CISD_DATA_CAP_MIN],
+		pcisd->capacity_now, pcisd->data[CISD_DATA_CAP_MAX], pcisd->data[CISD_DATA_CAP_PER_TIME],
+		pcisd->data[CISD_DATA_OVER_VOLTAGE], pcisd->data[CISD_DATA_RECHARGING_TIME]);
+
+
+	pr_info("cisd_debug: %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d\n",
+		pcisd->data[CISD_DATA_FULL_COUNT], pcisd->data[CISD_DATA_CAP_MAX],
+		pcisd->data[CISD_DATA_CAP_MIN], pcisd->data[CISD_DATA_CAP_ONCE],
+		pcisd->data[CISD_DATA_LEAKAGE_A], pcisd->data[CISD_DATA_LEAKAGE_B],
+		pcisd->data[CISD_DATA_LEAKAGE_C], pcisd->data[CISD_DATA_LEAKAGE_D],
+		pcisd->data[CISD_DATA_CAP_PER_TIME], pcisd->data[CISD_DATA_ERRCAP_LOW],
+		pcisd->data[CISD_DATA_ERRCAP_HIGH], pcisd->data[CISD_DATA_OVER_VOLTAGE],
+		pcisd->data[CISD_DATA_LEAKAGE_E], pcisd->data[CISD_DATA_LEAKAGE_F],
+		pcisd->data[CISD_DATA_LEAKAGE_G], pcisd->data[CISD_DATA_RECHARGING_TIME],
+		pcisd->data[CISD_DATA_VALERT_COUNT], pcisd->cisd_alg_index);
+	return ret;
+}
+
+void sec_battery_cisd_init(struct sec_battery_info *battery)
+{
+	union power_supply_propval capfull_val;
+
+	battery->cisd.state = CISD_STATE_NONE;
+
+	battery->cisd.delay_time = 600; /* 10 min */
+	battery->cisd.diff_volt_now = 40;
+	battery->cisd.diff_cap_now = 5;
+
+	capfull_val.intval = SEC_BATTERY_CAPACITY_FULL;
+	psy_do_property(battery->pdata->fuelgauge_name, get,
+		POWER_SUPPLY_PROP_ENERGY_NOW, capfull_val);
+	battery->cisd.curr_cap_max = capfull_val.intval;
+	battery->cisd.err_cap_high_thr = 4500;
+	battery->cisd.err_cap_low_thr = 4000;
+	battery->cisd.cc_delay_time = 3600; /* 60 min */
+	battery->cisd.lcd_off_delay_time = 13800; /* 230 min */
+	battery->cisd.full_delay_time = 3600; /* 60 min */
+	battery->cisd.recharge_delay_time = 9000; /* 150 min */
+	battery->cisd.cc_start_time = 0;
+	battery->cisd.full_start_time = 0;
+	battery->cisd.lcd_off_start_time = 0;
+	battery->cisd.overflow_start_time = 0;
+	battery->cisd.charging_end_time = 0;
+	battery->cisd.charging_end_time_2 = 0;
+	battery->cisd.recharge_count = 0;
+	battery->cisd.recharge_count_2 = 0;
+	battery->cisd.recharge_count_thres = 2;
+	battery->cisd.leakage_e_time = 3600; /* 60 min */
+	battery->cisd.leakage_f_time = 7200; /* 120 min */
+	battery->cisd.leakage_g_time = 14400; /* 240 min */
+	battery->cisd.current_max_thres = 900;
+	battery->cisd.charging_current_thres = 1000;
+	battery->cisd.current_avg_thres = 1000;
+
+	battery->cisd.data[CISD_DATA_FULL_COUNT] = 1;
+	battery->cisd.data[CISD_DATA_CAP_MIN] = 0xFFFF;
+	battery->cisd.data[CISD_DATA_RECHARGING_TIME] = 0x7FFFFFFF;
+	battery->cisd.data[CISD_DATA_CAP_ONCE] = 0;
+	battery->cisd.data[CISD_DATA_CAP_PER_TIME] = 0;
+	battery->cisd.data[CISD_DATA_BATT_TEMP_MAX] = -300;
+	battery->cisd.data[CISD_DATA_CHG_TEMP_MAX] = -300;
+	battery->cisd.data[CISD_DATA_WPC_TEMP_MAX] = -300;
+	battery->cisd.data[CISD_DATA_BATT_TEMP_MIN] = 1000;
+	battery->cisd.data[CISD_DATA_CHG_TEMP_MIN] = 1000;
+	battery->cisd.data[CISD_DATA_WPC_TEMP_MIN] = 1000;
+	pr_info("%s: BAT_THM:%d/%d, CHG_THM:%d/%d, WPC_THM:%d/%d\n", __func__,
+		battery->cisd.data[CISD_DATA_BATT_TEMP_MAX],
+		battery->cisd.data[CISD_DATA_BATT_TEMP_MIN],
+		battery->cisd.data[CISD_DATA_CHG_TEMP_MAX],
+		battery->cisd.data[CISD_DATA_CHG_TEMP_MIN],
+		battery->cisd.data[CISD_DATA_WPC_TEMP_MAX],
+		battery->cisd.data[CISD_DATA_WPC_TEMP_MIN]);
+
+	battery->cisd.capacity_now = capfull_val.intval;
+	battery->cisd.overflow_cap_thr = capfull_val.intval > 3850 ? capfull_val.intval : 3850;
+
+	battery->cisd.ab_vbat_max_count = 5;
+	battery->cisd.ab_vbat_check_count = 0;
+	battery->cisd.max_voltage_thr = battery->pdata->max_voltage_thr;
+	battery->cisd.cisd_alg_index = 1;
+}
diff -Naur linux-3.18.14/drivers/battery_v2/sec_multi_charger.c samsung/drivers/battery_v2/sec_multi_charger.c
--- linux-3.18.14/drivers/battery_v2/sec_multi_charger.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/sec_multi_charger.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,781 @@
+/*
+ *  sec_multi_charger.c
+ *  Samsung Mobile Charger Driver
+ *
+ *  Copyright (C) 2015 Samsung Electronics
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#define DEBUG
+
+#include "include/sec_multi_charger.h"
+
+static enum power_supply_property sec_multi_charger_props[] = {
+};
+
+static bool sec_multi_chg_check_sub_charging(struct sec_multi_charger_info *charger)
+{
+	union power_supply_propval value;
+
+	if (!charger->pdata->sub_charger_condition) {
+		pr_info("%s: sub charger off(default)\n", __func__);
+		return false;
+	}
+
+	if (charger->pdata->sub_charger_condition &
+		SEC_SUB_CHARGER_CONDITION_CHARGE_POWER) {
+		psy_do_property(charger->pdata->battery_name, get, POWER_SUPPLY_PROP_POWER_NOW, value);
+		if (value.intval < charger->pdata->sub_charger_condition_charge_power) {
+			if (charger->sub_is_charging)
+				pr_info("%s: sub charger off CHARGE_POWER(%d)\n", __func__, value.intval);
+			return false;
+		}
+	}
+
+	if (charger->pdata->sub_charger_condition &
+		SEC_SUB_CHARGER_CONDITION_CURRENT_MAX) {
+		if (charger->total_current.input_current_limit < charger->pdata->sub_charger_condition_current_max) {
+			if (charger->sub_is_charging)
+				pr_info("%s: sub charger off CURRENT_MAX(%d)\n", __func__,
+					charger->total_current.input_current_limit);
+			return false;
+		}
+	}
+
+	if (charger->pdata->sub_charger_condition &
+		SEC_SUB_CHARGER_CONDITION_ONLINE) {
+		int i = 0;
+
+		for (i = 0; i < charger->pdata->sub_charger_condition_online_size; i++) {
+			if (charger->cable_type == charger->pdata->sub_charger_condition_online[i])
+				break;
+		}
+
+		if (i >= charger->pdata->sub_charger_condition_online_size) {
+			if (charger->sub_is_charging)
+				pr_info("%s: sub charger off ONLINE(%d)\n", __func__, i);
+			return false;
+		}
+	}
+
+	if (charger->pdata->sub_charger_condition &
+		SEC_SUB_CHARGER_CONDITION_CHARGE_DONE) {
+		if (charger->sub_is_charging) {
+			/* psy_do_property(charger->pdata->main_charger_name, get,
+				POWER_SUPPLY_PROP_STATUS, value);
+			if (value.intval == POWER_SUPPLY_STATUS_FULL) {
+				pr_info("%s: sub charger off CHARGE DONE by main charger\n", __func__);
+				return false;
+			} */
+			psy_do_property(charger->pdata->sub_charger_name, get,
+				POWER_SUPPLY_PROP_STATUS, value);
+			if (value.intval == POWER_SUPPLY_STATUS_FULL) {
+				pr_info("%s: sub charger off CHARGE DONE by sub charger\n", __func__);
+				return false;
+			}
+		}
+	}
+
+	if (charger->pdata->sub_charger_condition &
+		SEC_SUB_CHARGER_CONDITION_CV) {
+		psy_do_property(charger->pdata->main_charger_name, get,
+			POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE, value);
+
+		if (value.intval) {
+			if (charger->sub_is_charging)
+				pr_info("%s: sub charger off CV(%d)\n", __func__, value.intval);
+			return false;
+		}
+	}
+
+	if (charger->pdata->sub_charger_condition &
+		SEC_SUB_CHARGER_CONDITION_CURRENT_NOW) {
+		int max_current_now = (charger->total_current.fast_charging_current / 2) +
+			charger->total_current.full_check_current_1st + SEC_SUB_CHARGER_CURRENT_MARGIN;
+		pr_info("%s: update max_current_now(%d)\n", __func__, max_current_now);
+
+		psy_do_property(charger->pdata->battery_name, get,
+			POWER_SUPPLY_PROP_CURRENT_NOW, value);
+
+		if (value.intval < max_current_now) {
+			if (charger->sub_is_charging)
+				pr_info("%s: sub charger off CURRENT_NOW(%d)\n", __func__, value.intval);
+			return false;
+		} else if (value.intval < max_current_now + SEC_SUB_CHARGER_CURRENT_MARGIN) {
+			if (!charger->sub_is_charging) {
+				return false;
+			}
+		}
+	}
+
+	return true;
+}
+
+static int sec_multi_chg_set_input_current(struct sec_multi_charger_info *charger)
+{
+	union power_supply_propval value;
+	int main_input_current = charger->main_current.input_current_limit,
+		sub_input_current = charger->sub_current.input_current_limit;
+
+	if (!charger->pdata->is_serial && charger->sub_is_charging) {
+		main_input_current = charger->total_current.input_current_limit / 2;
+		sub_input_current = charger->total_current.input_current_limit / 2;
+
+		/* check current max */
+		value.intval = sub_input_current;
+		psy_do_property(charger->pdata->sub_charger_name, get,
+			POWER_SUPPLY_PROP_CURRENT_MAX, value);
+		if (value.intval != sub_input_current) {
+			main_input_current = charger->total_current.input_current_limit - value.intval;
+			sub_input_current = value.intval;
+		}
+	} else {
+		main_input_current = charger->total_current.input_current_limit;
+		sub_input_current = 0;
+	}
+
+	/* set input current */
+	if (main_input_current != charger->main_current.input_current_limit) {
+		charger->main_current.input_current_limit = main_input_current;
+		value.intval = main_input_current;
+		psy_do_property(charger->pdata->main_charger_name, set,
+			POWER_SUPPLY_PROP_CURRENT_MAX, value);
+
+		pr_info("%s: set input current - main(%dmA)\n", __func__, value.intval);
+	}
+	if (sub_input_current != charger->sub_current.input_current_limit) {
+		charger->sub_current.input_current_limit = sub_input_current;
+		value.intval = sub_input_current;
+		psy_do_property(charger->pdata->sub_charger_name, set,
+			POWER_SUPPLY_PROP_CURRENT_MAX, value);
+
+		pr_info("%s: set input current - sub(%dmA)\n", __func__, value.intval);
+	}
+
+	return 0;
+}
+
+static int sec_multi_chg_set_charging_current(struct sec_multi_charger_info *charger)
+{
+	union power_supply_propval value;
+	unsigned int main_charging_current = charger->main_current.fast_charging_current,
+		sub_charging_current = charger->sub_current.fast_charging_current;
+
+	if (charger->sub_is_charging) {
+		main_charging_current = charger->total_current.fast_charging_current / 2;
+		sub_charging_current = charger->total_current.fast_charging_current / 2;
+	} else {
+		main_charging_current = charger->total_current.fast_charging_current;
+		sub_charging_current = 0;
+	}
+
+	/* set charging current */
+	if (main_charging_current != charger->main_current.fast_charging_current) {
+		charger->main_current.fast_charging_current = main_charging_current;
+		value.intval = main_charging_current;
+		psy_do_property(charger->pdata->main_charger_name, set,
+			POWER_SUPPLY_PROP_CURRENT_NOW, value);
+
+		pr_info("%s: set charging current - main(%dmA)\n", __func__, value.intval);
+	}
+	if (sub_charging_current != charger->sub_current.fast_charging_current) {
+		charger->sub_current.fast_charging_current = sub_charging_current;
+		value.intval = sub_charging_current;
+		psy_do_property(charger->pdata->sub_charger_name, set,
+			POWER_SUPPLY_PROP_CURRENT_NOW, value);
+
+		pr_info("%s: set charging current - sub(%dmA)\n", __func__, value.intval);
+	}
+
+	return 0;
+}
+
+static bool sec_multi_chg_check_abnormal_case(struct sec_multi_charger_info *charger)
+{
+	union power_supply_propval value;
+	bool check_val = false;
+
+	/* check abnormal case */
+	psy_do_property(charger->pdata->sub_charger_name, get,
+		POWER_SUPPLY_EXT_PROP_CHECK_MULTI_CHARGE, value);
+
+	check_val = (value.intval != POWER_SUPPLY_STATUS_CHARGING && charger->sub_is_charging);
+	pr_info("%s: check abnormal case(check_val:%d, status:%d, sub_is_charging:%d)\n",
+		__func__, check_val, value.intval, charger->sub_is_charging);
+
+	return check_val;
+}
+
+static void sec_multi_chg_check_input_current(struct sec_multi_charger_info *charger)
+{
+	union power_supply_propval value;
+	bool sub_is_charging = charger->sub_is_charging;
+
+	if (!sub_is_charging || charger->cable_type == POWER_SUPPLY_TYPE_BATTERY) {
+		pr_info("%s: does not need that check input current when sub charger is off.", __func__);
+		return;
+	}
+
+	if (charger->pdata->sub_charger_condition &
+		SEC_SUB_CHARGER_CONDITION_CHARGE_POWER) {
+		psy_do_property(charger->pdata->battery_name, get, POWER_SUPPLY_PROP_POWER_NOW, value);
+		if (value.intval < charger->pdata->sub_charger_condition_charge_power) {
+			if (sub_is_charging)
+				pr_info("%s: sub charger off CHARGE_POWER(%d)\n", __func__, value.intval);
+			sub_is_charging = false;
+		}
+	}
+
+	if (charger->pdata->sub_charger_condition &
+		SEC_SUB_CHARGER_CONDITION_CURRENT_MAX) {
+		if (charger->total_current.input_current_limit < charger->pdata->sub_charger_condition_current_max) {
+			if (sub_is_charging)
+				pr_info("%s: sub charger off CURRENT_MAX(%d)\n", __func__,
+					charger->total_current.input_current_limit);
+			sub_is_charging = false;
+		}
+	}
+
+	if (!sub_is_charging || sec_multi_chg_check_abnormal_case(charger)) {
+		charger->sub_is_charging = sub_is_charging;
+
+		if (sub_is_charging)
+			value.intval = SEC_BAT_CHG_MODE_CHARGING;
+		else
+			value.intval = SEC_BAT_CHG_MODE_CHARGING_OFF;
+
+		psy_do_property(charger->pdata->sub_charger_name, set,
+			POWER_SUPPLY_PROP_CHARGING_ENABLED, value);
+
+		sec_multi_chg_set_charging_current(charger);
+	}
+}
+
+static int sec_multi_chg_check_enable(struct sec_multi_charger_info *charger)
+{
+	union power_supply_propval value;
+	bool sub_is_charging = charger->sub_is_charging;
+
+	if ((charger->cable_type == POWER_SUPPLY_TYPE_BATTERY) ||
+		(charger->status == POWER_SUPPLY_STATUS_DISCHARGING) ||
+		charger->chg_mode != SEC_BAT_CHG_MODE_CHARGING) {
+		pr_info("%s: skip multi charging routine\n", __func__);
+		return 0;
+	}
+
+	if (charger->multi_mode != SEC_MULTI_CHARGER_NORMAL) {
+		pr_info("%s: skip multi charging routine, because the multi_mode = %d\n", __func__, charger->multi_mode);
+		return 0;
+	}
+
+	/* check sub charging */
+	charger->sub_is_charging = sec_multi_chg_check_sub_charging(charger);
+
+	/* set sub charging */
+	if (charger->sub_is_charging != sub_is_charging) {
+		if (charger->sub_is_charging)
+			value.intval = SEC_BAT_CHG_MODE_CHARGING;
+		else
+			value.intval = SEC_BAT_CHG_MODE_CHARGING_OFF;
+
+		/* set charging current */
+		sec_multi_chg_set_input_current(charger);
+		sec_multi_chg_set_charging_current(charger);
+
+		psy_do_property(charger->pdata->sub_charger_name, set,
+			POWER_SUPPLY_PROP_CHARGING_ENABLED, value);
+
+		pr_info("%s: change sub_is_charging(%d)\n", __func__, charger->sub_is_charging);
+	} else if (charger->sub_is_charging && sec_multi_chg_check_abnormal_case(charger)) {
+		pr_info("%s: abnormal case, sub charger off\n ", __func__);
+
+		charger->sub_is_charging = false;
+
+		sec_multi_chg_set_input_current(charger);
+		sec_multi_chg_set_charging_current(charger);
+
+		value.intval = SEC_BAT_CHG_MODE_CHARGING_OFF;
+		psy_do_property(charger->pdata->sub_charger_name, set,
+			POWER_SUPPLY_PROP_CHARGING_ENABLED, value);
+	}
+	return 0;
+}
+
+static int sec_multi_chg_get_property(struct power_supply *psy,
+			    enum power_supply_property psp,
+			    union power_supply_propval *val)
+{
+	struct sec_multi_charger_info *charger =
+		container_of(psy, struct sec_multi_charger_info, psy_chg);
+	enum power_supply_ext_property ext_psp = psp;
+	union power_supply_propval value;
+
+	value.intval = val->intval;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_HEALTH:
+		psy_do_property(charger->pdata->battery_name, get,
+			POWER_SUPPLY_PROP_HEALTH, value);
+		if (charger->cable_type != POWER_SUPPLY_TYPE_BATTERY && 
+			value.intval != POWER_SUPPLY_HEALTH_UNDERVOLTAGE)
+			psy_do_property(charger->pdata->sub_charger_name, get, psp, value);
+	case POWER_SUPPLY_PROP_STATUS:
+	case POWER_SUPPLY_PROP_ONLINE:
+	case POWER_SUPPLY_PROP_PRESENT:
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+	case POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL:
+	case POWER_SUPPLY_PROP_CHARGE_UNO_CONTROL:
+	case POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX:
+		psy_do_property(charger->pdata->main_charger_name, get, psp, value);
+		val->intval = value.intval;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		psy_do_property(charger->pdata->main_charger_name, get, psp, value);
+		val->intval = value.intval;
+		sec_multi_chg_check_enable(charger);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = charger->total_current.fast_charging_current;
+		break;
+	case POWER_SUPPLY_PROP_TEMP:
+		break;
+	case POWER_SUPPLY_PROP_MAX ... POWER_SUPPLY_EXT_PROP_MAX:
+		switch (ext_psp) {
+		case POWER_SUPPLY_EXT_PROP_CHECK_SLAVE_I2C:
+			psy_do_property(charger->pdata->sub_charger_name, get, psp, value);
+			val->intval = value.intval;
+			break;
+		case POWER_SUPPLY_EXT_PROP_MULTI_CHARGER_MODE:
+			switch (charger->multi_mode) {
+				case SEC_MULTI_CHARGER_MAIN_ONLY:
+					val->strval = "master";
+					break;
+				case SEC_MULTI_CHARGER_SUB_ONLY:
+					val->strval = "slave";
+					break;
+				case SEC_MULTI_CHARGER_ALL_ENABLE:
+					val->strval = "dual";
+					break;
+				case SEC_MULTI_CHARGER_NORMAL:
+					if (!charger->sub_is_charging)
+						val->strval = "master"; //Main Charger Default ON;	Sub charger depend on sub_charger_condition .
+					else
+						val->strval = "dual";
+					break;
+				default:
+					val->strval = "master";
+					break;
+			}
+			break;
+		default:
+			return -EINVAL;
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sec_multi_chg_set_property(struct power_supply *psy,
+			    enum power_supply_property psp,
+			    const union power_supply_propval *val)
+{
+	struct sec_multi_charger_info *charger =
+		container_of(psy, struct sec_multi_charger_info, psy_chg);
+	enum power_supply_ext_property ext_psp = psp;
+	union power_supply_propval value, get_value;
+
+	value.intval = val->intval;
+	switch (psp) {
+	case POWER_SUPPLY_PROP_CHARGING_ENABLED:
+		charger->chg_mode = val->intval;
+		psy_do_property(charger->pdata->main_charger_name, set,
+			psp, value);
+
+		psy_do_property(charger->pdata->main_charger_name, get, POWER_SUPPLY_PROP_ONLINE, get_value);
+		if (get_value.intval != POWER_SUPPLY_TYPE_BATTERY) {
+			if (val->intval != SEC_BAT_CHG_MODE_CHARGING) {
+				psy_do_property(charger->pdata->sub_charger_name, set,
+					psp, value);
+			} else if (charger->sub_is_charging) {
+				psy_do_property(charger->pdata->sub_charger_name, set,
+					psp, value);
+			}
+		}
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		psy_do_property(charger->pdata->main_charger_name, set,
+			psp, value);
+		psy_do_property(charger->pdata->sub_charger_name, set,
+			psp, value);
+
+		/* INIT */
+		if (val->intval == POWER_SUPPLY_TYPE_BATTERY) {
+			charger->sub_is_charging = false;
+			charger->main_current.input_current_limit = 0;
+			charger->main_current.fast_charging_current = 0;
+			charger->sub_current.input_current_limit = 0;
+			charger->sub_current.fast_charging_current = 0;
+			charger->multi_mode = SEC_MULTI_CHARGER_NORMAL;
+		} else if (charger->sub_is_charging &&
+			charger->cable_type != val->intval &&
+			charger->chg_mode == SEC_BAT_CHG_MODE_CHARGING &&
+			charger->multi_mode == SEC_MULTI_CHARGER_NORMAL) {
+			charger->sub_is_charging = false;
+			/* set charging current */
+			sec_multi_chg_set_input_current(charger);
+			sec_multi_chg_set_charging_current(charger);
+			/* disable sub charger */
+			value.intval = SEC_BAT_CHG_MODE_CHARGING_OFF;
+			psy_do_property(charger->pdata->sub_charger_name, set,
+				POWER_SUPPLY_PROP_CHARGING_ENABLED, value);
+		} else {
+			pr_info("%s: invalid condition (sub_is_charging(%d), chg_mode(%d), multi_mode(%d))\n",
+				__func__, charger->sub_is_charging, charger->chg_mode, charger->multi_mode);
+		}
+		charger->cable_type = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_STATUS:
+		charger->status = val->intval;
+	case POWER_SUPPLY_PROP_HEALTH:
+	case POWER_SUPPLY_PROP_PRESENT:
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+		psy_do_property(charger->pdata->main_charger_name, set, psp, value);
+		psy_do_property(charger->pdata->sub_charger_name, set, psp, value);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_FULL:
+		charger->total_current.full_check_current_1st = val->intval;
+		psy_do_property(charger->pdata->main_charger_name, set, psp, value);
+		psy_do_property(charger->pdata->sub_charger_name, set, psp, value);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		charger->total_current.input_current_limit = val->intval;
+		sec_multi_chg_check_input_current(charger);
+		sec_multi_chg_set_input_current(charger);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		charger->total_current.fast_charging_current = val->intval;
+		sec_multi_chg_set_charging_current(charger);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+		charger->siop_level = val->intval;
+		psy_do_property(charger->pdata->main_charger_name, set, psp, value);
+		psy_do_property(charger->pdata->sub_charger_name, set, psp, value);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL:
+	case POWER_SUPPLY_PROP_CHARGE_UNO_CONTROL:
+		psy_do_property(charger->pdata->main_charger_name, set, psp, value);
+		break;
+#if defined(CONFIG_AFC_CHARGER_MODE)
+	case POWER_SUPPLY_PROP_AFC_CHARGER_MODE:
+		psy_do_property(charger->pdata->main_charger_name, set, psp, value);
+		break;
+#endif
+	case POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX:
+		/* AICL Enable */
+		if(!charger->pdata->aicl_disable)
+			psy_do_property(charger->pdata->main_charger_name, set, psp, value);
+		break;
+	case POWER_SUPPLY_PROP_MAX ... POWER_SUPPLY_EXT_PROP_MAX:
+		switch (ext_psp) {
+		case POWER_SUPPLY_EXT_PROP_MULTI_CHARGER_MODE:
+			if (charger->chg_mode == SEC_BAT_CHG_MODE_CHARGING && charger->multi_mode != val->intval) {
+				charger->multi_mode = val->intval;
+				switch (val->intval) {
+				case SEC_MULTI_CHARGER_MAIN_ONLY:
+					pr_info("%s: Only Use Main Charger \n", __func__);
+					charger->total_current.input_current_limit = is_hv_wire_type(charger->cable_type) ?
+						SEC_MULTI_CHARGER_TEST_MASTER_MODE_CURRENT :charger->total_current.input_current_limit;
+					charger->sub_is_charging = false;
+					value.intval = SEC_BAT_CHG_MODE_CHARGING_OFF;
+					psy_do_property(charger->pdata->sub_charger_name, set,
+						POWER_SUPPLY_PROP_CHARGING_ENABLED, value);
+
+					value.intval = SEC_BAT_CHG_MODE_CHARGING;
+					psy_do_property(charger->pdata->main_charger_name, set,
+						POWER_SUPPLY_PROP_CHARGING_ENABLED, value);
+					break;
+				case SEC_MULTI_CHARGER_SUB_ONLY:
+					pr_info("%s: Only Use Sub Charger \n", __func__);
+					charger->total_current.input_current_limit = is_hv_wire_type(charger->cable_type) ?
+						SEC_MULTI_CHARGER_TEST_SLAVE_MODE_CURRENT :charger->total_current.input_current_limit;
+					charger->sub_is_charging = true;
+					value.intval = SEC_BAT_CHG_MODE_CHARGING;
+					psy_do_property(charger->pdata->sub_charger_name, set,
+						POWER_SUPPLY_PROP_CHARGING_ENABLED, value);
+
+					value.intval = SEC_BAT_CHG_MODE_CHARGING_OFF;
+					psy_do_property(charger->pdata->main_charger_name, set,
+						POWER_SUPPLY_PROP_CHARGING_ENABLED, value);
+					break;
+				case SEC_MULTI_CHARGER_ALL_ENABLE:
+					pr_info("%s: Enable Main & Sub Charger together \n", __func__);
+					charger->sub_is_charging = true;
+					value.intval = SEC_BAT_CHG_MODE_CHARGING;
+					psy_do_property(charger->pdata->sub_charger_name, set,
+						POWER_SUPPLY_PROP_CHARGING_ENABLED, value);
+
+					value.intval = SEC_BAT_CHG_MODE_CHARGING;
+					psy_do_property(charger->pdata->main_charger_name, set,
+						POWER_SUPPLY_PROP_CHARGING_ENABLED, value);
+					break;
+				default:
+					charger->multi_mode = SEC_MULTI_CHARGER_NORMAL;
+					charger->sub_is_charging = false;
+					value.intval = SEC_BAT_CHG_MODE_CHARGING_OFF;
+					psy_do_property(charger->pdata->sub_charger_name, set,
+						POWER_SUPPLY_PROP_CHARGING_ENABLED, value);
+
+					value.intval = SEC_BAT_CHG_MODE_CHARGING;
+					psy_do_property(charger->pdata->main_charger_name, set,
+						POWER_SUPPLY_PROP_CHARGING_ENABLED, value);
+					break;
+				}
+				/* set charging current */
+				sec_multi_chg_set_input_current(charger);
+				sec_multi_chg_set_charging_current(charger);
+			}
+			pr_info("%s: set Multi Charger Mode (%d)\n", __func__, charger->multi_mode);
+			break;
+		default:
+			return -EINVAL;
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static int sec_multi_charger_parse_dt(struct device *dev,
+		struct sec_multi_charger_info *charger)
+{
+	struct device_node *np = dev->of_node;
+	struct sec_multi_charger_platform_data *pdata = charger->pdata;
+	int ret = 0, temp_value = 0;
+	int len;
+	const u32 *p;
+	
+	if (!np) {
+		pr_err("%s: np NULL\n", __func__);
+		return 1;
+	} else {
+		ret = of_property_read_string(np, "charger,battery_name",
+				(char const **)&charger->pdata->battery_name);
+		if (ret)
+			pr_err("%s: battery_name is Empty\n", __func__);
+
+		ret = of_property_read_string(np, "charger,main_charger",
+				(char const **)&charger->pdata->main_charger_name);
+		if (ret)
+			pr_err("%s: main_charger is Empty\n", __func__);
+
+		ret = of_property_read_string(np, "charger,sub_charger",
+				(char const **)&charger->pdata->sub_charger_name);
+		if (ret)
+			pr_err("%s: sub_charger is Empty\n", __func__);
+
+		ret = of_property_read_u32(np, "charger,is_serial",
+			&temp_value);
+		if (ret) {
+			pr_err("%s: is_serial is Empty\n", __func__);
+			temp_value = 1;
+		}
+		pdata->is_serial = (temp_value != 0);
+
+		pdata->aicl_disable = of_property_read_bool(np,
+			"charger,aicl_disable");
+
+		ret = of_property_read_u32(np, "charger,sub_charger_condition",
+				&pdata->sub_charger_condition);
+		if (ret) {
+			pr_err("%s: sub_charger_condition is Empty\n", __func__);
+			pdata->sub_charger_condition = 0;
+		}
+
+		if (pdata->sub_charger_condition) {
+			ret = of_property_read_u32(np, "charger,sub_charger_condition_current_max",
+					&pdata->sub_charger_condition_current_max);
+			if (ret) {
+				pr_err("%s: sub_charger_condition_current_max is Empty\n", __func__);
+				pdata->sub_charger_condition &= ~SEC_SUB_CHARGER_CONDITION_CURRENT_MAX;
+				pdata->sub_charger_condition_current_max = 0;
+			}
+
+			ret = of_property_read_u32(np, "charger,sub_charger_condition_charge_power",
+					&pdata->sub_charger_condition_charge_power);
+			if (ret) {
+				pr_err("%s: sub_charger_condition_charge_power is Empty\n", __func__);
+				pdata->sub_charger_condition &= ~SEC_SUB_CHARGER_CONDITION_CHARGE_POWER;
+				pdata->sub_charger_condition_charge_power = 15000;
+			}
+
+			p = of_get_property(np, "charger,sub_charger_condition_online", &len);
+			if (p) {
+				len = len / sizeof(u32);
+
+				pdata->sub_charger_condition_online = kzalloc(sizeof(unsigned int) * len,
+								  GFP_KERNEL);
+				ret = of_property_read_u32_array(np, "charger,sub_charger_condition_online",
+						 pdata->sub_charger_condition_online, len);
+
+				pdata->sub_charger_condition_online_size = len;
+			} else {
+				pdata->sub_charger_condition &= ~SEC_SUB_CHARGER_CONDITION_ONLINE;
+				pdata->sub_charger_condition_online_size = 0;
+			}
+
+			pr_info("%s: sub_charger_condition(0x%x)\n", __func__, pdata->sub_charger_condition);
+		}
+	}
+	return 0;
+}
+#endif
+
+static int __devinit sec_multi_charger_probe(struct platform_device *pdev)
+{
+	struct sec_multi_charger_info *charger;
+	struct sec_multi_charger_platform_data *pdata = NULL;
+	int ret = 0;
+
+	dev_info(&pdev->dev,
+		"%s: SEC Multi-Charger Driver Loading\n", __func__);
+
+	charger = kzalloc(sizeof(*charger), GFP_KERNEL);
+	if (!charger)
+		return -ENOMEM;
+
+	if (pdev->dev.of_node) {
+		pdata = devm_kzalloc(&pdev->dev,
+				sizeof(struct sec_multi_charger_platform_data),
+				GFP_KERNEL);
+		if (!pdata) {
+			dev_err(&pdev->dev, "Failed to allocate memory\n");
+			ret = -ENOMEM;
+			goto err_charger_free;
+		}
+
+		charger->pdata = pdata;
+		if (sec_multi_charger_parse_dt(&pdev->dev, charger)) {
+			dev_err(&pdev->dev,
+				"%s: Failed to get sec-multi-charger dt\n", __func__);
+			ret = -EINVAL;
+			goto err_charger_free;
+		}
+	} else {
+		pdata = dev_get_platdata(&pdev->dev);
+		charger->pdata = pdata;
+	}
+
+	charger->sub_is_charging = false;
+	charger->multi_mode = SEC_MULTI_CHARGER_NORMAL;
+
+	platform_set_drvdata(pdev, charger);
+	charger->dev = &pdev->dev;
+	charger->psy_chg.name		= "sec-multi-charger";
+	charger->psy_chg.type		= POWER_SUPPLY_TYPE_UNKNOWN;
+	charger->psy_chg.get_property	= sec_multi_chg_get_property;
+	charger->psy_chg.set_property	= sec_multi_chg_set_property;
+	charger->psy_chg.properties	= sec_multi_charger_props;
+	charger->psy_chg.num_properties	= ARRAY_SIZE(sec_multi_charger_props);
+
+	ret = power_supply_register(&pdev->dev, &charger->psy_chg);
+	if (ret) {
+		dev_err(charger->dev,
+			"%s: Failed to Register psy_chg\n", __func__);
+		goto err_pdata_free;
+	}
+
+	dev_info(charger->dev,
+		"%s: SEC Multi-Charger Driver Loaded\n", __func__);
+	return 0;
+
+err_pdata_free:
+	kfree(pdata);
+err_charger_free:
+	kfree(charger);
+
+	return ret;
+}
+
+static int __devexit sec_multi_charger_remove(struct platform_device *pdev)
+{
+	struct sec_multi_charger_info *charger = platform_get_drvdata(pdev);
+
+	power_supply_unregister(&charger->psy_chg);
+
+	dev_dbg(charger->dev, "%s: End\n", __func__);
+
+	kfree(charger->pdata);
+	kfree(charger);
+
+	return 0;
+}
+
+static int sec_multi_charger_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int sec_multi_charger_resume(struct device *dev)
+{
+	return 0;
+}
+
+static void sec_multi_charger_shutdown(struct device *dev)
+{
+}
+
+#ifdef CONFIG_OF
+static struct of_device_id sec_multi_charger_dt_ids[] = {
+	{ .compatible = "samsung,sec-multi-charger" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, sec_multi_charger_dt_ids);
+#endif /* CONFIG_OF */
+
+static const struct dev_pm_ops sec_multi_charger_pm_ops = {
+	.suspend = sec_multi_charger_suspend,
+	.resume = sec_multi_charger_resume,
+};
+
+static struct platform_driver sec_multi_charger_driver = {
+	.driver = {
+		.name = "sec-multi-charger",
+		.owner = THIS_MODULE,
+		.pm = &sec_multi_charger_pm_ops,
+		.shutdown = sec_multi_charger_shutdown,
+#ifdef CONFIG_OF
+		.of_match_table = sec_multi_charger_dt_ids,
+#endif
+	},
+	.probe = sec_multi_charger_probe,
+	.remove = __devexit_p(sec_multi_charger_remove),
+};
+
+static int __init sec_multi_charger_init(void)
+{
+	pr_info("%s: \n", __func__);
+	return platform_driver_register(&sec_multi_charger_driver);
+}
+
+static void __exit sec_multi_charger_exit(void)
+{
+	platform_driver_unregister(&sec_multi_charger_driver);
+}
+
+device_initcall_sync(sec_multi_charger_init);
+module_exit(sec_multi_charger_exit);
+
+MODULE_DESCRIPTION("Samsung Multi Charger Driver");
+MODULE_AUTHOR("Samsung Electronics");
+MODULE_LICENSE("GPL");
diff -Naur linux-3.18.14/drivers/battery_v2/sec_step_charging.c samsung/drivers/battery_v2/sec_step_charging.c
--- linux-3.18.14/drivers/battery_v2/sec_step_charging.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/sec_step_charging.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,125 @@
+/*
+ *  sec_step_charging.c
+ *  Samsung Mobile Battery Driver
+ *
+ *  Copyright (C) 2012 Samsung Electronics
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include "include/sec_battery.h"
+
+#define STEP_CHARGING_CONDITION_VOLTAGE	0x01
+#define STEP_CHARGING_CONDITION_SOC	0x02
+#define STEP_CHARGING_CONDITION_CHARGE_POWER 0x04
+#define STEP_CHARGING_CONDITION_ONLINE 0x08
+
+void sec_bat_reset_step_charging(struct sec_battery_info *battery)
+{
+	battery->step_charging_status = -1;
+}
+/*
+ * true: step is changed
+ * false: not changed
+ */
+bool sec_bat_check_step_charging(struct sec_battery_info *battery)
+{
+	int i, value;
+
+	if (!battery->step_charging_type)
+		return false;
+
+	if (battery->step_charging_type & STEP_CHARGING_CONDITION_CHARGE_POWER)
+		if (battery->charge_power < battery->step_charging_charge_power)
+			return false;
+
+	if (battery->step_charging_type & STEP_CHARGING_CONDITION_ONLINE)
+		if (!is_hv_wire_12v_type(battery->cable_type))
+			return false;
+
+	if (battery->step_charging_status < 0)
+		i = 0;
+	else
+		i = battery->step_charging_status;
+
+	if (battery->step_charging_type & STEP_CHARGING_CONDITION_VOLTAGE)
+		value = battery->voltage_avg;
+	else if (battery->step_charging_type & STEP_CHARGING_CONDITION_SOC)
+		value = battery->capacity;
+	else
+		return false;
+	
+	while(i < battery->step_charging_step - 1) {
+		if (value < battery->pdata->step_charging_condition[i]){
+			break;
+		}
+		i++;
+		if(battery->step_charging_status != -1)
+			break;
+	}
+
+	if (i != battery->step_charging_status) {
+		pr_info("%s : prev=%d, new=%d, value=%d, current=%d\n", __func__,
+			battery->step_charging_status, i, value, battery->pdata->step_charging_current[i]);
+		battery->pdata->charging_current[battery->cable_type].fast_charging_current = battery->pdata->step_charging_current[i];
+		battery->step_charging_status = i;
+		return true;
+	}
+	return false;
+}
+
+void sec_step_charging_init(struct sec_battery_info *battery, struct device *dev)
+{
+	struct device_node *np = dev->of_node;
+	int ret, len;
+	sec_battery_platform_data_t *pdata = battery->pdata;
+	unsigned int i;
+	const u32 *p;
+
+	ret = of_property_read_u32(np, "battery,step_charging_type",
+			&battery->step_charging_type);
+	pr_err("%s: step_charging_type 0x%x\n", __func__, battery->step_charging_type);
+	if (ret) {
+		pr_err("%s: step_charging_type is Empty\n", __func__);
+		battery->step_charging_type = 0;
+		return;
+	}
+	ret = of_property_read_u32(np, "battery,step_charging_charge_power",
+			&battery->step_charging_charge_power);
+	if (ret) {
+		pr_err("%s: step_charging_charge_power is Empty\n", __func__);
+		battery->step_charging_charge_power = 20000;
+	}
+	p = of_get_property(np, "battery,step_charging_condtion", &len);
+	if (!p) {
+		battery->step_charging_step = 0;
+	} else {
+		len = len / sizeof(u32);
+		battery->step_charging_step = len;
+		pdata->step_charging_condition = kzalloc(sizeof(u32) * len, GFP_KERNEL);
+		ret = of_property_read_u32_array(np, "battery,step_charging_condtion",
+				pdata->step_charging_condition, len);
+		if (ret) {
+			pr_info("%s : step_charging_condtion read fail\n", __func__);
+			battery->step_charging_step = 0;
+		} else {
+			pdata->step_charging_current = kzalloc(sizeof(u32) * len, GFP_KERNEL);
+			ret = of_property_read_u32_array(np, "battery,step_charging_current",
+					pdata->step_charging_current, len);
+			if (ret) {
+				pr_info("%s : step_charging_current read fail\n", __func__);
+				battery->step_charging_step = 0;
+			} else {
+				battery->step_charging_status = -1;
+				for (i = 0; i < len; i++) {
+					pr_info("%s : step condition(%d), current(%d)\n",
+					__func__, pdata->step_charging_condition[i],
+					pdata->step_charging_current[i]);
+				}
+				pdata->max_charging_current = pdata->step_charging_current[0]; 
+			}
+		}
+	}
+}
diff -Naur linux-3.18.14/drivers/battery_v2/sm5703_charger.c samsung/drivers/battery_v2/sm5703_charger.c
--- linux-3.18.14/drivers/battery_v2/sm5703_charger.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/sm5703_charger.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,1592 @@
+/* drivers/battery/sm5703_charger.c
+ * SM5703 Charger Driver
+ *
+ * Copyright (C) 2013 Siliconmitus Technology Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ */
+
+#include "include/charger/sm5703_charger.h"
+#include <linux/sec_batt.h>
+#include <linux/wakelock.h>
+
+#ifdef CONFIG_SM5703_MUIC
+#include <linux/i2c/sm5703-muic.h>
+#endif
+
+#include <linux/mfd/sm5703.h>
+
+#ifdef CONFIG_FLED_SM5703
+#include <linux/leds/sm5703_fled.h>
+#include <linux/leds/smfled.h>
+#endif
+
+#include <linux/version.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/of_gpio.h>
+
+#ifdef CONFIG_USB_HOST_NOTIFY
+#include <linux/usb_notify.h>
+#endif
+
+#define ENABLE_AICL 1
+
+#define EN_NOBAT_IRQ	0
+#define EN_DONE_IRQ		1
+#define EN_TOPOFF_IRQ	1
+#define EN_CHGON_IRQ	0
+#define EN_AICL_IRQ		1
+#define EN_OTGFAIL_IRQ	1
+
+#define MINVAL(a, b) ((a <= b) ? a : b)
+
+#ifndef EN_TEST_READ
+#define EN_TEST_READ 1
+#endif
+
+#define ENABLE 1
+#define DISABLE 0
+
+static int sm5703_reg_map[] = {
+	SM5703_INTMSK1,
+	SM5703_INTMSK2,
+	SM5703_INTMSK3,
+	SM5703_INTMSK4,
+	SM5703_STATUS1,
+	SM5703_STATUS2,
+	SM5703_STATUS3,
+	SM5703_STATUS4,
+	SM5703_CNTL,		
+	SM5703_VBUSCNTL,
+	SM5703_CHGCNTL1,
+	SM5703_CHGCNTL2,
+	SM5703_CHGCNTL3,
+	SM5703_CHGCNTL4,
+	SM5703_CHGCNTL5,
+	SM5703_CHGCNTL6,
+	SM5703_OTGCURRENTCNTL,
+	SM5703_Q3LIMITCNTL,
+	SM5703_STATUS5,
+};
+
+typedef struct sm5703_charger_data {
+	struct i2c_client	*i2c;
+	sm5703_mfd_chip_t	*sm5703;
+	struct power_supply	psy_chg;
+	struct power_supply	psy_otg;
+	sm5703_charger_platform_data_t *pdata;
+	struct wake_lock aicl_wake_lock;
+	struct delayed_work aicl_work;
+	int input_current;
+	int charging_current;
+	int topoff_current;
+	int cable_type;
+	bool aicl_state;
+	bool is_charging;
+	int charge_mode;
+	struct mutex io_lock;
+	/* register programming */
+	int reg_addr;
+	int reg_data;
+	int nchgen;
+
+	bool ovp;
+	bool is_mdock;
+	struct workqueue_struct *wq;
+	int status;
+#ifdef CONFIG_FLED_SM5703
+	struct sm_fled_info *fled_info;
+#endif
+} sm5703_charger_data_t;
+
+static enum power_supply_property sec_charger_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_CHARGE_TYPE,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_CURRENT_MAX,
+	POWER_SUPPLY_PROP_CURRENT_AVG,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL,
+	POWER_SUPPLY_PROP_CHARGING_ENABLED,
+};
+
+static enum power_supply_property sm5703_otg_props[] = {
+	POWER_SUPPLY_PROP_ONLINE,
+};
+
+int otg_enable_flag;
+
+static int sm5703_get_charging_health(
+		struct sm5703_charger_data *charger);
+
+static void sm5703_read_regs(struct i2c_client *i2c, char *str)
+{
+	u8 data = 0;
+	int i = 0;
+	for (i = SM5703_INTMSK1; i < ARRAY_SIZE(sm5703_reg_map); i++) {
+		data = sm5703_reg_read(i2c, sm5703_reg_map[i]);
+		sprintf(str+strlen(str), "0x%02x, ", data);
+	}
+}
+
+static void sm5703_test_read(struct i2c_client *i2c)
+{
+	int data;
+	char str[1000] = {0,};
+	int i;
+
+	/* SM5703 REG: 0x04 ~ 0x13 */
+	for (i = SM5703_INTMSK1; i <= SM5703_CHGCNTL6; i++) {
+		data = sm5703_reg_read(i2c, i);
+		sprintf(str+strlen(str), "0x%0x = 0x%02x, ", i, data);
+	}
+
+	sprintf(str+strlen(str), "0x%0x = 0x%02x, ",SM5703_OTGCURRENTCNTL,
+		sm5703_reg_read(i2c, SM5703_OTGCURRENTCNTL));
+	sprintf(str+strlen(str), "0x%0x = 0x%02x, ", SM5703_STATUS5,
+		sm5703_reg_read(i2c, SM5703_STATUS5));
+	sprintf(str+strlen(str), "0x%0x = 0x%02x, ", SM5703_Q3LIMITCNTL,
+		sm5703_reg_read(i2c, SM5703_Q3LIMITCNTL));
+	pr_info("%s: %s\n", __func__, str);
+}
+
+#define SM5703_FLEDCNTL6			0x19
+static void sm5703_charger_otg_control(struct sm5703_charger_data *charger,
+		bool enable)
+{
+	pr_info("%s: called charger otg control : %s\n", __func__,
+			enable ? "on" : "off");
+
+	otg_enable_flag = enable;
+
+	if (!enable) {
+		sm5703_assign_bits(charger->i2c,
+			SM5703_FLEDCNTL6, SM5703_BSTOUT_MASK,
+			SM5703_BSTOUT_4P5);
+#ifdef CONFIG_FLED_SM5703
+		/* turn off OTG */
+		if (charger->fled_info == NULL)
+			charger->fled_info = sm_fled_get_info_by_name(NULL);
+		if (charger->fled_info)
+			sm5703_boost_notification(charger->fled_info, 0);
+#else
+		sm5703_assign_bits(charger->i2c,
+			SM5703_CNTL, SM5703_OPERATION_MODE_MASK,
+			SM5703_OPERATION_MODE_CHARGING_ON);
+#endif
+	} else {
+		sm5703_assign_bits(charger->i2c,
+			SM5703_FLEDCNTL6, SM5703_BSTOUT_MASK,
+			SM5703_BSTOUT_5P0);
+#ifdef CONFIG_FLED_SM5703
+		if (charger->fled_info == NULL)
+			charger->fled_info = sm_fled_get_info_by_name(NULL);
+		if (charger->fled_info)
+			sm5703_boost_notification(charger->fled_info, 1);
+#else
+		sm5703_assign_bits(charger->i2c,
+			SM5703_CNTL, SM5703_OPERATION_MODE_MASK,
+			SM5703_OPERATION_MODE_USB_OTG_MODE);
+#endif
+		charger->cable_type = POWER_SUPPLY_TYPE_OTG;
+	}
+}
+
+static void sm5703_enable_charger_switch(struct sm5703_charger_data *charger,
+		int onoff)
+{
+#ifdef CONFIG_CHARGER_SM5703_DUALPATH
+	union power_supply_propval batt_pres;
+#endif
+
+	if (onoff > 0) {
+		pr_info("%s: turn on charger\n", __func__);
+#ifdef CONFIG_FLED_SM5703
+		if (charger->fled_info == NULL)
+			charger->fled_info = sm_fled_get_info_by_name(NULL);
+		if (charger->fled_info)
+			sm5703_charger_notification(charger->fled_info,1);
+#else
+		sm5703_assign_bits(charger->i2c,
+			SM5703_CNTL, SM5703_OPERATION_MODE_MASK,
+			SM5703_OPERATION_MODE_CHARGING_ON);
+#endif
+		charger->nchgen = false;
+		gpio_direction_output(charger->pdata->chgen_gpio,
+			charger->nchgen); /* nCHG enable */
+
+		pr_info("%s : STATUS OF CHARGER ON(0)/OFF(1): %d\n",
+			__func__, charger->nchgen);
+	} else {
+		pr_info("%s: turn off charger\n", __func__);
+
+		charger->nchgen = true;
+#ifdef CONFIG_FLED_SM5703
+		if (charger->fled_info == NULL)
+			charger->fled_info = sm_fled_get_info_by_name(NULL);
+		if (charger->fled_info)
+			sm5703_charger_notification(charger->fled_info,0);
+#endif
+		gpio_direction_output(charger->pdata->chgen_gpio,
+			charger->nchgen); /* nCHG disable */
+		pr_info("%s : STATUS OF CHARGER ON(0)/OFF(1): %d\n",
+			__func__, charger->nchgen);
+
+#ifdef CONFIG_CHARGER_SM5703_DUALPATH
+		psy_do_property("battery", get,
+					POWER_SUPPLY_PROP_PRESENT, batt_pres);
+		if(batt_pres.intval == false) {
+			sm5703_assign_bits(charger->i2c,
+					SM5703_CNTL, SM5703_OPERATION_MODE_MASK,
+					SM5703_OPERATION_MODE_SUSPEND);
+			pr_info("%s: Set SM5703 mode to Suspend, W/O for VF check \n", __func__);
+		}
+#endif
+	}
+}
+
+static void sm5703_enable_autostop(struct sm5703_charger_data *charger,
+		int onoff)
+{
+	pr_info("%s:[BATT] Autostop set(%d)\n", __func__, onoff);
+
+	mutex_lock(&charger->io_lock);
+
+	if (onoff)
+		sm5703_set_bits(charger->i2c, SM5703_CHGCNTL4, SM5703_AUTOSTOP_MASK);
+	else
+		sm5703_clr_bits(charger->i2c, SM5703_CHGCNTL4, SM5703_AUTOSTOP_MASK);
+
+	mutex_unlock(&charger->io_lock);    
+}
+
+static int sm5703_set_topoff_timer(struct sm5703_charger_data *charger,
+				unsigned int topoff_timer)
+{
+	struct i2c_client *i2c = charger->sm5703->i2c_client;
+
+	sm5703_assign_bits(i2c,
+		SM5703_CHGCNTL5, SM5703_TOPOFF_TIMER_MASK,
+		((topoff_timer & SM5703_TOPOFF_TIMER) << SM5703_TOPOFF_TIMER_SHIFT));
+	pr_info("%s : TOPOFF timer set (timer=0x%x)\n",
+		__func__, topoff_timer);
+
+	return 0;
+}
+
+static void sm5703_enable_autoset(struct sm5703_charger_data *charger,
+		int onoff)
+{
+	pr_info("%s:[BATT] Autoset set(%d)\n", __func__, onoff);
+
+	mutex_lock(&charger->io_lock);
+
+	if (onoff)
+		sm5703_set_bits(charger->i2c, SM5703_CNTL, SM5703_AUTOSET_MASK);
+	else
+		sm5703_clr_bits(charger->i2c, SM5703_CNTL, SM5703_AUTOSET_MASK);
+
+	mutex_unlock(&charger->io_lock);
+}
+
+static void sm5703_enable_aiclen(struct sm5703_charger_data *charger,
+		int onoff)
+{
+	pr_info("%s:[BATT] AICLEN set(%d)\n", __func__, onoff);
+
+	mutex_lock(&charger->io_lock);
+
+	if (onoff)
+		sm5703_set_bits(charger->i2c, SM5703_CHGCNTL5, SM5703_AICLEN_MASK);
+	else
+		sm5703_clr_bits(charger->i2c, SM5703_CHGCNTL5, SM5703_AICLEN_MASK);
+
+	mutex_unlock(&charger->io_lock);    
+}
+
+static void sm5703_set_aiclth(struct sm5703_charger_data *charger,
+		int aiclth)
+{
+	int data = 0, temp = 0;
+
+	mutex_lock(&charger->io_lock);
+	data = sm5703_reg_read(charger->i2c, SM5703_CHGCNTL5);
+	data &= ~SM5703_AICLTH;
+
+	if (aiclth >= 4900)
+		aiclth = 4900;
+
+	if(aiclth <= 4300)
+		data &= ~SM5703_AICLTH;
+	else {
+		temp = (aiclth - 4300)/100;
+		data |= temp;
+	}
+
+	sm5703_reg_write(charger->i2c, SM5703_CHGCNTL5, data);
+
+	data = sm5703_reg_read(charger->i2c, SM5703_CHGCNTL5);
+	pr_info("%s : SM5703_CHGCNTL5 (AICHTH) : 0x%02x\n",
+			__func__, data);    
+	mutex_unlock(&charger->io_lock);
+}
+
+static void sm5703_set_freqsel(struct sm5703_charger_data *charger,
+		int freqsel_hz)
+{
+	int data = 0;
+
+	mutex_lock(&charger->io_lock);
+	data = sm5703_reg_read(charger->i2c, SM5703_CHGCNTL6);
+	data &= ~SM5703_FREQSEL_MASK;
+	data |= (freqsel_hz << SM5703_FREQSEL_SHIFT);
+
+	sm5703_reg_write(charger->i2c, SM5703_CHGCNTL6, data);
+
+	data = sm5703_reg_read(charger->i2c, SM5703_CHGCNTL6);
+	pr_info("%s : SM5703_CHGCNTL6 (FREQSEL) : 0x%02x\n",
+			__func__, data);    
+	mutex_unlock(&charger->io_lock);
+}
+
+static void sm5703_set_input_current_limit(struct sm5703_charger_data *charger,
+		int current_limit)
+{
+	int data = 0, temp = 0;
+
+	mutex_lock(&charger->io_lock);
+	data = sm5703_reg_read(charger->i2c, SM5703_VBUSCNTL);
+	data &= ~SM5703_VBUSLIMIT;
+
+	if (charger->input_current < current_limit && charger->aicl_state) {
+		pr_info("%s: skip set input current limit(%d <--> %d), aicl_state(%d)\n",
+			__func__, charger->input_current, current_limit, charger->aicl_state);
+	} else {
+#ifdef CONFIG_CHARGER_SM5703_SOFT_START_CHARGING
+		/* Soft Start Charging */
+		if ((charger->cable_type != POWER_SUPPLY_TYPE_BATTERY) && !lpcharge) {
+			data = sm5703_reg_read(charger->i2c, SM5703_VBUSCNTL);
+			data &= ~SM5703_VBUSLIMIT;
+			sm5703_reg_write(charger->i2c, SM5703_VBUSCNTL, data);
+			msleep(100);
+		}
+#endif
+
+		if(current_limit <= 100)
+			current_limit = 100;
+		else if (current_limit >= 2100)
+			current_limit = 2100;
+
+		temp = ((current_limit - 100) / 50) | data;
+		sm5703_reg_write(charger->i2c, SM5703_VBUSCNTL, temp);
+
+		data = sm5703_reg_read(charger->i2c, SM5703_VBUSCNTL);
+		pr_info("%s : SM5703_VBUSCNTL (Input current limit) : 0x%02x\n",
+				__func__, data);
+	}
+
+	mutex_unlock(&charger->io_lock);
+}
+
+static int sm5703_get_input_current_limit(struct sm5703_charger_data *charger)
+{
+	int ret, current_limit = 0;
+	ret = sm5703_reg_read(charger->i2c, SM5703_VBUSCNTL);
+	if (ret < 0)
+		return ret;
+	ret&=SM5703_VBUSLIMIT_MASK;
+
+	current_limit = (100 + (ret*50));
+
+	return current_limit;
+}
+
+static void sm5703_set_regulation_voltage(struct sm5703_charger_data *charger,
+		int float_voltage)
+{
+	int data = 0;
+
+	data = sm5703_reg_read(charger->i2c, SM5703_CHGCNTL3);
+
+	data &= ~SM5703_BATREG_MASK;
+
+	if ((float_voltage) <= 4120)
+		data = 0x00;
+	else if ((float_voltage) >= 4430)
+		data = 0x1f;
+	else
+		data = ((float_voltage - 4120) / 10);
+
+	mutex_lock(&charger->io_lock);
+	sm5703_reg_write(charger->i2c, SM5703_CHGCNTL3, data);
+	data = sm5703_reg_read(charger->i2c, SM5703_CHGCNTL3);
+	pr_info("%s : SM5703_CHGCNTL3 (Battery regulation voltage) : 0x%02x\n",
+			__func__, data);
+	mutex_unlock(&charger->io_lock);
+}
+
+#if defined(CONFIG_BATTERY_SWELLING)
+static int sm5703_get_regulation_voltage(struct sm5703_charger_data *charger)
+{
+	int data = 0;
+
+	data = sm5703_reg_read(charger->i2c, SM5703_CHGCNTL3);
+	data &= SM5703_BATREG_MASK;
+
+	return (4120 + (data * 10));
+}
+#endif
+
+static void sm5703_set_fast_charging_current(struct sm5703_charger_data *charger,
+		int charging_current)
+{
+	int data = 0;
+
+	if(charging_current <= 100)
+		charging_current = 100;
+	else if (charging_current >= 2500)
+		charging_current = 2500;
+
+	data = (charging_current - 100) / 50;
+
+	sm5703_reg_write(charger->i2c, SM5703_CHGCNTL2, data);
+
+	data = sm5703_reg_read(charger->i2c, SM5703_CHGCNTL2);
+	pr_info("%s : SM5703_CHGCNTL2 (fastchg current) : 0x%02x\n",
+			__func__, data);
+
+}
+
+static int sm5703_get_fast_charging_current(struct sm5703_charger_data *charger)
+{
+	int data = sm5703_reg_read(charger->i2c, SM5703_CHGCNTL2);
+	int charging_current = 0;
+
+	if (data < 0)
+		return data;
+
+	data &= SM5703_FASTCHG_MASK;
+
+	charging_current = (100 + (data*50));
+
+	return charging_current;
+}
+
+static int sm5703_get_topoff_current(struct sm5703_charger_data *charger)
+{
+	int ret, data = 0, topoff_current = 0;
+	mutex_lock(&charger->io_lock);
+	ret = sm5703_reg_read(charger->i2c, SM5703_CHGCNTL4);
+	mutex_unlock(&charger->io_lock);
+	if (ret < 0) {
+		pr_info("%s: warning --> fail to read i2c register(%d)\n", __func__, ret);
+		return ret;
+	}
+
+	data = ((ret & SM5703_TOPOFF_MASK) >> SM5703_TOPOFF_SHIFT);  
+
+	topoff_current = (100 + (data*25));
+
+	return topoff_current;
+}
+
+static void sm5703_set_topoff_current(struct sm5703_charger_data *charger,
+		int current_limit)
+{
+	int data = 0, temp = 0;
+
+	pr_info("%s : Set Termination\n", __func__);
+
+	data = sm5703_reg_read(charger->i2c, SM5703_CHGCNTL4);
+
+	data &= ~SM5703_TOPOFF_MASK;
+
+	if(current_limit <= 100)
+		current_limit = 100;
+	else if (current_limit >= 475)
+		current_limit = 475;
+
+	temp = (current_limit - 100) / 25;
+	data |= (temp << SM5703_TOPOFF_SHIFT);
+
+	sm5703_reg_write(charger->i2c, SM5703_CHGCNTL4, data);
+
+	data = sm5703_reg_read(charger->i2c, SM5703_CHGCNTL4);
+	pr_info("%s : SM5703_CHGCNTL4 (Top-off current threshold) : 0x%02x\n",
+			__func__, data);    
+}
+
+static void sm5703_set_otgcurrent(struct sm5703_charger_data *charger,
+		int otg_current)
+{
+	int data = 0;
+
+	data = sm5703_reg_read(charger->i2c, SM5703_OTGCURRENTCNTL);
+
+	data &= ~SM5703_OTGCURRENT_MASK;
+
+	if (otg_current <= 500)
+		data = 0x00;
+	else if (otg_current <= 700)
+		data = 0x01;
+	else if (otg_current <= 900)
+		data = 0x02;    
+	else
+		data = 0x3;
+
+	mutex_lock(&charger->io_lock);
+	sm5703_reg_write(charger->i2c, SM5703_OTGCURRENTCNTL, data);
+	data = sm5703_reg_read(charger->i2c, SM5703_OTGCURRENTCNTL);
+	pr_info("%s : SM5703_OTGCURRENTCNTL (OTG current) : 0x%02x\n",
+			__func__, data);
+	mutex_unlock(&charger->io_lock);
+}
+
+static void sm5703_set_bst_iq3limit(struct sm5703_charger_data *charger,
+		int iq3limit)
+{
+	int data = 0;
+
+	mutex_lock(&charger->io_lock);
+	data = sm5703_reg_read(charger->i2c, SM5703_Q3LIMITCNTL);
+	data &= ~SM5703_BST_IQ3LIMIT_MASK;
+	data |= (iq3limit << SM5703_BST_IQ3LIMIT_SHIFT);
+
+	sm5703_reg_write(charger->i2c, SM5703_Q3LIMITCNTL, data);
+
+	data = sm5703_reg_read(charger->i2c, SM5703_Q3LIMITCNTL);
+	pr_info("%s : SM5703_Q3LIMITCNTL (BST_IQ3LIMIT) : 0x%02x\n",
+			__func__, data);
+	mutex_unlock(&charger->io_lock);
+}
+
+enum {
+	SM5703_AICL_4300MV = 0,
+	SM5703_AICL_4400MV,
+	SM5703_AICL_4500MV,
+	SM5703_AICL_4600MV,
+	SM5703_AICL_4700MV,
+	SM5703_AICL_4800MV,
+	SM5703_AICL_4900MV,
+};
+
+#if ENABLE_AICL
+/* Dedicated charger (non-USB) device
+ * will use lower AICL level to get better performance
+ */
+static void sm5703_set_aicl_level(struct sm5703_charger_data *charger)
+{
+	int aicl;
+	switch(charger->cable_type) {
+		case POWER_SUPPLY_TYPE_USB ... POWER_SUPPLY_TYPE_USB_ACA:
+			aicl = SM5703_AICL_4500MV;
+			break;
+		default:
+			aicl = SM5703_AICL_4500MV;
+	}
+	mutex_lock(&charger->io_lock);
+	sm5703_assign_bits(charger->i2c,
+			SM5703_CHGCNTL5, SM5703_AICLTH_MASK, aicl);
+	mutex_unlock(&charger->io_lock);
+}
+#endif /*ENABLE_AICL*/
+
+#if 0 //temp block
+static void sm5703_configure_charger(struct sm5703_charger_data *charger)
+{
+	/* check aicl state */
+	if ((sm5703_reg_read(charger->i2c, SM5703_STATUS1) & 0x01) &&
+			!charger->aicl_state) {
+		charger->aicl_state = true;
+		wake_lock(&charger->aicl_wake_lock);
+		queue_delayed_work_on(0, charger->wq, &charger->aicl_work, msecs_to_jiffies(50));
+	}
+}
+#endif
+
+/* here is set init charger data */
+static bool sm5703_chg_init(struct sm5703_charger_data *charger)
+{
+	sm5703_mfd_chip_t *chip = i2c_get_clientdata(charger->i2c);
+	int ret;
+	chip->charger = charger;
+
+	/* AUTOSTOP */
+	sm5703_enable_autostop(chip->charger, (int)charger->pdata->chg_autostop);
+	/* AUTOSET */
+	sm5703_enable_autoset(chip->charger, (int)charger->pdata->chg_autoset);
+	/* AICLEN */
+	sm5703_enable_aiclen(chip->charger, (int)charger->pdata->chg_aiclen);
+	/* AICLTH */
+	sm5703_set_aiclth(chip->charger, (int)charger->pdata->chg_aiclth);
+	/* FREQSEL */
+	sm5703_set_freqsel(chip->charger, SM5703_FREQSEL_1P5MHZ);
+	/* Auto-Stop configuration for Emergency status */
+	sm5703_set_topoff_timer(charger, SM5703_TOPOFF_TIMER_45m);
+
+	/* MUST set correct regulation voltage first
+	 * Before MUIC pass cable type information to charger
+	 * charger would be already enabled (default setting)
+	 * it might cause EOC event by incorrect regulation voltage */
+	sm5703_set_regulation_voltage(charger,
+			charger->pdata->chg_float_voltage);
+
+	sm5703_set_otgcurrent(charger, 1200); /* OTGCURRENT : 1.2A */
+
+	sm5703_set_bst_iq3limit(charger, SM5703_BST_IQ3LIMIT_0P7X);
+
+	ret = sm5703_reg_read(charger->i2c, SM5703_STATUS3);
+	if (ret < 0)
+		pr_info("Error : can't get charging status (%d)\n", ret);
+
+	if (ret & SM5703_STATUS3_TOPOFF) {
+		pr_info("%s: W/A Charger already topoff state. Charger Off\n",
+				__func__);
+		sm5703_enable_charger_switch(charger, 0);
+		msleep(100);
+		sm5703_enable_charger_switch(charger, 1);
+	}
+
+	sm5703_test_read(charger->i2c);
+
+	return true;
+}
+
+
+static int sm5703_get_charging_status(struct sm5703_charger_data *charger)
+{
+	int status = POWER_SUPPLY_STATUS_UNKNOWN;
+	int ret;
+	int nCHG = 0;
+
+	ret = sm5703_reg_read(charger->i2c, SM5703_STATUS3);
+	if (ret<0) {
+		pr_info("Error : can't get charging status (%d)\n", ret);
+
+	}
+
+	nCHG = gpio_get_value(charger->pdata->chgen_gpio);
+
+	if ((ret & SM5703_STATUS3_DONE) || (ret & SM5703_STATUS3_TOPOFF)) {
+		status = POWER_SUPPLY_STATUS_FULL;
+		pr_info("%s : Status, Power Supply Full \n", __func__);
+	} else if (ret & SM5703_STATUS3_CHGON) {
+		status = POWER_SUPPLY_STATUS_CHARGING;    
+	} else {
+		if (nCHG)
+			status = POWER_SUPPLY_STATUS_DISCHARGING;
+		else
+			status = POWER_SUPPLY_STATUS_NOT_CHARGING;
+	}
+
+	/* TEMP_TEST : when OTG is enabled(charging_current -1), handle OTG func. */
+	if (charger->charging_current < 0) {
+		/* For OTG mode, SM5703 would still report "charging" */
+		status = POWER_SUPPLY_STATUS_DISCHARGING;
+		ret = sm5703_reg_read(charger->i2c, SM5703_STATUS1);
+		if (ret & SM5703_STATUS1_OTGFAIL) {
+			pr_info("%s: otg overcurrent limit\n", __func__);
+			sm5703_charger_otg_control(charger, false);
+		}
+
+	}
+
+	return status;
+}
+
+static int sm5703_get_charging_health(struct sm5703_charger_data *charger)
+{
+	int vbus_status = sm5703_reg_read(charger->i2c, SM5703_STATUS5);
+	int health = POWER_SUPPLY_HEALTH_GOOD;
+	int chg_cntl = 0, nCHG = 0;
+
+	pr_info("%s : charger->is_charging = %d, charger->cable_type = %d, charger->aicl_state = %d\n",
+		__func__, charger->is_charging, charger->cable_type, charger->aicl_state);
+
+	chg_cntl = sm5703_reg_read(charger->i2c, SM5703_CNTL);
+	nCHG = gpio_get_value(charger->pdata->chgen_gpio);
+	pr_info("%s: SM5703_CNTL, nCHG : 0x%x, %d\n", __func__, chg_cntl, nCHG);
+
+	/* temp for test */
+	pr_info("%s : vbus_status = %d\n", __func__, vbus_status);
+
+	if (vbus_status < 0) {
+		health = POWER_SUPPLY_HEALTH_UNKNOWN;
+		pr_info("%s : Health : %d, vbus_status : %d\n", __func__, health,vbus_status);
+
+		return (int)health;
+	}
+
+	if (vbus_status & SM5703_STATUS5_VBUSOK)
+		health = POWER_SUPPLY_HEALTH_GOOD;
+	else if (vbus_status & SM5703_STATUS5_VBUSOVP)
+		health = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+	else if (vbus_status & SM5703_STATUS5_VBUSUVLO)
+		health = POWER_SUPPLY_HEALTH_UNDERVOLTAGE;
+	else
+		health = POWER_SUPPLY_HEALTH_UNKNOWN;
+
+	pr_info("%s : Health : %d\n", __func__, health);
+
+	return (int)health;
+}
+
+static int sec_chg_get_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		union power_supply_propval *val)
+{
+
+	int chg_curr, aicr, vbus_status;
+	struct sm5703_charger_data *charger =
+		container_of(psy, struct sm5703_charger_data, psy_chg);
+
+	switch (psp) {
+		case POWER_SUPPLY_PROP_ONLINE:
+			vbus_status = sm5703_reg_read(charger->i2c, SM5703_STATUS5);
+			if (charger->cable_type != POWER_SUPPLY_TYPE_BATTERY &&
+				!(vbus_status & SM5703_STATUS5_VBUSOK))
+					charger->cable_type = POWER_SUPPLY_TYPE_BATTERY;
+
+			val->intval = charger->cable_type;
+			pr_info("%s: Charger Cable type : %d\n", __func__, charger->cable_type);
+			break;
+		case POWER_SUPPLY_PROP_STATUS:
+			val->intval = sm5703_get_charging_status(charger);
+			break;
+		case POWER_SUPPLY_PROP_HEALTH:
+			val->intval = sm5703_get_charging_health(charger);
+			break;
+		case POWER_SUPPLY_PROP_CURRENT_MAX:
+			sm5703_test_read(charger->i2c);
+			val->intval = sm5703_get_input_current_limit(charger);
+			break;
+		case POWER_SUPPLY_PROP_CURRENT_AVG:
+		case POWER_SUPPLY_PROP_CURRENT_NOW:
+			if (charger->charging_current) {
+				aicr = sm5703_get_input_current_limit(charger);
+				chg_curr = sm5703_get_fast_charging_current(charger);
+				val->intval = MINVAL(aicr, chg_curr);
+			} else
+				val->intval = 0;
+			break;
+		case POWER_SUPPLY_PROP_CURRENT_FULL:
+			val->intval = sm5703_get_topoff_current(charger);
+			break;
+#if defined(CONFIG_BATTERY_SWELLING)
+		case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+			val->intval = sm5703_get_regulation_voltage(charger);
+		break;
+#endif
+		case POWER_SUPPLY_PROP_CHARGE_TYPE:
+			if (!charger->is_charging || charger->cable_type == POWER_SUPPLY_TYPE_BATTERY) {
+				val->intval = POWER_SUPPLY_CHARGE_TYPE_NONE;
+			} else if (charger->input_current <= SLOW_CHARGING_CURRENT_STANDARD) {
+				val->intval = POWER_SUPPLY_CHARGE_TYPE_SLOW;
+				pr_info("%s: slow-charging mode\n", __func__);
+			} else
+				val->intval = POWER_SUPPLY_CHARGE_TYPE_FAST;
+			break;
+		case POWER_SUPPLY_PROP_CHARGING_ENABLED:
+			val->intval = charger->is_charging;
+			break;
+		case POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL:
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sec_chg_set_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		const union power_supply_propval *val)
+{
+	struct sm5703_charger_data *charger =
+		container_of(psy, struct sm5703_charger_data, psy_chg);
+	int buck_state = ENABLE;
+
+	switch (psp) {
+		case POWER_SUPPLY_PROP_STATUS:
+			charger->status = val->intval;
+			break;
+			/* val->intval : type */
+		case POWER_SUPPLY_PROP_ONLINE:
+			charger->cable_type = val->intval;
+			charger->aicl_state = false;
+#if ENABLE_AICL
+			sm5703_set_aicl_level(charger);
+#endif /*DISABLE_AICL*/
+			break;
+		case POWER_SUPPLY_PROP_CURRENT_MAX:
+			{
+				int input_current = val->intval;
+				sm5703_set_input_current_limit(charger, input_current);
+				charger->input_current = input_current;
+				pr_info("%s:[BATT] cable_type(%d), input_current(%d)\n",
+				__func__, charger->cable_type, charger->input_current);
+			}
+			break;
+		case POWER_SUPPLY_PROP_CURRENT_AVG:
+		case POWER_SUPPLY_PROP_CURRENT_NOW:
+			charger->charging_current = val->intval;
+			/* set charging current */
+			if (charger->is_charging) {
+				/* Fast charge and Termination current */
+				pr_info("%s : fast charging current (%dmA)\n",
+						__func__, charger->charging_current);
+				sm5703_set_fast_charging_current(charger, charger->charging_current);
+			}
+
+#if EN_TEST_READ
+			sm5703_test_read(charger->i2c);
+#endif
+			break;
+		case POWER_SUPPLY_PROP_CURRENT_FULL:
+			sm5703_set_topoff_current(charger, val->intval);
+			break;
+#if defined(CONFIG_BATTERY_SWELLING)
+		case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+			pr_info("%s: float voltage(%d)\n", __func__, val->intval);
+			charger->pdata->chg_float_voltage = val->intval;
+			sm5703_set_regulation_voltage(charger, val->intval);
+			break;
+#endif
+		case POWER_SUPPLY_PROP_HEALTH:
+			/* charger->ovp = val->intval; */
+			break;
+		case POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL:
+			sm5703_charger_otg_control(charger, val->intval);
+			break;
+		case POWER_SUPPLY_PROP_CHARGING_ENABLED:
+			charger->charge_mode = val->intval;
+			switch (charger->charge_mode) {
+			case SEC_BAT_CHG_MODE_BUCK_OFF:
+				buck_state = DISABLE;
+			case SEC_BAT_CHG_MODE_CHARGING_OFF:
+				charger->is_charging = false;
+				break;
+			case SEC_BAT_CHG_MODE_CHARGING:
+				charger->is_charging = true;
+				break;
+			}
+
+			if (buck_state == DISABLE) {
+				sm5703_enable_charger_switch(charger, charger->is_charging);
+				sm5703_assign_bits(charger->i2c,
+					SM5703_CNTL, SM5703_OPERATION_MODE_MASK,
+					SM5703_OPERATION_MODE_SUSPEND);
+				pr_info("%s: SM5703 OPERATION MODE SUSPEND\n",__func__);
+			} else {
+				sm5703_enable_charger_switch(charger, charger->is_charging);
+			}
+			break;
+		case POWER_SUPPLY_PROP_ENERGY_NOW:
+			/* charger off when jig detected */
+			if (val->intval)
+				sm5703_enable_charger_switch(charger, false);
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sm5703_otg_get_property(struct power_supply *psy,
+				enum power_supply_property psp,
+				union power_supply_propval *val)
+{
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = otg_enable_flag;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int sm5703_otg_set_property(struct power_supply *psy,
+				enum power_supply_property psp,
+				const union power_supply_propval *val)
+{
+	union power_supply_propval value;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		value.intval = val->intval;
+		pr_info("%s: OTG %s\n", __func__, value.intval > 0 ? "on" : "off");
+		psy_do_property("sm5703-charger", set,
+					POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL, value);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+ssize_t sm5703_chg_show_attrs(struct device *dev,
+		const ptrdiff_t offset, char *buf)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct sm5703_charger_data *charger =
+		container_of(psy, struct sm5703_charger_data, psy_chg);
+	int i = 0;
+	char *str = NULL;
+
+	switch (offset) {
+	case CHG_REG:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%x\n",
+				charger->reg_addr);
+		break;
+	case CHG_DATA:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%x\n",
+				charger->reg_data);
+		break;
+	case CHG_REGS:
+		str = kzalloc(sizeof(char) * 256, GFP_KERNEL);
+		if (!str)
+			return -ENOMEM;
+
+		sm5703_read_regs(charger->i2c, str);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%s\n",
+				str);
+
+		kfree(str);
+		break;
+	default:
+		i = -EINVAL;
+		break;
+	}
+
+	return i;
+}
+
+ssize_t sm5703_chg_store_attrs(struct device *dev,
+		const ptrdiff_t offset,
+		const char *buf, size_t count)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct sm5703_charger_data *charger =
+		container_of(psy, struct sm5703_charger_data, psy_chg);
+
+	int ret = 0;
+	int x = 0;
+	uint8_t data = 0;
+
+	switch (offset) {
+	case CHG_REG:
+		if (sscanf(buf, "%x\n", &x) == 1) {
+			charger->reg_addr = x;
+			data = sm5703_reg_read(charger->i2c,
+					charger->reg_addr);
+			charger->reg_data = data;
+			dev_dbg(dev, "%s: (read) addr = 0x%x, data = 0x%x\n",
+					__func__, charger->reg_addr, charger->reg_data);
+			ret = count;
+		}
+		break;
+	case CHG_DATA:
+		if (sscanf(buf, "%x\n", &x) == 1) {
+			data = (u8)x;
+
+			dev_dbg(dev, "%s: (write) addr = 0x%x, data = 0x%x\n",
+					__func__, charger->reg_addr, data);
+			ret = sm5703_reg_write(charger->i2c,
+					charger->reg_addr, data);
+			if (ret < 0) {
+				dev_dbg(dev, "I2C write fail Reg0x%x = 0x%x\n",
+						(int)charger->reg_addr, (int)data);
+			}
+			ret = count;
+		}
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+struct sm5703_chg_irq_handler {
+	char *name;
+	int irq_index;
+	irqreturn_t (*handler)(int irq, void *data);
+};
+#if EN_NOBAT_IRQ
+static irqreturn_t sm5703_chg_nobat_irq_handler(int irq, void *data)
+{
+	struct sm5703_charger_data *info = data;
+	struct i2c_client *iic = info->sm5703->i2c_client;
+
+	/* set full charged flag
+	 * until TA/USB unplug event / stop charging by PSY
+	 */
+
+	pr_info("%s : Nobat\n", __func__);
+
+#if EN_TEST_READ
+	sm5703_test_read(iic);
+#endif
+
+	return IRQ_HANDLED;
+}
+#endif /*EN_NOBAT_IRQ*/
+
+#if EN_DONE_IRQ
+static irqreturn_t sm5703_chg_done_irq_handler(int irq, void *data)
+{
+	struct sm5703_charger_data *info = data;
+	struct i2c_client *iic = info->sm5703->i2c_client;
+
+	/* set full charged flag
+	 * until TA/USB unplug event / stop charging by PSY
+	 */
+
+	pr_info("%s : Full charged(done)\n", __func__);
+
+#if EN_TEST_READ
+	sm5703_test_read(iic);
+#endif
+
+	return IRQ_HANDLED;
+}
+#endif/*EN_DONE_IRQ*/
+
+#if EN_TOPOFF_IRQ
+static irqreturn_t sm5703_chg_topoff_irq_handler(int irq, void *data)
+{
+	struct sm5703_charger_data *info = data;
+	struct i2c_client *iic = info->sm5703->i2c_client;
+
+	/* set full charged flag
+	 * until TA/USB unplug event / stop charging by PSY
+	 */
+
+	pr_info("%s : Full charged(topoff)\n", __func__);
+
+#if EN_TEST_READ
+	sm5703_test_read(iic);
+#endif
+
+	return IRQ_HANDLED;
+}
+#endif /*EN_TOPOFF_IRQ*/
+
+static void sm5703_chg_aicl_work(struct work_struct *work)
+{
+	struct sm5703_charger_data *charger =
+		container_of(work, struct sm5703_charger_data, aicl_work.work);
+	int reg_data = 0, temp = 0, aicl_state;
+	int current_limit = charger->input_current;
+
+	mutex_lock(&charger->io_lock);
+	/* disable aicl irq */
+	sm5703_assign_bits(charger->i2c, SM5703_INTMSK1, 0x01, 0x01);
+
+	/* reduce input current */
+	reg_data = sm5703_reg_read(charger->i2c, SM5703_VBUSCNTL);
+	reg_data &= ~SM5703_VBUSLIMIT;
+	do {
+		current_limit -= REDUCE_CURRENT_STEP;
+		temp = ((current_limit - 100) / 50) | reg_data;
+		sm5703_reg_write(charger->i2c, SM5703_VBUSCNTL, temp);
+		msleep(200);
+		aicl_state = sm5703_reg_read(charger->i2c, SM5703_STATUS1) & 0x01;
+		pr_info("%s: aicl state(%d), current limit(%d), max(%d)\n",
+			__func__, aicl_state, current_limit, charger->input_current);
+	} while (aicl_state && current_limit > MINIMUM_INPUT_CURRENT);
+	charger->input_current = current_limit;
+
+	/* check slow charging */
+	if (charger->input_current <= SLOW_CHARGING_CURRENT_STANDARD &&
+		charger->cable_type != POWER_SUPPLY_TYPE_BATTERY) {
+		union power_supply_propval value;
+		psy_do_property("battery", set,
+			POWER_SUPPLY_PROP_CHARGE_TYPE, value);
+		pr_info("%s: slow charging on : input current(%dmA), cable type(%d)\n",
+			__func__, charger->input_current, charger->cable_type);
+	}
+
+	/* enable aicl irq */
+	sm5703_assign_bits(charger->i2c, SM5703_INTMSK1, 0x01, 0x00);
+	mutex_unlock(&charger->io_lock);
+
+	wake_unlock(&charger->aicl_wake_lock);
+}
+
+#if EN_AICL_IRQ
+static irqreturn_t sm5703_chg_aicl_irq_handler(int irq, void *data)
+{
+	struct sm5703_charger_data *info = data;
+	struct i2c_client *iic = info->sm5703->i2c_client;
+
+#if EN_TEST_READ
+	sm5703_test_read(iic);
+#endif
+
+	pr_info("%s: cable type:%d, current max:%d, aicl_state:%d\n",
+		__func__, info->cable_type, info->input_current, info->aicl_state);
+
+	if (info->cable_type != POWER_SUPPLY_TYPE_BATTERY &&
+		info->input_current > MINIMUM_INPUT_CURRENT &&
+		!info->aicl_state) {
+		info->aicl_state = true;
+		wake_lock(&info->aicl_wake_lock);
+		queue_delayed_work_on(0, info->wq, &info->aicl_work, msecs_to_jiffies(50));
+	}
+	return IRQ_HANDLED;
+}
+#endif
+
+#if EN_CHGON_IRQ
+static irqreturn_t sm5703_chg_chgon_irq_handler(int irq, void *data)
+{
+	struct sm5703_charger_data *info = data;
+	struct i2c_client *iic = info->sm5703->i2c_client;
+
+	pr_info("%s : Chgon\n", __func__);
+
+#if EN_TEST_READ
+	sm5703_test_read(iic);
+#endif
+
+	return IRQ_HANDLED;
+}
+#endif /*EN_CHGON_IRQ*/
+
+#if EN_OTGFAIL_IRQ
+static irqreturn_t sm5703_chg_otgfail_irq_handler(int irq, void *data)
+{
+	struct sm5703_charger_data *info = data;
+	/* struct i2c_client *iic = info->sm5703->i2c_client; */
+	int ret;
+
+#ifdef CONFIG_USB_HOST_NOTIFY
+	struct otg_notify *o_notify;
+
+	o_notify = get_otg_notify();
+#endif
+	pr_info("%s : OTG Failed\n", __func__);
+
+	ret = sm5703_reg_read(info->sm5703->i2c_client, SM5703_STATUS1);
+	if (ret & SM5703_STATUS1_OTGFAIL) {
+		pr_info("%s: otg overcurrent limit\n", __func__);
+#ifdef CONFIG_USB_HOST_NOTIFY
+		send_otg_notify(o_notify, NOTIFY_EVENT_OVERCURRENT, 0);
+#endif
+		sm5703_charger_otg_control(info, false);
+	}
+
+	return IRQ_HANDLED;
+}
+#endif /*EN_CHGON_IRQ*/
+
+const struct sm5703_chg_irq_handler sm5703_chg_irq_handlers[] = {
+#if EN_NOBAT_IRQ    
+	{
+		.name = "NOBAT",
+		.handler = sm5703_chg_nobat_irq_handler,
+		.irq_index = SM5703_NOBAT_IRQ,
+	},
+#endif /*EN_NOBAT_IRQ*/
+#if EN_DONE_IRQ
+	{
+		.name = "DONE",
+		.handler = sm5703_chg_done_irq_handler,
+		.irq_index = SM5703_DONE_IRQ,
+	},
+#endif/*EN_DONE_IRQ*/	
+#if EN_TOPOFF_IRQ	
+	{
+		.name = "TOPOFF",
+		.handler = sm5703_chg_topoff_irq_handler,
+		.irq_index = SM5703_TOPOFF_IRQ,
+	},
+#endif /*EN_TOPOFF_IRQ*/
+#if EN_CHGON_IRQ
+	{
+		.name = "CHGON",
+		.handler = sm5703_chg_chgon_irq_handler,
+		.irq_index = SM5703_CHGON_IRQ,
+	},
+#endif /*EN_CHGON_IRQ*/
+#if EN_AICL_IRQ
+	{
+		.name = SM5703_AICL_IRQ_NAME,
+		.handler = sm5703_chg_aicl_irq_handler,
+		.irq_index = SM5703_AICL_IRQ,
+	},
+#endif /* EN_AICL_IRQ */
+#if EN_OTGFAIL_IRQ
+	{
+		.name = "OTGFAIL",
+		.handler = sm5703_chg_otgfail_irq_handler,
+		.irq_index = SM5703_OTGFAIL_IRQ,
+	},
+#endif /* EN_OTGFAIL_IRQ */
+};
+
+
+static int register_irq(struct platform_device *pdev,
+		struct sm5703_charger_data *info)
+{
+	int irq;
+	int i, j;
+	int ret;
+	const struct sm5703_chg_irq_handler *irq_handler = sm5703_chg_irq_handlers;
+	const char *irq_name;
+	for (i = 0; i < ARRAY_SIZE(sm5703_chg_irq_handlers); i++) {
+		irq_name = sm5703_get_irq_name_by_index(irq_handler[i].irq_index);
+		irq = platform_get_irq_byname(pdev, irq_name);
+		ret = request_threaded_irq(irq, NULL, irq_handler[i].handler,
+				IRQF_ONESHOT | IRQF_TRIGGER_FALLING |
+				IRQF_NO_SUSPEND, irq_name, info);
+		if (ret < 0) {
+			pr_err("%s : Failed to request IRQ (%s): #%d: %d\n",
+					__func__, irq_name, irq, ret);
+			goto err_irq;
+		}
+
+		pr_info("%s : Register IRQ%d(%s) successfully\n",
+				__func__, irq, irq_name);
+	}
+
+	return 0;
+err_irq:
+	for (j = 0; j < i; j++) {
+		irq_name = sm5703_get_irq_name_by_index(irq_handler[j].irq_index);
+		irq = platform_get_irq_byname(pdev, irq_name);
+		free_irq(irq, info);
+	}
+
+	return ret;
+}
+
+static void unregister_irq(struct platform_device *pdev,
+		struct sm5703_charger_data *info)
+{
+	int irq;
+	int i;
+	const char *irq_name;
+	const struct sm5703_chg_irq_handler *irq_handler = sm5703_chg_irq_handlers;
+
+	for (i = 0; i < ARRAY_SIZE(sm5703_chg_irq_handlers); i++) {
+		irq_name = sm5703_get_irq_name_by_index(irq_handler[i].irq_index);
+		irq = platform_get_irq_byname(pdev, irq_name);
+		free_irq(irq, info);
+	}
+}
+
+#ifdef CONFIG_OF
+static int sec_bat_read_u32_index_dt(const struct device_node *np,
+		const char *propname,
+		u32 index, u32 *out_value)
+{
+	struct property *prop = of_find_property(np, propname, NULL);
+	u32 len = (index + 1) * sizeof(*out_value);
+
+	if (!prop)
+		return (-EINVAL);
+	if (!prop->value)
+		return (-ENODATA);
+	if (len > prop->length)
+		return (-EOVERFLOW);
+
+	*out_value = be32_to_cpup(((__be32 *)prop->value) + index);
+
+	return 0;
+}
+
+static int sm5703_charger_parse_dt(struct device *dev,
+		struct sm5703_charger_platform_data *pdata)
+{
+	struct device_node *np = of_find_node_by_name(NULL, "charger");
+	const u32 *p;
+	int ret, i, len;
+
+	ret = of_property_read_u32(np, "chg_autostop", &pdata->chg_autostop);
+	if (ret < 0) {
+		pr_info("%s : cannot get chg autostop\n", __func__);
+		pdata->chg_autostop = 0;
+	}
+
+	ret = of_property_read_u32(np, "chg_autoset", &pdata->chg_autoset);
+	if (ret < 0) {
+		pr_info("%s : cannot get chg autoset\n", __func__);
+		pdata->chg_autoset = 0;
+	}
+
+	ret = of_property_read_u32(np, "chg_aiclen", &pdata->chg_aiclen);
+	if (ret < 0) {
+		pr_info("%s : cannot get chg aiclen\n", __func__);
+		pdata->chg_aiclen = 0;
+	}
+
+	ret = of_property_read_u32(np, "chg_aiclth", &pdata->chg_aiclth);
+	if (ret < 0) {
+		pr_info("%s : cannot get chg aiclth\n", __func__);
+		pdata->chg_aiclth = 4500;
+	}
+
+	ret = of_property_read_u32(np, "fg_vol_val", &pdata->fg_vol_val);
+	if (ret < 0) {
+		pr_info("%s : cannot get fg_vol_val\n", __func__);
+		pdata->fg_vol_val = 4350;
+	}
+
+	ret = of_property_read_u32(np, "fg_soc_val", &pdata->fg_soc_val);
+	if (ret < 0) {
+		pr_info("%s : cannot get fg_soc_val\n", __func__);
+		pdata->fg_soc_val = 95;
+	}
+
+	ret = of_property_read_u32(np, "fg_curr_avr_val",
+		&pdata->fg_curr_avr_val);
+	if (ret < 0) {
+		pr_info("%s : cannot get fg_curr_avr_val\n", __func__);
+		pdata->fg_curr_avr_val = 150;
+	}
+
+	ret = of_property_read_u32(np, "battery,chg_float_voltage",
+			&pdata->chg_float_voltage);
+	if (ret < 0) {
+		pr_info("%s : cannot get chg float voltage\n", __func__);
+		pdata->chg_float_voltage = 4350;
+	}
+
+	pdata->chgen_gpio = of_get_named_gpio(np, "battery,chg_gpio_en", 0);
+	if (pdata->chgen_gpio < 0) {
+		pr_err("%s : cannot get chgen gpio : %d\n",
+			__func__, pdata->chgen_gpio);
+		return -ENODATA;	
+	} else {
+		pr_info("%s: chgen gpio : %d\n", __func__, pdata->chgen_gpio);
+	}
+
+	np = of_find_node_by_name(NULL, "battery");
+	if (!np) {
+		pr_info("%s : np NULL\n", __func__);
+		return -ENODATA;
+	}
+
+	ret = of_property_read_string(np,
+		"battery,charger_name", (char const **)&pdata->charger_name);
+	if (ret) {
+		pdata->charger_name = "sm5703-charger";
+		pr_info("%s: Charger name is Empty. Set default.\n", __func__);
+	}
+
+	ret = of_property_read_u32(np, "battery,full_check_type_2nd",
+			&pdata->full_check_type_2nd);
+	if (ret)
+		pr_info("%s : Full check type 2nd is Empty\n", __func__);
+
+	p = of_get_property(np, "battery,input_current_limit", &len);
+
+	len = len / sizeof(u32);
+
+	pdata->charging_current =
+		kzalloc(sizeof(sec_charging_current_t) * len, GFP_KERNEL);
+
+	for(i = 0; i < len; i++) {
+		ret = sec_bat_read_u32_index_dt(np,
+			"battery,input_current_limit", i,
+			&pdata->charging_current[i].input_current_limit);
+	}
+
+	dev_info(dev,"sm5703 charger parse dt retval = %d\n", ret);
+	return ret;
+}
+
+static struct of_device_id sm5703_charger_match_table[] = {
+	{ .compatible = "siliconmitus,sm5703-charger",},
+	{},
+};
+#else
+static int sm5703_charger_parse_dt(struct device *dev,
+		struct sm5703_charger_platform_data *pdata)
+{
+	return -ENOSYS;
+}
+#define sm5703_charger_match_table NULL
+#endif /* CONFIG_OF */
+
+static int sm5703_charger_probe(struct platform_device *pdev)
+{
+	sm5703_mfd_chip_t *chip = dev_get_drvdata(pdev->dev.parent);
+#ifndef CONFIG_OF
+	struct sm5703_mfd_platform_data *mfd_pdata =
+				dev_get_platdata(chip->dev);
+#endif	
+	struct sm5703_charger_data *charger;
+	int ret = 0;
+
+	otg_enable_flag = 0;
+
+	pr_info("%s:[BATT] SM5703 Charger driver probe..\n", __func__);
+
+	charger = kzalloc(sizeof(*charger), GFP_KERNEL);
+	if (!charger)
+		return -ENOMEM;
+
+	mutex_init(&charger->io_lock);
+	charger->sm5703= chip;
+	charger->i2c = chip->i2c_client;
+
+#ifdef CONFIG_OF	
+	charger->pdata = devm_kzalloc(&pdev->dev,
+			sizeof(*(charger->pdata)), GFP_KERNEL);
+	if (!charger->pdata) {
+		dev_err(&pdev->dev, "Failed to allocate memory\n");
+		ret = -ENOMEM;
+		goto err_parse_dt_nomem;
+	}
+	ret = sm5703_charger_parse_dt(&pdev->dev, charger->pdata);
+	if (ret < 0)
+		goto err_parse_dt;
+#else		
+	charger->pdata = mfd_pdata->charger_platform_data;
+#endif
+
+	platform_set_drvdata(pdev, charger);
+
+	if (charger->pdata->charger_name == NULL)
+		charger->pdata->charger_name = "sm5703-charger";
+
+	charger->psy_chg.name			= charger->pdata->charger_name;
+	charger->psy_chg.type			= POWER_SUPPLY_TYPE_UNKNOWN;
+	charger->psy_chg.get_property	= sec_chg_get_property;
+	charger->psy_chg.set_property	= sec_chg_set_property;
+	charger->psy_chg.properties		= sec_charger_props;
+	charger->psy_chg.num_properties	= ARRAY_SIZE(sec_charger_props);
+	charger->psy_otg.name			= "otg";
+	charger->psy_otg.type			= POWER_SUPPLY_TYPE_OTG;
+	charger->psy_otg.get_property	= sm5703_otg_get_property;
+	charger->psy_otg.set_property	= sm5703_otg_set_property;
+	charger->psy_otg.properties		= sm5703_otg_props;
+	charger->psy_otg.num_properties	= ARRAY_SIZE(sm5703_otg_props);
+
+	charger->ovp = 0;
+	charger->is_mdock = false;
+	sm5703_chg_init(charger);
+
+	charger->wq = create_workqueue("sm5703chg_workqueue");
+	wake_lock_init(&charger->aicl_wake_lock, WAKE_LOCK_SUSPEND, "sm5703-aicl");
+#if EN_AICL_IRQ
+	INIT_DELAYED_WORK(&charger->aicl_work, sm5703_chg_aicl_work);
+#endif
+	ret = power_supply_register(&pdev->dev, &charger->psy_chg);
+	if (ret) {
+		pr_err("%s: Failed to Register psy_chg\n", __func__);
+		goto err_power_supply_register;
+	}
+
+	ret = power_supply_register(&pdev->dev, &charger->psy_otg);
+	if (ret) {
+		pr_err("%s: Failed to Register otg_chg\n", __func__);
+		goto err_power_supply_register_otg;
+	}
+
+	ret = register_irq(pdev, charger);
+	if (ret < 0)
+		goto err_reg_irq;
+
+	ret = gpio_request(charger->pdata->chgen_gpio, "sm5703_nCHGEN");
+	if (ret) {
+		pr_info("%s : Request GPIO %d failed\n",
+				__func__, (int)charger->pdata->chgen_gpio);
+	}
+
+	sm5703_test_read(charger->i2c);
+	pr_info("%s:[BATT] SM5703 charger driver loaded OK\n", __func__);
+
+	return 0;
+err_reg_irq:
+	power_supply_unregister(&charger->psy_otg);
+err_power_supply_register_otg:
+	power_supply_unregister(&charger->psy_chg);
+err_power_supply_register:
+	destroy_workqueue(charger->wq);
+	wake_lock_destroy(&charger->aicl_wake_lock);
+err_parse_dt:
+err_parse_dt_nomem:
+	mutex_destroy(&charger->io_lock);
+	kfree(charger);
+	return ret;
+}
+
+static int sm5703_charger_remove(struct platform_device *pdev)
+{
+	struct sm5703_charger_data *charger =
+		platform_get_drvdata(pdev);
+	unregister_irq(pdev, charger);
+	power_supply_unregister(&charger->psy_chg);
+	destroy_workqueue(charger->wq);
+	wake_lock_destroy(&charger->aicl_wake_lock);
+	mutex_destroy(&charger->io_lock);
+	kfree(charger);
+	return 0;
+}
+
+#if defined CONFIG_PM
+static int sm5703_charger_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int sm5703_charger_resume(struct device *dev)
+{
+	return 0;
+}
+#else
+#define sm5703_charger_suspend NULL
+#define sm5703_charger_resume NULL
+#endif
+
+static void sm5703_charger_shutdown(struct device *dev)
+{
+	pr_info("%s: SM5703 Charger driver shutdown\n", __func__);
+}
+
+static SIMPLE_DEV_PM_OPS(sm5703_charger_pm_ops, sm5703_charger_suspend,
+		sm5703_charger_resume);
+
+static struct platform_driver sm5703_charger_driver = {
+	.driver		= {
+		.name	= "sm5703-charger",
+		.owner	= THIS_MODULE,
+		.of_match_table = sm5703_charger_match_table,
+		.pm		= &sm5703_charger_pm_ops,
+		.shutdown = sm5703_charger_shutdown,
+	},
+	.probe		= sm5703_charger_probe,
+	.remove		= sm5703_charger_remove,
+};
+
+static int __init sm5703_charger_init(void)
+{
+	int ret = 0;
+
+	pr_info("%s \n", __func__);
+	ret = platform_driver_register(&sm5703_charger_driver);
+
+	return ret;
+}
+device_initcall(sm5703_charger_init);
+
+static void __exit sm5703_charger_exit(void)
+{
+	platform_driver_unregister(&sm5703_charger_driver);
+}
+module_exit(sm5703_charger_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Charger driver for SM5703");
diff -Naur linux-3.18.14/drivers/battery_v2/sm5703_fuelgauge.c samsung/drivers/battery_v2/sm5703_fuelgauge.c
--- linux-3.18.14/drivers/battery_v2/sm5703_fuelgauge.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/sm5703_fuelgauge.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,1925 @@
+/* drivers/battery/sm5703_fuelgauge.c
+ * SM5703 Voltage Tracking Fuelgauge Driver
+ *
+ * Copyright (C) 2013
+ * Author: Dongik Sin <dongik.sin@samsung.com>
+ * Modified by SW Jung
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ */
+#include "include/fuelgauge/sm5703_fuelgauge.h"
+#include "include/fuelgauge/sm5703_fuelgauge_impl.h"
+#if defined(CONFIG_STMP_SUPPORT_FG_ALERT)
+#include <linux/input/stmpe1801_key.h>
+#endif
+#include <linux/uaccess.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/fs.h>
+#include <linux/math64.h>
+#include <linux/compiler.h>
+
+#define FG_DET_BAT_PRESENT 1
+
+#define MINVAL(a, b) ((a <= b) ? a : b)
+
+static void sm5703_fuelgauge_fuelalert_init(struct sm5703_fuelgauge_data *fuelgauge,
+		int soc);
+
+static void fg_vbatocv_check(struct i2c_client *client);
+
+enum battery_table_type {
+	DISCHARGE_TABLE = 0,
+	CHARGE_TABLE,
+	Q_TABLE,
+	TABLE_MAX,
+};
+
+static enum power_supply_property sm5703_fuelgauge_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_VOLTAGE_AVG,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CURRENT_AVG,
+	POWER_SUPPLY_PROP_CHARGE_FULL,
+	POWER_SUPPLY_PROP_ENERGY_NOW,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_TEMP_AMBIENT,
+	POWER_SUPPLY_PROP_CAPACITY_LEVEL,
+};
+
+static bool sm5703_fg_reg_init(struct sm5703_fuelgauge_data *fuelgauge,
+                int manual_ocv_write);
+
+static inline int sm5703_fg_read_device(struct i2c_client *client,
+		int reg, int bytes, void *dest)
+{
+	int ret;
+
+	if (bytes > 1)
+		ret = i2c_smbus_read_i2c_block_data(client, reg, bytes, dest);
+	else {
+		ret = i2c_smbus_read_byte_data(client, reg);
+		if (ret < 0)
+			return ret;
+		*(unsigned char *)dest = (unsigned char)ret;
+	}
+	return ret;
+}
+
+static int32_t sm5703_fg_i2c_read_word(struct i2c_client *client,
+		uint8_t reg_addr)
+{
+	uint16_t data = 0;
+	int ret;
+	ret = sm5703_fg_read_device(client, reg_addr, 2, &data);
+	/* dev_dbg(&client->dev, "%s: ret = %d, addr = 0x%x, data = 0x%x\n",
+			__func__, ret, reg_addr, data); */
+
+	if (ret < 0)
+		return ret;
+	else
+		return data;
+
+	/* not use big endian */
+	/* return (int32_t)be16_to_cpu(data); */
+}
+
+static int32_t sm5703_fg_i2c_write_word(struct i2c_client *client,
+		uint8_t reg_addr,uint16_t data)
+{
+	int ret;
+
+	/* not use big endian */
+	/* data = cpu_to_be16(data); */
+	ret = i2c_smbus_write_i2c_block_data(client, reg_addr,
+		2, (uint8_t *)&data);
+
+	/* dev_dbg(&client->dev, "%s: ret = %d, addr = 0x%x, data = 0x%x\n",
+			__func__, ret, reg_addr, data);
+	*/
+
+	return ret;
+}
+
+#if 0
+static void sm5703_pr_ver_info(struct i2c_client *client)
+{
+	dev_info(&client->dev, "SM5703 Fuel-Gauge Ver %s\n", FG_DRIVER_VER);
+}
+#endif
+
+static void sm5703_fg_test_read(struct i2c_client *client)
+{
+	int ret, ret1, ret2, ret3, ret4;
+
+	ret = sm5703_fg_i2c_read_word(client, 0x30);
+	dev_info(&client->dev, "%s: sm5703 FG 0x30 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(client, 0x31);
+	dev_info(&client->dev, "%s: sm5703 FG 0x31 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(client, 0x32);
+	dev_info(&client->dev, "%s: sm5703 FG 0x32 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(client, 0x33);
+	dev_info(&client->dev, "%s: sm5703 FG 0x33 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(client, 0x34);
+	dev_info(&client->dev, "%s: sm5703 FG 0x34 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(client, 0x35);
+	dev_info(&client->dev, "%s: sm5703 FG 0x35 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(client, 0x36);
+	dev_info(&client->dev, "%s: sm5703 FG 0x36 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(client, 0x37);
+	dev_info(&client->dev, "%s: sm5703 FG 0x37 = 0x%x \n", __func__, ret);
+
+	ret = sm5703_fg_i2c_read_word(client, 0x40);
+	dev_info(&client->dev, "%s: sm5703 FG 0x40 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(client, 0x41);
+	dev_info(&client->dev, "%s: sm5703 FG 0x41 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(client, 0x42);
+	dev_info(&client->dev, "%s: sm5703 FG 0x42 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(client, 0x43);
+	dev_info(&client->dev, "%s: sm5703 FG 0x43 = 0x%x \n", __func__, ret);
+
+	ret1 = sm5703_fg_i2c_read_word(client, 0xAC);
+	ret2 = sm5703_fg_i2c_read_word(client, 0xAD);
+	ret3 = sm5703_fg_i2c_read_word(client, 0xAE);
+	ret4 = sm5703_fg_i2c_read_word(client, 0xAF);
+	pr_info("0xAC=0x%04x, 0xAD=0x%04x, 0xAE=0x%04x, 0xAF=0x%04x \n", ret1, ret2, ret3, ret4);
+
+	ret1 = sm5703_fg_i2c_read_word(client, 0xBC);
+	ret2 = sm5703_fg_i2c_read_word(client, 0xBD);
+	ret3 = sm5703_fg_i2c_read_word(client, 0xBE);
+	ret4 = sm5703_fg_i2c_read_word(client, 0xBF);
+	pr_info("0xBC=0x%04x, 0xBD=0x%04x, 0xBE=0x%04x, 0xBF=0x%04x \n", ret1, ret2, ret3, ret4);
+
+	ret1 = sm5703_fg_i2c_read_word(client, 0xCC);
+	ret2 = sm5703_fg_i2c_read_word(client, 0xCD);
+	ret3 = sm5703_fg_i2c_read_word(client, 0xCE);
+	ret4 = sm5703_fg_i2c_read_word(client, 0xCF);
+	pr_info("0xCC=0x%04x, 0xCD=0x%04x, 0xCE=0x%04x, 0xCF=0x%04x \n", ret1, ret2, ret3, ret4);
+
+	ret1 = sm5703_fg_i2c_read_word(client, 0x85);
+	ret2 = sm5703_fg_i2c_read_word(client, 0x86);
+	ret3 = sm5703_fg_i2c_read_word(client, 0x87);
+	ret4 = sm5703_fg_i2c_read_word(client, 0x28);
+	pr_info("0x85=0x%04x, 0x86=0x%04x, 0x87=0x%04x, 0x28=0x%04x \n", ret1, ret2, ret3, ret4);
+}
+
+static int sm5703_get_temperature(struct sm5703_fuelgauge_data *fuelgauge)
+{
+	int ret;
+
+	int temp;/* = 250; 250 means 25.0oC*/
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, SM5703_REG_TEMPERATURE);
+	if (ret<0) {
+		pr_err("%s: read temp reg fail", __func__);
+		temp = 0;
+	} else {
+		/* integer bit */
+		temp = ((ret & 0x7F00) >> 8) * 10;
+		/* integer + fractional bit */
+		temp = temp + (((ret & 0x00ff) * 10) / 256);
+		if (ret & 0x8000) {
+			temp *= -1;
+		}
+	}
+	fuelgauge->info.temperature = temp;
+
+	dev_info(&fuelgauge->i2c->dev,
+		"%s: read = 0x%x, temperature = %d\n", __func__, ret, temp);
+
+	return temp;
+}
+
+static unsigned int sm5703_get_ocv(struct sm5703_fuelgauge_data *fuelgauge)
+{
+	int ret;
+	unsigned int ocv;/* = 3500; 3500 means 3500mV */
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, SM5703_REG_OCV);
+	if (ret<0) {
+		pr_err("%s: read ocv reg fail\n", __func__);
+		ocv = 4000;
+	} else {
+		/* integer bit */
+		ocv = ((ret&0x0700)>>8) * 1000;
+		/* integer + fractional bit */
+		ocv = ocv + (((ret&0x00ff)*1000)/256);
+	}
+
+	fuelgauge->info.batt_ocv = ocv;
+
+	dev_info(&fuelgauge->i2c->dev, "%s: read = 0x%x, ocv = %d\n", __func__, ret, ocv);
+
+	return ocv;
+}
+
+static u32 sm5703_get_soc(struct sm5703_fuelgauge_data *fuelgauge)
+{
+	int ret;
+	u32 soc;
+	int ta_exist;
+	int curr_cal;
+	int temp_cal_fact;
+	union power_supply_propval value;
+
+	fg_vbatocv_check(fuelgauge->i2c);
+
+	ta_exist = fuelgauge->is_charging && (fuelgauge->info.batt_current >= 0);
+
+	dev_dbg(&fuelgauge->i2c->dev, "%s: is_charging = %d, ta_exist = %d\n", __func__, fuelgauge->is_charging, ta_exist);
+
+	if(ta_exist)
+		curr_cal = fuelgauge->info.curr_cal + (fuelgauge->info.charge_offset_cal << 8);
+	else
+		curr_cal = fuelgauge->info.curr_cal;
+	dev_dbg(&fuelgauge->i2c->dev, "%s: curr_cal = 0x%x\n", __func__, curr_cal);
+
+	/* abnormal case.... SW reset */
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, SM5703_REG_FG_OP_STATUS);
+	if ((ret & 0x00FF) != DISABLE_RE_INIT) {
+		ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, SM5703_REG_CNTL);
+		pr_info( "%s: SM5703 FG abnormal case!!!! SM5703_REG_CNTL : 0x%x\n", __func__, ret);
+		if (ret == 0x2008) {
+			pr_info( "%s: SM5703 FG abnormal case.... SW reset\n", __func__);
+			/* SW reset code */
+			sm5703_fg_i2c_write_word(fuelgauge->i2c, 0x90, 0x0008);
+			/* delay 200ms */
+			msleep(200);
+			/* init code */
+			sm5703_fg_reg_init(fuelgauge, 1);
+		}
+	}
+
+	sm5703_get_temperature(fuelgauge);
+	sm5703_get_ocv(fuelgauge);
+	temp_cal_fact = fuelgauge->info.temp_std - (fuelgauge->info.temperature / 10);
+	temp_cal_fact = temp_cal_fact / fuelgauge->info.temp_offset;
+	temp_cal_fact = temp_cal_fact * fuelgauge->info.temp_offset_cal;
+	curr_cal = curr_cal + (temp_cal_fact << 8);
+
+	/* compensate soc in case of low bat_temp */
+	psy_do_property("battery", get, POWER_SUPPLY_PROP_TEMP, value);
+	if ((value.intval / 10) < 25) {
+		curr_cal = curr_cal + ((((25 - (value.intval / 10)) / 6) * 3) << 8);
+	}
+
+	dev_info(&fuelgauge->i2c->dev, "%s: fg_get_soc : temp_std = %d, temperature = %d, temp_offset = %d, temp_offset_cal = 0x%x, curr_cal = 0x%x, bat_temp = %d\n",
+		__func__, fuelgauge->info.temp_std, fuelgauge->info.temperature, fuelgauge->info.temp_offset, fuelgauge->info.temp_offset_cal, curr_cal, value.intval);
+
+	sm5703_fg_i2c_write_word(fuelgauge->i2c, SM5703_REG_CURR_CAL, curr_cal);
+
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, SM5703_REG_SOC);
+	if (ret < 0) {
+		pr_err("%s: read soc reg fail\n", __func__);
+		soc = 500;
+	} else {
+		/* integer bit */
+		soc = ((ret & 0xff00) >> 8) * 10;
+		/* integer + fractional bit */
+		soc = soc + (((ret & 0x00ff) * 10) / 256);
+	}
+
+	fuelgauge->info.batt_soc = soc;
+
+	dev_info(&fuelgauge->i2c->dev, "%s: read = 0x%x, soc = %d\n", __func__, ret, soc);
+
+	/* temp for SM5703 FG debug */
+	sm5703_fg_test_read(fuelgauge->i2c);
+
+	return soc;
+}
+
+static unsigned int sm5703_get_vbat(struct sm5703_fuelgauge_data *fuelgauge)
+{
+	int ret;
+
+	unsigned int vbat;/* = 3500; 3500 means 3500mV*/
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, SM5703_REG_VOLTAGE);
+	if (ret < 0) {
+		pr_err("%s: read vbat reg fail", __func__);
+		vbat = 4000;
+	} else {
+		/* integer bit */
+		vbat = ((ret & 0x0700) >> 8) * 1000;
+		/* integer + fractional bit */
+		vbat = vbat + (((ret&0x00ff) * 1000) / 256);
+	}
+
+	fuelgauge->info.batt_voltage = vbat;
+
+	if ((fuelgauge->force_dec_mode == SM5703_COLD_MODE) && vbat > 3400) {
+		fuelgauge->force_dec_mode = SM5703_RECOVERY_MODE;
+		wake_unlock(&fuelgauge->fuel_alert_wake_lock);
+		sm5703_fuelgauge_fuelalert_init(fuelgauge,
+				fuelgauge->pdata->fuel_alert_soc);
+		pr_info("%s : COLD MODE DISABLE\n", __func__);
+	}
+
+	dev_dbg(&fuelgauge->i2c->dev, "%s: read = 0x%x, vbat = %d\n", __func__, ret, vbat);
+
+	return vbat;
+}
+
+static unsigned int sm5703_get_avgvbat(struct sm5703_fuelgauge_data *fuelgauge)
+{
+	int ret, cnt;
+	u32 vbat; /* = 3500; 3500 means 3500mV*/
+	u32 old_vbat = 0;
+
+	for (cnt = 0; cnt < 5; cnt++) {
+		ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, SM5703_REG_VOLTAGE);
+		if (ret < 0) {
+			pr_err("%s: read vbat reg fail", __func__);
+			vbat = 4000;
+		} else {
+			/* integer bit */
+			vbat = ((ret & 0x0700) >> 8) * 1000;
+			/* integer + fractional bit */
+			vbat = vbat + (((ret&0x00ff) * 1000) / 256);
+		}
+
+		if (cnt == 0)
+			old_vbat = vbat;
+		else
+			old_vbat = vbat / 2 + old_vbat / 2;
+	}
+
+	fuelgauge->info.batt_avgvoltage = old_vbat;
+	dev_dbg(&fuelgauge->i2c->dev, "%s: batt_avgvoltage = %d\n",
+			__func__, fuelgauge->info.batt_avgvoltage);
+
+	return old_vbat;
+}
+
+static int sm5703_get_curr(struct sm5703_fuelgauge_data *fuelgauge)
+{
+	int ret;
+	int curr;/* = 1000; 1000 means 1000mA*/
+
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, SM5703_REG_CURRENT);
+	if (ret<0) {
+		pr_err("%s: read curr reg fail", __func__);
+		curr = 0;
+	} else {
+		/* integer bit */
+		curr = ((ret&0x0700) >> 8) * 1000;
+		/* integer + fractional bit */
+		curr = curr + (((ret & 0x00ff) * 1000) / 256);
+		if(ret & 0x8000) {
+			curr *= -1;
+		}
+	}
+
+	fuelgauge->info.batt_current = curr;
+	dev_dbg(&fuelgauge->i2c->dev, "%s: read = 0x%x, curr = %d\n",
+		__func__, ret, curr);
+
+	return curr;
+}
+
+static int sm5703_get_avgcurr(struct sm5703_fuelgauge_data *fuelgauge)
+{
+	int ret, cnt;
+	int curr;/* = 1000; 1000 means 1000mA*/
+	int old_curr = 0;
+
+	for (cnt = 0; cnt < 5; cnt++) {
+		ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, SM5703_REG_CURRENT);
+		if (ret < 0) {
+			pr_err("%s: read curr reg fail", __func__);
+			curr = 0;
+		} else {
+			/* integer bit */
+			curr = ((ret&0x0700) >> 8) * 1000;
+			/* integer + fractional bit */
+			curr = curr + (((ret & 0x00ff) * 1000) / 256);
+			if(ret & 0x8000) {
+				curr *= -1;
+			}
+		}
+
+		if (cnt == 0)
+			old_curr = curr;
+		else
+			old_curr = curr / 2 + old_curr / 2;
+	}
+
+	fuelgauge->info.batt_avgcurrent = old_curr;
+	dev_dbg(&fuelgauge->i2c->dev, "%s: batt_avgcurrent = %d\n",
+		__func__, fuelgauge->info.batt_avgcurrent);
+
+	return old_curr;
+}
+
+
+static unsigned int sm5703_get_device_id(struct i2c_client *client)
+{
+	int ret;
+	ret = sm5703_fg_i2c_read_word(client, SM5703_REG_DEVICE_ID);
+	/* ret &= 0x00ff; */
+
+	dev_info(&client->dev, "%s: device_id = 0x%x\n", __func__, ret);
+
+	return ret;
+}
+
+static bool sm5703_fg_check_reg_init_need(struct i2c_client *client)
+{
+	int ret;
+
+	ret = sm5703_fg_i2c_read_word(client, SM5703_REG_FG_OP_STATUS);
+
+	if((ret & 0x00FF) == DISABLE_RE_INIT) {
+		dev_dbg(&client->dev, "%s: return 0\n", __func__);
+		return 0;
+	} else {
+		dev_dbg(&client->dev, "%s: return 1\n", __func__);
+		return 1;
+	}
+}
+
+static int calculate_iocv(struct i2c_client *client)
+{
+	int i;
+	int max=0, min=0, sum=0, l_avg=0, s_avg=0, l_minmax_offset=0;
+	int ret=0;
+
+	for (i = SM5703_REG_IOCV_B_L_MIN; i <= SM5703_REG_IOCV_B_L_MAX; i++) {
+		ret = sm5703_fg_i2c_read_word(client, i);
+		if (i == SM5703_REG_IOCV_B_L_MIN) {
+			max = ret;
+			min = ret;
+			sum = ret;
+		} else {
+			if(ret > max)
+				max = ret;
+			else if(ret < min)
+				min = ret;
+			sum = sum + ret;
+		}
+	}
+	sum = sum - max - min;
+	l_minmax_offset = max - min;
+	l_avg = sum / (SM5703_REG_IOCV_B_L_MAX-SM5703_REG_IOCV_B_L_MIN-1);
+	dev_info(&client->dev,
+		"%s: iocv_l_max=0x%x, iocv_l_min=0x%x, iocv_l_sum=0x%x, iocv_l_avg=0x%x \n",
+		__func__, max, min, sum, l_avg);
+
+	ret = sm5703_fg_i2c_read_word(client, SM5703_REG_END_V_IDX);
+	pr_info("%s: iocv_status_read = addr : 0x%x , data : 0x%x\n",
+		__func__, SM5703_REG_END_V_IDX, ret);
+
+	if ((ret & 0x0030) == 0x0030) {
+		for (i = SM5703_REG_IOCV_B_S_MIN; i <= SM5703_REG_IOCV_B_S_MAX; i++) {
+			ret = sm5703_fg_i2c_read_word(client, i);
+			if (i == SM5703_REG_IOCV_B_S_MIN) {
+				max = ret;
+				min = ret;
+				sum = ret;
+			} else {
+				if(ret > max)
+					max = ret;
+				else if(ret < min)
+					min = ret;
+				sum = sum + ret;
+			}
+		}
+		sum = sum - max - min;
+		s_avg = sum / (SM5703_REG_IOCV_B_S_MAX-SM5703_REG_IOCV_B_S_MIN-1);
+		dev_info(&client->dev,
+			"%s: iocv_s_max=0x%x, iocv_s_min=0x%x, iocv_s_sum=0x%x, iocv_s_avg=0x%x \n",
+			__func__, max, min, sum, s_avg);
+	}
+
+	if (((abs(l_avg - s_avg) > 0x29) && (l_minmax_offset < 0xCC)) || (s_avg == 0)){
+		ret = l_avg;
+	} else {
+		ret = s_avg;
+	}
+
+	return ret;
+}
+
+#ifdef ENABLE_BATT_LONG_LIFE
+int get_v_max_index_by_cycle(struct i2c_client *client)
+{
+
+	int cycle_index=0, len;
+	struct sm5703_fuelgauge_data *fuelgauge = i2c_get_clientdata(client);
+
+	for (len = fuelgauge->pdata->num_age_step-1; len >= 0; --len) {
+		if(fuelgauge->chg_float_voltage == fuelgauge->pdata->age_data[len].float_voltage) {
+			cycle_index=len;
+			break;
+		}
+	}
+	pr_info("%s: chg_float_voltage = %d, index = %d \n", __func__, fuelgauge->chg_float_voltage, cycle_index);
+
+	return cycle_index;
+}
+#endif
+
+static void fg_vbatocv_check(struct i2c_client *client)
+{
+	int ret;
+	int ta_exist;
+	union power_supply_propval value;
+	struct sm5703_fuelgauge_data *fuelgauge = i2c_get_clientdata(client);
+
+	ta_exist = fuelgauge->is_charging && (fuelgauge->info.batt_current >= 0);
+
+	/* iocv error case cover start */
+	if ((abs(fuelgauge->info.batt_current) < 40) ||
+		((ta_exist) &&
+		(abs(fuelgauge->info.batt_current) < 100))) {
+		/* 30mV over */
+		if(abs(fuelgauge->info.batt_ocv-fuelgauge->info.batt_voltage) > 30) {
+			fuelgauge->info.iocv_error_count ++;
+		}
+		if(fuelgauge->info.iocv_error_count > 5) /* prevent to overflow */
+			fuelgauge->info.iocv_error_count = 6;
+	} else {
+		fuelgauge->info.iocv_error_count = 0;
+	}
+
+	dev_info(&client->dev, "%s: iocv_error_count (%d)\n",
+		__func__, fuelgauge->info.iocv_error_count);
+
+	if (fuelgauge->info.iocv_error_count > 5) {
+		dev_info(&client->dev,
+			"%s: p_v - v = (%d)\n", __func__,
+			fuelgauge->info.p_batt_voltage - fuelgauge->info.batt_voltage);
+
+		if (abs(fuelgauge->info.p_batt_voltage - fuelgauge->info.batt_voltage)>15) { /* 15mV over */
+			fuelgauge->info.iocv_error_count = 0;
+		} else {
+			/* mode change to mix RS manual mode */
+			dev_info(&client->dev, "%s: mode change to mix RS manual mode\n", __func__);
+			/* RS manual value write */
+			sm5703_fg_i2c_write_word(client, SM5703_REG_RS_MAN, fuelgauge->info.rs_value[0]);
+			/* run update */
+			sm5703_fg_i2c_write_word(client, SM5703_REG_PARAM_RUN_UPDATE, 0);
+			sm5703_fg_i2c_write_word(client, SM5703_REG_PARAM_RUN_UPDATE, 1);
+			/* mode change */
+			ret = sm5703_fg_i2c_read_word(client, SM5703_REG_CNTL);
+			ret = (ret | ENABLE_MIX_MODE) | ENABLE_RS_MAN_MODE; /* +RS_MAN_MODE */
+			sm5703_fg_i2c_write_word(client, SM5703_REG_CNTL, ret);
+		}
+	} else {
+		psy_do_property("battery", get,	POWER_SUPPLY_PROP_TEMP, value);
+		if((value.intval / 10) > 15)
+		{
+			if((fuelgauge->info.p_batt_voltage < fuelgauge->info.n_tem_poff) &&
+				(fuelgauge->info.batt_voltage < fuelgauge->info.n_tem_poff) &&
+				(!ta_exist)) {
+				dev_info(&client->dev,
+					"%s: mode change to normal tem mix RS manual mode\n", __func__);
+				/* mode change to mix RS manual mode */
+				/* RS manual value write */
+				if((fuelgauge->info.p_batt_voltage < (fuelgauge->info.n_tem_poff - fuelgauge->info.n_tem_poff_offset)) &&
+					(fuelgauge->info.batt_voltage < (fuelgauge->info.n_tem_poff - fuelgauge->info.n_tem_poff_offset))) {
+					sm5703_fg_i2c_write_word(client, SM5703_REG_RS_MAN, fuelgauge->info.rs_value[0]>>1);
+				} else {
+					sm5703_fg_i2c_write_word(client, SM5703_REG_RS_MAN, fuelgauge->info.rs_value[0]);
+				}
+				/* run update*/
+				sm5703_fg_i2c_write_word(client, SM5703_REG_PARAM_RUN_UPDATE, 0);
+				sm5703_fg_i2c_write_word(client, SM5703_REG_PARAM_RUN_UPDATE, 1);
+
+				/* mode change */
+				ret = sm5703_fg_i2c_read_word(client, SM5703_REG_CNTL);
+				ret = (ret | ENABLE_MIX_MODE) | ENABLE_RS_MAN_MODE; // +RS_MAN_MODE
+				sm5703_fg_i2c_write_word(client, SM5703_REG_CNTL, ret);
+			} else {
+				dev_info(&client->dev, "%s: mode change to mix RS auto mode\n", __func__);
+
+				/* mode change to mix RS auto mode */
+				ret = sm5703_fg_i2c_read_word(client, SM5703_REG_CNTL);
+				ret = (ret | ENABLE_MIX_MODE) & ~ENABLE_RS_MAN_MODE; // -RS_MAN_MODE
+				sm5703_fg_i2c_write_word(client, SM5703_REG_CNTL, ret);
+			}
+		} else {
+			if((fuelgauge->info.p_batt_voltage < fuelgauge->info.l_tem_poff) &&
+				(fuelgauge->info.batt_voltage < fuelgauge->info.l_tem_poff) &&
+				(!ta_exist)) {
+				dev_info(&client->dev,
+				"%s: mode change to normal tem mix RS manual mode\n", __func__);
+				/* mode change to mix RS manual mode */
+				/* RS manual value write */
+				if((fuelgauge->info.p_batt_voltage < (fuelgauge->info.l_tem_poff - fuelgauge->info.l_tem_poff_offset)) &&
+					(fuelgauge->info.batt_voltage < (fuelgauge->info.l_tem_poff - fuelgauge->info.l_tem_poff_offset))) {
+					sm5703_fg_i2c_write_word(client, SM5703_REG_RS_MAN, fuelgauge->info.rs_value[0]>>1);
+				} else {
+					sm5703_fg_i2c_write_word(client, SM5703_REG_RS_MAN, fuelgauge->info.rs_value[0]);
+				}
+				/* run update */
+				sm5703_fg_i2c_write_word(client, SM5703_REG_PARAM_RUN_UPDATE, 0);
+				sm5703_fg_i2c_write_word(client, SM5703_REG_PARAM_RUN_UPDATE, 1);
+
+				/* mode change */
+				ret = sm5703_fg_i2c_read_word(client, SM5703_REG_CNTL);
+				ret = (ret | ENABLE_MIX_MODE) | ENABLE_RS_MAN_MODE; /* +RS_MAN_MODE */
+				sm5703_fg_i2c_write_word(client, SM5703_REG_CNTL, ret);
+			} else {
+				dev_info(&client->dev, "%s: mode change to mix RS auto mode\n", __func__);
+
+				/* mode change to mix RS auto mode */
+				ret = sm5703_fg_i2c_read_word(client, SM5703_REG_CNTL);
+				ret = (ret | ENABLE_MIX_MODE) & ~ENABLE_RS_MAN_MODE; /* -RS_MAN_MODE */
+				sm5703_fg_i2c_write_word(client, SM5703_REG_CNTL, ret);
+			}
+		}
+	}
+	fuelgauge->info.p_batt_voltage = fuelgauge->info.batt_voltage;
+	fuelgauge->info.p_batt_current = fuelgauge->info.batt_current;
+	/* iocv error case cover end */
+}
+
+/* capacity is  0.1% unit */
+static void sm5703_fg_get_scaled_capacity(
+	struct sm5703_fuelgauge_data *fuelgauge,
+	union power_supply_propval *val)
+{
+	val->intval = (val->intval < fuelgauge->pdata->capacity_min) ?
+		0 : ((val->intval - fuelgauge->pdata->capacity_min) * 1000 /
+		(fuelgauge->capacity_max - fuelgauge->pdata->capacity_min));
+
+	dev_dbg(&fuelgauge->i2c->dev,
+			"%s: scaled capacity (%d.%d)\n",
+			__func__, val->intval/10, val->intval%10);
+}
+
+/* capacity is integer */
+static void sm5703_fg_get_atomic_capacity(
+	struct sm5703_fuelgauge_data *fuelgauge,
+	union power_supply_propval *val)
+{
+	if (fuelgauge->pdata->capacity_calculation_type &
+			SEC_FUELGAUGE_CAPACITY_TYPE_ATOMIC) {
+		if (fuelgauge->capacity_old < val->intval)
+			val->intval = fuelgauge->capacity_old + 1;
+		else if (fuelgauge->capacity_old > val->intval)
+			val->intval = fuelgauge->capacity_old - 1;
+	}
+
+	/* keep SOC stable in abnormal status */
+	if (fuelgauge->pdata->capacity_calculation_type &
+			SEC_FUELGAUGE_CAPACITY_TYPE_SKIP_ABNORMAL) {
+		if (!fuelgauge->is_charging &&
+				fuelgauge->capacity_old < val->intval) {
+			dev_err(&fuelgauge->i2c->dev,
+					"%s: capacity (old %d : new %d)\n",
+					__func__, fuelgauge->capacity_old, val->intval);
+			val->intval = fuelgauge->capacity_old;
+		}
+	}
+
+	/* updated old capacity */
+	fuelgauge->capacity_old = val->intval;
+}
+
+static int sm5703_fg_check_capacity_max(
+		struct sm5703_fuelgauge_data *fuelgauge, int capacity_max)
+{
+	int new_capacity_max = capacity_max;
+
+	if (new_capacity_max < (fuelgauge->pdata->capacity_max -
+				fuelgauge->pdata->capacity_max_margin - 10)) {
+		new_capacity_max =
+			(fuelgauge->pdata->capacity_max -
+			 fuelgauge->pdata->capacity_max_margin);
+
+		dev_info(&fuelgauge->i2c->dev, "%s: set capacity max(%d --> %d)\n",
+				__func__, capacity_max, new_capacity_max);
+	} else if (new_capacity_max > (fuelgauge->pdata->capacity_max +
+				fuelgauge->pdata->capacity_max_margin)) {
+		new_capacity_max =
+			(fuelgauge->pdata->capacity_max +
+			 fuelgauge->pdata->capacity_max_margin);
+
+		dev_info(&fuelgauge->i2c->dev, "%s: set capacity max(%d --> %d)\n",
+				__func__, capacity_max, new_capacity_max);
+	}
+
+	return new_capacity_max;
+}
+
+static int sm5703_fg_calculate_dynamic_scale(
+		struct sm5703_fuelgauge_data *fuelgauge, int capacity)
+{
+	union power_supply_propval raw_soc_val;
+	raw_soc_val.intval = sm5703_get_soc(fuelgauge);
+
+	if (raw_soc_val.intval <
+			fuelgauge->pdata->capacity_max -
+			fuelgauge->pdata->capacity_max_margin) {
+		fuelgauge->capacity_max =
+			fuelgauge->pdata->capacity_max -
+			fuelgauge->pdata->capacity_max_margin;
+		pr_info("%s: capacity_max (%d)", __func__,
+				fuelgauge->capacity_max);
+	} else {
+		fuelgauge->capacity_max =
+			(raw_soc_val.intval >
+			 fuelgauge->pdata->capacity_max +
+			 fuelgauge->pdata->capacity_max_margin) ?
+			(fuelgauge->pdata->capacity_max +
+			 fuelgauge->pdata->capacity_max_margin) :
+			raw_soc_val.intval;
+		pr_info("%s: raw soc (%d)", __func__,
+				fuelgauge->capacity_max);
+	}
+
+	if (capacity != 100) {
+		fuelgauge->capacity_max = sm5703_fg_check_capacity_max(
+			fuelgauge, (fuelgauge->capacity_max * 100 / (capacity + 1)));
+		fuelgauge->capacity_old = capacity;
+	} else {
+		fuelgauge->capacity_max =
+			(fuelgauge->capacity_max * 99 / 100);
+
+		sm5703_fg_get_scaled_capacity(fuelgauge, &raw_soc_val);
+		fuelgauge->capacity_old = min((raw_soc_val.intval / 10), 100);
+	}
+
+	pr_info("%s: %d is used for capacity_max, capacity(%d)\n",
+			__func__, fuelgauge->capacity_max, capacity);
+
+	return fuelgauge->capacity_max;
+}
+
+static void sm5703_fuelgauge_fuelalert_init(struct sm5703_fuelgauge_data *fuelgauge,
+		int soc)
+{
+	int ret;
+
+	dev_dbg(&fuelgauge->i2c->dev, "%s: sec_hal_fg_fuelalert_init\n", __func__);
+
+	/* remove interrupt */
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, SM5703_REG_INTFG);
+
+	/* check status ? need add action */
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, SM5703_REG_STATUS);
+
+	/* remove all mask */
+	sm5703_fg_i2c_write_word(fuelgauge->i2c, SM5703_REG_INTFG_MASK, 0);
+
+	/* set volt and soc alert threshold */
+	ret = 0x0320; /* 3125mV */
+	sm5703_fg_i2c_write_word(fuelgauge->i2c, SM5703_REG_V_ALARM, ret);
+
+	ret = soc << 8;
+	sm5703_fg_i2c_write_word(fuelgauge->i2c, SM5703_REG_SOC_ALARM, ret);
+
+	/* update parameters */
+	sm5703_fg_i2c_write_word(fuelgauge->i2c, SM5703_REG_PARAM_RUN_UPDATE, 0);
+	sm5703_fg_i2c_write_word(fuelgauge->i2c, SM5703_REG_PARAM_RUN_UPDATE, 1);
+
+	/* enable low soc, low voltage alert */
+	fuelgauge->info.irq_ctrl = ENABLE_L_SOC_INT | ENABLE_L_VOL_INT;
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, SM5703_REG_CNTL);
+	ret = (ret & 0xFFF0) | fuelgauge->info.irq_ctrl;
+	sm5703_fg_i2c_write_word(fuelgauge->i2c, SM5703_REG_CNTL, ret);
+
+	/* reset soc alert flag */
+	fuelgauge->info.soc_alert_flag = false;
+	fuelgauge->is_fuel_alerted = false;
+
+	return;
+}
+
+static bool sm5703_fg_reg_init(struct sm5703_fuelgauge_data *fuelgauge,
+		int manual_ocv_write)
+{
+	int i, j, value, ret;
+	uint8_t table_reg;
+	int write_table[3][16];
+	
+	dev_info(&fuelgauge->i2c->dev, "%s: sm5703_fg_reg_init START!!\n", __func__);
+
+	/* start first param_ctrl unlock */
+	sm5703_fg_i2c_write_word(fuelgauge->i2c,
+		SM5703_REG_PARAM_CTRL, SM5703_FG_PARAM_UNLOCK_CODE);
+
+	/* RCE write */
+	for (i = 0; i < 3; i++) {
+		sm5703_fg_i2c_write_word(fuelgauge->i2c,
+			SM5703_REG_RCE0+i, fuelgauge->info.rce_value[i]);
+		dev_dbg(&fuelgauge->i2c->dev,
+			"%s: RCE write RCE%d = 0x%x : 0x%x\n",
+			__func__,
+			i, SM5703_REG_RCE0+i, fuelgauge->info.rce_value[i]);
+	}
+
+	/* DTCD write */
+	sm5703_fg_i2c_write_word(fuelgauge->i2c,
+		SM5703_REG_DTCD, fuelgauge->info.dtcd_value);
+	dev_dbg(&fuelgauge->i2c->dev,
+		"%s: DTCD write DTCD = 0x%x : 0x%x\n",
+		__func__,
+		SM5703_REG_DTCD, fuelgauge->info.dtcd_value);
+
+	/* RS write */
+	sm5703_fg_i2c_write_word(fuelgauge->i2c,
+		SM5703_REG_RS, fuelgauge->info.rs_value[0]);
+	dev_dbg(&fuelgauge->i2c->dev,
+		"%s: RS write RS = 0x%x : 0x%x\n",
+		__func__,
+		SM5703_REG_RS, fuelgauge->info.rs_value[0]);
+
+
+	/* VIT_PERIOD write */
+	sm5703_fg_i2c_write_word(fuelgauge->i2c,
+		SM5703_REG_VIT_PERIOD, fuelgauge->info.vit_period);
+	dev_dbg(&fuelgauge->i2c->dev,
+		"%s: VIT_PERIOD write VIT_PERIOD = 0x%x : 0x%x\n",
+		__func__,
+		SM5703_REG_VIT_PERIOD, fuelgauge->info.vit_period);
+
+	/* TABLE_LEN write & pram unlock */
+	sm5703_fg_i2c_write_word(fuelgauge->i2c,
+		SM5703_REG_PARAM_CTRL,
+		SM5703_FG_PARAM_UNLOCK_CODE | SM5703_FG_TABLE_LEN);
+
+#ifdef ENABLE_BATT_LONG_LIFE
+	i = get_v_max_index_by_cycle(fuelgauge->i2c);
+	pr_info("%s: v_max_now is change %x -> %x \n", __func__, fuelgauge->info.v_max_now, fuelgauge->info.v_max_table[i]);
+	pr_info("%s: q_max_now is change %x -> %x \n", __func__, fuelgauge->info.q_max_now, fuelgauge->info.q_max_table[i]);
+	fuelgauge->info.v_max_now = fuelgauge->info.v_max_table[i];
+	fuelgauge->info.q_max_now = fuelgauge->info.q_max_table[i];
+#endif
+
+	for (i=TABLE_MAX-1; i >= 0; i--) {
+		for (j=0; j <= SM5703_FG_TABLE_LEN; j++) {
+#ifdef ENABLE_BATT_LONG_LIFE
+			if (i == Q_TABLE) {
+				write_table[i][j] = fuelgauge->info.battery_table[i][j];
+				if (j == SM5703_FG_TABLE_LEN) {
+					write_table[i][SM5703_FG_TABLE_LEN - 1] = fuelgauge->info.q_max_now;
+					write_table[i][SM5703_FG_TABLE_LEN] = fuelgauge->info.q_max_now + (fuelgauge->info.q_max_now / 1000);
+				}
+			} else {
+				write_table[i][j] = fuelgauge->info.battery_table[i][j];
+				if (j == SM5703_FG_TABLE_LEN - 1) {
+					write_table[i][SM5703_FG_TABLE_LEN - 1] = fuelgauge->info.v_max_now;
+
+					if (write_table[i][SM5703_FG_TABLE_LEN - 1] < write_table[i][SM5703_FG_TABLE_LEN - 2]) {
+						write_table[i][SM5703_FG_TABLE_LEN - 2] = write_table[i][SM5703_FG_TABLE_LEN - 1] - 0x18; // ~11.7mV
+						write_table[Q_TABLE][SM5703_FG_TABLE_LEN - 2] = (write_table[Q_TABLE][SM5703_FG_TABLE_LEN - 1] * 99) / 100;
+					}
+				}
+			}
+#else
+			write_table[i][j] = fuelgauge->info.battery_table[i][j];
+#endif
+		}
+	}
+
+	for (i=0; i < 3; i++)
+	{
+		table_reg = SM5703_REG_TABLE_START + (i<<4);
+		for(j=0; j <= SM5703_FG_TABLE_LEN; j++)
+		{
+			sm5703_fg_i2c_write_word(fuelgauge->i2c, (table_reg + j),  write_table[i][j]);
+			msleep(10);
+			if (write_table[i][j] != sm5703_fg_i2c_read_word(fuelgauge->i2c, (table_reg + j))) {
+				pr_info("%s: TABLE write FAIL retry[%d][%d] = 0x%x : 0x%x\n",
+					__func__, i, j, (table_reg + j), write_table[i][j]);
+				sm5703_fg_i2c_write_word(fuelgauge->i2c, (table_reg + j), write_table[i][j]);
+			}
+			pr_info("%s: TABLE write OK [%d][%d] = 0x%x : 0x%x\n",
+				__func__, i, j, (table_reg + j), write_table[i][j]);
+		}
+	}
+
+	/* MIX_MODE write */
+	sm5703_fg_i2c_write_word(fuelgauge->i2c,
+		SM5703_REG_RS_MIX_FACTOR, fuelgauge->info.rs_value[1]);
+	sm5703_fg_i2c_write_word(fuelgauge->i2c,
+		SM5703_REG_RS_MAX, fuelgauge->info.rs_value[2]);
+	sm5703_fg_i2c_write_word(fuelgauge->i2c,
+		SM5703_REG_RS_MIN, fuelgauge->info.rs_value[3]);
+	sm5703_fg_i2c_write_word(fuelgauge->i2c,
+		SM5703_REG_MIX_RATE, fuelgauge->info.mix_value[0]);
+	sm5703_fg_i2c_write_word(fuelgauge->i2c,
+		SM5703_REG_MIX_INIT_BLANK, fuelgauge->info.mix_value[1]);
+
+	dev_dbg(&fuelgauge->i2c->dev,
+		"%s: RS_MIX_FACTOR = 0x%x, RS_MAX = 0x%x, RS_MIN = 0x%x,\
+		MIX_RATE = 0x%x, MIX_INIT_BLANK = 0x%x\n",		\
+		__func__, fuelgauge->info.rs_value[1],
+		fuelgauge->info.rs_value[2],
+		fuelgauge->info.rs_value[3],
+		fuelgauge->info.mix_value[0],
+		fuelgauge->info.mix_value[1]);
+
+	/* CAL write */
+	sm5703_fg_i2c_write_word(fuelgauge->i2c,
+		SM5703_REG_VOLT_CAL, fuelgauge->info.volt_cal);
+	sm5703_fg_i2c_write_word(fuelgauge->i2c,
+		SM5703_REG_CURR_CAL, fuelgauge->info.curr_cal);
+
+	dev_dbg(&fuelgauge->i2c->dev, "%s: VOLT_CAL = 0x%x, CURR_CAL = 0x%x\n",
+		__func__, fuelgauge->info.volt_cal, fuelgauge->info.curr_cal);
+
+	/* top off soc set */
+	if(sm5703_get_device_id(fuelgauge->i2c) < 3) {
+		if(fuelgauge->info.topoff_soc >= 5)
+			fuelgauge->info.topoff_soc = 5; /* 93% */
+		else if(fuelgauge->info.topoff_soc >= 3)
+			fuelgauge->info.topoff_soc = fuelgauge->info.topoff_soc - 3;
+		else if(fuelgauge->info.topoff_soc >= 0)
+			fuelgauge->info.topoff_soc = fuelgauge->info.topoff_soc + 5;
+	}
+	sm5703_fg_i2c_write_word(fuelgauge->i2c,
+		SM5703_REG_TOPOFFSOC, fuelgauge->info.topoff_soc);
+
+	/* INIT_last -  control register set */
+	value = sm5703_fg_i2c_read_word(fuelgauge->i2c, SM5703_REG_CNTL);
+	value &= 0xDFFF;
+	value |= ENABLE_MIX_MODE | ENABLE_TEMP_MEASURE | (fuelgauge->info.enable_topoff_soc << 13);
+
+	/* surge reset defence */
+	if (manual_ocv_write) {
+		value = value | ENABLE_MANUAL_OCV;
+	}
+
+	pr_info("%s: SM5703_REG_CNTL reg : 0x%x\n", __func__, value);
+
+	ret = sm5703_fg_i2c_write_word(fuelgauge->i2c, SM5703_REG_CNTL, value);
+	if (ret < 0)
+		dev_dbg(&fuelgauge->i2c->dev,
+		"%s: fail control register set(%d)\n", __func__, ret);
+
+	/* Lock */
+	value = SM5703_FG_PARAM_LOCK_CODE | SM5703_FG_TABLE_LEN;
+	sm5703_fg_i2c_write_word(fuelgauge->i2c,
+		SM5703_REG_PARAM_CTRL, value);
+	dev_info(&fuelgauge->i2c->dev,
+		"%s: LAST PARAM CTRL VALUE = 0x%x : 0x%x\n",
+		__func__, SM5703_REG_PARAM_CTRL, value);
+
+	/* surge reset defence */
+	if (manual_ocv_write)
+		value = ((fuelgauge->info.batt_ocv << 8) / 125);
+	else
+		value = calculate_iocv(fuelgauge->i2c);
+
+	sm5703_fg_i2c_write_word(fuelgauge->i2c, SM5703_REG_IOCV_MAN, value);
+	pr_info( "%s: IOCV_MAN_WRITE = %d : 0x%x\n",
+			__func__, fuelgauge->info.batt_ocv, value);
+
+	return 1;
+}
+
+static bool sm5703_fg_init(struct sm5703_fuelgauge_data *fuelgauge)
+{
+	int ret;
+	int ta_exist, reg_val;
+	union power_supply_propval value;
+
+	/* SM5703 i2c read check */
+	ret = sm5703_get_device_id(fuelgauge->i2c);
+	if (ret < 0) {
+		dev_dbg(&fuelgauge->i2c->dev,
+			"%s: fail to do i2c read(%d)\n", __func__, ret);
+
+		return false;
+	}
+
+	/* enable_topoff set */
+	reg_val = sm5703_fg_i2c_read_word(fuelgauge->i2c, SM5703_REG_CNTL);
+	reg_val &= 0xDFFF;
+	reg_val |= (fuelgauge->info.enable_topoff_soc << 13);
+
+	pr_info("%s: SM5703_REG_CNTL reg : 0x%x\n", __func__, reg_val);
+
+	sm5703_fg_i2c_write_word(fuelgauge->i2c, SM5703_REG_CNTL, reg_val);
+	
+#ifdef ENABLE_BATT_LONG_LIFE
+	fuelgauge->info.q_max_now = sm5703_fg_i2c_read_word(fuelgauge->i2c, 0xCE);
+	pr_info("%s: q_max_now = 0x%x\n", __func__, fuelgauge->info.q_max_now);
+	fuelgauge->info.q_max_now = sm5703_fg_i2c_read_word(fuelgauge->i2c, 0xCE);
+	pr_info("%s: q_max_now = 0x%x\n", __func__, fuelgauge->info.q_max_now);
+#endif
+
+	value.intval = POWER_SUPPLY_HEALTH_UNKNOWN;
+	psy_do_property("sm5703-charger", get,
+			POWER_SUPPLY_PROP_HEALTH, value);
+	dev_dbg(&fuelgauge->i2c->dev,
+		"%s: get POWER_SUPPLY_PROP_HEALTH = 0x%x\n",
+		__func__, value.intval);
+
+	ta_exist = fuelgauge->is_charging && (fuelgauge->info.batt_current >= 0);
+	dev_dbg(&fuelgauge->i2c->dev,
+		"%s: is_charging = %d, ta_exist = %d\n",
+		__func__, fuelgauge->is_charging, ta_exist);
+
+	/* get first voltage measure to avgvoltage */
+	fuelgauge->info.batt_avgvoltage = sm5703_get_avgvbat(fuelgauge);
+
+	/* get first temperature */
+	fuelgauge->info.temperature = sm5703_get_temperature(fuelgauge);
+
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, 0x30);
+	pr_info("%s: sm5703 FG 0x30 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, 0x31);
+	pr_info("%s: sm5703 FG 0x31 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, 0x32);
+	pr_info("%s: sm5703 FG 0x32 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, 0x33);
+	pr_info("%s: sm5703 FG 0x33 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, 0x34);
+	pr_info("%s: sm5703 FG 0x34 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, 0x35);
+	pr_info("%s: sm5703 FG 0x35 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, 0x36);
+	pr_info("%s: sm5703 FG 0x36 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, 0x37);
+	pr_info("%s: sm5703 FG 0x37 = 0x%x \n", __func__, ret);
+
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, 0x40);
+	pr_info("%s: sm5703 FG 0x40 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, 0x41);
+	pr_info("%s: sm5703 FG 0x41 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, 0x42);
+	pr_info("%s: sm5703 FG 0x42 = 0x%x \n", __func__, ret);
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, 0x43);
+	pr_info("%s: sm5703 FG 0x43 = 0x%x \n", __func__, ret);
+
+	return true;
+}
+
+static bool sm5703_fg_reset(struct sm5703_fuelgauge_data *fuelgauge)
+{
+	dev_info(&fuelgauge->i2c->dev, "%s: sec_hal_fg_reset\n", __func__);
+
+	/* SW reset code */
+	sm5703_fg_i2c_write_word(fuelgauge->i2c, 0x90, 0x0008);
+
+	/* delay 200ms */
+	msleep(200);
+
+	/* init code */
+	if(sm5703_fg_check_reg_init_need(fuelgauge->i2c))
+		sm5703_fg_reg_init(fuelgauge, 0);
+
+	return true;
+}
+
+static void sm5703_fg_reset_capacity_by_jig_connection(struct sm5703_fuelgauge_data *fuelgauge)
+{
+	int ret;
+
+	if (fuelgauge->pdata->model_type == J2LTE) {
+#ifdef USE_SUSPEND_LATE
+		int retry = 0;
+
+		while(fuelgauge->is_sleep_state == true){
+			pr_info("%s sleep_state retry=%d\n", __func__, retry);
+			usleep_range(10 * 1000, 10 * 1000);
+			if (++retry > 5)
+				break;
+		}
+#endif
+	}
+
+	ret = sm5703_fg_i2c_read_word(fuelgauge->i2c, SM5703_REG_CNTL);
+	ret &= 0xFFEF;
+	sm5703_fg_i2c_write_word(fuelgauge->i2c, SM5703_REG_CNTL, ret);
+}
+
+static int sm5703_fg_get_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		union power_supply_propval *val)
+{
+	struct sm5703_fuelgauge_data *fuelgauge =
+		container_of(psy, struct sm5703_fuelgauge_data, psy_fg);
+
+	switch (psp) {
+		case POWER_SUPPLY_PROP_STATUS:
+		case POWER_SUPPLY_PROP_CHARGE_FULL:
+		case POWER_SUPPLY_PROP_ENERGY_NOW:
+			return -ENODATA;
+		/* Cell voltage (VCELL, mV) */
+		case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+			val->intval = sm5703_get_vbat(fuelgauge);
+			break;
+		/* Additional Voltage Information (mV) */
+		case POWER_SUPPLY_PROP_VOLTAGE_AVG:
+			switch (val->intval) {
+				case SEC_BATTERY_VOLTAGE_AVERAGE:
+					val->intval = sm5703_get_avgvbat(fuelgauge);
+					break;
+				case SEC_BATTERY_VOLTAGE_OCV:
+					val->intval = sm5703_get_ocv(fuelgauge);
+					break;
+			}
+			break;
+		/* Current (mA) */
+		case POWER_SUPPLY_PROP_CURRENT_NOW:
+			val->intval = sm5703_get_curr(fuelgauge);
+			break;
+		/* Average Current (mA) */
+		case POWER_SUPPLY_PROP_CURRENT_AVG:
+			val->intval = sm5703_get_avgcurr(fuelgauge);
+			break;
+		case POWER_SUPPLY_PROP_CAPACITY:
+			if (val->intval == SEC_FUELGAUGE_CAPACITY_TYPE_RAW) {
+				val->intval = sm5703_get_soc(fuelgauge) * 10;
+			} else {
+				val->intval = sm5703_get_soc(fuelgauge);
+
+				if (fuelgauge->pdata->capacity_calculation_type &
+						(SEC_FUELGAUGE_CAPACITY_TYPE_SCALE |
+						 SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE))
+					sm5703_fg_get_scaled_capacity(fuelgauge, val);
+
+				/* capacity should be between 0% and 100%
+				 * (0.1% degree)
+				 */
+				if (val->intval > 1000)
+					val->intval = 1000;
+				if (val->intval < 0)
+					val->intval = 0;
+
+				/* get only integer part */
+				val->intval /= 10;
+
+				if (!fuelgauge->is_charging &&
+						(fuelgauge->force_dec_mode == SM5703_COLD_MODE)) {
+					pr_info("%s : SW V EMPTY. Decrease SOC\n", __func__);
+					val->intval = 0;
+				} else if ((fuelgauge->force_dec_mode == SM5703_RECOVERY_MODE) &&
+						(val->intval == fuelgauge->capacity_old)) {
+					fuelgauge->force_dec_mode = SM5703_NORMAL_MODE;
+				}
+
+				/* check whether doing the wake_unlock */
+				if ((val->intval > fuelgauge->pdata->fuel_alert_soc) &&
+						fuelgauge->is_fuel_alerted) {
+					wake_unlock(&fuelgauge->fuel_alert_wake_lock);
+					sm5703_fuelgauge_fuelalert_init(fuelgauge,
+							fuelgauge->pdata->fuel_alert_soc);
+				}
+
+				/* (Only for atomic capacity)
+				 * In initial time, capacity_old is 0.
+				 * and in resume from sleep,
+				 * capacity_old is too different from actual soc.
+				 * should update capacity_old
+				 * by val->intval in booting or resume.
+				 */
+				if (fuelgauge->initial_update_of_soc &&
+						fuelgauge->force_dec_mode == SM5703_NORMAL_MODE) {
+					/* updated old capacity */
+					fuelgauge->capacity_old = val->intval;
+					fuelgauge->initial_update_of_soc = false;
+					break;
+				}
+
+				if (fuelgauge->pdata->capacity_calculation_type &
+						(SEC_FUELGAUGE_CAPACITY_TYPE_ATOMIC |
+						 SEC_FUELGAUGE_CAPACITY_TYPE_SKIP_ABNORMAL))
+					sm5703_fg_get_atomic_capacity(fuelgauge, val);
+			}
+			break;
+		/* Battery Temperature */
+		case POWER_SUPPLY_PROP_TEMP:
+		/* Target Temperature */
+		case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+			val->intval = sm5703_get_temperature(fuelgauge);
+			break;
+		case POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:
+			val->intval = fuelgauge->capacity_max;
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sm5703_fg_set_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		const union power_supply_propval *val)
+{
+	struct sm5703_fuelgauge_data *fuelgauge =
+		container_of(psy, struct sm5703_fuelgauge_data, psy_fg);
+
+	switch (psp) {
+		case POWER_SUPPLY_PROP_STATUS:
+			if(val->intval == POWER_SUPPLY_STATUS_FULL) {
+#ifdef ENABLE_BATT_LONG_LIFE
+			pr_info("%s: POWER_SUPPLY_PROP_STATUS_FULL : q_max_now = 0x%x \n", __func__, fuelgauge->info.q_max_now);
+			if(fuelgauge->info.q_max_now != 
+				fuelgauge->info.q_max_table[get_v_max_index_by_cycle(fuelgauge->i2c)]){
+				if (!sm5703_fg_reset(fuelgauge))
+					return -EINVAL;
+			}
+#endif
+		}	
+			break;
+		case POWER_SUPPLY_PROP_CHARGE_FULL:
+			if (fuelgauge->pdata->capacity_calculation_type &
+					SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE) {
+				sm5703_fg_calculate_dynamic_scale(fuelgauge, val->intval);
+			}
+			break;
+		case POWER_SUPPLY_PROP_ONLINE:
+			fuelgauge->cable_type = val->intval;
+			if (val->intval == POWER_SUPPLY_TYPE_BATTERY) {
+				fuelgauge->is_charging = false;
+			} else {
+				fuelgauge->is_charging = true;
+				if (fuelgauge->force_dec_mode != SM5703_NORMAL_MODE) {
+					fuelgauge->force_dec_mode = SM5703_NORMAL_MODE;
+					fuelgauge->initial_update_of_soc = true;
+					wake_unlock(&fuelgauge->fuel_alert_wake_lock);
+					sm5703_fuelgauge_fuelalert_init(fuelgauge,
+							fuelgauge->pdata->fuel_alert_soc);
+				}
+
+				if (fuelgauge->info.is_low_batt_alarm) {
+					pr_info("%s: Reset low_batt_alarm\n",
+							__func__);
+					fuelgauge->info.is_low_batt_alarm = false;
+				}
+			}
+			break;
+		case POWER_SUPPLY_PROP_CAPACITY:
+			if (val->intval == SEC_FUELGAUGE_CAPACITY_TYPE_RESET) {
+				fuelgauge->initial_update_of_soc = true;
+
+				if (!sm5703_fg_reset(fuelgauge))
+					return -EINVAL;
+				else
+					break;
+
+			}
+			break;
+		case POWER_SUPPLY_PROP_TEMP:
+			break;
+		case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+			break;
+		case POWER_SUPPLY_PROP_ENERGY_NOW:
+			sm5703_fg_reset_capacity_by_jig_connection(fuelgauge);
+			break;
+		case POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:
+			dev_info(&fuelgauge->i2c->dev,
+					"%s: capacity_max changed, %d -> %d\n",
+					__func__, fuelgauge->capacity_max, val->intval);
+			fuelgauge->capacity_max = sm5703_fg_check_capacity_max(fuelgauge, val->intval);
+			fuelgauge->initial_update_of_soc = true;
+			break;
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+		case POWER_SUPPLY_PROP_CAPACITY_LEVEL:
+			pr_info("%s: chg_float_voltage changed, %d -> %d\n",
+			__func__, fuelgauge->chg_float_voltage, val->intval);
+			fuelgauge->chg_float_voltage = val->intval;
+			break;
+#endif
+		default:
+			return -EINVAL;
+	}
+	return 0;
+}
+
+static void sm5703_fg_isr_work(struct work_struct *work)
+{
+	struct sm5703_fuelgauge_data *fuelgauge =
+		container_of(work, struct sm5703_fuelgauge_data, isr_work.work);
+	int fg_alert_status;
+
+	fg_alert_status = sm5703_fg_i2c_read_word(fuelgauge->i2c, SM5703_REG_STATUS);
+	dev_info(&fuelgauge->i2c->dev, "%s: fg_alert_status(0x%x)\n",
+		__func__, fg_alert_status);
+
+	fg_alert_status &= fuelgauge->info.irq_ctrl;
+	if (!fg_alert_status) {
+		wake_unlock(&fuelgauge->fuel_alert_wake_lock);
+	}
+
+	if (fg_alert_status & ENABLE_L_VOL_INT) {
+		pr_info("%s : Battery Voltage is Very Low!! SW V EMPTY ENABLE\n", __func__);
+		fuelgauge->force_dec_mode = SM5703_COLD_MODE;
+	}
+}
+
+#if defined(CONFIG_STMP_SUPPORT_FG_ALERT)
+static void sm5703_fg_isr(void *irq_data)
+{
+	struct sm5703_fuelgauge_data *fuelgauge = irq_data;
+	int fg_irq;
+
+	/* clear interrupt */
+	fg_irq = sm5703_fg_i2c_read_word(fuelgauge->i2c, SM5703_REG_INTFG);
+	dev_info(&fuelgauge->i2c->dev, "%s: fg_irq(0x%x)\n", __func__, fg_irq);
+
+	if (!fuelgauge->is_fuel_alerted) {
+		wake_lock(&fuelgauge->fuel_alert_wake_lock);
+		fuelgauge->is_fuel_alerted = true;
+		schedule_delayed_work(&fuelgauge->isr_work, 0);
+	}
+}
+#else
+static irqreturn_t sm5703_fg_irq_thread(int irq, void *irq_data)
+{
+	struct sm5703_fuelgauge_data *fuelgauge = irq_data;
+	int fg_irq;
+
+	/* clear interrupt */
+	fg_irq = sm5703_fg_i2c_read_word(fuelgauge->i2c, SM5703_REG_INTFG);
+	dev_info(&fuelgauge->i2c->dev, "%s: fg_irq(0x%x)\n",
+		__func__, fg_irq);
+
+	if (!fuelgauge->is_fuel_alerted) {
+		wake_lock(&fuelgauge->fuel_alert_wake_lock);
+		fuelgauge->is_fuel_alerted = true;
+		schedule_delayed_work(&fuelgauge->isr_work, 0);
+	}
+	return IRQ_HANDLED;
+}
+#endif
+
+#ifdef CONFIG_OF
+#define PROPERTY_NAME_SIZE 128
+
+#define PINFO(format, args...) \
+	printk(KERN_INFO "%s() line-%d: " format, \
+			__func__, __LINE__, ## args)
+
+#define DECL_PARAM_PROP(_id, _name) {.id = _id, .name = _name,}
+
+static int get_battery_id(struct sm5703_fuelgauge_data *fuelgauge)
+{
+    /* sm5703fg does not support this function */
+    return 0;
+}
+
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+static int temp_parse_dt(struct sm5703_fuelgauge_data *fuelgauge)
+{
+	struct device_node *np = of_find_node_by_name(NULL, "battery");
+	int len=0, ret;
+	const u32 *p;
+
+	if (np == NULL) {
+		pr_err("%s np NULL\n", __func__);
+	} else {
+		p = of_get_property(np, "battery,age_data", &len);
+		if (p) {
+			fuelgauge->pdata->num_age_step = len / sizeof(sec_age_data_t);
+			fuelgauge->pdata->age_data = kzalloc(len, GFP_KERNEL);
+			ret = of_property_read_u32_array(np, "battery,age_data",
+					 (u32 *)fuelgauge->pdata->age_data, len/sizeof(u32));
+			if (ret) {
+				pr_err("%s failed to read battery->pdata->age_data: %d\n",
+						__func__, ret);
+				kfree(fuelgauge->pdata->age_data);
+				fuelgauge->pdata->age_data = NULL;
+				fuelgauge->pdata->num_age_step = 0;
+			}
+			pr_info("%s num_age_step : %d\n", __func__, fuelgauge->pdata->num_age_step);
+			for (len = 0; len < fuelgauge->pdata->num_age_step; ++len) {
+				pr_info("[%d/%d]cycle:%d, float:%d, full_v:%d, recharge_v:%d, soc:%d\n",
+					len, fuelgauge->pdata->num_age_step-1,
+					fuelgauge->pdata->age_data[len].cycle,
+					fuelgauge->pdata->age_data[len].float_voltage,
+					fuelgauge->pdata->age_data[len].full_condition_vcell,
+					fuelgauge->pdata->age_data[len].recharge_condition_vcell,
+					fuelgauge->pdata->age_data[len].full_condition_soc);
+			}
+		} else {
+			fuelgauge->pdata->num_age_step = 0;
+			pr_err("%s there is not age_data\n", __func__);
+		}
+	}
+	return 0;
+}
+#endif
+static int sm5703_fg_parse_dt(struct sm5703_fuelgauge_data *fuelgauge)
+{
+	char prop_name[PROPERTY_NAME_SIZE];
+	int battery_id = -1;
+#ifdef ENABLE_BATT_LONG_LIFE
+	int v_max_table[5];
+	int q_max_table[5];
+#endif
+	int table[16];
+	int rce_value[3];
+	int rs_value[4];
+	int mix_value[2];
+	int topoff_soc[2];
+	int set_temp_poff[4] = {3400,100,3300,80};
+
+	int ret;
+	int i, j;
+
+	struct device_node *np = of_find_node_by_name(NULL, "sm5703-fuelgauge");
+
+	if (np == NULL) {
+		pr_err("%s np NULL\n", __func__);
+	} else {
+		fuelgauge->pdata->fg_irq = of_get_named_gpio(np, "fuelgauge,fuel_int", 0);
+		if (fuelgauge->pdata->fg_irq < 0)
+			pr_err("%s error reading fg_irq = %d\n",
+				__func__, fuelgauge->pdata->fg_irq);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_max",
+				&fuelgauge->pdata->capacity_max);
+		if (ret < 0)
+			pr_err("%s error reading capacity_max %d\n", __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_max_margin",
+				&fuelgauge->pdata->capacity_max_margin);
+		if (ret < 0)
+			pr_err("%s error reading capacity_max_margin %d\n", __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_min",
+				&fuelgauge->pdata->capacity_min);
+		if (ret < 0)
+			pr_err("%s error reading capacity_min %d\n", __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_calculation_type",
+				&fuelgauge->pdata->capacity_calculation_type);
+		if (ret < 0)
+			pr_err("%s error reading capacity_calculation_type %d\n",
+					__func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,fuel_alert_soc",
+				&fuelgauge->pdata->fuel_alert_soc);
+		if (ret < 0)
+			pr_err("%s error reading pdata->fuel_alert_soc %d\n",
+					__func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,model_type",
+			&fuelgauge->pdata->model_type);
+		if (ret < 0)
+			pr_err("%s error reading pdata->model_type %d\n",
+					__func__, ret);
+	}
+
+	pr_info("%s: fg_irq : %d, capacity_max : %d, capacity_max_margin : %d, capacity_min : %d\n",
+		__func__, fuelgauge->pdata->fg_irq, fuelgauge->pdata->capacity_max,
+		fuelgauge->pdata->capacity_max_margin, fuelgauge->pdata->capacity_min);
+
+	/* get battery_params node */
+	np = of_find_node_by_name(of_node_get(np), "battery_params");
+	if (np == NULL) {
+		PINFO("Cannot find child node \"battery_params\"\n");
+		return -EINVAL;
+	}
+
+	/* get battery_id */
+	if (of_property_read_u32(np, "battery,id", &battery_id) < 0)
+		PINFO("not battery,id property\n");
+	if (battery_id == -1)
+		battery_id = get_battery_id(fuelgauge);
+	PINFO("battery id = %d\n", battery_id);
+	
+#ifdef ENABLE_BATT_LONG_LIFE
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "v_max_table");
+	ret = of_property_read_u32_array(np, prop_name, v_max_table, fuelgauge->pdata->num_age_step);
+
+	if(ret < 0){
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+
+		for (i = 0; i <fuelgauge->pdata->num_age_step; i++){
+			fuelgauge->info.v_max_table[i] = fuelgauge->info.battery_table[DISCHARGE_TABLE][SM5703_FG_TABLE_LEN-1];
+			PINFO("%s = <v_max_table[%d] 0x%x>\n", prop_name, i, fuelgauge->info.v_max_table[i]);
+		}
+	}else{
+		for (i = 0; i < fuelgauge->pdata->num_age_step; i++){
+			fuelgauge->info.v_max_table[i] = v_max_table[i];
+			PINFO("%s = <v_max_table[%d] 0x%x>\n", prop_name, i, fuelgauge->info.v_max_table[i]);
+		}
+	}
+
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "q_max_table");
+	ret = of_property_read_u32_array(np, prop_name, q_max_table,fuelgauge->pdata->num_age_step);
+
+	if(ret < 0){
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+
+		for (i = 0; i < fuelgauge->pdata->num_age_step; i++){
+			fuelgauge->info.q_max_table[i] = 100;
+			PINFO("%s = <q_max_table[%d] %d>\n", prop_name, i, fuelgauge->info.q_max_table[i]);
+		}
+	}else{
+		for (i = 0; i < fuelgauge->pdata->num_age_step; i++){
+			fuelgauge->info.q_max_table[i] = q_max_table[i];
+			PINFO("%s = <q_max_table[%d] %d>\n", prop_name, i, fuelgauge->info.q_max_table[i]);
+		}
+	}
+	fuelgauge->chg_float_voltage = fuelgauge->pdata->age_data[0].float_voltage;
+	fuelgauge->info.v_max_now = fuelgauge->info.v_max_table[0];
+	fuelgauge->info.q_max_now = fuelgauge->info.q_max_table[0];
+	PINFO("%s = <v_max_now = 0x%x>, <q_max_now = 0x%x>, <chg_float_voltage = %d>\n", prop_name, fuelgauge->info.v_max_now, fuelgauge->info.q_max_now, fuelgauge->chg_float_voltage);
+#endif
+	
+	
+	/* get battery_table */
+	for (i = DISCHARGE_TABLE; i < TABLE_MAX; i++) {
+		snprintf(prop_name, PROPERTY_NAME_SIZE,
+				"battery%d,%s%d", battery_id, "battery_table", i);
+
+		ret = of_property_read_u32_array(np, prop_name, table, 16);
+		if (ret < 0) {
+			PINFO("Can get prop %s (%d)\n", prop_name, ret);
+		}
+		for (j = 0; j <= SM5703_FG_TABLE_LEN; j++) {
+			fuelgauge->info.battery_table[i][j] = table[j];
+			PINFO("%s = <table[%d][%d] 0x%x>\n", prop_name, i, j, table[j]);
+		}
+	}
+
+	/* get rce */
+	for (i = 0; i < 3; i++) {
+		snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "rce_value");
+		ret = of_property_read_u32_array(np, prop_name, rce_value, 3);
+		if (ret < 0) {
+			PINFO("Can get prop %s (%d)\n", prop_name, ret);
+		}
+		fuelgauge->info.rce_value[i] = rce_value[i];
+	}
+	PINFO("%s = <0x%x 0x%x 0x%x>\n", prop_name, rce_value[0], rce_value[1], rce_value[2]);
+
+	/* get dtcd_value */
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "dtcd_value");
+	ret = of_property_read_u32_array(np, prop_name, &fuelgauge->info.dtcd_value, 1);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	PINFO("%s = <0x%x>\n",prop_name, fuelgauge->info.dtcd_value);
+
+	/* get rs_value */
+	for (i = 0; i < 4; i++) {
+		snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "rs_value");
+		ret = of_property_read_u32_array(np, prop_name, rs_value, 4);
+		if (ret < 0) {
+			PINFO("Can get prop %s (%d)\n", prop_name, ret);
+		}
+		fuelgauge->info.rs_value[i] = rs_value[i];
+	}
+	PINFO("%s = <0x%x 0x%x 0x%x 0x%x>\n", prop_name, rs_value[0], rs_value[1], rs_value[2], rs_value[3]);
+
+	/* get vit_period */
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "vit_period");
+	ret = of_property_read_u32_array(np, prop_name, &fuelgauge->info.vit_period, 1);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	PINFO("%s = <0x%x>\n",prop_name, fuelgauge->info.vit_period);
+
+	/* get mix_value */
+	for (i = 0; i < 2; i++) {
+		snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "mix_value");
+		ret = of_property_read_u32_array(np, prop_name, mix_value, 2);
+		if (ret < 0) {
+			PINFO("Can get prop %s (%d)\n", prop_name, ret);
+		}
+		fuelgauge->info.mix_value[i] = mix_value[i];
+	}
+	PINFO("%s = <0x%x 0x%x>\n", prop_name, mix_value[0], mix_value[1]);
+
+	/* battery_type */
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "battery_type");
+	ret = of_property_read_u32_array(np, prop_name, &fuelgauge->info.battery_type, 1);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	PINFO("%s = <%d>\n", prop_name, fuelgauge->info.battery_type);
+
+	/* TOP OFF SOC */
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "topoff_soc");
+	ret = of_property_read_u32_array(np, prop_name, topoff_soc, 2);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	fuelgauge->info.enable_topoff_soc = topoff_soc[0];
+	fuelgauge->info.topoff_soc = topoff_soc[1];
+	PINFO("%s = <0x%x 0x%x>\n", prop_name, fuelgauge->info.enable_topoff_soc, fuelgauge->info.topoff_soc);
+
+	/* VOL & CURR CAL */
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "volt_cal");
+	ret = of_property_read_u32_array(np, prop_name, &fuelgauge->info.volt_cal, 1);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	PINFO("%s = <0x%x>\n", prop_name, fuelgauge->info.volt_cal);
+
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "curr_cal");
+	ret = of_property_read_u32_array(np, prop_name, &fuelgauge->info.curr_cal, 1);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	PINFO("%s = <0x%x>\n", prop_name, fuelgauge->info.curr_cal);
+
+	/* temp_std */
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "temp_std");
+	ret = of_property_read_u32_array(np, prop_name, &fuelgauge->info.temp_std, 1);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	PINFO("%s = <%d>\n", prop_name, fuelgauge->info.temp_std);
+
+	/* temp_offset */
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "temp_offset");
+	ret = of_property_read_u32_array(np, prop_name, &fuelgauge->info.temp_offset, 1);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	PINFO("%s = <%d>\n", prop_name, fuelgauge->info.temp_offset);
+
+	/* temp_offset_cal */
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "temp_offset_cal");
+	ret = of_property_read_u32_array(np, prop_name, &fuelgauge->info.temp_offset_cal, 1);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	PINFO("%s = <0x%x>\n", prop_name, fuelgauge->info.temp_offset_cal);
+
+	/* charge_offset_cal */
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "charge_offset_cal");
+	ret = of_property_read_u32_array(np, prop_name, &fuelgauge->info.charge_offset_cal, 1);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	PINFO("%s = <0x%x>\n", prop_name, fuelgauge->info.charge_offset_cal);
+
+	/* tem poff level */
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "tem_poff");
+	ret = of_property_read_u32_array(np, prop_name, set_temp_poff, 4);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	fuelgauge->info.n_tem_poff = set_temp_poff[0];
+	fuelgauge->info.n_tem_poff_offset = set_temp_poff[1];
+	fuelgauge->info.l_tem_poff = set_temp_poff[2];
+	fuelgauge->info.l_tem_poff_offset = set_temp_poff[3];
+
+	PINFO("%s = <%d, %d, %d, %d>\n", prop_name,
+		fuelgauge->info.n_tem_poff, fuelgauge->info.n_tem_poff_offset,
+		fuelgauge->info.l_tem_poff, fuelgauge->info.l_tem_poff_offset);
+
+	np = of_find_node_by_name(NULL, "battery");
+	if (!np) {
+		pr_info("%s : np NULL\n", __func__);
+		return -ENODATA;
+	}
+
+	ret = of_property_read_string(np, "battery,fuelgauge_name",
+		(char const **)&fuelgauge->pdata->fuelgauge_name);
+	if (ret)
+		pr_info("%s: fuelgauge name is Empty.\n", __func__);
+
+	return 0;
+}
+
+static struct of_device_id sm5703_fuelgauge_match_table[] = {
+	{ .compatible = "samsung,sm5703-fuelgauge",},
+	{},
+};
+#else
+static int sm5703_fg_parse_dt(struct sm5703_fuelgauge_data *fuelgauge)
+{
+	return -ENOSYS;
+}
+
+#define sm5703_fuelgauge_match_table NULL
+#endif /* CONFIG_OF */
+
+static int sm5703_fuelgauge_probe(struct i2c_client *client,
+		const struct i2c_device_id *id)
+{
+	struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
+	struct sm5703_fuelgauge_data *fuelgauge;
+	union power_supply_propval raw_soc_val;
+	int ret = 0;
+
+	pr_info("%s: SM5703 Fuelgauge Driver Loading\n", __func__);
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE))
+		return -EIO;
+
+	fuelgauge = kzalloc(sizeof(*fuelgauge), GFP_KERNEL);
+	if (!fuelgauge)
+		return -ENOMEM;
+
+	mutex_init(&fuelgauge->fg_lock);
+
+	fuelgauge->i2c = client;
+
+	if (client->dev.of_node) {
+		fuelgauge->pdata = devm_kzalloc(&client->dev, sizeof(*(fuelgauge->pdata)),
+				GFP_KERNEL);
+		if (!fuelgauge->pdata) {
+			dev_err(&client->dev, "Failed to allocate memory\n");
+			ret = -ENOMEM;
+			goto err_parse_dt_nomem;
+		}
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+		temp_parse_dt(fuelgauge);
+#endif
+		ret = sm5703_fg_parse_dt(fuelgauge);
+		if (ret < 0)
+			goto err_parse_dt;
+	} else {
+		fuelgauge->pdata = client->dev.platform_data;
+	}
+
+	i2c_set_clientdata(client, fuelgauge);
+
+	if (fuelgauge->pdata->fuelgauge_name == NULL)
+		fuelgauge->pdata->fuelgauge_name = "sm5703-fuelgauge";
+
+	fuelgauge->psy_fg.name          = fuelgauge->pdata->fuelgauge_name;
+	fuelgauge->psy_fg.type          = POWER_SUPPLY_TYPE_UNKNOWN;
+	fuelgauge->psy_fg.get_property  = sm5703_fg_get_property;
+	fuelgauge->psy_fg.set_property  = sm5703_fg_set_property;
+	fuelgauge->psy_fg.properties    = sm5703_fuelgauge_props;
+	fuelgauge->psy_fg.num_properties =
+		ARRAY_SIZE(sm5703_fuelgauge_props);
+
+	fuelgauge->capacity_max = fuelgauge->pdata->capacity_max;
+	raw_soc_val.intval = sm5703_get_soc(fuelgauge);
+
+	if (raw_soc_val.intval > fuelgauge->capacity_max)
+		sm5703_fg_calculate_dynamic_scale(fuelgauge, 100);
+
+	ret = sm5703_fg_init(fuelgauge);
+	if (ret < 0) {
+		pr_err("%s: Failed to Initialize Fuelgauge\n", __func__); 
+		/* goto err_data_free; */
+	}
+
+	ret = power_supply_register(&client->dev, &fuelgauge->psy_fg);
+	if (ret) {
+		pr_err("%s: Failed to Register psy_fg\n", __func__);
+		goto err_data_free;
+	}
+
+	if (fuelgauge->pdata->fuel_alert_soc >= 0) {
+		sm5703_fuelgauge_fuelalert_init(fuelgauge,
+					fuelgauge->pdata->fuel_alert_soc);
+		wake_lock_init(&fuelgauge->fuel_alert_wake_lock,
+					WAKE_LOCK_SUSPEND, "fuel_alerted");
+
+#if defined(CONFIG_STMP_SUPPORT_FG_ALERT)
+		INIT_DELAYED_WORK(
+					&fuelgauge->isr_work, sm5703_fg_isr_work);
+		ret = stmpe_request_irq(6, sm5703_fg_isr,
+							STMPE_TRIGGER_FALLING,
+							"SM5703-Fuelgauge", fuelgauge);
+		if(ret) {
+			pr_err("%s: Failed register to STMPE (%d)\n", __func__, ret);
+			goto err_supply_unreg;
+		}
+#else
+		if (fuelgauge->pdata->fg_irq > 0) {
+			INIT_DELAYED_WORK(
+					&fuelgauge->isr_work, sm5703_fg_isr_work);
+
+			fuelgauge->fg_irq = gpio_to_irq(fuelgauge->pdata->fg_irq);
+			dev_info(&client->dev,
+					"%s: fg_irq = %d\n", __func__, fuelgauge->fg_irq);
+			if (fuelgauge->fg_irq > 0) {
+				ret = request_threaded_irq(fuelgauge->fg_irq,
+						NULL, sm5703_fg_irq_thread,
+						IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING
+						| IRQF_ONESHOT,
+						"fuelgauge-irq", fuelgauge);
+				if (ret) {
+					dev_err(&client->dev,
+							"%s: Failed to Reqeust IRQ\n", __func__);
+					goto err_supply_unreg;
+				}
+
+				ret = enable_irq_wake(fuelgauge->fg_irq);
+				if (ret < 0)
+					dev_err(&client->dev,
+							"%s: Failed to Enable Wakeup Source(%d)\n",
+							__func__, ret);
+			} else {
+				dev_err(&client->dev, "%s: Failed gpio_to_irq(%d)\n",
+						__func__, fuelgauge->fg_irq);
+				goto err_supply_unreg;
+			}
+		}
+#endif
+	}
+
+	fuelgauge->initial_update_of_soc = true;
+	fuelgauge->force_dec_mode = SM5703_NORMAL_MODE;
+
+#ifdef USE_SUSPEND_LATE
+	fuelgauge->is_sleep_state = false;
+#endif
+
+	pr_info("%s: SM5703 Fuelgauge Driver Loaded\n", __func__);
+	return 0;
+
+err_supply_unreg:
+	power_supply_unregister(&fuelgauge->psy_fg);
+err_data_free:
+	if (client->dev.of_node)
+		kfree(fuelgauge->pdata);
+
+err_parse_dt:
+err_parse_dt_nomem:
+	mutex_destroy(&fuelgauge->fg_lock);
+	kfree(fuelgauge);
+
+	return ret;
+}
+
+static const struct i2c_device_id sm5703_fuelgauge_id[] = {
+	{"sm5703-fuelgauge", 0},
+	{}
+};
+
+static void sm5703_fuelgauge_shutdown(struct i2c_client *client)
+{
+}
+
+static int sm5703_fuelgauge_remove(struct i2c_client *client)
+{
+	struct sm5703_fuelgauge_data *fuelgauge = i2c_get_clientdata(client);
+
+	if (fuelgauge->pdata->fuel_alert_soc >= 0)
+		wake_lock_destroy(&fuelgauge->fuel_alert_wake_lock);
+
+	return 0;
+}
+
+#if defined CONFIG_PM
+static int sm5703_fuelgauge_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int sm5703_fuelgauge_resume(struct device *dev)
+{
+	struct sm5703_fuelgauge_data *fuelgauge = dev_get_drvdata(dev);
+
+	fuelgauge->initial_update_of_soc = true;
+
+	return 0;
+}
+
+#ifdef USE_SUSPEND_LATE
+static int sm5703_suspend_late(struct device *dev)
+{
+	struct sm5703_fuelgauge_data *fuelgauge = dev_get_drvdata(dev);
+
+	fuelgauge->is_sleep_state = true;
+
+	return 0;
+}
+
+static int sm5703_resume_noirq(struct device *dev)
+{
+	struct sm5703_fuelgauge_data *fuelgauge = dev_get_drvdata(dev);
+
+	fuelgauge->is_sleep_state = false;
+
+	return 0;
+}
+#endif
+
+#else
+#define sm5703_fuelgauge_suspend NULL
+#define sm5703_fuelgauge_resume NULL
+#endif
+
+const struct dev_pm_ops sm5703_fuelgauge_pm_ops = {
+	.suspend = sm5703_fuelgauge_suspend,
+	.resume = sm5703_fuelgauge_resume,
+#ifdef USE_SUSPEND_LATE
+	.suspend_late = sm5703_suspend_late,
+	.resume_noirq = sm5703_resume_noirq,
+#endif
+};
+
+static struct i2c_driver sm5703_fuelgauge_driver = {
+	.driver = {
+		.name = "sm5703-fuelgauge",
+		.owner = THIS_MODULE,
+		.pm = &sm5703_fuelgauge_pm_ops,
+		.of_match_table = sm5703_fuelgauge_match_table,
+	},
+	.probe  = sm5703_fuelgauge_probe,
+	.remove = sm5703_fuelgauge_remove,
+	.shutdown   = sm5703_fuelgauge_shutdown,
+	.id_table   = sm5703_fuelgauge_id,
+};
+
+static int __init sm5703_fuelgauge_init(void)
+{
+	pr_info("%s: SM5703 Fuelgauge Init\n", __func__);
+	return i2c_add_driver(&sm5703_fuelgauge_driver);
+}
+
+static void __exit sm5703_fuelgauge_exit(void)
+{
+	i2c_del_driver(&sm5703_fuelgauge_driver);
+}
+module_init(sm5703_fuelgauge_init);
+module_exit(sm5703_fuelgauge_exit);
+
+MODULE_DESCRIPTION("Samsung SM5703 Fuel Gauge Driver");
+MODULE_AUTHOR("Samsung Electronics");
+MODULE_LICENSE("GPL");
diff -Naur linux-3.18.14/drivers/battery_v2/sm5705_charger.c samsung/drivers/battery_v2/sm5705_charger.c
--- linux-3.18.14/drivers/battery_v2/sm5705_charger.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/sm5705_charger.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,2229 @@
+
+/*
+ *  /drivers/battery/sm5705_charger_1.c
+ *
+ *  SM5705 Charger driver for SEC_BATTERY Flatform support
+ *
+ *  Copyright (C) 2015 Silicon Mitus,
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#define pr_fmt(fmt)	"sm5705-charger: %s: " fmt, __func__
+
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/power_supply.h>
+#include <linux/mfd/sm5705.h>
+#include <linux/spinlock.h>
+#ifdef CONFIG_USB_HOST_NOTIFY
+#include <linux/usb_notify.h>
+#endif
+#if defined(CONFIG_VBUS_NOTIFIER)
+#include <linux/vbus_notifier.h>
+#endif
+#include <linux/of_gpio.h>
+
+#include "include/charger/sm5705_charger.h"
+#include "include/charger/sm5705_charger_oper.h"
+
+#if defined(CONFIG_USE_POGO)
+extern void muic_detect_dev_for_wcin(void);
+#endif
+extern void muic_detect_dev_for_nobat(void);
+
+//#define SM5705_CHG_FULL_DEBUG 1
+
+#define ENABLE 1
+#define DISABLE 0
+
+enum {
+	SM5705_CHG_SRC_VBUS = 0x0,
+	SM5705_CHG_SRC_WPC,
+	SM5705_CHG_SRC_MAX,
+};
+
+enum {
+	SM5705_CHG_OTG_CURRENT_0_5A     = 0x0,
+	SM5705_CHG_OTG_CURRENT_0_7A,
+	SM5705_CHG_OTG_CURRENT_0_9A,
+	SM5705_CHG_OTG_CURRENT_1_5A,
+};
+
+enum {
+	SM5705_CHG_BST_IQ3LIMIT_2_0A    = 0x0,
+	SM5705_CHG_BST_IQ3LIMIT_2_8A,
+	SM5705_CHG_BST_IQ3LIMIT_3_5A,
+	SM5705_CHG_BST_IQ3LIMIT_4_0A,
+};
+
+/* Interrupt status Index & Offset */
+enum {
+	SM5705_INT_STATUS1 = 0x0,
+	SM5705_INT_STATUS2,
+	SM5705_INT_STATUS3,
+	SM5705_INT_STATUS4,
+	SM5705_INT_MAX,
+};
+
+enum {
+	SM5705_INT_STATUS1_VBUSPOK          = 0x0,
+	SM5705_INT_STATUS1_VBUSUVLO,
+	SM5705_INT_STATUS1_VBUSOVP,
+	SM5705_INT_STATUS1_VBUSLIMIT,
+	SM5705_INT_STATUS1_WPCINPOK,
+	SM5705_INT_STATUS1_WPCINUVLO,
+	SM5705_INT_STATUS1_WPCINOVP,
+	SM5705_INT_STATUS1_WPCINLIMIT,
+};
+
+enum {
+	SM5705_INT_STATUS2_AICL             = 0x0,
+	SM5705_INT_STATUS2_BATOVP,
+	SM5705_INT_STATUS2_NOBAT,
+	SM5705_INT_STATUS2_CHGON,
+	SM5705_INT_STATUS2_Q4FULLON,
+	SM5705_INT_STATUS2_TOPOFF,
+	SM5705_INT_STATUS2_DONE,
+	SM5705_INT_STATUS2_WDTMROFF,
+};
+
+enum {
+	SM5705_INT_STATUS3_THEMREG          = 0x0,
+	SM5705_INT_STATUS3_THEMSHDN,
+	SM5705_INT_STATUS3_OTGFAIL,
+	SM5705_INT_STATUS3_DISLIMIT,
+	SM5705_INT_STATUS3_PRETMROFF,
+	SM5705_INT_STATUS3_FASTTMROFF,
+	SM5705_INT_STATUS3_LOWBATT,
+	SM5705_INT_STATUS3_nEQ4,
+};
+
+enum {
+	SM5705_INT_STATUS4_FLED1SHORT       = 0x0,
+	SM5705_INT_STATUS4_FLED1OPEN,
+	SM5705_INT_STATUS4_FLED2SHORT,
+	SM5705_INT_STATUS4_FLED2OPEN,
+	SM5705_INT_STATUS4_BOOSTPOK_NG,
+	SM5705_INT_STATUS4_BOOSTPOL,
+	SM5705_INT_STATUS4_ABSTMR1OFF,
+	SM5705_INT_STATUS4_SBPS,
+};
+
+#if defined(SM5705_USED_WIRELESS_CHARGER) || defined(CONFIG_USE_POGO)
+#define __n_is_cable_type_for_wireless(cable_type) \
+					((cable_type != POWER_SUPPLY_TYPE_WIRELESS) && \
+					(cable_type != POWER_SUPPLY_TYPE_HV_WIRELESS) && \
+					(cable_type != POWER_SUPPLY_TYPE_PMA_WIRELESS) && \
+					(cable_type != POWER_SUPPLY_TYPE_HV_WIRELESS_ETX))
+
+#define __is_cable_type_for_wireless(cable_type)  \
+					((cable_type == POWER_SUPPLY_TYPE_WIRELESS) || \
+					(cable_type == POWER_SUPPLY_TYPE_PMA_WIRELESS))
+
+#define __is_cable_type_for_hv_wireless(cable_type)  \
+					((cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS) || \
+					(cable_type == POWER_SUPPLY_TYPE_HV_WIRELESS_ETX))
+#else
+#define __n_is_cable_type_for_wireless(cable_type)  (true)
+#define __is_cable_type_for_wireless(cable_type)    (false)
+#define __is_cable_type_for_hv_wireless(cable_type) (false)
+#endif
+
+#define __is_cable_type_for_hv_mains(cable_type)  \
+					((cable_type == POWER_SUPPLY_TYPE_HV_MAINS) || \
+					(cable_type == POWER_SUPPLY_TYPE_HV_PREPARE_MAINS) || \
+					(cable_type == POWER_SUPPLY_TYPE_HV_ERR))
+
+static struct device_attribute sm5705_charger_attrs[] = {
+	SM5705_CHARGER_ATTR(chip_id),
+	SM5705_CHARGER_ATTR(charger_op_mode),
+};
+
+/**
+ *  SM5705 Charger device register control functions
+ */
+
+#if defined(SM5705_WATCHDOG_RESET_ACTIVATE)
+static struct sm5705_charger_data *g_sm5705_charger;
+static int sm5705_CHG_set_WATCHDOG_TMR(struct sm5705_charger_data *charger,
+				unsigned char wdt_timer)
+{
+	sm5705_update_reg(charger->i2c,
+		SM5705_REG_CHGCNTL8, ((wdt_timer & 0x3) << 5), (0x3 << 5));
+	pr_info("WATCHDOG_TMR set (timer=%d)\n", wdt_timer);
+
+	return 0;
+}
+
+static int sm5705_CHG_set_ENWATCHDOG(struct sm5705_charger_data *charger,
+				bool enable, bool enchg_reon)
+{
+	unsigned char reg_val = (enchg_reon << 4) | (enable << 3);
+
+	sm5705_update_reg(charger->i2c, SM5705_REG_CNTL, reg_val, (0x3 << 3));
+	pr_info("ENWATCHDOG set (enable=%d, enCHG_REON=%d)\n", enable, enchg_reon);
+
+	return 0;
+}
+
+static void sm5705_CHG_set_WDTMR_RST(struct sm5705_charger_data *charger)
+{
+	sm5705_update_reg(charger->i2c, SM5705_REG_CHGCNTL8, (0x1 << 7), (0x1 << 7));
+}
+#endif
+
+static bool sm5705_CHG_get_INT_STATUS(struct sm5705_charger_data *charger,
+				unsigned char index, unsigned char offset)
+{
+	unsigned char reg_val;
+	int ret;
+
+	ret = sm5705_read_reg(charger->i2c, SM5705_REG_STATUS1 + index, &reg_val);
+	if (ret < 0) {
+		pr_err("fail to I2C read REG:SM5705_REG_INT%d\n", 1 + index);
+		return 0;
+	}
+
+	reg_val = (reg_val & (1 << offset)) >> offset;
+
+	return reg_val;
+}
+
+static int sm5705_CHG_set_TOPOFF_TMR(struct sm5705_charger_data *charger,
+				unsigned char topoff_timer)
+{
+	sm5705_update_reg(charger->i2c,
+		SM5705_REG_CHGCNTL8, ((topoff_timer & 0x3) << 3), (0x3 << 3));
+	pr_info("TOPOFF_TMR set (timer=%d)\n", topoff_timer);
+
+	return 0;
+}
+
+static int sm5705_CHG_enable_AUTOSTOP(struct sm5705_charger_data *charger,
+				bool enable)
+{
+	int ret;
+
+	ret = sm5705_update_reg(charger->i2c, SM5705_REG_CHGCNTL4, (enable << 6), (1 << 6));
+	if (ret < 0) {
+		pr_err("fail to update REG:SM5705_REG_CHGCNTL4 in AUTOSTOP[6]\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+#if defined(CONFIG_USE_POGO)
+static int sm5705_CHG_set_external_boost(struct sm5705_charger_data *charger,
+				bool enable)
+{
+	int ret;
+
+	ret = sm5705_update_reg(charger->i2c, SM5705_REG_CHGCNTL7, (enable << 4), (1 << 4));
+	if (ret < 0) {
+		pr_err("fail to update REG:SM5705_REG_CHGCNTL7 in ENUSBLOD2[4]\n");
+		return ret;
+	}
+
+	return 0;
+}
+#endif
+
+static unsigned char _calc_BATREG_offset_to_float_mV(unsigned short mV)
+{
+	unsigned char offset;
+
+	if (mV < 4000) {
+		offset = 0x0;     /* BATREG = 3.8V */
+	} else if (mV < 4010) {
+		offset = 0x1;     /* BATREG = 4.0V */
+	} else if (mV < 4630) {
+		offset = (((mV - 4010) / 10) + 2);    /* BATREG = 4.01 ~ 4.62 */
+	} else {
+		offset = 0x15;    /* default Offset : 4.2V */
+	}
+
+	return offset;
+}
+
+static int sm5705_CHG_set_BATREG(struct sm5705_charger_data *charger,
+				unsigned short float_mV)
+{
+	unsigned char offset = _calc_BATREG_offset_to_float_mV(float_mV);
+	int ret;
+
+	pr_info("set BATREG voltage(%dmV - offset=0x%x)\n", float_mV, offset);
+
+	ret = sm5705_update_reg(charger->i2c, SM5705_REG_CHGCNTL4, offset, 0x3F);
+	if (ret < 0) {
+		pr_err("fail to update REG:SM5705_REG_CHGCNTL4 in BATREG[5:0]\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static unsigned short _calc_float_mV_to_BATREG_offset(unsigned char offset)
+{
+	return ((offset - 2) * 10) + 4010;
+}
+
+static unsigned short sm5705_CHG_get_BATREG(struct sm5705_charger_data *charger)
+{
+	unsigned char offset;
+	int ret;
+
+	ret = sm5705_read_reg(charger->i2c, SM5705_REG_CHGCNTL4, &offset);
+	if (ret < 0) {
+		pr_err("fail to read REG:SM5705_REG_CHGCNTL4\n");
+		return 0;
+	}
+
+	return _calc_float_mV_to_BATREG_offset(offset & 0x3F);
+}
+
+static unsigned char _calc_TOPOFF_offset_to_topoff_mA(unsigned short mA)
+{
+	unsigned char offset;
+
+	if (mA < 100) {
+		offset = 0x0;
+	} else if (mA < 480) {
+		offset = (mA - 100) / 25;
+	} else {
+		offset = 0xF;
+	}
+
+	return offset;
+}
+
+static int sm5705_CHG_set_TOPOFF(struct sm5705_charger_data *charger,
+				unsigned short topoff_mA)
+{
+	unsigned char offset = _calc_TOPOFF_offset_to_topoff_mA(topoff_mA);
+	int ret;
+
+	pr_info("set TOP-OFF current(%dmA - offset=0x%x)\n", topoff_mA, offset);
+
+	ret = sm5705_update_reg(charger->i2c, SM5705_REG_CHGCNTL5, offset, 0xF);
+	if (ret < 0) {
+		pr_err("fail to update REG:SM5705_REG_CHGCNTL5 in TOPOFF[3:0]\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int sm5705_CHG_set_FREQSEL(struct sm5705_charger_data *charger,
+                unsigned char freq_index)
+{
+	int ret;
+
+	pr_info("set BUCK&BOOST freq=0x%x\n", freq_index);
+
+	ret = sm5705_update_reg(charger->i2c, SM5705_REG_CHGCNTL5, ((freq_index & 0x3) << 4), (0x3 << 4));
+	if (ret < 0) {
+		pr_err("fail to update REG:SM5705_REG_CHGCNTL5 in FREQSEL[5:4]\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static unsigned char _calc_AICL_threshold_offset_to_mV(unsigned short aiclth_mV)
+{
+	unsigned char offset;
+
+	if (aiclth_mV < 4500) {
+		offset = 0x0;
+	} else if (aiclth_mV < 4900) {
+		offset = (aiclth_mV - 4500) / 100;
+	} else {
+		offset = 0x3;
+	}
+
+	return offset;
+}
+
+static int sm5705_CHG_set_AICLTH(struct sm5705_charger_data *charger,
+				unsigned short aiclth_mV)
+{
+	unsigned char offset = _calc_AICL_threshold_offset_to_mV(aiclth_mV);
+	int ret;
+
+	pr_info("set AICL threshold (%dmV - offset=0x%x)\n", aiclth_mV, offset);
+
+	ret = sm5705_update_reg(charger->i2c, SM5705_REG_CHGCNTL7, (offset << 6), 0xC0);
+	if (ret < 0) {
+		pr_err("fail to update REG:SM5705_REG_CHGCNTL7 in AICLTH[7:6]\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int sm5705_CHG_set_OVPSEL(struct sm5705_charger_data *charger, bool enable)
+{
+	int ret;
+
+	pr_info("set OVPSEL=%d\n", enable);
+
+	ret = sm5705_update_reg(charger->i2c, SM5705_REG_CHGCNTL7, (enable << 2), (1 << 2));
+	if (ret < 0) {
+		pr_err("fail to update REG:SM5705_REG_CHGCNTL7 in OVPSEL[2]\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int sm5705_CHG_enable_AICL(struct sm5705_charger_data *charger, bool enable)
+{
+	int ret;
+
+	ret = sm5705_update_reg(charger->i2c, SM5705_REG_CHGCNTL7, (enable << 5), (1 << 5));
+	if (ret < 0) {
+		pr_err("fail to update REG:SM5705_REG_CHGCNTL7 in AICLEN[5]\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int sm5705_CHG_set_BST_IQ3LIMIT(struct sm5705_charger_data *charger,
+				unsigned char index)
+{
+	if (index > SM5705_CHG_BST_IQ3LIMIT_4_0A) {
+		pr_err("invalid limit current index (index=0x%x)\n", index);
+		return -EINVAL;
+	}
+
+	sm5705_update_reg(charger->i2c, SM5705_REG_CHGCNTL6, ((index & 0x3)), 0x3);
+
+	pr_info("BST IQ3LIMIT set (index=0x%x)\n", index);
+
+	return 0;
+}
+
+#if defined(SM5705_I2C_RESET_ACTIVATE)
+static int sm5705_CHG_set_ENI2CRESET(struct sm5705_charger_data *charger, bool enable)
+{
+	sm5705_update_reg(charger->i2c, SM5705_REG_CHGCNTL6, (enable << 4), (0x1 << 4));
+	pr_info("ENI2CRESET set (enable=%d)\n", enable);
+	return 0;
+}
+#endif
+
+#if defined(SM5705_MANUAL_RESET_ACTIVATE)
+static int sm5705_CHG_set_ENMRSTB(struct sm5705_charger_data *charger,
+				unsigned char timer)
+{
+	sm5705_update_reg(charger->i2c, SM5705_REG_CHGCNTL8, (timer & 0x3), 0x3);
+	pr_info("ENMRSTB set (timer=%d)\n", timer);
+	return 0;
+}
+#endif
+
+static int sm5705_CHG_enable_AUTOSET(struct sm5705_charger_data *charger, bool enable)
+{
+	int ret;
+
+	ret = sm5705_update_reg(charger->i2c, SM5705_REG_CHGCNTL7, (enable << 1), (1 << 1));
+	if (ret < 0) {
+		pr_err("fail to update REG:SM5705_REG_CHGCNTL7 in AUTOSET[1]\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static unsigned char _calc_FASTCHG_current_offset_to_mA(unsigned short mA)
+{
+	unsigned char offset;
+
+	if (mA < 100) {
+		offset = 0x00;
+	} else {
+		offset = ((mA - 100) / 50) & 0x3F;
+	}
+
+	return offset;
+}
+
+static int sm5705_CHG_set_FASTCHG(struct sm5705_charger_data *charger,
+				unsigned char index, unsigned short FASTCHG_mA)
+{
+	unsigned char offset = _calc_FASTCHG_current_offset_to_mA(FASTCHG_mA);
+
+	pr_info("FASTCHG src=%d, current=%dmA offset=0x%x\n", index, FASTCHG_mA, offset);
+
+	if (index > SM5705_CHG_SRC_WPC) {
+		return -EINVAL;
+	}
+
+	sm5705_write_reg(charger->i2c, SM5705_REG_CHGCNTL2 + index, offset);
+
+	return 0;
+}
+
+static unsigned char _calc_INPUT_LIMIT_current_offset_to_mA(unsigned char index,
+				unsigned short mA)
+{
+	unsigned char offset;
+
+	if (mA < 100) {
+		offset = 0x10;
+	} else {
+		if (index == SM5705_CHG_SRC_VBUS) {
+			offset = ((mA - 100) / 25) & 0x7F;       /* max = 3275mA */
+		} else {
+			offset = ((mA - 100) / 25) & 0x3F;       /* max = 1650mA */
+		}
+	}
+
+	return offset;
+}
+
+static int sm5705_CHG_set_INPUT_LIMIT(struct sm5705_charger_data *charger,
+				unsigned char index, unsigned short LIMIT_mA)
+{
+	unsigned char offset = _calc_INPUT_LIMIT_current_offset_to_mA(index, LIMIT_mA);
+
+	pr_info("set Input LIMIT src=%d, current=%dmA offset=0x%x\n", index, LIMIT_mA, offset);
+
+	if (index > SM5705_CHG_SRC_WPC) {
+		return -EINVAL;
+	}
+
+	sm5705_write_reg(charger->i2c, SM5705_REG_VBUSCNTL + index, offset);
+
+	return 0;
+}
+
+static unsigned short _calc_INPUT_LIMIT_current_mA_to_offset(unsigned char index,
+				unsigned char offset)
+{
+	return (offset * 25) + 100;
+}
+
+static unsigned short sm5705_CHG_get_INPUT_LIMIT(struct sm5705_charger_data *charger,
+				unsigned char index)
+{
+	unsigned short LIMIT_mA;
+	unsigned char offset;
+
+	if (index > SM5705_CHG_SRC_WPC) {
+		pr_err("invalid charger source index = %d\n", index);
+		return 0;
+	}
+
+	sm5705_read_reg(charger->i2c, SM5705_REG_VBUSCNTL + index, &offset);
+
+	LIMIT_mA = _calc_INPUT_LIMIT_current_mA_to_offset(index, offset);
+
+#ifdef SM5705_CHG_FULL_DEBUG
+	pr_info("get INPUT LIMIT src=%d, offset=0x%x, current=%dmA\n", index, offset, LIMIT_mA);
+#endif
+
+	return LIMIT_mA;
+}
+
+static unsigned short _calc_FASTCHG_current_mA_to_offset(unsigned char index,
+				unsigned char offset)
+{
+	return (offset * 50) + 100;
+}
+
+static unsigned short sm5705_CHG_get_FASTCHG(struct sm5705_charger_data *charger,
+				unsigned char index)
+{
+	unsigned short FASTCHG_mA;
+	unsigned char offset;
+
+	if (index > SM5705_CHG_SRC_WPC) {
+		pr_err("invalid charger source index = %d\n", index);
+		return 0;
+	}
+
+	sm5705_read_reg(charger->i2c, SM5705_REG_CHGCNTL2 + index, &offset);
+
+	FASTCHG_mA = _calc_FASTCHG_current_mA_to_offset(index, offset);
+
+	pr_info("get FASTCHG src=%d, offset=0x%x, current=%dmA\n", index, offset, FASTCHG_mA);
+
+	return FASTCHG_mA;
+}
+
+/* monitering REG_MAP */
+static unsigned char sm5705_CHG_read_reg(struct sm5705_charger_data *charger,
+				unsigned char reg)
+{
+	unsigned char reg_val = 0x0;
+
+	sm5705_read_reg(charger->i2c, reg, &reg_val);
+
+	return reg_val;
+}
+
+static void sm5705_chg_test_read(struct sm5705_charger_data *charger)
+{
+	char str[1000] = {0,};
+	int i;
+
+	for (i = SM5705_REG_INTMSK1; i <= SM5705_REG_FLED1CNTL1; i++) {
+		sprintf(str+strlen(str), "0x%02X:0x%02x, ", i, sm5705_CHG_read_reg(charger, i));
+	}
+
+	sprintf(str+strlen(str), "0x%02X:0x%02x, ", SM5705_REG_FLEDCNTL6,
+		sm5705_CHG_read_reg(charger, SM5705_REG_FLEDCNTL6));
+	sprintf(str+strlen(str), "0x%02X:0x%02x, ", SM5705_REG_SBPSCNTL,
+		sm5705_CHG_read_reg(charger, SM5705_REG_SBPSCNTL));
+
+	pr_info("[CHG] %s\n", str);
+}
+
+/**
+ *  SM5705 Charger Driver support functions
+ */
+
+static bool sm5705_charger_check_oper_otg_mode_on(void)
+{
+	unsigned char current_status = sm5705_charger_oper_get_current_status();
+	bool ret;
+
+	if (current_status & (1 << SM5705_CHARGER_OP_EVENT_OTG)) {
+		ret = true;
+	} else {
+		ret = false;
+	}
+
+	return ret;
+}
+
+static bool sm5705_charger_get_charging_on_status(struct sm5705_charger_data *charger)
+{
+	return sm5705_CHG_get_INT_STATUS(charger, SM5705_INT_STATUS2, SM5705_INT_STATUS2_CHGON);
+}
+
+static bool sm5705_charger_get_power_source_status(struct sm5705_charger_data *charger)
+{
+	int gpio = gpio_get_value(charger->pdata->chg_gpio_en);
+
+	return ((gpio & 0x1)  == 0);    /* charging pin active LOW */
+}
+
+static int sm5705_get_input_current(struct sm5705_charger_data *charger)
+{
+	int get_current;
+
+	if (!(__n_is_cable_type_for_wireless(charger->cable_type)) ||
+			charger->cable_type == POWER_SUPPLY_TYPE_POGO) {
+		get_current = sm5705_CHG_get_INPUT_LIMIT(charger, SM5705_CHG_SRC_WPC);
+	} else {
+		get_current = sm5705_CHG_get_INPUT_LIMIT(charger, SM5705_CHG_SRC_VBUS);
+	}
+#ifdef SM5705_CHG_FULL_DEBUG
+	pr_info("src_type=%d, current=%d\n",
+		__n_is_cable_type_for_wireless(charger->cable_type), get_current);
+#endif
+
+	return get_current;
+}
+
+static int sm5705_get_charge_current(struct sm5705_charger_data *charger)
+{
+	int get_current;
+
+	if (!(__n_is_cable_type_for_wireless(charger->cable_type)) ||
+			charger->cable_type == POWER_SUPPLY_TYPE_POGO) {
+		get_current = sm5705_CHG_get_FASTCHG(charger, SM5705_CHG_SRC_WPC);
+	} else {
+		get_current = sm5705_CHG_get_FASTCHG(charger, SM5705_CHG_SRC_VBUS);
+	}
+	pr_info("src_type=%d, current=%d\n",
+		__n_is_cable_type_for_wireless(charger->cable_type), get_current);
+
+	return get_current;
+}
+
+static void sm5705_enable_charging_on_switch(struct sm5705_charger_data *charger,
+				bool enable)
+{
+	if ((enable == 0) & sm5705_CHG_get_INT_STATUS(charger, SM5705_INT_STATUS1, SM5705_INT_STATUS1_VBUSPOK)) {
+		sm5705_CHG_set_FREQSEL(charger, SM5705_BUCK_BOOST_FREQ_1_5MHz);
+	} else {
+		sm5705_CHG_set_FREQSEL(charger, SM5705_BUCK_BOOST_FREQ_3MHz);
+	}
+
+	gpio_direction_output(charger->pdata->chg_gpio_en, !(enable));
+
+	if (!enable) {
+		/* SET: charging-off condition */
+		charger->charging_current = 0;
+		charger->topoff_pending = 0;
+	}
+
+	sm5705_chg_test_read(charger);
+	pr_info("turn-%s Charging enable pin\n", enable ? "ON" : "OFF");
+}
+
+static int sm5705_set_charge_current(struct sm5705_charger_data *charger,
+				unsigned short charge_current)
+{
+	if (!(__n_is_cable_type_for_wireless(charger->cable_type)) ||
+			charger->cable_type == POWER_SUPPLY_TYPE_POGO) {
+		sm5705_CHG_set_FASTCHG(charger, SM5705_CHG_SRC_WPC, charge_current);
+	} else {
+		sm5705_CHG_set_FASTCHG(charger, SM5705_CHG_SRC_VBUS, charge_current);
+	}
+
+	return 0;
+}
+
+static int sm5705_set_input_current(struct sm5705_charger_data *charger,
+				unsigned short input_current)
+{
+	if (!input_current) {
+		pr_info("skip process, input_current = 0\n");
+		return 0;
+	}
+
+	if (!(__n_is_cable_type_for_wireless(charger->cable_type)) ||
+			charger->cable_type == POWER_SUPPLY_TYPE_POGO) {
+		sm5705_CHG_set_INPUT_LIMIT(charger, SM5705_CHG_SRC_WPC, input_current);
+	} else {
+		sm5705_CHG_set_INPUT_LIMIT(charger, SM5705_CHG_SRC_VBUS, input_current);
+	}
+
+	return 0;
+}
+
+/**
+ *  SM5705 Power-supply class management functions
+ */
+static void sm5705_set_operation_mode(struct sm5705_charger_data *charger)
+{
+	int prev_op_mode, prev_status;
+	prev_op_mode = sm5705_charger_oper_get_current_op_mode();
+	prev_status = sm5705_charger_oper_get_current_status();
+
+	if (charger->cable_type == POWER_SUPPLY_TYPE_OTG ||
+		charger->cable_type == POWER_SUPPLY_TYPE_POWER_SHARING) {
+		sm5705_charger_oper_push_event(SM5705_CHARGER_OP_EVENT_VBUS, DISABLE);
+	} else if (charger->cable_type == POWER_SUPPLY_TYPE_BATTERY) {
+		/* set default value */
+		sm5705_charger_oper_push_event(SM5705_CHARGER_OP_EVENT_VBUS, DISABLE);
+
+		if (charger->pdata->support_slow_charging)
+			cancel_delayed_work(&charger->aicl_work);
+	} else {
+#if defined(SM5705_USED_WIRELESS_CHARGER)
+		if (__is_cable_type_for_wireless(charger->cable_type) ||
+			__is_cable_type_for_hv_wireless(charger->cable_type) ||
+			charger->cable_type == POWER_SUPPLY_TYPE_POGO) {
+			sm5705_charger_oper_push_event(SM5705_CHARGER_OP_EVENT_VBUS, DISABLE);
+			sm5705_charger_oper_push_event(SM5705_CHARGER_OP_EVENT_WPC, ENABLE);
+		} else {
+			sm5705_charger_oper_push_event(SM5705_CHARGER_OP_EVENT_WPC, DISABLE);
+			sm5705_charger_oper_push_event(SM5705_CHARGER_OP_EVENT_VBUS, ENABLE);
+		}
+#else
+		sm5705_charger_oper_push_event(SM5705_CHARGER_OP_EVENT_VBUS, ENABLE);
+#endif
+		if (charger->pdata->support_slow_charging) {
+			pr_info("request aicl work for 5V-TA\n");
+			queue_delayed_work(charger->wqueue, &charger->aicl_work, msecs_to_jiffies(3000));
+		}
+	}
+
+	pr_info("cable = %d, op_mode(%d->%d), op_status(0x%x->0x%x)\n",
+		charger->cable_type,
+		prev_op_mode, sm5705_charger_oper_get_current_op_mode(),
+		prev_status, sm5705_charger_oper_get_current_status());
+}
+
+static void psy_chg_set_usb_hc(struct sm5705_charger_data *charger, int value)
+{
+	if (value) {
+		/* set input/charging current for usb up to TA's current */
+		charger->pdata->charging_current[POWER_SUPPLY_TYPE_USB].fast_charging_current =
+			charger->pdata->charging_current[POWER_SUPPLY_TYPE_MAINS].fast_charging_current;
+		charger->pdata->charging_current[POWER_SUPPLY_TYPE_USB].input_current_limit =
+			charger->pdata->charging_current[POWER_SUPPLY_TYPE_MAINS].input_current_limit;
+	} else {
+		/* restore input/charging current for usb */
+		charger->pdata->charging_current[POWER_SUPPLY_TYPE_USB].fast_charging_current =
+			charger->pdata->charging_current[POWER_SUPPLY_TYPE_BATTERY].input_current_limit;
+		charger->pdata->charging_current[POWER_SUPPLY_TYPE_USB].input_current_limit =
+			charger->pdata->charging_current[POWER_SUPPLY_TYPE_BATTERY].input_current_limit;
+	}
+}
+
+#if defined(SM5705_SUPPORT_OTG_CONTROL)
+static void psy_chg_set_charge_otg_control(struct sm5705_charger_data *charger, int otg_en)
+{
+	union power_supply_propval value;
+
+	psy_do_property("wireless", get, POWER_SUPPLY_PROP_ONLINE, value);
+
+	if (otg_en && !value.intval) {
+		/* OTG - Enable */
+		sm5705_charger_oper_push_event(SM5705_CHARGER_OP_EVENT_VBUS, DISABLE);
+		sm5705_charger_oper_push_event(SM5705_CHARGER_OP_EVENT_OTG, ENABLE);
+		pr_info("OTG enable, cable(%d)\n", charger->cable_type);
+	} else {
+		/* OTG - Disable */
+		if (charger->cable_type == POWER_SUPPLY_TYPE_BATTERY)
+			sm5705_charger_oper_push_event(SM5705_CHARGER_OP_EVENT_VBUS, DISABLE);
+		sm5705_charger_oper_push_event(SM5705_CHARGER_OP_EVENT_OTG, DISABLE);
+		pr_info("OTG disable, cable(%d)\n", charger->cable_type);
+	}
+}
+#endif
+
+#if defined(SM5705_SUPPORT_AICL_CONTROL)
+static void psy_chg_set_aicl_control(struct sm5705_charger_data *charger, int aicl_en)
+{
+	if (aicl_en) {
+		sm5705_CHG_enable_AICL(charger, 1);
+		pr_info("CHGIN AICL ENABLE\n");
+	} else {
+		sm5705_CHG_enable_AICL(charger, 0);
+		pr_info("CHGIN AICL DISABLE\n");
+	}
+}
+#endif
+
+#if defined(CONFIG_AFC_CHARGER_MODE)
+extern void muic_charger_init(void);
+static void psy_chg_set_afc_charger_mode(struct sm5705_charger_data *charger, int afc_mode)
+{
+	pr_info("afc_charger_mode value = %d\n", afc_mode);
+	muic_charger_init();
+}
+#endif
+
+static int sm5705_chg_set_property(struct power_supply *psy,
+				enum power_supply_property psp, const union power_supply_propval *val)
+{
+	struct sm5705_charger_data *charger =
+		container_of(psy, struct sm5705_charger_data, psy_chg);
+	int buck_state = ENABLE;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		pr_info("POWER_SUPPLY_PROP_STATUS - status=%d\n", val->intval);
+		charger->status = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		pr_info("POWER_SUPPLY_PROP_ONLINE - cable(%d->%d)\n",
+			charger->cable_type, val->intval);
+		charger->cable_type = val->intval;
+		if ((charger->cable_type == POWER_SUPPLY_TYPE_OTG) && (sm5705_charger_check_oper_otg_mode_on() == 0)) {
+			psy_chg_set_charge_otg_control(charger, true);
+			pr_info("POWER_SUPPLY_PROP_ONLINE - enable OTG");
+		}
+		charger->input_current = charger->pdata->charging_current
+				[charger->cable_type].input_current_limit;
+		sm5705_set_operation_mode(charger);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		pr_info("POWER_SUPPLY_PROP_CURRENT_MAX - current=%d\n", val->intval);
+		if (charger->input_current != val->intval) {
+			pr_info("change input current (%d --> %d)\n", charger->input_current, val->intval);
+			charger->input_current = val->intval;
+		}
+		sm5705_set_input_current(charger, val->intval);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		pr_info("POWER_SUPPLY_PROP_CURRENT_AVG/NOW - current=%d\n", val->intval);
+		charger->charging_current = val->intval;
+		if (charger->is_charging) {
+			/* Fast charge and Termination current */
+			pr_info("%s : fast charging current (%dmA)\n",
+				__func__, charger->charging_current);
+			sm5705_set_charge_current(charger, charger->charging_current);
+		}
+			break;
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:
+#if defined(CONFIG_USE_POGO)
+		/* external boost control */
+		pr_info("[SM5705Q] external boost (%d)\n", val->intval);
+		sm5705_CHG_set_external_boost(charger, val->intval);
+#endif
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+		pr_info("POWER_SUPPLY_PROP_VOLTAGE_MAX - float voltage=%d\n", val->intval);
+		sm5705_CHG_set_BATREG(charger, val->intval);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_FULL:
+		if (charger->pdata->full_check_type_2nd == SEC_BATTERY_FULLCHARGED_CHGPSY) {
+			sm5705_CHG_set_TOPOFF(charger, val->intval);
+		}
+		break;
+#if defined(CONFIG_AFC_CHARGER_MODE)
+	case POWER_SUPPLY_PROP_AFC_CHARGER_MODE:
+		psy_chg_set_afc_charger_mode(charger, val->intval);
+		break;
+#endif
+	case POWER_SUPPLY_PROP_USB_HC:
+		pr_info("POWER_SUPPLY_PROP_USB_HC - value=%d\n", val->intval);
+		psy_chg_set_usb_hc(charger, val->intval);
+		break;
+#if defined(SM5705_SUPPORT_OTG_CONTROL)
+	case POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL:
+		pr_info("POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL - otg_en=%d\n", val->intval);
+		psy_chg_set_charge_otg_control(charger, val->intval);
+		break;
+#endif
+#if defined(SM5705_SUPPORT_AICL_CONTROL)
+	case POWER_SUPPLY_PROP_CHARGE_AICL_CONTROL:
+		pr_info("POWER_SUPPLY_PROP_CHARGE_AICL_CONTROL - aicl_en=%d\n", val->intval);
+		psy_chg_set_aicl_control(charger, val->intval);
+		break;
+#endif
+	case POWER_SUPPLY_PROP_CHARGING_ENABLED:
+		charger->charge_mode = val->intval;
+		switch (charger->charge_mode) {
+		case SEC_BAT_CHG_MODE_BUCK_OFF:
+			buck_state = DISABLE;
+		case SEC_BAT_CHG_MODE_CHARGING_OFF:
+			charger->is_charging = false;
+			break;
+		case SEC_BAT_CHG_MODE_CHARGING:
+			charger->is_charging = true;
+			break;
+		}
+		sm5705_enable_charging_on_switch(charger, charger->is_charging);
+		if (buck_state) {
+			if (!sm5705_charger_check_oper_otg_mode_on()) {
+				sm5705_update_reg(charger->i2c, SM5705_REG_CNTL, SM5705_CHARGER_OP_MODE_CHG_ON, 0x07);
+				pr_info("update op_mode : SM5705_CHARGER_OP_MODE_CHG_ON\n");
+			}
+		} else {
+			sm5705_update_reg(charger->i2c, SM5705_REG_CNTL, SM5705_CHARGER_OP_MODE_SUSPEND, 0x07);
+			pr_info("update op_mode : SM5705_CHARGER_OP_MODE_SUSPEND\n"); 
+		}
+		break;
+	case POWER_SUPPLY_PROP_ENERGY_NOW:
+		/* WA: abnormal swiching case in JIG cable */
+		if (sm5705_call_fg_device_id() <= 2 && !charger->is_rev2_wa_done) {
+			if (val->intval) {
+				pr_info("queue_delayed_work, op_mode_switch_work\n");
+				cancel_delayed_work(&charger->op_mode_switch_work);
+				queue_delayed_work(charger->wqueue, &charger->op_mode_switch_work,
+						msecs_to_jiffies(8000)); /* delay 8sec */
+			} else {
+				cancel_delayed_work(&charger->op_mode_switch_work);
+			}
+		}
+		/* charger off when jig detected */
+		if (val->intval)
+			sm5705_enable_charging_on_switch(charger, false);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX:
+		break;
+        case POWER_SUPPLY_PROP_PRESENT:
+                charger->is_jig_on = true;
+                break;
+	default:
+		pr_err("un-known Power-supply property type (psp=%d)\n", psp);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int psy_chg_get_charge_source_type(struct sm5705_charger_data *charger)
+{
+	int src_type;
+
+	if (sm5705_CHG_get_INT_STATUS(charger, SM5705_INT_STATUS1, SM5705_INT_STATUS1_VBUSPOK)) {
+		src_type = POWER_SUPPLY_TYPE_MAINS;
+	} else if (sm5705_CHG_get_INT_STATUS(charger, SM5705_INT_STATUS1, SM5705_INT_STATUS1_WPCINPOK)) {
+		src_type = POWER_SUPPLY_TYPE_WIRELESS;
+	} else {
+		src_type = POWER_SUPPLY_TYPE_BATTERY;
+	}
+
+	return src_type;
+}
+
+static bool _decide_charge_full_status(struct sm5705_charger_data *charger)
+{
+	if ((sm5705_CHG_get_INT_STATUS(charger, SM5705_INT_STATUS2, SM5705_INT_STATUS2_TOPOFF)) ||
+		(sm5705_CHG_get_INT_STATUS(charger, SM5705_INT_STATUS2, SM5705_INT_STATUS2_DONE))) {
+		return charger->topoff_pending;
+	}
+
+	return false;
+}
+
+
+static int psy_chg_get_charger_state(struct sm5705_charger_data *charger)
+{
+	int status = POWER_SUPPLY_STATUS_UNKNOWN;
+
+	if (_decide_charge_full_status(charger)) {
+		status = POWER_SUPPLY_STATUS_FULL;
+	} else if(sm5705_charger_get_charging_on_status(charger)){
+		status = POWER_SUPPLY_STATUS_CHARGING;
+	} else {
+		if (sm5705_charger_get_power_source_status(charger)) {
+			status = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		} else {
+			status = POWER_SUPPLY_STATUS_DISCHARGING;
+		}
+	}
+
+	return status;
+}
+
+static int psy_chg_get_charge_type(struct sm5705_charger_data *charger)
+{
+	int charge_type;
+
+	if (sm5705_charger_get_charging_on_status(charger)) {
+		if (sm5705_get_input_current(charger) <= charger->pdata->slow_current_threshold) {
+			charge_type = POWER_SUPPLY_CHARGE_TYPE_SLOW;
+		} else {
+			charge_type = POWER_SUPPLY_CHARGE_TYPE_FAST;
+		}
+	} else {
+		charge_type = POWER_SUPPLY_CHARGE_TYPE_NONE;
+	}
+
+	return charge_type;
+}
+
+static int psy_chg_get_charging_health(struct sm5705_charger_data *charger)
+{
+	int state;
+	unsigned char reg_data;
+	unsigned char reg2_data;
+
+	sm5705_read_reg(charger->i2c, SM5705_REG_STATUS1, &reg_data);
+	sm5705_read_reg(charger->i2c, SM5705_REG_STATUS2, &reg2_data);
+
+	pr_info("is_charging=%d(%d), cable_type=%d, input_limit=%d, chg_curr=%d, REG_STATUS1=0x%x, REG_STATUS2=0x%x\n",
+			charger->is_charging, sm5705_charger_get_power_source_status(charger),
+			charger->cable_type, charger->input_current, charger->charging_current,
+			reg_data, reg2_data);
+
+#if defined(CONFIG_USE_POGO)
+	if ((charger->cable_type == POWER_SUPPLY_TYPE_BATTERY) &&
+			(reg_data & SM5705_STATUS1_WPCINPOK)) {
+		wake_lock(&charger->wpc_wake_lock);
+		cancel_delayed_work(&charger->pogo_work);
+		queue_delayed_work(charger->wqueue, &charger->pogo_work, 0);
+	}
+#endif
+
+#if !defined(CONFIG_USE_POGO)
+	if (charger->cable_type != POWER_SUPPLY_TYPE_WIRELESS) {
+#else
+	if (charger->cable_type != POWER_SUPPLY_TYPE_POGO) {
+#endif
+		if (reg_data & (1 << SM5705_INT_STATUS1_VBUSPOK)) {
+			state = POWER_SUPPLY_HEALTH_GOOD;
+		} else if (reg_data & (1 << SM5705_INT_STATUS1_VBUSOVP)) {
+			state = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+		} else if (reg_data & (1 << SM5705_INT_STATUS1_VBUSUVLO)) {
+			state = POWER_SUPPLY_HEALTH_UNDERVOLTAGE;
+		} else {
+			state = POWER_SUPPLY_HEALTH_UNKNOWN;
+		}
+	} else {
+		if (reg_data & (1 << SM5705_INT_STATUS1_WPCINPOK)) {
+			state = POWER_SUPPLY_HEALTH_GOOD;
+		} else if (reg_data & (1 << SM5705_INT_STATUS1_WPCINOVP)) {
+			state = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+		} else if (reg_data & (1 << SM5705_INT_STATUS1_WPCINUVLO)) {
+			state = POWER_SUPPLY_HEALTH_UNDERVOLTAGE;
+		} else {
+			state = POWER_SUPPLY_HEALTH_UNKNOWN;
+		}
+	}
+
+	return (int)state;
+}
+
+static int sm5705_chg_create_attrs(struct device *dev)
+{
+	int i, rc;
+
+	for (i = 0; i < ARRAY_SIZE(sm5705_charger_attrs); i++) {
+		rc = device_create_file(dev, &sm5705_charger_attrs[i]);
+		if (rc)
+			goto create_attrs_failed;
+	}
+	return rc;
+
+create_attrs_failed:
+	pr_err("failed (%d)\n", rc);
+	while (i--)
+		device_remove_file(dev, &sm5705_charger_attrs[i]);
+	return rc;
+}
+
+ssize_t sm5705_chg_show_attrs(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	const ptrdiff_t offset = attr - sm5705_charger_attrs;
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct sm5705_charger_data *charger =
+		container_of(psy, struct sm5705_charger_data, psy_chg);
+	int i = 0;
+	unsigned char reg_data;
+
+	switch (offset){
+	case CHIP_ID:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%s\n", "SM5705");
+		break;
+	case CHARGER_OP_MODE:
+		sm5705_read_reg(charger->i2c, SM5705_REG_CNTL, &reg_data);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",reg_data);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return i;
+}
+
+ssize_t sm5705_chg_store_attrs(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	const ptrdiff_t offset = attr - sm5705_charger_attrs;
+	int ret = 0;
+	int x = 0;
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct sm5705_charger_data *charger =
+		container_of(psy, struct sm5705_charger_data, psy_chg);
+
+	switch(offset){
+	case CHIP_ID:
+		ret = count;
+		break;
+	case CHARGER_OP_MODE:
+		if (sscanf(buf, "%10d\n", &x) == 1) {
+			if (x == 2) {
+				sm5705_update_reg(charger->i2c, SM5705_REG_CNTL, SM5705_CHARGER_OP_MODE_SUSPEND, 0x07);
+			}else if(x == 1){
+				sm5705_update_reg(charger->i2c, SM5705_REG_CNTL, SM5705_CHARGER_OP_MODE_CHG_ON, 0x07);
+			}else {
+				pr_info("change charger op mode fail\n");
+				return -EINVAL;
+			}
+			ret = count;
+		}
+		break;
+	default:
+		ret = -EINVAL;
+	}
+	return ret;
+}
+
+static int sm5705_chg_get_property(struct power_supply *psy,
+				enum power_supply_property psp, union power_supply_propval *val)
+{
+	struct sm5705_charger_data *charger =
+		container_of(psy, struct sm5705_charger_data, psy_chg);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = psy_chg_get_charge_source_type(charger);
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		if (sm5705_CHG_get_INT_STATUS(charger, SM5705_INT_STATUS2, SM5705_INT_STATUS2_NOBAT))
+			val->intval = 0;
+		else
+			val->intval = 1;
+		break;
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = psy_chg_get_charger_state(charger);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+		val->intval = psy_chg_get_charge_type(charger);
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = psy_chg_get_charging_health(charger);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		val->intval = sm5705_get_input_current(charger);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:
+		val->intval = sm5705_get_charge_current(charger);
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+		val->intval = sm5705_CHG_get_BATREG(charger);
+		break;
+#if defined(CONFIG_AFC_CHARGER_MODE)
+	case POWER_SUPPLY_PROP_AFC_CHARGER_MODE:
+		return -ENODATA;
+#endif
+#if defined(SM5705_SUPPORT_OTG_CONTROL)
+	case POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL:
+		val->intval = sm5705_charger_check_oper_otg_mode_on();
+		break;
+#endif
+#if defined(SM5705_SUPPORT_AICL_CONTROL)
+	case POWER_SUPPLY_PROP_CHARGE_AICL_CONTROL:
+		return -ENODATA;
+#endif
+	case POWER_SUPPLY_PROP_CHARGING_ENABLED:
+		val->intval = sm5705_charger_get_power_source_status(charger);
+		break;
+	case POWER_SUPPLY_PROP_ENERGY_NOW:
+		return -ENODATA;
+	default:
+		pr_err("un-known Power-supply property type (psp=%d)\n", psp);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static enum power_supply_property sm5705_charger_props[] = {
+};
+
+static int sm5705_otg_get_property(struct power_supply *psy,
+				enum power_supply_property psp, union power_supply_propval *val)
+{
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = sm5705_charger_check_oper_otg_mode_on();
+		pr_info("POWER_SUPPLY_PROP_ONLINE - %s\n", (val->intval) ? "ON" : "OFF");
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int sm5705_otg_set_property(struct power_supply *psy,
+				enum power_supply_property psp, const union power_supply_propval *val)
+{
+	struct sm5705_charger_data *charger =
+		container_of(psy, struct sm5705_charger_data, psy_otg);
+	union power_supply_propval value;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		pr_info("POWER_SUPPLY_PROP_ONLINE - %s\n", (val->intval) ? "ON" : "OFF");
+#if defined(SM5705_SUPPORT_OTG_CONTROL)
+		value.intval = val->intval;
+		psy_do_property("sm5705-charger", set, POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL, value);
+#else
+		if (val->intval) {
+			value.intval = POWER_SUPPLY_TYPE_OTG;
+		} else {
+			value.intval = POWER_SUPPLY_TYPE_BATTERY;
+		}
+		psy_do_property("sm5705-charger", set, POWER_SUPPLY_PROP_ONLINE, value);
+#endif
+		power_supply_changed(&charger->psy_otg);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static enum power_supply_property sm5705_otg_props[] = {
+	POWER_SUPPLY_PROP_ONLINE,
+};
+
+/**
+ *  SM5705 Charger IRQ & Work-queue service management functions
+ */
+ static void sm5705_op_mode_switch_work(struct work_struct *work)
+{
+	struct sm5705_charger_data *charger =
+		container_of(work, struct sm5705_charger_data, op_mode_switch_work.work);
+
+	pr_info("schedule work start.\n");
+
+	charger->is_rev2_wa_done = true;
+	/* OP Mode switch : CHG_ON(init) -> USB_OTG -> CHG_ON -> FLASH_BOOST -> CHG_ON */
+	sm5705_update_reg(charger->i2c, SM5705_REG_CNTL, SM5705_CHARGER_OP_MODE_USB_OTG, 0x07);
+	msleep(2000);
+	sm5705_update_reg(charger->i2c, SM5705_REG_CNTL, SM5705_CHARGER_OP_MODE_CHG_ON, 0x07);
+	msleep(3000);
+	sm5705_update_reg(charger->i2c, SM5705_REG_CNTL, SM5705_CHARGER_OP_MODE_FLASH_BOOST, 0x07);
+	msleep(2000);
+	sm5705_update_reg(charger->i2c, SM5705_REG_CNTL, SM5705_CHARGER_OP_MODE_CHG_ON, 0x07);
+
+	pr_info("schedule work done.\n");
+}
+
+#if defined(CONFIG_USE_POGO)
+static void sm5705_pogo_work(struct work_struct *work)
+{
+	struct sm5705_charger_data *charger =
+		container_of(work, struct sm5705_charger_data, pogo_work.work);
+	union power_supply_propval value;
+	int wpcin_state;
+	unsigned char reg_data;
+
+	sm5705_read_reg(charger->i2c, SM5705_REG_STATUS1, &reg_data);
+	pr_info("%s: REG_STATUS1=0x%x\n", __func__, reg_data);
+
+	wpcin_state = (reg_data & SM5705_STATUS1_WPCINPOK) ? 1 : 0;
+
+	pr_info("irq_wpcin_state = %d, wpcin_state = %d \n", charger->irq_wpcin_state, wpcin_state);
+
+	if ((charger->irq_wpcin_state == 0) && (wpcin_state == 1)) {
+		value.intval = 1;
+		psy_do_property("pogo", set, POWER_SUPPLY_PROP_ONLINE, value);
+		muic_detect_dev_for_wcin();
+
+		pr_info("%s: pogo activated\n", __func__);
+	} else if ((charger->irq_wpcin_state == 1) && (wpcin_state == 0)) {
+		value.intval = 0;
+		psy_do_property("pogo", set, POWER_SUPPLY_PROP_ONLINE, value);
+		muic_detect_dev_for_wcin();
+		pr_info("%s: pogo de-activated\n", __func__);
+	}
+
+	pr_info("w(%d to %d)\n", charger->irq_wpcin_state, wpcin_state);
+
+	charger->irq_wpcin_state = wpcin_state;
+
+	wake_unlock(&charger->wpc_wake_lock);
+	pr_info("schedule pogo work done.\n");
+}
+#endif /* CONFIG_USE_POGO */
+
+#if EN_NOBAT_IRQ
+static void sm5705_nobat_work(struct work_struct *work)
+{
+	struct sm5705_charger_data *charger =
+		container_of(work, struct sm5705_charger_data, nobat_work.work);
+
+        if (charger->is_jig_on) {
+                pr_info("%s : skip battery check\n", __func__);
+                return;
+        }
+
+	pr_info("%s: schedule work start.\n", __func__);
+
+	if (sm5705_CHG_get_INT_STATUS(charger, SM5705_INT_STATUS2, SM5705_INT_STATUS2_NOBAT)) {
+		pr_info("%s: buck off because battery is not exist\n", __func__);
+		sm5705_update_reg(charger->i2c, SM5705_REG_CNTL, SM5705_CHARGER_OP_MODE_SUSPEND, 0x07);
+	}
+
+        muic_detect_dev_for_nobat();
+
+	pr_info("%s: schedule work done.\n", __func__);
+}
+#endif /*EN_NOBAT_IRQ*/
+
+#if EN_TOPOFF_IRQ
+static void sm5705_topoff_work(struct work_struct *work)
+{
+	struct sm5705_charger_data *charger =
+		container_of(work, struct sm5705_charger_data, topoff_work.work);
+	bool topoff = 1;
+	int i;
+
+	pr_info("schedule work start.\n");
+
+	for (i=0; i < 3; ++i) {
+		topoff &= sm5705_CHG_get_INT_STATUS(charger, SM5705_INT_STATUS2, SM5705_INT_STATUS2_TOPOFF);
+		msleep(150);
+
+		pr_info("%dth Check TOP-OFF state=%d\n", i, topoff);
+	}
+
+	charger->topoff_pending = topoff;
+
+	pr_info("schedule work done.\n");
+}
+#endif /*EN_TOPOFF_IRQ*/
+
+static void _reduce_input_limit_current(struct sm5705_charger_data *charger, int cur)
+{
+	unsigned short vbus_limit_current = sm5705_CHG_get_INPUT_LIMIT(charger, SM5705_CHG_SRC_VBUS);
+
+	if ((vbus_limit_current <= MINIMUM_INPUT_CURRENT) || (vbus_limit_current <= cur)) {
+		return;
+	}
+
+	vbus_limit_current = ((vbus_limit_current - cur) < MINIMUM_INPUT_CURRENT) ?
+		MINIMUM_INPUT_CURRENT : vbus_limit_current - cur;
+	sm5705_CHG_set_INPUT_LIMIT(charger, SM5705_CHG_SRC_VBUS, vbus_limit_current);
+
+	charger->input_current = sm5705_get_input_current(charger);
+
+	pr_info("vbus_limit_current=%d, charger->input_current=%d\n",
+		vbus_limit_current, charger->input_current);
+}
+
+static void _check_slow_charging(struct sm5705_charger_data *charger, int input_current)
+{
+	/* under 400mA considered as slow charging concept for VZW */
+	if (input_current <= charger->pdata->slow_current_threshold &&
+		charger->cable_type != POWER_SUPPLY_TYPE_BATTERY) {
+		union power_supply_propval value;
+
+		pr_info("slow charging on : input current(%dmA), cable type(%d)\n",
+			input_current, charger->cable_type);
+
+		value.intval = POWER_SUPPLY_CHARGE_TYPE_SLOW;
+		psy_do_property("battery", set, POWER_SUPPLY_PROP_CHARGE_TYPE, value);
+	}
+}
+
+static bool _check_aicl_state(struct sm5705_charger_data *charger)
+{
+	return sm5705_CHG_get_INT_STATUS(charger, SM5705_INT_STATUS2, SM5705_INT_STATUS2_AICL);
+}
+
+static void sm5705_aicl_work(struct work_struct *work)
+{
+	struct sm5705_charger_data *charger =
+		container_of(work, struct sm5705_charger_data, aicl_work.work);
+	int prev_current_max, max_count, now_count = 0;
+
+	if (!charger->pdata->support_slow_charging || sm5705_call_fg_device_id() <= 2) {
+		pr_info("don't support AICL work at REV.2\n");
+		return;
+	}
+
+	if (!sm5705_charger_get_charging_on_status(charger) ||
+		__is_cable_type_for_hv_mains(charger->cable_type)) {
+		pr_info("don't need AICL work\n");
+		return;
+	}
+
+	pr_info("schedule work start.\n");
+
+	/* Reduce input limit current */
+	max_count = charger->input_current / REDUCE_CURRENT_STEP;
+	prev_current_max = charger->input_current;
+	while (_check_aicl_state(charger) && (now_count++ < max_count)) {
+		_reduce_input_limit_current(charger, REDUCE_CURRENT_STEP);
+		msleep(AICL_VALID_CHECK_DELAY_TIME);
+	}
+	if (prev_current_max > charger->input_current) {
+		pr_info("charging_current_max(%d --> %d)\n",
+			prev_current_max, charger->input_current);
+		_check_slow_charging(charger, charger->input_current);
+	}
+
+	pr_info("schedule work done.\n");
+}
+
+#if defined(SM5705_USED_WIRELESS_CHARGER)
+static void wc_afc_detect_work(struct work_struct *work)
+{
+	struct sm5705_charger_data *charger = container_of(work, struct sm5705_charger_data, wc_afc_work.work);
+
+	pr_info("schedule work start.\n");
+
+	if (__is_cable_type_for_wireless(charger->cable_type) && \
+		sm5705_charger_get_charging_on_status(charger) && charger->wc_afc_detect) {
+		charger->wc_afc_detect = false;
+
+		if (charger->input_current >=
+			charger->pdata->charging_current[POWER_SUPPLY_TYPE_WIRELESS].input_current_limit) {
+			charger->input_current =
+				charger->pdata->charging_current[POWER_SUPPLY_TYPE_WIRELESS].input_current_limit;
+		}
+		pr_info("current_max(%d)\n", charger->input_current);
+	}
+
+	pr_info("schedule work doen.\n");
+}
+
+static void wpc_detect_work(struct work_struct *work)
+{
+	struct sm5705_charger_data *charger = container_of(work, struct sm5705_charger_data, wpc_work.work);
+	union power_supply_propval value;
+	int wpcin_state;
+
+	pr_info("schedule work start.\n");
+
+#if defined(CONFIG_WIRELESS_CHARGER_P9220)
+	wpcin_state = !gpio_get_value(charger->pdata->irq_gpio);
+#else
+	wpcin_state = gpio_get_value(charger->pdata->wpc_det);
+#endif
+	pr_info("wc_w_state = %d \n", wpcin_state);
+
+	if ((charger->irq_wpcin_state == 0) && (wpcin_state == 1)) {
+		value.intval = 1;
+		psy_do_property("wireless", set, POWER_SUPPLY_PROP_ONLINE, value);
+		value.intval = POWER_SUPPLY_TYPE_WIRELESS;
+		psy_do_property(charger->pdata->wireless_charger_name, set, POWER_SUPPLY_PROP_ONLINE, value);
+
+		pr_info("wpc activated, set V_INT as PN\n");
+	} else if ((charger->irq_wpcin_state == 1) && (wpcin_state == 0)) {
+		value.intval = 0;
+		psy_do_property("wireless", set, POWER_SUPPLY_PROP_ONLINE, value);
+
+		pr_info("wpc deactivated, set V_INT as PD\n");
+	}
+
+	pr_info("w(%d to %d)\n", charger->irq_wpcin_state, wpcin_state);
+
+	charger->irq_wpcin_state = wpcin_state;
+
+	wake_unlock(&charger->wpc_wake_lock);
+
+	pr_info("%s: schedule work done.\n");
+}
+#endif
+
+static unsigned char _get_valid_vbus_status(struct sm5705_charger_data *charger)
+{
+	unsigned char vbusin, prev_vbusin = 0xff;
+	int stable_count = 0;
+
+	while (1) {
+		sm5705_read_reg(charger->i2c, SM5705_REG_STATUS1, &vbusin);
+		vbusin &= 0xF;
+
+		if (prev_vbusin == vbusin) {
+			stable_count++;
+		} else {
+			pr_info("VBUS status mismatch (0x%x / 0x%x), Reset stable count\n",
+				vbusin, prev_vbusin);
+			stable_count = 0;
+		}
+
+		if (stable_count == 10) {
+			break;
+		}
+
+		prev_vbusin = vbusin;
+		msleep(10);
+	}
+
+	return vbusin;
+}
+
+static int _check_vbus_power_supply_status(struct sm5705_charger_data *charger,
+				unsigned char vbus_status, int prev_battery_health)
+{
+	int battery_health = prev_battery_health;
+
+	if (vbus_status & (1 << SM5705_INT_STATUS1_VBUSPOK)) {
+		if (prev_battery_health == POWER_SUPPLY_HEALTH_OVERVOLTAGE) {
+			pr_info("overvoltage->normal\n");
+			battery_health = POWER_SUPPLY_HEALTH_GOOD;
+		} else if (prev_battery_health == POWER_SUPPLY_HEALTH_UNDERVOLTAGE){
+			pr_info("undervoltage->normal\n");
+			battery_health = POWER_SUPPLY_HEALTH_GOOD;
+		}
+	} else {
+		if ((vbus_status & (1 << SM5705_INT_STATUS1_VBUSOVP)) &&
+			(prev_battery_health != POWER_SUPPLY_HEALTH_OVERVOLTAGE)) {
+			pr_info("charger is over voltage\n");
+			battery_health = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+		} else if ((vbus_status & (1 << SM5705_INT_STATUS1_VBUSUVLO)) &&
+			(prev_battery_health != POWER_SUPPLY_HEALTH_UNDERVOLTAGE) &&
+			__n_is_cable_type_for_wireless(charger->cable_type) &&
+			charger->cable_type != POWER_SUPPLY_TYPE_POGO &&
+			(charger->cable_type != POWER_SUPPLY_TYPE_BATTERY)) {
+			pr_info("vBus is undervoltage\n");
+			battery_health = POWER_SUPPLY_HEALTH_UNDERVOLTAGE;
+		}
+	}
+
+	return battery_health;
+}
+
+static irqreturn_t sm5705_chg_vbus_in_isr(int irq, void *data)
+{
+	struct sm5705_charger_data *charger = data;
+	union power_supply_propval value;
+	unsigned char vbus_status;
+	int prev_battery_health;
+
+	pr_info("start.\n");
+
+	vbus_status = _get_valid_vbus_status(charger);
+
+	psy_do_property("battery", get,POWER_SUPPLY_PROP_HEALTH, value);
+	prev_battery_health = value.intval;
+
+	value.intval = _check_vbus_power_supply_status(charger, vbus_status, prev_battery_health);
+	if (prev_battery_health != value.intval) {
+		psy_do_property("battery", set, POWER_SUPPLY_PROP_HEALTH, value);
+	}
+	pr_info("battery change status [%d] -> [%d] (VBUS_REG:0x%x)\n",
+		prev_battery_health, value.intval, vbus_status);
+
+	/*
+	if (prev_battery_health == POWER_SUPPLY_HEALTH_UNDERVOLTAGE &&
+		value.intval == POWER_SUPPLY_HEALTH_GOOD) {
+		sm5705_set_input_current(charger, charger->input_current);
+	}
+	 */
+	pr_info("done.\n");
+
+	return IRQ_HANDLED;
+}
+
+#if defined(CONFIG_USE_POGO)
+static irqreturn_t sm5705_chg_wpcin_pok_pogo_isr(int irq, void *data)
+{
+	struct sm5705_charger_data *charger = data;
+	unsigned long delay;
+
+	delay = msecs_to_jiffies(0);
+	pr_info("POGO IRQ=%d delay = %ld\n", irq, delay);
+
+	wake_lock(&charger->wpc_wake_lock);
+	cancel_delayed_work(&charger->pogo_work);
+	queue_delayed_work(charger->wqueue, &charger->pogo_work, delay);
+
+	return IRQ_HANDLED;
+}
+#endif
+
+#if EN_NOBAT_IRQ
+static irqreturn_t sm5705_chg_nobat_isr(int irq, void *data)
+{
+	struct sm5705_charger_data *charger = data;
+	unsigned long delay;
+
+	delay = msecs_to_jiffies(0);
+	pr_info("NOBAT IRQ=%d delay = %ld\n", irq, delay);
+
+	queue_delayed_work(charger->wqueue, &charger->nobat_work, delay);
+
+	return IRQ_HANDLED;
+}
+#endif /*EN_NOBAT_IRQ*/
+
+#if EN_TOPOFF_IRQ
+static irqreturn_t sm5705_chg_topoff_isr(int irq, void *data)
+{
+	struct sm5705_charger_data *charger = data;
+
+	pr_info("IRQ=%d\n", irq);
+
+	charger->topoff_pending = 0;
+	queue_delayed_work(charger->wqueue, &charger->topoff_work, msecs_to_jiffies(500));
+
+	return IRQ_HANDLED;
+}
+#endif /*EN_TOPOFF_IRQ*/
+
+#if EN_OTGFAIL_IRQ
+static irqreturn_t sm5705_chg_otgfail_isr(int irq, void *data)
+{
+	struct sm5705_charger_data *charger = data;
+	unsigned char reg_data;
+
+#ifdef CONFIG_USB_HOST_NOTIFY
+	struct otg_notify *o_notify = get_otg_notify();
+#endif
+	pr_info("IRQ=%d : OTG Failed\n", irq);
+
+	sm5705_read_reg(charger->i2c, SM5705_REG_STATUS3, &reg_data);
+	if (reg_data & SM5705_STATUS3_OTGFAIL) {
+		pr_info("otg overcurrent limit\n");
+#ifdef CONFIG_USB_HOST_NOTIFY
+		send_otg_notify(o_notify, NOTIFY_EVENT_OVERCURRENT, 0);
+#endif
+		psy_chg_set_charge_otg_control(charger, false);
+	}
+
+	return IRQ_HANDLED;
+}
+#endif /*EN_OTGFAIL_IRQ*/
+
+#if defined(SM5705_USED_WIRELESS_CHARGER)
+static irqreturn_t sm5705_chg_wpcin_pok_isr(int irq, void *data)
+{
+	struct sm5705_charger_data *charger = data;
+	unsigned long delay;
+
+#ifdef CONFIG_SAMSUNG_BATTERY_FACTORY
+	delay = msecs_to_jiffies(0);
+#else
+	if (charger->irq_wpcin_state)
+		delay = msecs_to_jiffies(500);
+	else
+		delay = msecs_to_jiffies(0);
+#endif
+	pr_info("IRQ=%d delay = %ld\n", irq, delay);
+
+	wake_lock(&charger->wpc_wake_lock);
+	queue_delayed_work(charger->wqueue, &charger->wpc_work, delay);
+
+	return IRQ_HANDLED;
+}
+#endif
+
+/**
+ *  SM5705 Charger driver management functions
+ **/
+ #if defined(SM5705_WATCHDOG_RESET_ACTIVATE)
+void sm5705_charger_watchdog_timer_keepalive(void)
+{
+    if (g_sm5705_charger) {
+        sm5705_CHG_set_WDTMR_RST(g_sm5705_charger);
+    }
+}
+#endif
+
+#ifdef CONFIG_OF
+static int _parse_sm5705_charger_node_propertys(struct device *dev,
+				struct device_node *np, sec_charger_platform_data_t *pdata)
+{
+	pdata->chg_gpio_en = of_get_named_gpio(np, "battery,chg_gpio_en", 0); //nCHGEN
+	if (IS_ERR_VALUE(pdata->chg_gpio_en)) {
+		pr_info("can't parsing dt:battery,chg_gpio_en\n");
+		return -ENOENT;
+	}
+	pr_info("battery charge enable pin = %d\n", pdata->chg_gpio_en);
+
+#if defined(CONFIG_CHARGING_VZWCONCEPT)
+	pdata->support_slow_charging = true;
+#else
+	pdata->support_slow_charging = of_property_read_bool(np, "battery,support_slow_charging");
+	if (pdata->support_slow_charging) {
+		int ret = 0;
+		ret = of_property_read_u32(np, "battery,slow_current_threshold", &pdata->slow_current_threshold);
+		if (ret < 0) {
+			pr_info("%s: using default slow charging current threshold\n", __func__);
+			pdata->slow_current_threshold = 400;
+		}
+	}
+#endif
+
+	return 0;
+}
+
+static int _get_of_charging_current_table_max_size(struct device *dev, struct device_node *np)
+{
+	const unsigned int *propertys;
+	int len;
+
+	propertys = of_get_property(np, "battery,input_current_limit", &len);
+	if (unlikely(!propertys)) {
+		pr_info("can't parsing dt:battery,input_current_limit\n");
+	} else {
+		pr_info("dt:battery,input_current_limit length=%d\n", len);
+	}
+
+	return len / sizeof(unsigned int);
+}
+
+static int _parse_battery_node_propertys(struct device *dev, struct device_node *np,
+				sec_charger_platform_data_t *pdata)
+{
+	int i, array_max_size, ret;
+
+	ret = of_property_read_u32(np, "battery,chg_float_voltage", &pdata->chg_float_voltage);
+	if (IS_ERR_VALUE(ret)) {
+		pr_err("can't parsing dt:battery,chg_float_voltage\n");
+	}
+
+#if defined(SM5705_USED_WIRELESS_CHARGER)
+	ret = of_property_read_string(np,"battery,wirelss_charger_name",
+				(char const **)&pdata->wireless_charger_name);
+	if (IS_ERR_VALUE(ret)) {
+		pr_err("can't parsing dt:battery,wirelss_charger_name\n");
+	}
+	pr_info("wireless charger name=%s\n", pdata->wireless_charger_name);
+
+#if defined(CONFIG_WIRELESS_CHARGER_INBATTERY)
+	pdata->wpc_det = of_get_named_gpio(np, "battery,wpc_det", 0);
+	if (IS_ERR_VALUE(pdata->wpc_det)) {
+		pr_err("can't parsing dt:battery,wpc_det\n");
+		return -ENOENT;
+	}
+	pr_info("WPC detect pin = %d\n", pdata->wpc_det);
+#endif
+
+#if defined(CONFIG_WIRELESS_CHARGER_HIGH_VOLTAGE)
+	ret = of_property_read_u32(np, "battery,wpc_charging_limit_current",
+				&pdata->wpc_charging_limit_current);
+	if (IS_ERR_VALUE(ret)) {
+		pr_err("can't parsing dt:battery,wpc_charging_limit_current\n");
+	}
+
+	ret = of_property_read_u32(np, "battery,sleep_mode_limit_current",
+				&pdata->sleep_mode_limit_current);
+	if (IS_ERR_VALUE(ret)) {
+		pr_err("can't parsing dt:battery,sleep_mode_limit_current\n");
+	}
+#endif
+
+	ret = of_property_read_u32(np, "battery,wireless_cc_cv", &pdata->wireless_cc_cv);
+	if (IS_ERR_VALUE(ret)) {
+		pr_err("can't parsing dt:battery,wireless_cc_cv\n");
+	}
+#endif
+
+	ret = of_property_read_u32(np, "battery,full_check_type_2nd", &pdata->full_check_type_2nd);
+	if (IS_ERR_VALUE(ret)) {
+		pr_err("can't parsing dt:battery,full_check_type_2nd\n");
+	}
+
+	array_max_size = _get_of_charging_current_table_max_size(dev, np);
+	if (array_max_size == 0) {
+		return -ENOENT;
+	}
+	pr_info("charging current table max size = %d\n", array_max_size);
+
+	pdata->charging_current = kzalloc(sizeof(sec_charging_current_t) * array_max_size, GFP_KERNEL);
+	if (unlikely(!pdata->charging_current)) {
+		pr_err("fail to allocate memory for charging current table\n");
+		return -ENOMEM;
+	}
+
+	for(i = 0; i < array_max_size; ++i) {
+		of_property_read_u32_index(np, "battery,input_current_limit",
+			i, &pdata->charging_current[i].input_current_limit);
+	}
+
+	pr_info("dt:battery node parse done.\n");
+
+	return 0;
+}
+
+
+static int sm5705_charger_parse_dt(struct sm5705_charger_data *charger,
+				struct sec_charger_platform_data *pdata)
+{
+	struct device_node *np;
+	int ret;
+
+	np = of_find_node_by_name(NULL, "sm5705-charger");
+	if (np == NULL) {
+		pr_err("fail to find dt_node:sm5705-charger\n");
+		return -ENOENT;
+	} else {
+		ret = _parse_sm5705_charger_node_propertys(charger->dev, np, pdata);
+	}
+
+	np = of_find_node_by_name(NULL, "battery");
+	if (np == NULL) {
+		pr_err("fail to find dt_node:battery\n");
+		return -ENOENT;
+	} else {
+		ret = _parse_battery_node_propertys(charger->dev, np, pdata);
+		if (IS_ERR_VALUE(ret)) {
+			return ret;
+		}
+	}
+
+	return ret;
+}
+#endif
+
+static sec_charger_platform_data_t *_get_sm5705_charger_platform_data
+				(struct platform_device *pdev, struct sm5705_charger_data *charger)
+{
+#ifdef CONFIG_OF
+	sec_charger_platform_data_t *pdata;
+	int ret;
+
+	pdata = kzalloc(sizeof(sec_charger_platform_data_t), GFP_KERNEL);
+	if (!pdata) {
+		pr_err("fail to memory allocate for sec_charger_platform_data\n");
+		return NULL;
+	}
+
+	ret = sm5705_charger_parse_dt(charger, pdata);
+	if (IS_ERR_VALUE(ret)) {
+		pr_err("fail to parse sm5705 charger device tree (ret=%d)\n", ret);
+		kfree(pdata);
+		return NULL;
+	}
+#else
+	struct sm5705_platform_data *sm5705_pdata = dev_get_platdata(sm5705->dev);
+	struct sm5705_dev *sm5705 = dev_get_drvdata(pdev->dev.parent);
+	sec_charger_platform_data_t *pdata;
+
+	pdata = sm5705_pdata->charger_data;
+	if (!pdata) {
+		pr_err("fail to get sm5705 charger platform data\n");
+		return NULL;
+	}
+#endif
+
+	pr_info("Get valid platform data done. (pdata=%p)\n", pdata);
+	return pdata;
+}
+
+static int _init_sm5705_charger_info(struct platform_device *pdev,
+				struct sm5705_dev *sm5705, struct sm5705_charger_data *charger)
+{
+	struct sm5705_platform_data *pdata = dev_get_platdata(sm5705->dev);
+	int ret;
+	mutex_init(&charger->charger_mutex);
+
+	if (pdata == NULL) {
+		pr_err("can't get sm5705_platform_data\n");
+		return -EINVAL;
+	}
+
+	pr_info("init process start..\n");
+
+	/* setup default charger configuration parameter & flagment */
+	charger->wc_afc_detect = false;
+	charger->input_current = 500;
+	charger->topoff_pending = false;
+	charger->is_charging = false;
+	charger->cable_type = POWER_SUPPLY_TYPE_BATTERY;
+	charger->is_mdock = false;
+	charger->is_rev2_wa_done = false;
+	charger->irq_wpcin_state = 0;
+        charger->is_jig_on = false;
+
+	/* Request GPIO pin - CHG_IN */
+	if (charger->pdata->chg_gpio_en) {
+		ret = gpio_request(charger->pdata->chg_gpio_en, "sm5705_nCHGEN");
+		if (ret) {
+			pr_err("fail to request GPIO %u\n", charger->pdata->chg_gpio_en);
+			return ret;
+		}
+	}
+
+	/* initialize delayed workqueue */
+	charger->wqueue = create_singlethread_workqueue(dev_name(charger->dev));
+	if (!charger->wqueue) {
+		pr_err("fail to Create Workqueue\n");
+		return -ENOMEM;
+	}
+
+#if defined(CONFIG_USE_POGO)
+	INIT_DELAYED_WORK(&charger->pogo_work, sm5705_pogo_work);
+#endif
+#if defined(SM5705_USED_WIRELESS_CHARGER)
+	INIT_DELAYED_WORK(&charger->wpc_work, wpc_detect_work);
+	INIT_DELAYED_WORK(&charger->wc_afc_work, wc_afc_detect_work);
+#endif
+	if (charger->pdata->support_slow_charging)
+		INIT_DELAYED_WORK(&charger->aicl_work, sm5705_aicl_work);
+#if EN_NOBAT_IRQ
+	INIT_DELAYED_WORK(&charger->nobat_work, sm5705_nobat_work);
+#endif
+#if EN_TOPOFF_IRQ
+	INIT_DELAYED_WORK(&charger->topoff_work, sm5705_topoff_work);
+#endif
+	INIT_DELAYED_WORK(&charger->op_mode_switch_work, sm5705_op_mode_switch_work);
+
+#if defined(SM5705_SW_SOFT_START)
+	wake_lock_init(&charger->softstart_wake_lock, WAKE_LOCK_SUSPEND, "charger-softstart");
+#endif
+	wake_lock_init(&charger->wpc_wake_lock, WAKE_LOCK_SUSPEND, "charger-wpc");
+	wake_lock_init(&charger->check_slow_wake_lock, WAKE_LOCK_SUSPEND, "charger-check-slow");
+	wake_lock_init(&charger->aicl_wake_lock, WAKE_LOCK_SUSPEND, "charger-aicl");
+
+	/* Get IRQ service routine number */
+	charger->irq_wpcin_pok = pdata->irq_base + SM5705_WPCINPOK_IRQ;
+	charger->irq_vbus_pok = pdata->irq_base + SM5705_VBUSPOK_IRQ;
+	charger->irq_aicl = pdata->irq_base + SM5705_AICL_IRQ;
+#if defined(CONFIG_USE_POGO)
+	charger->irq_wpcin_pok_pogo = pdata->irq_base + SM5705_WPCINPOK_IRQ;
+	charger->irq_wpcin_uvlo_pogo = pdata->irq_base + SM5705_WPCINUVLO_IRQ;
+#endif
+#if EN_NOBAT_IRQ
+	charger->irq_nobat = pdata->irq_base + SM5705_NOBAT_IRQ;
+#endif
+#if EN_TOPOFF_IRQ
+	charger->irq_topoff = pdata->irq_base + SM5705_TOPOFF_IRQ;
+#endif
+#if EN_OTGFAIL_IRQ
+	charger->irq_otgfail = pdata->irq_base + SM5705_OTGFAIL_IRQ;
+#endif
+	charger->irq_done = pdata->irq_base + SM5705_DONE_IRQ;
+
+	pr_info("init process done..\n");
+
+	return 0;
+}
+
+static void sm5705_charger_initialize(struct sm5705_charger_data *charger)
+{
+	pr_info("charger initial hardware condition process start. (float_voltage=%d)\n",
+		charger->pdata->chg_float_voltage);
+
+	/* Auto-Stop configuration for Emergency status */
+	sm5705_CHG_set_TOPOFF(charger, 250);
+	sm5705_CHG_set_TOPOFF_TMR(charger, SM5705_TOPOFF_TIMER_45m);
+	sm5705_CHG_enable_AUTOSTOP(charger, 1);
+#if defined(CONFIG_USE_POGO)
+	sm5705_CHG_set_external_boost(charger, 0);
+#endif
+
+	sm5705_CHG_set_BATREG(charger, charger->pdata->chg_float_voltage);
+
+	sm5705_CHG_set_AICLTH(charger, 4500);
+	sm5705_CHG_enable_AICL(charger, 1);
+
+	sm5705_CHG_enable_AUTOSET(charger, 1);
+
+	sm5705_CHG_set_BST_IQ3LIMIT(charger, SM5705_CHG_BST_IQ3LIMIT_3_5A);
+
+	sm5705_CHG_set_OVPSEL(charger, 1); /* fix OVPSEL */
+
+	/* SM5705 Charger Reset contdition initialize */
+#if defined(SM5705_I2C_RESET_ACTIVATE)
+	sm5705_CHG_set_ENI2CRESET(charger, 1);
+#endif
+
+#if defined(SM5705_MANUAL_RESET_ACTIVATE)
+	sm5705_CHG_set_ENMRSTB(charger, SM5705_MANUAL_RESET_TIMER);
+#endif
+
+#if defined(SM5705_WATCHDOG_RESET_ACTIVATE)
+	sm5705_CHG_set_WATCHDOG_TMR(charger, SM5705_WATCHDOG_RESET_TIMER);
+	sm5705_CHG_set_ENWATCHDOG(charger, 1, 1);
+	g_sm5705_charger= charger;
+#endif
+
+	sm5705_chg_test_read(charger);
+
+	pr_info("charger initial hardware condition process done.\n");
+}
+
+static int sm5705_charger_probe(struct platform_device *pdev)
+{
+	struct sm5705_dev *sm5705 = dev_get_drvdata(pdev->dev.parent);
+	struct sm5705_charger_data *charger;
+	int ret = 0;
+
+	pr_info("Sm5705 Charger Driver Probing start\n");
+
+	charger = kzalloc(sizeof(struct sm5705_charger_data), GFP_KERNEL);
+	if (!charger) {
+		pr_err("fail to memory allocate for sm5705 charger handler\n");
+		return -ENOMEM;
+	}
+
+	charger->dev = &pdev->dev;
+	charger->i2c = sm5705->i2c;
+	charger->pdata = _get_sm5705_charger_platform_data(pdev, charger);
+	if (charger->pdata == NULL) {
+		pr_err("fail to get charger platform data\n");
+		goto err_free;
+	}
+
+	ret = _init_sm5705_charger_info(pdev, sm5705, charger);
+	if (IS_ERR_VALUE(ret)) {
+		pr_err("can't initailize sm5705 charger");
+		goto err_free;
+	}
+	platform_set_drvdata(pdev, charger);
+
+	sm5705_charger_initialize(charger);
+
+	charger->psy_chg.name = "sm5705-charger";
+	charger->psy_chg.type = POWER_SUPPLY_TYPE_UNKNOWN;
+	charger->psy_chg.get_property = sm5705_chg_get_property;
+	charger->psy_chg.set_property = sm5705_chg_set_property;
+	charger->psy_chg.properties	= sm5705_charger_props;
+	charger->psy_chg.num_properties	= ARRAY_SIZE(sm5705_charger_props);
+	ret = power_supply_register(&pdev->dev, &charger->psy_chg);
+	if (ret) {
+		pr_err("fail to register psy_chg\n");
+		goto err_power_supply_register;
+	}
+
+	charger->psy_otg.name = "otg";
+	charger->psy_otg.type = POWER_SUPPLY_TYPE_OTG;
+	charger->psy_otg.get_property = sm5705_otg_get_property;
+	charger->psy_otg.set_property = sm5705_otg_set_property;
+	charger->psy_otg.properties	 = sm5705_otg_props;
+	charger->psy_otg.num_properties	= ARRAY_SIZE(sm5705_otg_props);
+	ret = power_supply_register(&pdev->dev, &charger->psy_otg);
+	if (ret) {
+		pr_err("fail to register otg_chg\n");
+		goto err_power_supply_register_chg;
+	}
+
+	/* Operation Mode Initialize */
+	sm5705_charger_oper_table_init(charger->i2c);
+
+	/* Request IRQ */
+#if defined(CONFIG_USE_POGO)
+	ret = request_threaded_irq(charger->irq_wpcin_pok_pogo, NULL,
+			sm5705_chg_wpcin_pok_pogo_isr, IRQF_TRIGGER_FALLING, "pogo-pok-int", charger);
+	if (ret) {
+		pr_err("fail to request wpcin pogo IRQ: %d: %d\n", charger->irq_wpcin_pok_pogo, ret);
+		goto err_power_supply_register_otg;
+	}
+	ret = request_threaded_irq(charger->irq_wpcin_uvlo_pogo, NULL,
+			sm5705_chg_wpcin_pok_pogo_isr, IRQF_TRIGGER_FALLING, "pogo-uvlo-int", charger);
+	if (ret) {
+		pr_err("fail to request wpcin pogo IRQ: %d: %d\n", charger->irq_wpcin_uvlo_pogo, ret);
+		goto err_power_supply_register_otg;
+	}
+#endif /* CONFIG_USE_POGO */
+#if defined(SM5705_USED_WIRELESS_CHARGER)
+	ret = request_threaded_irq(charger->irq_wpcin_pok, NULL,
+			sm5705_chg_wpcin_pok_isr, IRQF_TRIGGER_FALLING, "wpc-int", charger);
+	if (ret) {
+		pr_err("fail to request wpcin IRQ: %d: %d\n", charger->irq_wpcin_pok, ret);
+		goto err_power_supply_register_otg;
+	}
+#endif
+	ret = request_threaded_irq(charger->irq_vbus_pok, NULL,
+			sm5705_chg_vbus_in_isr, 0, "chgin-irq", charger);
+	if (ret < 0) {
+		pr_err("fail to request chgin IRQ: %d: %d\n", charger->irq_vbus_pok, ret);
+		goto err_power_supply_register_otg;
+	}
+#if EN_NOBAT_IRQ
+	ret = request_threaded_irq(charger->irq_nobat, NULL,
+			sm5705_chg_nobat_isr, 0, "nobat-irq", charger);
+	if (ret < 0) {
+		pr_err("fail to request nobat IRQ: %d: %d\n", charger->irq_nobat, ret);
+		goto err_power_supply_register_otg;
+	}
+#endif /*EN_NOBAT_IRQ*/
+#if EN_TOPOFF_IRQ
+	ret = request_threaded_irq(charger->irq_topoff, NULL,
+			sm5705_chg_topoff_isr, 0, "topoff-irq", charger);
+	if (ret < 0) {
+		pr_err("fail to request topoff IRQ: %d: %d\n", charger->irq_topoff, ret);
+		goto err_power_supply_register_otg;
+	}
+#endif /*EN_TOPOFF_IRQ*/
+#if EN_OTGFAIL_IRQ
+	ret = request_threaded_irq(charger->irq_otgfail, NULL,
+			sm5705_chg_otgfail_isr, 0, "otgfail-irq", charger);
+	if (ret < 0) {
+		pr_err("fail to request otgfail IRQ: %d: %d\n", charger->irq_otgfail, ret);
+		goto err_power_supply_register_otg;
+	}
+#endif
+	ret = sm5705_chg_create_attrs(charger->psy_chg.dev);
+	if (ret){
+		pr_err("Failed to create_attrs\n");
+		goto err_power_supply_register_otg;
+	}
+
+	pr_info("SM5705 Charger Driver Loaded Done\n");
+
+	return 0;
+
+err_power_supply_register_otg:
+	power_supply_unregister(&charger->psy_otg);
+err_power_supply_register_chg:
+	power_supply_unregister(&charger->psy_chg);
+err_power_supply_register:
+	destroy_workqueue(charger->wqueue);
+	mutex_destroy(&charger->charger_mutex);
+err_free:
+	kfree(charger);
+
+	return ret;
+}
+
+static int sm5705_charger_remove(struct platform_device *pdev)
+{
+	struct sm5705_charger_data *charger = platform_get_drvdata(pdev);
+
+#if defined(CONFIG_USE_POGO)
+	cancel_delayed_work(&charger->pogo_work);
+#endif
+#if defined(SM5705_USED_WIRELESS_CHARGER)
+	cancel_delayed_work(&charger->wpc_work);
+	cancel_delayed_work(&charger->wc_afc_work);
+#endif
+	if (charger->pdata->support_slow_charging)
+		cancel_delayed_work(&charger->aicl_work);
+#if EN_NOBAT_IRQ
+	cancel_delayed_work(&charger->nobat_work);
+#endif
+#if EN_TOPOFF_IRQ
+	cancel_delayed_work(&charger->topoff_work);
+#endif
+	cancel_delayed_work(&charger->op_mode_switch_work);
+	destroy_workqueue(charger->wqueue);
+#if defined(CONFIG_USE_POGO)
+	free_irq(charger->irq_wpcin_pok_pogo, NULL);
+	free_irq(charger->irq_wpcin_uvlo_pogo, NULL);
+#endif
+#if defined(SM5705_USED_WIRELESS_CHARGER)
+	free_irq(charger->irq_wpcin_pok, NULL);
+#endif
+	free_irq(charger->irq_vbus_pok, NULL);
+#if EN_NOBAT_IRQ
+	free_irq(charger->irq_nobat, NULL);
+#endif
+#if EN_TOPOFF_IRQ
+	free_irq(charger->irq_topoff, NULL);
+#endif
+#if EN_OTGFAIL_IRQ
+	free_irq(charger->irq_otgfail, NULL);
+#endif
+
+	power_supply_unregister(&charger->psy_chg);
+	mutex_destroy(&charger->charger_mutex);
+	kfree(charger);
+	return 0;
+}
+
+static void sm5705_charger_shutdown(struct device *dev)
+{
+	struct sm5705_charger_data *charger = dev_get_drvdata(dev);
+
+	sm5705_update_reg(charger->i2c, SM5705_REG_CNTL,
+			SM5705_CHARGER_OP_MODE_CHG_ON, 0x07);
+
+	pr_info("call shutdown\n");
+}
+
+#if defined CONFIG_PM
+static int sm5705_charger_suspend(struct device *dev)
+{
+	pr_info("call suspend\n");
+	return 0;
+}
+
+static int sm5705_charger_resume(struct device *dev)
+{
+	pr_info("call resume\n");
+	return 0;
+}
+#else
+#define sm5705_charger_suspend NULL
+#define sm5705_charger_resume NULL
+#endif
+
+static SIMPLE_DEV_PM_OPS(sm5705_charger_pm_ops, sm5705_charger_suspend, sm5705_charger_resume);
+static struct platform_driver sm5705_charger_driver = {
+	.driver = {
+		.name = "sm5705-charger",
+		.owner = THIS_MODULE,
+		.pm = &sm5705_charger_pm_ops,
+		.shutdown = sm5705_charger_shutdown,
+	},
+	.probe = sm5705_charger_probe,
+	.remove = sm5705_charger_remove,
+};
+
+static int __init sm5705_charger_init(void)
+{
+	return platform_driver_register(&sm5705_charger_driver);
+}
+
+static void __exit sm5705_charger_exit(void)
+{
+	platform_driver_unregister(&sm5705_charger_driver);
+}
+
+
+module_init(sm5705_charger_init);
+module_exit(sm5705_charger_exit);
+
+MODULE_DESCRIPTION("SM5705 Charger Driver");
+MODULE_LICENSE("GPL v2");
+
diff -Naur linux-3.18.14/drivers/battery_v2/sm5705_charger_oper.c samsung/drivers/battery_v2/sm5705_charger_oper.c
--- linux-3.18.14/drivers/battery_v2/sm5705_charger_oper.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/sm5705_charger_oper.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,231 @@
+/*
+ * drivers/battery/sm5705_charger_oper.c
+ *
+ * SM5705 Charger Operation Mode controller
+ *
+ * Copyright (C) 2015 Siliconmitus Technology Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/kernel.h>
+#include "include/charger/sm5705_charger.h"
+#include "include/charger/sm5705_charger_oper.h"
+
+enum {
+	BST_OUT_4000mV              = 0x0,
+	BST_OUT_4100mV              = 0x1,
+	BST_OUT_4200mV              = 0x2,
+	BST_OUT_4300mV              = 0x3,
+	BST_OUT_4400mV              = 0x4,
+	BST_OUT_4500mV              = 0x5,
+	BST_OUT_4600mV              = 0x6,
+	BST_OUT_4700mV              = 0x7,
+	BST_OUT_4800mV              = 0x8,
+	BST_OUT_4900mV              = 0x9,
+	BST_OUT_5000mV              = 0xA,
+	BST_OUT_5100mV              = 0xB,
+};
+
+enum {
+	OTG_CURRENT_500mA           = 0x0,
+	OTG_CURRENT_700mA           = 0x1,
+	OTG_CURRENT_900mA           = 0x2,
+	OTG_CURRENT_1500mA          = 0x3,
+};
+
+#define SM5705_OPERATION_MODE_MASK  0x07
+#define SM5705_BSTOUT_MASK          0x0F
+#define SM5705_OTGCURRENT_MASK      0xC
+
+struct sm5705_charger_oper_table_info {
+	unsigned char status;
+	unsigned char oper_mode;
+	unsigned char BST_OUT;
+	unsigned char OTG_CURRENT;
+};
+
+struct sm5705_charger_oper_info {
+	struct i2c_client *i2c;
+
+	int max_table_num;
+	struct sm5705_charger_oper_table_info current_table;
+};
+static struct sm5705_charger_oper_info oper_info;
+
+/**
+ *  (VBUS in/out) (WPC in/out) (FLASH on/off) (TORCH on/off) (OTG cable in/out) (Power Sharing cable in/out)
+ **/
+static struct sm5705_charger_oper_table_info sm5705_charger_operation_mode_table[] = {
+	/* Charger mode : Charging ON */
+	{ make_OP_STATUS(0,0,0,0,0,0), SM5705_CHARGER_OP_MODE_CHG_ON, BST_OUT_4500mV, OTG_CURRENT_500mA},
+	{ make_OP_STATUS(1,0,0,0,0,0), SM5705_CHARGER_OP_MODE_CHG_ON, BST_OUT_4500mV, OTG_CURRENT_500mA},
+	{ make_OP_STATUS(1,1,0,0,0,0), SM5705_CHARGER_OP_MODE_CHG_ON, BST_OUT_4500mV, OTG_CURRENT_500mA},
+	{ make_OP_STATUS(1,0,0,1,0,0), SM5705_CHARGER_OP_MODE_CHG_ON, BST_OUT_4500mV, OTG_CURRENT_500mA},
+	{ make_OP_STATUS(1,1,0,1,0,0), SM5705_CHARGER_OP_MODE_CHG_ON, BST_OUT_4500mV, OTG_CURRENT_500mA},
+	{ make_OP_STATUS(0,1,0,0,0,0), SM5705_CHARGER_OP_MODE_CHG_ON, BST_OUT_4500mV, OTG_CURRENT_500mA},
+	{ make_OP_STATUS(1, 0, 0, 0, 1, 0), SM5705_CHARGER_OP_MODE_CHG_ON, BST_OUT_4500mV, OTG_CURRENT_500mA},
+	/* Charger mode : Flash Boost */
+	{ make_OP_STATUS(0,0,1,0,0,0), SM5705_CHARGER_OP_MODE_FLASH_BOOST, BST_OUT_4500mV, OTG_CURRENT_500mA},
+	{ make_OP_STATUS(0,0,1,0,1,0), SM5705_CHARGER_OP_MODE_FLASH_BOOST, BST_OUT_4500mV, OTG_CURRENT_900mA},
+	{ make_OP_STATUS(0,0,1,0,0,1), SM5705_CHARGER_OP_MODE_FLASH_BOOST, BST_OUT_4500mV, OTG_CURRENT_900mA},
+	{ make_OP_STATUS(0,1,1,0,0,0), SM5705_CHARGER_OP_MODE_FLASH_BOOST, BST_OUT_4500mV, OTG_CURRENT_500mA},
+	{ make_OP_STATUS(0,1,1,0,1,0), SM5705_CHARGER_OP_MODE_FLASH_BOOST, BST_OUT_4500mV, OTG_CURRENT_900mA},
+	{ make_OP_STATUS(0,1,1,0,0,1), SM5705_CHARGER_OP_MODE_FLASH_BOOST, BST_OUT_4500mV, OTG_CURRENT_900mA},
+	{ make_OP_STATUS(1,0,1,0,0,0), SM5705_CHARGER_OP_MODE_FLASH_BOOST, BST_OUT_4500mV, OTG_CURRENT_500mA},
+	{ make_OP_STATUS(1,1,1,0,0,0), SM5705_CHARGER_OP_MODE_FLASH_BOOST, BST_OUT_4500mV, OTG_CURRENT_500mA},
+	{ make_OP_STATUS(0,0,0,1,0,0), SM5705_CHARGER_OP_MODE_FLASH_BOOST, BST_OUT_4500mV, OTG_CURRENT_500mA},
+	/* Charger mode : Wireless OTG & Charger ON */
+	{ make_OP_STATUS(0,1,0,1,1,0), SM5705_CHARGER_OP_MODE_WPC_OTG_CHG_ON, BST_OUT_5100mV, OTG_CURRENT_900mA},
+	{ make_OP_STATUS(0,1,0,1,0,1), SM5705_CHARGER_OP_MODE_WPC_OTG_CHG_ON, BST_OUT_5100mV, OTG_CURRENT_900mA},
+	{ make_OP_STATUS(0,1,0,1,0,0), SM5705_CHARGER_OP_MODE_WPC_OTG_CHG_ON, BST_OUT_4500mV, OTG_CURRENT_500mA},
+	{ make_OP_STATUS(0,1,0,0,1,0), SM5705_CHARGER_OP_MODE_WPC_OTG_CHG_ON, BST_OUT_5100mV, OTG_CURRENT_900mA},
+	{ make_OP_STATUS(0,1,0,0,0,1), SM5705_CHARGER_OP_MODE_WPC_OTG_CHG_ON, BST_OUT_5100mV, OTG_CURRENT_900mA},
+	/* Charger mode : USB OTG */
+	{ make_OP_STATUS(0,0,0,1,1,0), SM5705_CHARGER_OP_MODE_USB_OTG, BST_OUT_5100mV, OTG_CURRENT_900mA},
+	{ make_OP_STATUS(0,0,0,1,0,1), SM5705_CHARGER_OP_MODE_USB_OTG, BST_OUT_5100mV, OTG_CURRENT_900mA},
+	{ make_OP_STATUS(0,0,0,0,1,0), SM5705_CHARGER_OP_MODE_USB_OTG, BST_OUT_5100mV, OTG_CURRENT_900mA},
+	{ make_OP_STATUS(0,0,0,0,0,1), SM5705_CHARGER_OP_MODE_USB_OTG, BST_OUT_5100mV, OTG_CURRENT_900mA},
+};
+
+/**
+ * SM5705 Charger operation mode controller relative I2C setup
+ */
+
+static int sm5705_charger_oper_set_mode(struct i2c_client *i2c, unsigned char mode)
+{
+	return sm5705_update_reg(i2c, SM5705_REG_CNTL, mode, SM5705_OPERATION_MODE_MASK);
+}
+
+static int sm5705_charger_oper_set_BSTOUT(struct i2c_client *i2c, unsigned char BSTOUT)
+{
+	return sm5705_update_reg(i2c, SM5705_REG_FLEDCNTL6, BSTOUT, SM5705_BSTOUT_MASK);
+}
+
+static int sm5705_charger_oper_set_OTG_CURRENT(struct i2c_client *i2c, unsigned char OTG_CURRENT)
+{
+	return sm5705_update_reg(i2c, SM5705_REG_CHGCNTL6, OTG_CURRENT << 2, SM5705_OTGCURRENT_MASK);
+}
+
+/**
+ * SM5705 Charger operation mode controller API functions.
+ */
+
+static inline unsigned char _update_status(int event_type, bool enable)
+{
+	if (event_type > SM5705_CHARGER_OP_EVENT_VBUS) {
+		return oper_info.current_table.status;
+	}
+
+	if (enable) {
+		return (oper_info.current_table.status | (1 << event_type));
+	} else {
+		return (oper_info.current_table.status & ~(1 << event_type));
+	}
+}
+
+static inline void sm5705_charger_oper_change_state(unsigned char new_status)
+{
+	int i;
+
+	for (i=0; i < oper_info.max_table_num; ++i) {
+		if (new_status == sm5705_charger_operation_mode_table[i].status) {
+			break;
+		}
+	}
+	if (i == oper_info.max_table_num) {
+		pr_err("sm5705-charger: %s: can't find matched Charger Operation Mode Table (status = 0x%x)\n", __func__, new_status);
+		return;
+	}
+
+	if (sm5705_charger_operation_mode_table[i].BST_OUT != oper_info.current_table.BST_OUT) {
+		sm5705_charger_oper_set_BSTOUT(oper_info.i2c, sm5705_charger_operation_mode_table[i].BST_OUT);
+		oper_info.current_table.BST_OUT = sm5705_charger_operation_mode_table[i].BST_OUT;
+	}
+	if (sm5705_charger_operation_mode_table[i].OTG_CURRENT != oper_info.current_table.OTG_CURRENT) {
+		sm5705_charger_oper_set_OTG_CURRENT(oper_info.i2c, sm5705_charger_operation_mode_table[i].OTG_CURRENT);
+		oper_info.current_table.OTG_CURRENT = sm5705_charger_operation_mode_table[i].OTG_CURRENT;
+	}
+
+	/* USB_OTG to CHG_ON work-around for BAT_REG stabilize */
+	if (oper_info.current_table.oper_mode == SM5705_CHARGER_OP_MODE_USB_OTG && \
+		sm5705_charger_operation_mode_table[i].oper_mode == SM5705_CHARGER_OP_MODE_CHG_ON) {
+		pr_info("sm5705-charger: %s: trans op_mode:suspend for BAT_REG stabilize (time=100ms)\n", __func__);
+		sm5705_charger_oper_set_mode(oper_info.i2c, SM5705_CHARGER_OP_MODE_SUSPEND);
+		msleep(100);
+	}
+
+	if (sm5705_charger_operation_mode_table[i].oper_mode != oper_info.current_table.oper_mode) {
+		sm5705_charger_oper_set_mode(oper_info.i2c, sm5705_charger_operation_mode_table[i].oper_mode);
+		oper_info.current_table.oper_mode = sm5705_charger_operation_mode_table[i].oper_mode;
+	}
+	oper_info.current_table.status = new_status;
+
+	pr_info("sm5705-charger: %s: New table[%d] info (STATUS: 0x%x, MODE: %d, BST_OUT: 0x%x, OTG_CURRENT: 0x%x\n", \
+			__func__, i, oper_info.current_table.status, oper_info.current_table.oper_mode, oper_info.current_table.BST_OUT, oper_info.current_table.OTG_CURRENT);
+}
+
+int sm5705_charger_oper_push_event(int event_type, bool enable)
+{
+	unsigned char new_status;
+
+	if (oper_info.i2c == NULL) {
+		pr_err("sm5705-charger: %s: required sm5705 charger operation table initialize\n", __func__);
+		return -ENOENT;
+	}
+
+	pr_info("sm5705-charger: %s: event_type=%d, enable=%d\n", __func__, event_type, enable);
+
+	new_status = _update_status(event_type, enable);
+	if (new_status == oper_info.current_table.status) {
+		goto out;
+	}
+
+	sm5705_charger_oper_change_state(new_status);
+
+out:
+	return 0;
+}
+EXPORT_SYMBOL(sm5705_charger_oper_push_event);
+
+int sm5705_charger_oper_table_init(struct i2c_client *i2c)
+{
+	if (i2c == NULL) {
+		pr_err("sm5705-charger: %s: invalid i2c client handler=n", __func__);
+		return -EINVAL;
+	}
+	oper_info.i2c = i2c;
+
+	/* set default operation mode condition */
+	oper_info.max_table_num = ARRAY_SIZE(sm5705_charger_operation_mode_table);
+	oper_info.current_table.status = make_OP_STATUS(0, 0, 0, 0, 0, 0);
+	oper_info.current_table.oper_mode = SM5705_CHARGER_OP_MODE_CHG_ON;
+	oper_info.current_table.BST_OUT = BST_OUT_4500mV;
+	oper_info.current_table.OTG_CURRENT = OTG_CURRENT_500mA;
+
+	sm5705_charger_oper_set_mode(oper_info.i2c, oper_info.current_table.oper_mode);
+	sm5705_charger_oper_set_BSTOUT(oper_info.i2c, oper_info.current_table.BST_OUT);
+	sm5705_charger_oper_set_OTG_CURRENT(oper_info.i2c, oper_info.current_table.OTG_CURRENT);
+
+	pr_info("sm5705-charger: %s: current table info (STATUS: 0x%x, MODE: %d, BST_OUT: 0x%x, OTG_CURRENT: 0x%x\n", \
+			__func__, oper_info.current_table.status, oper_info.current_table.oper_mode, oper_info.current_table.BST_OUT, oper_info.current_table.OTG_CURRENT);
+
+	return 0;
+}
+EXPORT_SYMBOL(sm5705_charger_oper_table_init);
+
+int sm5705_charger_oper_get_current_status(void)
+{
+	return oper_info.current_table.status;
+}
+EXPORT_SYMBOL(sm5705_charger_oper_get_current_status);
+
+int sm5705_charger_oper_get_current_op_mode(void)
+{
+	return oper_info.current_table.oper_mode;
+}
+EXPORT_SYMBOL(sm5705_charger_oper_get_current_op_mode);
diff -Naur linux-3.18.14/drivers/battery_v2/sm5705_fuelgauge.c samsung/drivers/battery_v2/sm5705_fuelgauge.c
--- linux-3.18.14/drivers/battery_v2/sm5705_fuelgauge.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/sm5705_fuelgauge.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,2944 @@
+/* drivers/battery/sm5705_fuelgauge.c
+ * SM5705 Voltage Tracking Fuelgauge Driver
+ *
+ * Copyright (C) 2013
+ * Author: Dongik Sin <dongik.sin@samsung.com>
+ * Modified by SW Jung
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ */
+
+#define pr_fmt(fmt)	"sm5705-fuelgauge: %s: " fmt, __func__
+
+#include "include/fuelgauge/sm5705_fuelgauge.h"
+#include "include/fuelgauge/sm5705_fuelgauge_impl.h"
+#include <linux/uaccess.h>
+#include <linux/of.h>
+#include <linux/fs.h>
+#include <linux/math64.h>
+#include <linux/compiler.h>
+#include <linux/of_gpio.h>
+
+#define SM5705_FG_DEVICE_NAME "sm5705-fg"
+#define ALIAS_NAME "sm5705-fuelgauge"
+
+#define FG_DET_BAT_PRESENT 1
+#define MINVAL(a, b) ((a <= b) ? a : b)
+#define MAXVAL(a, b) ((a > b) ? a : b)
+
+#define LIMIT_N_CURR_MIXFACTOR -2000
+#define FG_ABNORMAL_RESET -1
+#define IGNORE_N_I_OFFSET 1
+#define ABSOLUTE_ERROR_OCV_MATCH 1 
+//#define SM5705_FG_FULL_DEBUG 1
+
+enum battery_table_type {
+	DISCHARGE_TABLE = 0,
+	Q_TABLE,
+	TABLE_MAX,
+};
+
+static int sm5705_device_id = -1;
+
+static struct device_attribute sm5705_fg_attrs[] = {
+	SM5705_FG_ATTR(reg),
+	SM5705_FG_ATTR(data),
+	SM5705_FG_ATTR(regs),
+};
+
+static enum power_supply_property sm5705_fuelgauge_props[] = {
+};
+
+bool sm5705_fg_fuelalert_init(struct i2c_client *client, int soc);
+
+static inline int sm5705_fg_read_device(struct i2c_client *client,
+				      int reg, int bytes, void *dest)
+{
+	int ret;
+
+	if (bytes > 1)
+		ret = i2c_smbus_read_i2c_block_data(client, reg, bytes, dest);
+	else {
+		ret = i2c_smbus_read_byte_data(client, reg);
+		if (ret < 0)
+			return ret;
+		*(unsigned char *)dest = (unsigned char)ret;
+	}
+	return ret;
+}
+
+static int32_t sm5705_fg_i2c_read_word(struct i2c_client *client,
+                        uint8_t reg_addr)
+{
+	uint16_t data = 0;
+	int ret;
+	ret = sm5705_fg_read_device(client, reg_addr, 2, &data);
+	//pr_info("ret = %d, addr = 0x%x, data = 0x%x\n", ret, reg_addr, data);
+
+	if (ret < 0)
+		return ret;
+	else
+		return data;
+
+	// not use big endian
+	//return (int32_t)be16_to_cpu(data);
+}
+
+
+static int32_t sm5705_fg_i2c_write_word(struct i2c_client *client,
+                            uint8_t reg_addr,uint16_t data)
+{
+	int ret;
+
+	// not use big endian
+	//data = cpu_to_be16(data);
+	ret = i2c_smbus_write_i2c_block_data(client, reg_addr, 2, (uint8_t *)&data);
+//	pr_info("ret = %d, addr = 0x%x, data = 0x%x\n", ret, reg_addr, data);
+
+	return ret;
+}
+
+static int32_t sm5705_fg_i2c_verified_write_word(struct i2c_client *client,
+		uint8_t reg_addr,uint16_t data)
+{
+	int ret;
+
+	// not use big endian
+	//data = cpu_to_be16(data);
+	ret = i2c_smbus_write_i2c_block_data(client, reg_addr, 2, (uint8_t *)&data);
+	if(ret<0)
+	{
+		msleep(50);
+		pr_info("1st fail i2c write : ret = %d, addr = 0x%x, data = 0x%x\n", ret, reg_addr, data);
+		ret = i2c_smbus_write_i2c_block_data(client, reg_addr, 2, (uint8_t *)&data);
+		if(ret<0)
+		{
+			msleep(50);
+			pr_info("2nd fail i2c write : ret = %d, addr = 0x%x, data = 0x%x\n", ret, reg_addr, data);
+			ret = i2c_smbus_write_i2c_block_data(client, reg_addr, 2, (uint8_t *)&data);
+			if(ret<0)
+			{
+				pr_info("3rd fail i2c write : ret = %d, addr = 0x%x, data = 0x%x\n", ret, reg_addr, data);
+			}
+		}
+	}
+	//	pr_info("ret = %d, addr = 0x%x, data = 0x%x\n", ret, reg_addr, data);
+
+	return ret;
+}
+
+static int sm5705_get_all_value(struct i2c_client *client);
+static unsigned int sm5705_get_vbat(struct i2c_client *client);
+static unsigned int sm5705_get_ocv(struct i2c_client *client);
+static int sm5705_get_curr(struct i2c_client *client);
+static int sm5705_get_temperature(struct i2c_client *client);
+static unsigned int sm5705_get_soc(struct i2c_client *client);
+static int sm5705_abnormal_reset_check(struct i2c_client *client);
+
+#if 0
+static void sm5705_pr_ver_info(struct i2c_client *client)
+{
+	pr_info("SM5705 Fuel-Gauge Ver %s\n", FG_DRIVER_VER);
+}
+#endif
+
+static unsigned int sm5705_get_ocv(struct i2c_client *client)
+{
+	int ret;
+	unsigned int ocv;// = 3500; /*3500 means 3500mV*/
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+
+	ret = sm5705_fg_i2c_read_word(client, SM5705_REG_OCV);
+	if (ret<0) {
+		pr_err("read ocv reg fail\n");
+		ocv = 4000;
+	} else {
+		ocv = ((ret&0x7800)>>11) * 1000; //integer;
+		ocv = ocv + (((ret&0x07ff)*1000)/2048); // integer + fractional
+	}
+
+	fuelgauge->info.batt_ocv = ocv;
+#ifdef SM5705_FG_FULL_DEBUG
+	pr_info(" read = 0x%x, ocv = %d\n", ret, ocv);
+#endif
+
+	return ocv;
+}
+
+void sm5705_cal_avg_vbat(struct sec_fuelgauge_info *fuelgauge)
+{
+	if (fuelgauge->info.batt_avgvoltage == 0)
+		fuelgauge->info.batt_avgvoltage = fuelgauge->info.batt_voltage;
+
+	else if (fuelgauge->info.batt_voltage == 0 && fuelgauge->info.p_batt_voltage == 0)
+		fuelgauge->info.batt_avgvoltage = 3400;
+
+	else if(fuelgauge->info.batt_voltage == 0)
+		fuelgauge->info.batt_avgvoltage =
+				((fuelgauge->info.batt_avgvoltage) + (fuelgauge->info.p_batt_voltage))/2;
+
+	else if(fuelgauge->info.p_batt_voltage == 0)
+		fuelgauge->info.batt_avgvoltage =
+				((fuelgauge->info.batt_avgvoltage) + (fuelgauge->info.batt_voltage))/2;
+
+	else
+		fuelgauge->info.batt_avgvoltage =
+				((fuelgauge->info.batt_avgvoltage*2) +
+				 (fuelgauge->info.p_batt_voltage+fuelgauge->info.batt_voltage))/4;
+
+#ifdef SM5705_FG_FULL_DEBUG
+	pr_info("batt_avgvoltage = %d\n", fuelgauge->info.batt_avgvoltage);
+#endif
+
+	return;
+}
+
+static unsigned int sm5705_get_vbat(struct i2c_client *client)
+{
+	int ret;
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+
+	unsigned int vbat;/* = 3500; 3500 means 3500mV*/
+
+	ret = sm5705_fg_i2c_read_word(client, SM5705_REG_VOLTAGE);
+	if (ret<0) {
+		pr_err("read vbat reg fail");
+		vbat = 4000;
+	} else {
+		vbat = ((ret&0x3800)>>11) * 1000; //integer;
+		vbat = vbat + (((ret&0x07ff)*1000)/2048); // integer + fractional
+	}
+	fuelgauge->info.batt_voltage = vbat;
+
+#ifdef SM5705_FG_FULL_DEBUG
+	pr_info("read = 0x%x, vbat = %d\n", ret, vbat);
+#endif
+	sm5705_cal_avg_vbat(fuelgauge);
+
+	if ((fuelgauge->volt_alert_flag == true) && vbat > 3400) {
+		fuelgauge->volt_alert_flag = false;
+		sm5705_fg_fuelalert_init(client,
+				fuelgauge->pdata->fuel_alert_soc);
+		pr_info("volt_alert_flag = %d \n", fuelgauge->volt_alert_flag);
+	}
+
+	return vbat;
+}
+
+void sm5705_cal_avg_current(struct sec_fuelgauge_info *fuelgauge)
+{
+	if (fuelgauge->info.batt_avgcurrent == 0)
+		fuelgauge->info.batt_avgcurrent = fuelgauge->info.batt_current;
+
+	else if (fuelgauge->info.batt_avgcurrent == 0 && fuelgauge->info.p_batt_current == 0)
+		fuelgauge->info.batt_avgcurrent = fuelgauge->info.batt_current;
+
+	else if(fuelgauge->info.batt_current == 0)
+		fuelgauge->info.batt_avgcurrent =
+				((fuelgauge->info.batt_avgcurrent) + (fuelgauge->info.p_batt_current))/2;
+
+	else if(fuelgauge->info.p_batt_current == 0)
+		fuelgauge->info.batt_avgcurrent =
+				((fuelgauge->info.batt_avgcurrent) + (fuelgauge->info.batt_current))/2;
+
+	else
+		fuelgauge->info.batt_avgcurrent =
+				((fuelgauge->info.batt_avgcurrent*2) +
+				 (fuelgauge->info.p_batt_current+fuelgauge->info.batt_current))/4;
+
+#ifdef SM5705_FG_FULL_DEBUG
+	pr_info("batt_avgcurrent = %d\n", fuelgauge->info.batt_avgcurrent);
+#endif
+
+	return;
+}
+
+
+static int sm5705_get_curr(struct i2c_client *client)
+{
+	int ret, volt_slope, mohm_volt_cal;
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+
+	int curr;/* = 1000; 1000 means 1000mA*/
+
+	ret = sm5705_fg_i2c_read_word(client, SM5705_REG_CURRENT);
+	if (ret<0) {
+		pr_err("read curr reg fail");
+		curr = 0;
+	} else {
+		curr = ((ret&0x1800)>>11) * 1000; //integer;
+		curr = curr + (((ret&0x07ff)*1000)/2048); // integer + fractional
+
+		if(ret&0x8000) {
+			curr *= -1;
+		}
+	}
+	fuelgauge->info.batt_current = curr;
+
+#ifdef SM5705_FG_FULL_DEBUG
+	pr_info("read = 0x%x, curr = %d\n", ret, curr);
+#endif
+
+	//set vbat offset cancel start
+	volt_slope = sm5705_fg_i2c_read_word(client, SM5705_REG_VOLT_CAL);
+	volt_slope = volt_slope & 0xFF00;
+	mohm_volt_cal = fuelgauge->info.volt_cal & 0x00FF;
+	if(fuelgauge->info.enable_v_offset_cancel_p)
+	{
+		if(fuelgauge->is_charging && (curr > fuelgauge->info.v_offset_cancel_level))
+		{
+			if(mohm_volt_cal & 0x0080)
+			{
+				mohm_volt_cal = -(mohm_volt_cal & 0x007F);
+			}
+			mohm_volt_cal = mohm_volt_cal - (curr/(fuelgauge->info.v_offset_cancel_mohm * 13)); // ((curr*0.001)*0.006)*2048 -> 6mohm
+			if(mohm_volt_cal < 0)
+			{
+				mohm_volt_cal = -mohm_volt_cal;
+				mohm_volt_cal = mohm_volt_cal|0x0080;
+			}
+		}
+	}
+	if(fuelgauge->info.enable_v_offset_cancel_n)
+	{
+		if(!(fuelgauge->is_charging) && (curr < -(fuelgauge->info.v_offset_cancel_level)))
+		{
+			if(fuelgauge->info.volt_cal & 0x0080)
+			{
+				mohm_volt_cal = -(mohm_volt_cal & 0x007F);
+			}
+			mohm_volt_cal = mohm_volt_cal - (curr/(fuelgauge->info.v_offset_cancel_mohm * 13)); // ((curr*0.001)*0.006)*2048 -> 6mohm
+			if(mohm_volt_cal < 0)
+			{
+				mohm_volt_cal = -mohm_volt_cal;
+				mohm_volt_cal = mohm_volt_cal|0x0080;
+			}
+		}
+	}
+	sm5705_fg_i2c_write_word(client, SM5705_REG_VOLT_CAL, (mohm_volt_cal | volt_slope));
+	pr_info("<%d %d %d %d> info.volt_cal = 0x%x, volt_slope = 0x%x, mohm_volt_cal = 0x%x\n",
+			fuelgauge->info.enable_v_offset_cancel_p, fuelgauge->info.enable_v_offset_cancel_n
+			, fuelgauge->info.v_offset_cancel_level, fuelgauge->info.v_offset_cancel_mohm
+			, fuelgauge->info.volt_cal, volt_slope, mohm_volt_cal);
+	//set vbat offset cancel end
+
+	sm5705_cal_avg_current(fuelgauge);
+
+	return curr;
+}
+
+static int sm5705_get_temperature(struct i2c_client *client)
+{
+	int ret;
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+
+	int temp;/* = 250; 250 means 25.0oC*/
+	//double temp_data;
+
+	ret = sm5705_fg_i2c_read_word(client, SM5705_REG_TEMPERATURE);
+	if (ret<0) {
+		pr_err("read temp reg fail");
+		temp = 0;
+	} else {
+		temp = ((ret&0x7F00)>>8) * 10; //integer bit
+		temp = temp + (((ret&0x00f0)*10)/256); // integer + fractional bit
+		if(ret&0x8000) {
+			temp *= -1;
+		}
+	}
+	fuelgauge->info.temp_fg = temp;
+
+#ifdef SM5705_FG_FULL_DEBUG
+	pr_info("read = 0x%x, temp_fg = %d\n", ret, temp);
+#endif
+
+	return temp;
+}
+
+static int sm5705_get_soc_cycle(struct i2c_client *client)
+{
+	int ret;
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+
+	int cycle;
+
+	ret = sm5705_fg_i2c_read_word(client, SM5705_REG_SOC_CYCLE);
+	if (ret<0) {
+		pr_err("read cycle reg fail");
+		cycle = 0;
+	} else {
+		cycle = ret&0x03FF;
+	}
+	fuelgauge->info.batt_soc_cycle = cycle;
+
+#ifdef SM5705_FG_FULL_DEBUG
+	pr_info("read = 0x%x, soc_cycle = %d\n", ret, cycle);
+#endif
+
+	return cycle;
+}
+
+static void sm5705_fg_test_read(struct i2c_client *client)
+{
+	int ret0, ret1, ret2, ret3, ret4, ret5, ret6, ret7, ret8, ret9;
+
+	ret0 = sm5705_fg_i2c_read_word(client, 0xA0);
+	ret1 = sm5705_fg_i2c_read_word(client, 0xAC);
+	ret2 = sm5705_fg_i2c_read_word(client, 0xAD);
+	ret3 = sm5705_fg_i2c_read_word(client, 0xAE);
+	ret4 = sm5705_fg_i2c_read_word(client, 0xAF);
+	ret5 = sm5705_fg_i2c_read_word(client, 0x28);
+	ret6 = sm5705_fg_i2c_read_word(client, 0x2F);
+	ret7 = sm5705_fg_i2c_read_word(client, 0x01);
+	pr_info("0xA0=0x%04x, 0xAC=0x%04x, 0xAD=0x%04x, 0xAE=0x%04x, 0xAF=0x%04x, 0x28=0x%04x, 0x2F=0x%04x, 0x01=0x%04x, SM5705_ID=0x%04x\n",
+			ret0, ret1, ret2, ret3, ret4, ret5, ret6, ret7, sm5705_device_id);
+
+	ret0 = sm5705_fg_i2c_read_word(client, 0xB0);
+	ret1 = sm5705_fg_i2c_read_word(client, 0xBC);
+	ret2 = sm5705_fg_i2c_read_word(client, 0xBD);
+	ret3 = sm5705_fg_i2c_read_word(client, 0xBE);
+	ret4 = sm5705_fg_i2c_read_word(client, 0xBF);
+	ret5 = sm5705_fg_i2c_read_word(client, 0x85);
+	ret6 = sm5705_fg_i2c_read_word(client, 0x86);
+	ret7 = sm5705_fg_i2c_read_word(client, 0x87);
+	ret8 = sm5705_fg_i2c_read_word(client, 0x1F);
+	ret9 = sm5705_fg_i2c_read_word(client, 0x94);
+	pr_info("0xB0=0x%04x, 0xBC=0x%04x, 0xBD=0x%04x, 0xBE=0x%04x, 0xBF=0x%04x, 0x85=0x%04x, 0x86=0x%04x, 0x87=0x%04x, 0x1F=0x%04x, 0x94=0x%04x\n",
+			ret0, ret1, ret2, ret3, ret4, ret5, ret6, ret7, ret8, ret9);
+
+	return;
+}
+
+static unsigned int sm5705_get_device_id(struct i2c_client *client)
+{
+	int ret;
+	ret = sm5705_fg_i2c_read_word(client, SM5705_REG_DEVICE_ID);
+	sm5705_device_id = ret;
+	pr_info("SM5705 device_id = 0x%x\n", ret);
+
+	return ret;
+}
+
+int sm5705_call_fg_device_id(void)
+{
+	pr_info("extern call SM5705 fg_device_id = 0x%x\n", sm5705_device_id);
+
+	return sm5705_device_id;
+}
+
+unsigned int sm5705_get_soc(struct i2c_client *client)
+{
+	int ret;
+	unsigned int soc;
+
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+
+	ret = sm5705_fg_i2c_read_word(client, SM5705_REG_SOC);
+	if (ret<0) {
+		pr_err("Warning!!!! read soc reg fail\n");
+		soc = 500;
+	} else {
+		soc = ((ret&0xff00)>>8) * 10; //integer bit;
+		soc = soc + (((ret&0x00ff)*10)/256); // integer + fractional bit
+	}
+
+	if (sm5705_abnormal_reset_check(client) < 0)
+	{
+		pr_info("FG init ERROR!! pre_SOC returned!!, read_SOC = %d, pre_SOC = %d\n", soc, fuelgauge->info.batt_soc);
+		return fuelgauge->info.batt_soc;
+	}
+
+#ifdef SM5705_FG_FULL_DEBUG
+	pr_info("read = 0x%x, soc = %d\n", ret, soc);
+#endif
+
+	// for low temp power off test
+	if(fuelgauge->info.volt_alert_flag && (fuelgauge->info.temperature < -100))
+	{
+		pr_info("volt_alert_flag is TRUE!!!! SOC make force ZERO!!!!\n");
+		fuelgauge->info.batt_soc = 0;
+		return 0;
+	}
+
+	fuelgauge->info.batt_soc = soc;
+
+	return soc;
+}
+
+static bool sm5705_fg_check_reg_init_need(struct i2c_client *client)
+{
+	int ret;
+
+	ret = sm5705_fg_i2c_read_word(client, SM5705_REG_FG_OP_STATUS);
+
+	if((ret & INIT_CHECK_MASK) == DISABLE_RE_INIT)
+	{
+		pr_info("SM5705_REG_FG_OP_STATUS : 0x%x , return 0\n", ret);
+		return 0;
+	}
+	else
+	{
+		pr_info("SM5705_REG_FG_OP_STATUS : 0x%x , return 1\n", ret);
+		return 1;
+	}
+}
+
+static void sm5705_fg_buffer_read(struct i2c_client *client)
+{
+	int ret0, ret1, ret2, ret3, ret4, ret5;
+
+	ret0 = sm5705_fg_i2c_read_word(client, 0x30);
+	ret1 = sm5705_fg_i2c_read_word(client, 0x31);
+	ret2 = sm5705_fg_i2c_read_word(client, 0x32);
+	ret3 = sm5705_fg_i2c_read_word(client, 0x33);
+	ret4 = sm5705_fg_i2c_read_word(client, 0x34);
+	ret5 = sm5705_fg_i2c_read_word(client, 0x35);
+	pr_info("sm5705 FG buffer 0x30_0x35 lb_V = 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x \n",
+		ret0, ret1, ret2, ret3, ret4, ret5);
+
+	ret0 = sm5705_fg_i2c_read_word(client, 0x36);
+	ret1 = sm5705_fg_i2c_read_word(client, 0x37);
+	ret2 = sm5705_fg_i2c_read_word(client, 0x38);
+	ret3 = sm5705_fg_i2c_read_word(client, 0x39);
+	ret4 = sm5705_fg_i2c_read_word(client, 0x3A);
+	ret5 = sm5705_fg_i2c_read_word(client, 0x3B);
+	pr_info("sm5705 FG buffer 0x36_0x3B cb_V = 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x \n",
+		ret0, ret1, ret2, ret3, ret4, ret5);
+
+
+	ret0 = sm5705_fg_i2c_read_word(client, 0x40);
+	ret1 = sm5705_fg_i2c_read_word(client, 0x41);
+	ret2 = sm5705_fg_i2c_read_word(client, 0x42);
+	ret3 = sm5705_fg_i2c_read_word(client, 0x43);
+	ret4 = sm5705_fg_i2c_read_word(client, 0x44);
+	ret5 = sm5705_fg_i2c_read_word(client, 0x45);
+	pr_info("sm5705 FG buffer 0x40_0x45 lb_I = 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x \n",
+		ret0, ret1, ret2, ret3, ret4, ret5);
+
+
+	ret0 = sm5705_fg_i2c_read_word(client, 0x46);
+	ret1 = sm5705_fg_i2c_read_word(client, 0x47);
+	ret2 = sm5705_fg_i2c_read_word(client, 0x48);
+	ret3 = sm5705_fg_i2c_read_word(client, 0x49);
+	ret4 = sm5705_fg_i2c_read_word(client, 0x4A);
+	ret5 = sm5705_fg_i2c_read_word(client, 0x4B);
+	pr_info("sm5705 FG buffer 0x46_0x4B cb_I = 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x \n",
+		ret0, ret1, ret2, ret3, ret4, ret5);
+
+	return;
+}
+
+static bool sm5705_fg_get_batt_present(struct i2c_client *client)
+{
+	// SM5705 is not suport batt present
+	pr_debug("sm5705_fg_get_batt_present\n");
+
+	return true;
+}
+
+int sm5705_calculate_iocv(struct i2c_client *client)
+{
+	bool only_lb=false, valid_cb=false, sign_i_offset=0;
+	int roop_start=0, roop_max=0, i=0, cb_last_index = 0, cb_pre_last_index =0;
+	int lb_v_buffer[6] = {0, 0, 0, 0, 0, 0};
+	int lb_i_buffer[6] = {0, 0, 0, 0, 0, 0};
+	int cb_v_buffer[6] = {0, 0, 0, 0, 0, 0};
+	int cb_i_buffer[6] = {0, 0, 0, 0, 0, 0};
+	int i_offset_margin = 0x14, i_vset_margin = 0x67;
+	int v_max=0, v_min=0, v_sum=0, lb_v_avg=0, cb_v_avg=0, lb_v_minmax_offset=0, lb_v_set=0, lb_i_set=0, i_offset=0;
+	int i_max=0, i_min=0, i_sum=0, lb_i_avg=0, cb_i_avg=0, lb_i_minmax_offset=0, cb_v_set=0, cb_i_set=0;
+	int lb_i_p_v_min=0, lb_i_n_v_max=0, cb_i_p_v_min=0, cb_i_n_v_max=0;
+
+	int v_ret=0, i_ret=0, ret=0;
+
+	ret = sm5705_fg_i2c_read_word(client, SM5705_REG_END_V_IDX);
+	pr_info("iocv_status_read = addr : 0x%x , data : 0x%x\n", SM5705_REG_END_V_IDX, ret);
+
+	// init start
+	if((ret & 0x0010) == 0x0000)
+	{
+		only_lb = true;
+	}
+
+	if((ret & 0x0300) == 0x0300)
+	{
+		valid_cb = true;
+	}
+	// init end
+
+	// lb get start
+	roop_max = (ret & 0x000F);
+	if(roop_max > 6)
+		roop_max = 6;
+
+	roop_start = SM5705_REG_IOCV_B_L_MIN;
+	for (i = roop_start; i < roop_start + roop_max; i++)
+	{
+		v_ret = sm5705_fg_i2c_read_word(client, i);
+		i_ret = sm5705_fg_i2c_read_word(client, i+0x10);
+		if((i_ret&0x4000) == 0x4000)
+		{
+			i_ret = -(i_ret&0x3FFF);
+		}
+
+		lb_v_buffer[i-roop_start] = v_ret;
+		lb_i_buffer[i-roop_start] = i_ret;
+
+		if (i == roop_start)
+		{
+			v_max = v_ret;
+			v_min = v_ret;
+			v_sum = v_ret;
+			i_max = i_ret;
+			i_min = i_ret;
+			i_sum = i_ret;
+		}
+		else
+		{
+			if(v_ret > v_max)
+				v_max = v_ret;
+			else if(v_ret < v_min)
+				v_min = v_ret;
+			v_sum = v_sum + v_ret;
+
+			if(i_ret > i_max)
+				i_max = i_ret;
+			else if(i_ret < i_min)
+				i_min = i_ret;
+			i_sum = i_sum + i_ret;
+		}
+
+		if(abs(i_ret) > i_vset_margin)
+		{
+			if(i_ret > 0)
+			{
+				if(lb_i_p_v_min == 0)
+				{
+					lb_i_p_v_min = v_ret;
+				}
+				else
+				{
+					if(v_ret < lb_i_p_v_min)
+						lb_i_p_v_min = v_ret;
+				}
+			}
+			else
+			{
+				if(lb_i_n_v_max == 0)
+				{
+					lb_i_n_v_max = v_ret;
+				}
+				else
+				{
+					if(v_ret > lb_i_n_v_max)
+						lb_i_n_v_max = v_ret;
+				}
+			}
+		}
+	}
+	v_sum = v_sum - v_max - v_min;
+	i_sum = i_sum - i_max - i_min;
+
+	lb_v_minmax_offset = v_max - v_min;
+	lb_i_minmax_offset = i_max - i_min;
+
+	lb_v_avg = v_sum / (roop_max-2);
+	lb_i_avg = i_sum / (roop_max-2);
+	// lb get end
+
+	// lb_vset start
+	if(abs(lb_i_buffer[roop_max-1]) < i_vset_margin)
+	{
+		if(abs(lb_i_buffer[roop_max-2]) < i_vset_margin)
+		{
+			lb_v_set = MAXVAL(lb_v_buffer[roop_max-2], lb_v_buffer[roop_max-1]);
+			if(abs(lb_i_buffer[roop_max-3]) < i_vset_margin)
+			{
+				lb_v_set = MAXVAL(lb_v_buffer[roop_max-3], lb_v_set);
+			}
+		}
+		else
+		{
+			lb_v_set = lb_v_buffer[roop_max-1];
+		}
+	}
+	else
+	{
+		lb_v_set = lb_v_avg;
+	}
+
+	if(lb_i_n_v_max > 0)
+	{
+		lb_v_set = MAXVAL(lb_i_n_v_max, lb_v_set);
+	}
+	//else if(lb_i_p_v_min > 0)
+	//{
+	//	lb_v_set = MINVAL(lb_i_p_v_min, lb_v_set);
+	//}
+	// lb_vset end
+
+	// lb offset make start
+	if(roop_max > 3)
+	{
+		lb_i_set = (lb_i_buffer[2] + lb_i_buffer[3]) / 2;
+	}
+
+	if((abs(lb_i_buffer[roop_max-1]) < i_offset_margin) && (abs(lb_i_set) < i_offset_margin))
+	{
+		lb_i_set = MAXVAL(lb_i_buffer[roop_max-1], lb_i_set);
+	}
+	else if(abs(lb_i_buffer[roop_max-1]) < i_offset_margin)
+	{
+		lb_i_set = lb_i_buffer[roop_max-1];
+	}
+	else if(abs(lb_i_set) < i_offset_margin)
+	{
+		lb_i_set = lb_i_set;
+	}
+	else
+	{
+		lb_i_set = 0;
+	}
+
+	i_offset = lb_i_set;
+
+	i_offset = i_offset + 4;	// add extra offset
+
+	if(i_offset <= 0)
+	{
+		sign_i_offset = 1;
+#if IGNORE_N_I_OFFSET
+		i_offset = 0;
+#else
+		i_offset = -i_offset;
+#endif
+	}
+
+	i_offset = i_offset>>1;
+
+	if(sign_i_offset == 0)
+	{
+		i_offset = i_offset|0x0080;
+	}
+
+	//do not write in kernel point.
+	//sm5705_fg_i2c_write_word(client, SM5705_REG_CURR_OFF, i_offset);
+	// lb offset make end
+
+	pr_info("iocv_l_max=0x%x, iocv_l_min=0x%x, iocv_l_avg=0x%x, lb_v_set=0x%x, roop_max=%d \n",
+		v_max, v_min, lb_v_avg, lb_v_set, roop_max);
+	pr_info("ioci_l_max=0x%x, ioci_l_min=0x%x, ioci_l_avg=0x%x, lb_i_set=0x%x, i_offset=0x%x, sign_i_offset=%d\n",
+		i_max, i_min, lb_i_avg, lb_i_set, i_offset, sign_i_offset);
+
+	if(!only_lb)
+	{
+		// cb get start
+		roop_start = SM5705_REG_IOCV_B_C_MIN;
+		roop_max = 6;
+		for (i = roop_start; i < roop_start + roop_max; i++)
+		{
+			v_ret = sm5705_fg_i2c_read_word(client, i);
+			i_ret = sm5705_fg_i2c_read_word(client, i+0x10);
+			if((i_ret&0x4000) == 0x4000)
+			{
+				i_ret = -(i_ret&0x3FFF);
+			}
+
+			cb_v_buffer[i-roop_start] = v_ret;
+			cb_i_buffer[i-roop_start] = i_ret;
+
+			if (i == roop_start)
+			{
+				v_max = v_ret;
+				v_min = v_ret;
+				v_sum = v_ret;
+				i_max = i_ret;
+				i_min = i_ret;
+				i_sum = i_ret;
+			}
+			else
+			{
+				if(v_ret > v_max)
+					v_max = v_ret;
+				else if(v_ret < v_min)
+					v_min = v_ret;
+				v_sum = v_sum + v_ret;
+
+				if(i_ret > i_max)
+					i_max = i_ret;
+				else if(i_ret < i_min)
+					i_min = i_ret;
+				i_sum = i_sum + i_ret;
+			}
+
+			if(abs(i_ret) > i_vset_margin)
+			{
+				if(i_ret > 0)
+				{
+					if(cb_i_p_v_min == 0)
+					{
+						cb_i_p_v_min = v_ret;
+					}
+					else
+					{
+						if(v_ret < cb_i_p_v_min)
+							cb_i_p_v_min = v_ret;
+					}
+				}
+				else
+				{
+					if(cb_i_n_v_max == 0)
+					{
+						cb_i_n_v_max = v_ret;
+					}
+					else
+					{
+						if(v_ret > cb_i_n_v_max)
+							cb_i_n_v_max = v_ret;
+					}
+				}
+			}
+		}
+		v_sum = v_sum - v_max - v_min;
+		i_sum = i_sum - i_max - i_min;
+
+		cb_v_avg = v_sum / (roop_max-2);
+		cb_i_avg = i_sum / (roop_max-2);
+		// cb get end
+
+		// cb_vset start
+		cb_last_index = (ret & 0x000F)-7; //-6-1
+		if(cb_last_index < 0)
+		{
+			cb_last_index = 5;
+		}
+
+		for (i = roop_max; i > 0; i--)
+		{
+			if(abs(cb_i_buffer[cb_last_index]) < i_vset_margin)
+			{
+				cb_v_set = cb_v_buffer[cb_last_index];
+				if(abs(cb_i_buffer[cb_last_index]) < i_offset_margin)
+				{
+					cb_i_set = cb_i_buffer[cb_last_index];
+				}
+
+				cb_pre_last_index = cb_last_index - 1;
+				if(cb_pre_last_index < 0)
+				{
+					cb_pre_last_index = 5;
+				}
+
+				if(abs(cb_i_buffer[cb_pre_last_index]) < i_vset_margin)
+				{
+					cb_v_set = MAXVAL(cb_v_buffer[cb_pre_last_index], cb_v_set);
+					if(abs(cb_i_buffer[cb_pre_last_index]) < i_offset_margin)
+					{
+						cb_i_set = MAXVAL(cb_i_buffer[cb_pre_last_index], cb_i_set);
+					}
+				}
+			}
+			else
+			{
+				cb_last_index--;
+				if(cb_last_index < 0)
+				{
+					cb_last_index = 5;
+				}
+			}
+		}
+
+		if(cb_v_set == 0)
+		{
+			cb_v_set = cb_v_avg;
+			if(cb_i_set == 0)
+			{
+				cb_i_set = cb_i_avg;
+			}
+		}
+
+		if(cb_i_n_v_max > 0)
+		{
+			cb_v_set = MAXVAL(cb_i_n_v_max, cb_v_set);
+		}
+		//else if(cb_i_p_v_min > 0)
+		//{
+		//	cb_v_set = MINVAL(cb_i_p_v_min, cb_v_set);
+		//}
+		// cb_vset end
+
+		// cb offset make start
+		if(abs(cb_i_set) < i_offset_margin)
+		{
+			if(cb_i_set > lb_i_set)
+			{
+				i_offset = cb_i_set;
+				i_offset = i_offset + 4;	// add extra offset
+				if(i_offset <= 0)
+				{
+					sign_i_offset = 1;
+#if IGNORE_N_I_OFFSET
+					i_offset = 0;
+#else
+					i_offset = -i_offset;
+#endif
+				}
+
+				i_offset = i_offset>>1;
+				if(sign_i_offset == 0)
+				{
+					i_offset = i_offset|0x0080;
+				}
+
+				//do not write in kernel point.
+				//sm5705_fg_i2c_write_word(client, SM5705_REG_CURR_OFF, i_offset);
+			}
+		}
+		// cb offset make end
+
+		pr_info("iocv_c_max=0x%x, iocv_c_min=0x%x, iocv_c_avg=0x%x, cb_v_set=0x%x, cb_last_index=%d \n",
+			v_max, v_min, cb_v_avg, cb_v_set, cb_last_index);
+		pr_info("ioci_c_max=0x%x, ioci_c_min=0x%x, ioci_c_avg=0x%x, cb_i_set=0x%x, i_offset=0x%x, sign_i_offset=%d\n",
+			i_max, i_min, cb_i_avg, cb_i_set, i_offset, sign_i_offset);
+
+	}
+
+	// final set
+	if((abs(cb_i_set) > i_vset_margin) || only_lb)
+	{
+		ret = MAXVAL(lb_v_set, cb_i_n_v_max);
+	}
+	else
+	{
+		ret = cb_v_set;
+	}
+
+	return ret;
+
+}
+
+static void sm5705_set_soc_cycle_cfg(struct i2c_client *client)
+{
+	int value;
+
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+
+	value = fuelgauge->info.cycle_limit_cntl|(fuelgauge->info.cycle_high_limit<<12)|(fuelgauge->info.cycle_low_limit<<8);
+
+	pr_info("cycle cfg value = 0x%x\n", value);
+
+	sm5705_fg_i2c_write_word(client, SM5705_REG_SOC_CYCLE_CFG, value);
+}
+
+#ifdef ENABLE_BATT_LONG_LIFE
+int get_v_max_index_by_cycle(struct i2c_client *client)
+{
+	int cycle_index=0, len;
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+
+	for (len = fuelgauge->pdata->num_age_step-1; len >= 0; --len) {
+		if(fuelgauge->chg_full_soc == fuelgauge->pdata->age_data[len].full_condition_soc) {
+			cycle_index=len;
+			break;
+		}
+	}
+	pr_info("%s: chg_full_soc = %d, index = %d \n", __func__, fuelgauge->chg_full_soc, cycle_index);
+
+	return cycle_index;
+}
+#endif
+
+static bool sm5705_fg_reg_init(struct i2c_client *client, int is_surge)
+{
+	int i, j, value, ret;
+	uint8_t table_reg;
+	int write_table[2][16];
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+
+	pr_info("sm5705_fg_reg_init START!!\n");
+
+	// init mark
+	sm5705_fg_i2c_write_word(client, SM5705_REG_RESET, SM5705_FG_INIT_MARK);
+
+	// start first param_ctrl unlock
+	sm5705_fg_i2c_write_word(client, SM5705_REG_PARAM_CTRL, SM5705_FG_PARAM_UNLOCK_CODE);
+
+	// RCE write
+	for (i = 0; i < 3; i++)
+	{
+		sm5705_fg_i2c_write_word(client, SM5705_REG_RCE0+i, fuelgauge->info.rce_value[i]);
+		pr_info("RCE write RCE%d = 0x%x : 0x%x\n",  i, SM5705_REG_RCE0+i, fuelgauge->info.rce_value[i]);
+	}
+
+	// DTCD write
+	sm5705_fg_i2c_write_word(client, SM5705_REG_DTCD, fuelgauge->info.dtcd_value);
+	pr_info("DTCD write DTCD = 0x%x : 0x%x\n", SM5705_REG_DTCD, fuelgauge->info.dtcd_value);
+
+	// RS write
+	sm5705_fg_i2c_write_word(client, SM5705_REG_AUTO_RS_MAN, fuelgauge->info.rs_value[0]);
+	pr_info("RS write RS = 0x%x : 0x%x\n", SM5705_REG_AUTO_RS_MAN, fuelgauge->info.rs_value[0]);
+
+	// VIT_PERIOD write
+	sm5705_fg_i2c_write_word(client, SM5705_REG_VIT_PERIOD, fuelgauge->info.vit_period);
+	pr_info("VIT_PERIOD write VIT_PERIOD = 0x%x : 0x%x\n", SM5705_REG_VIT_PERIOD, fuelgauge->info.vit_period);
+
+	// TABLE_LEN write & pram unlock
+	sm5705_fg_i2c_write_word(client, SM5705_REG_PARAM_CTRL, SM5705_FG_PARAM_UNLOCK_CODE | SM5705_FG_TABLE_LEN);
+
+#ifdef ENABLE_BATT_LONG_LIFE
+	i = get_v_max_index_by_cycle(client);
+	pr_info("%s: v_max_now is change %x -> %x \n", __func__, fuelgauge->info.v_max_now, fuelgauge->info.v_max_table[i]);
+	pr_info("%s: q_max_now is change %x -> %x \n", __func__, fuelgauge->info.q_max_now, fuelgauge->info.q_max_table[i]);
+	fuelgauge->info.v_max_now = fuelgauge->info.v_max_table[i];
+	fuelgauge->info.q_max_now = fuelgauge->info.q_max_table[i];
+#endif
+	for (i=TABLE_MAX-1; i >= 0; i--){
+		for(j=0; j <= SM5705_FG_TABLE_LEN; j++){
+#ifdef ENABLE_BATT_LONG_LIFE
+			if(i == Q_TABLE){
+				write_table[i][j] = fuelgauge->info.battery_table[i][j];
+				if(j == SM5705_FG_TABLE_LEN){
+					write_table[i][SM5705_FG_TABLE_LEN-1] = fuelgauge->info.q_max_now;
+					write_table[i][SM5705_FG_TABLE_LEN] = fuelgauge->info.q_max_now + (fuelgauge->info.q_max_now/1000);
+				}
+			}else{
+				write_table[i][j] = fuelgauge->info.battery_table[i][j];
+				if(j == SM5705_FG_TABLE_LEN-1){
+					write_table[i][SM5705_FG_TABLE_LEN-1] = fuelgauge->info.v_max_now;
+
+					if(write_table[i][SM5705_FG_TABLE_LEN-1] < write_table[i][SM5705_FG_TABLE_LEN-2]){
+						write_table[i][SM5705_FG_TABLE_LEN-2] = write_table[i][SM5705_FG_TABLE_LEN-1] - 0x18; // ~11.7mV
+						write_table[Q_TABLE][SM5705_FG_TABLE_LEN-2] = (write_table[Q_TABLE][SM5705_FG_TABLE_LEN-1]*99)/100;
+					}
+				}
+			}
+#else
+			write_table[i][j] = fuelgauge->info.battery_table[i][j];
+#endif
+		}
+	}
+
+	for (i=0; i < TABLE_MAX; i++){
+		table_reg = SM5705_REG_TABLE_START + (i<<4);
+		for(j=0; j <= SM5705_FG_TABLE_LEN; j++){
+			sm5705_fg_i2c_write_word(client, (table_reg + j), write_table[i][j]);
+			msleep(10);
+			if(write_table[i][j] != sm5705_fg_i2c_read_word(client, (table_reg + j))){
+				pr_info("%s: TABLE write FAIL retry[%d][%d] = 0x%x : 0x%x\n",
+						__func__, i, j, (table_reg + j), write_table[i][j]);
+				sm5705_fg_i2c_write_word(client, (table_reg + j), write_table[i][j]);
+			}
+			pr_info("%s: TABLE write OK [%d][%d] = 0x%x : 0x%x\n",
+					__func__, i, j, (table_reg + j), write_table[i][j]);
+		}
+	}
+
+	// MIX_MODE write
+	sm5705_fg_i2c_write_word(client, SM5705_REG_RS_MIX_FACTOR, fuelgauge->info.rs_value[2]);
+	sm5705_fg_i2c_write_word(client, SM5705_REG_RS_MAX, fuelgauge->info.rs_value[3]);
+	sm5705_fg_i2c_write_word(client, SM5705_REG_RS_MIN, fuelgauge->info.rs_value[4]);
+	sm5705_fg_i2c_write_word(client, SM5705_REG_MIX_RATE, fuelgauge->info.mix_value[0]);
+	sm5705_fg_i2c_write_word(client, SM5705_REG_MIX_INIT_BLANK, fuelgauge->info.mix_value[1]);
+
+	pr_info("RS_MIX_FACTOR = 0x%x, RS_MAX = 0x%x, RS_MIN = 0x%x, MIX_RATE = 0x%x, MIX_INIT_BLANK = 0x%x\n",
+		fuelgauge->info.rs_value[2], fuelgauge->info.rs_value[3], fuelgauge->info.rs_value[4],
+		fuelgauge->info.mix_value[0], fuelgauge->info.mix_value[1]);
+
+	// CAL write
+	sm5705_fg_i2c_write_word(client, SM5705_REG_VOLT_CAL, fuelgauge->info.volt_cal);
+	sm5705_fg_i2c_write_word(client, SM5705_REG_CURR_OFF, fuelgauge->info.curr_offset);
+	sm5705_fg_i2c_write_word(client, SM5705_REG_CURR_P_SLOPE, fuelgauge->info.p_curr_cal);
+	sm5705_fg_i2c_write_word(client, SM5705_REG_CURR_N_SLOPE, fuelgauge->info.n_curr_cal);
+	pr_info("VOLT_CAL = 0x%x, curr_offset = 0x%x, p_curr_cal = 0x%x, n_curr_cal = 0x%x\n",
+		fuelgauge->info.volt_cal, fuelgauge->info.curr_offset,
+		fuelgauge->info.p_curr_cal, fuelgauge->info.n_curr_cal);
+
+	// MISC write
+	sm5705_fg_i2c_write_word(client, SM5705_REG_MISC, fuelgauge->info.misc);
+	pr_info("SM5705_REG_MISC 0x%x : 0x%x\n", SM5705_REG_MISC, fuelgauge->info.misc);
+
+	// TOPOFF SOC
+	sm5705_fg_i2c_write_word(client, SM5705_REG_TOPOFFSOC, fuelgauge->info.topoff_soc);
+	pr_info("SM5705_REG_TOPOFFSOC 0x%x : 0x%x\n", SM5705_REG_TOPOFFSOC, fuelgauge->info.topoff_soc);
+
+	// INIT_last -  control register set
+	value = sm5705_fg_i2c_read_word(client, SM5705_REG_CNTL);
+	if(value == CNTL_REG_DEFAULT_VALUE)
+	{
+		value = fuelgauge->info.cntl_value;
+	}
+	value = ENABLE_MIX_MODE | ENABLE_TEMP_MEASURE | ENABLE_MANUAL_OCV | (fuelgauge->info.enable_topoff_soc << 13);
+	pr_info("SM5705_REG_CNTL reg : 0x%x\n", value);
+
+	ret = sm5705_fg_i2c_write_word(client, SM5705_REG_CNTL, value);
+	if (ret < 0)
+		pr_info("fail control register set(%d)\n",  ret);
+
+	pr_info("LAST SM5705_REG_CNTL = 0x%x : 0x%x\n", SM5705_REG_CNTL, value);
+
+	// LOCK
+	value = SM5705_FG_PARAM_LOCK_CODE | SM5705_FG_TABLE_LEN;
+	sm5705_fg_i2c_write_word(client, SM5705_REG_PARAM_CTRL, value);
+	pr_info("LAST PARAM CTRL VALUE = 0x%x : 0x%x\n", SM5705_REG_PARAM_CTRL, value);
+
+	// surge reset defence
+	if(is_surge)
+	{
+		value = ((fuelgauge->info.batt_ocv<<8)/125);
+	}
+	else
+	{
+		value = sm5705_calculate_iocv(client);
+
+		if((fuelgauge->info.volt_cal & 0x0080) == 0x0080)
+		{
+			value = value - (fuelgauge->info.volt_cal & 0x007F);
+		}
+		else
+		{
+			value = value + (fuelgauge->info.volt_cal & 0x007F);
+		}
+	}
+
+	sm5705_fg_i2c_write_word(client, SM5705_REG_IOCV_MAN, value);
+	pr_info("IOCV_MAN_WRITE = %d : 0x%x\n", fuelgauge->info.batt_ocv, value);
+
+	// init delay
+	msleep(20);
+
+	// write batt data version
+	value = (fuelgauge->info.data_ver << 4) & SM5705_BATTERY_VERSION;
+	sm5705_fg_i2c_write_word(client, SM5705_REG_RESERVED, value);
+	pr_info("RESERVED = %d : 0x%x\n", SM5705_REG_RESERVED, value);
+
+	pr_info("%s: init_MARK = %d : 0x%x\n", __func__, SM5705_REG_RESET, sm5705_fg_i2c_read_word(client, SM5705_REG_RESET));
+
+	return 1;
+}
+
+static bool sm5705_fg_init(struct i2c_client *client, bool is_surge)
+{
+	int ret;
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+
+	fuelgauge->info.is_FG_initialised = 0;
+	fuelgauge->info.iocv_error_count = 0;
+
+	//board_fuelgauge_init(fuelgauge);
+
+	//SM5705 i2c read check
+	ret = sm5705_get_device_id(client);
+	if (ret < 0)
+	{
+		pr_info("fail to do i2c read(%d)\n", ret);
+	}
+
+	if(fuelgauge->info.batt_ocv == 0)
+	{
+		sm5705_get_ocv(client);
+	}
+
+	ret = sm5705_fg_i2c_read_word(client, SM5705_REG_CNTL);
+	if(ret != CNTL_REG_DEFAULT_VALUE)
+	{
+		fuelgauge->info.cntl_value = ret;
+	}
+
+	sm5705_set_soc_cycle_cfg(client);
+
+#ifdef ENABLE_BATT_LONG_LIFE
+	fuelgauge->info.q_max_now = sm5705_fg_i2c_read_word(client, 0xBE);
+	pr_info("%s: q_max_now = 0x%x\n", __func__, fuelgauge->info.q_max_now);
+	fuelgauge->info.q_max_now = sm5705_fg_i2c_read_word(client, 0xBE);
+	pr_info("%s: q_max_now = 0x%x\n", __func__, fuelgauge->info.q_max_now);
+#endif
+
+	if(sm5705_fg_check_reg_init_need(client))
+	{
+		sm5705_fg_reg_init(client, is_surge);
+	}
+
+	// curr_off save and restore
+	if(fuelgauge->info.en_auto_curr_offset)
+	{
+		ret = sm5705_fg_i2c_read_word(client, SM5705_REG_CURR_OFF);
+		fuelgauge->info.curr_offset = ret;
+	}
+	else
+	{
+		sm5705_fg_i2c_write_word(client, SM5705_REG_CURR_OFF, fuelgauge->info.curr_offset);
+	}
+
+	// set lcal
+	if(fuelgauge->info.curr_lcal_en)
+	{
+		sm5705_fg_i2c_write_word(client, SM5705_REG_CURRLCAL_0, fuelgauge->info.curr_lcal_0);
+		sm5705_fg_i2c_write_word(client, SM5705_REG_CURRLCAL_1, fuelgauge->info.curr_lcal_1);
+		sm5705_fg_i2c_write_word(client, SM5705_REG_CURRLCAL_2, fuelgauge->info.curr_lcal_2);
+	}
+
+	// get first measure all value
+	//soc
+	sm5705_get_soc(client);
+	//vbat
+	sm5705_get_vbat(client);
+	//current
+	sm5705_get_curr(client);
+	//ocv
+	sm5705_get_ocv(client);
+	//temperature
+	sm5705_get_temperature(client);
+
+	//cycle
+	sm5705_get_soc_cycle(client);
+
+	pr_info("vbat=%d, vbat_avg=%d, curr=%d, curr_avg=%d, ocv=%d, temp=%d, "
+		"cycle=%d, soc=%d, state=0x%x, Q=0x%x\n",
+		fuelgauge->info.batt_voltage, fuelgauge->info.batt_avgvoltage,
+		fuelgauge->info.batt_current, fuelgauge->info.batt_avgcurrent, fuelgauge->info.batt_ocv,
+		fuelgauge->info.temp_fg, fuelgauge->info.batt_soc_cycle, fuelgauge->info.batt_soc,
+		sm5705_fg_i2c_read_word(client, SM5705_REG_OCV_STATE),
+		sm5705_fg_i2c_read_word(client, SM5705_REG_Q_EST));
+
+	// for debug
+	sm5705_fg_buffer_read(client);
+	sm5705_fg_test_read(client);
+
+	fuelgauge->info.is_FG_initialised = 1;
+
+	return true;
+}
+
+static int sm5705_abnormal_reset_check(struct i2c_client *client)
+{
+	int cntl_read, reset_read;
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+
+	reset_read = sm5705_fg_i2c_read_word(client, SM5705_REG_RESET) & 0xF000;
+	// abnormal case.... SW reset
+	if((sm5705_fg_check_reg_init_need(client) && (fuelgauge->info.is_FG_initialised == 1)) || (reset_read == 0))
+	{
+		cntl_read = sm5705_fg_i2c_read_word(client, SM5705_REG_CNTL);
+		pr_info("%s: SM5705 FG abnormal case!!!! SM5705_REG_CNTL : 0x%x, is_FG_initialised : %d, reset_read : 0x%x\n",
+			__func__, cntl_read, fuelgauge->info.is_FG_initialised, reset_read);
+		// SW reset code
+		if(sm5705_fg_i2c_verified_write_word(client, SM5705_REG_RESET, SW_RESET_OTP_CODE) < 0)
+		{
+			pr_info("Warning!!!! SM5705 FG abnormal case.... SW reset FAIL \n");
+		}
+		else
+		{
+			pr_info("SM5705 FG abnormal case.... SW reset OK\n");
+		}
+		// delay 100ms
+		msleep(100);
+		// init code
+		sm5705_fg_init(client, true);
+		return FG_ABNORMAL_RESET;
+	}
+	return 0;
+}
+
+#ifdef ENABLE_FULL_OFFSET
+void sm5705_adabt_full_offset(struct i2c_client *client)
+{
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+	int fg_temp_gap;
+	int full_offset, i_offset, sign_offset, curr;
+	int curr_off, sign_origin, i_origin;
+	int curr, sign_curr, i_curr;
+
+#ifdef SM5705_FG_FULL_DEBUG
+	pr_info("flag_charge_health=%d, flag_full_charge=%d\n", fuelgauge->info.flag_charge_health, fuelgauge->info.flag_full_charge);
+#endif
+	if(fuelgauge->info.flag_charge_health && fuelgauge->info.flag_full_charge)
+	{
+		fg_temp_gap = (fuelgauge->info.temp_fg/10) - fuelgauge->info.temp_std;
+		if(abs(fg_temp_gap) < 10)
+		{
+			curr = sm5705_fg_i2c_read_word(client, SM5705_REG_CURRENT);
+			sign_curr = curr & 0x8000;
+			i_curr = (curr & 0x7FFF)>>1;
+			if(sign_curr == 1)
+			{
+				i_curr = -i_curr;
+			}
+
+			curr_off = sm5705_fg_i2c_read_word(client, SM5705_REG_CURR_OFF);
+			sign_origin = curr_off & 0x0080;
+			i_origin = curr_off & 0x007F;
+			if(sign_origin == 1)
+			{
+				i_origin = -i_origin;
+			}
+
+			full_offset = i_origin - i_curr;
+			if(full_offset < 0)
+			{
+				i_offset = -full_offset;
+				sign_offset = 1;
+			}
+			else
+			{
+				i_offset = full_offset;
+				sign_offset = 0;
+			}
+
+			pr_info("curr=%x, curr_off=%x, i_offset=%x, sign_offset=%d, full_offset_margin=%x, full_extra_offset=%x\n",
+				curr, curr_off, i_offset, sign_offset, fuelgauge->info.full_offset_margin, fuelgauge->info.full_extra_offset);
+			if(i_offset < ((fuelgauge->info.full_offset_margin<<10)/1000))
+			{
+				if(sign_offset == 1)
+				{
+					i_offset = -i_offset;
+				}
+
+				i_offset = i_offset + ((fuelgauge->info.full_extra_offset<<10)/1000);
+
+				if(i_offset <= 0)
+				{
+					full_offset = -i_offset;
+				}
+				else
+				{
+					full_offset = i_offset|0x0080;
+				}
+				fuelgauge->info.curr_offset = full_offset;
+				sm5705_fg_i2c_write_word(client, SM5705_REG_CURR_OFF, full_offset);
+				pr_info("%s: LAST i_offset=%x, sign_offset=%x, full_offset=%x\n", __func__, i_offset, sign_offset, full_offset);
+			}
+
+		}
+
+	}
+
+	return;
+}
+#endif
+
+void sm5705_vbatocv_check(struct i2c_client *client)
+{
+	int ret;
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+
+	// iocv error case cover start
+#ifdef ABSOLUTE_ERROR_OCV_MATCH
+	if((abs(fuelgauge->info.batt_current)<40) ||
+		((fuelgauge->is_charging) && (fuelgauge->info.batt_current<(fuelgauge->info.top_off)) &&
+		(fuelgauge->info.batt_current>(fuelgauge->info.top_off/3))))
+#else
+	if(((!fuelgauge->ta_exist) && (fuelgauge->info.batt_current<0) && (fuelgauge->info.batt_current>-40)) ||
+		((fuelgauge->ta_exist) && (fuelgauge->info.batt_current>0) && (fuelgauge->info.batt_current<40)) ||
+		((fuelgauge->is_charging) && (fuelgauge->info.batt_current<(fuelgauge->info.top_off)) &&
+		(fuelgauge->info.batt_current>(fuelgauge->info.top_off/3))))
+#endif
+	{
+		if(abs(fuelgauge->info.batt_ocv-fuelgauge->info.batt_voltage)>30) // 30mV over
+		{
+			fuelgauge->info.iocv_error_count ++;
+		}
+
+		pr_info("sm5705 FG iocv_error_count (%d)\n", fuelgauge->info.iocv_error_count);
+
+		if(fuelgauge->info.iocv_error_count > 5) // prevent to overflow
+			fuelgauge->info.iocv_error_count = 6;
+	}
+	else
+	{
+		fuelgauge->info.iocv_error_count = 0;
+	}
+
+	if(fuelgauge->info.iocv_error_count > 5)
+	{
+		pr_info("p_v - v = (%d)\n", fuelgauge->info.p_batt_voltage - fuelgauge->info.batt_voltage);
+		if(abs(fuelgauge->info.p_batt_voltage - fuelgauge->info.batt_voltage)>15) // 15mV over
+		{
+			fuelgauge->info.iocv_error_count = 0;
+		}
+		else
+		{
+			// mode change to mix RS manual mode
+			pr_info("mode change to mix RS manual mode\n");
+			// run update set
+			sm5705_fg_i2c_write_word(client, SM5705_REG_PARAM_RUN_UPDATE, 1);
+			// RS manual value write
+			sm5705_fg_i2c_write_word(client, SM5705_REG_RS_MAN, fuelgauge->info.rs_value[0]);
+			// run update set
+			sm5705_fg_i2c_write_word(client, SM5705_REG_PARAM_RUN_UPDATE, 0);
+			// mode change
+			ret = sm5705_fg_i2c_read_word(client, SM5705_REG_CNTL);
+			ret = (ret | ENABLE_MIX_MODE) | ENABLE_RS_MAN_MODE; // +RS_MAN_MODE
+			sm5705_fg_i2c_write_word(client, SM5705_REG_CNTL, ret);
+		}
+	}
+	else
+	{
+		if((fuelgauge->info.temperature/10) > 15)
+		{
+			if((fuelgauge->info.p_batt_voltage < fuelgauge->info.n_tem_poff) &&
+				(fuelgauge->info.batt_voltage < fuelgauge->info.n_tem_poff) && (!fuelgauge->is_charging))
+			{
+				pr_info("mode change to normal tem mix RS manual mode\n");
+				// mode change to mix RS manual mode
+				// run update init
+				sm5705_fg_i2c_write_word(client, SM5705_REG_PARAM_RUN_UPDATE, 1);
+				// RS manual value write
+				if((fuelgauge->info.p_batt_voltage <
+					(fuelgauge->info.n_tem_poff - fuelgauge->info.n_tem_poff_offset)) &&
+					(fuelgauge->info.batt_voltage <
+					(fuelgauge->info.n_tem_poff - fuelgauge->info.n_tem_poff_offset)))
+				{
+					sm5705_fg_i2c_write_word(client, SM5705_REG_RS_MAN, fuelgauge->info.rs_value[0]>>1);
+				}
+				else
+				{
+					sm5705_fg_i2c_write_word(client, SM5705_REG_RS_MAN, fuelgauge->info.rs_value[0]);
+				}
+				// run update set
+				sm5705_fg_i2c_write_word(client, SM5705_REG_PARAM_RUN_UPDATE, 0);
+
+				// mode change
+				ret = sm5705_fg_i2c_read_word(client, SM5705_REG_CNTL);
+				ret = (ret | ENABLE_MIX_MODE) | ENABLE_RS_MAN_MODE; // +RS_MAN_MODE
+				sm5705_fg_i2c_write_word(client, SM5705_REG_CNTL, ret);
+			}
+			else
+			{
+				pr_info("mode change to mix RS auto mode\n");
+
+				// mode change to mix RS auto mode
+				ret = sm5705_fg_i2c_read_word(client, SM5705_REG_CNTL);
+				ret = (ret | ENABLE_MIX_MODE) & ~ENABLE_RS_MAN_MODE; // -RS_MAN_MODE
+				sm5705_fg_i2c_write_word(client, SM5705_REG_CNTL, ret);
+			}
+		}
+		else
+		{
+			if((fuelgauge->info.p_batt_voltage < fuelgauge->info.l_tem_poff) &&
+				(fuelgauge->info.batt_voltage < fuelgauge->info.l_tem_poff) && (!fuelgauge->is_charging))
+			{
+				pr_info("mode change to normal tem mix RS manual mode\n");
+				// mode change to mix RS manual mode
+				// run update init
+				sm5705_fg_i2c_write_word(client, SM5705_REG_PARAM_RUN_UPDATE, 1);
+				// RS manual value write
+				if((fuelgauge->info.p_batt_voltage <
+					(fuelgauge->info.l_tem_poff - fuelgauge->info.l_tem_poff_offset)) &&
+					(fuelgauge->info.batt_voltage <
+					(fuelgauge->info.l_tem_poff - fuelgauge->info.l_tem_poff_offset)))
+				{
+					sm5705_fg_i2c_write_word(client, SM5705_REG_RS_MAN, fuelgauge->info.rs_value[0]>>1);
+				}
+				else
+				{
+					sm5705_fg_i2c_write_word(client, SM5705_REG_RS_MAN, fuelgauge->info.rs_value[0]);
+				}
+				// run update set
+				sm5705_fg_i2c_write_word(client, SM5705_REG_PARAM_RUN_UPDATE, 0);
+
+				// mode change
+				ret = sm5705_fg_i2c_read_word(client, SM5705_REG_CNTL);
+				ret = (ret | ENABLE_MIX_MODE) | ENABLE_RS_MAN_MODE; // +RS_MAN_MODE
+				sm5705_fg_i2c_write_word(client, SM5705_REG_CNTL, ret);
+			}
+			else
+			{
+				pr_info("mode change to mix RS auto mode\n");
+
+				// mode change to mix RS auto mode
+				ret = sm5705_fg_i2c_read_word(client, SM5705_REG_CNTL);
+				ret = (ret | ENABLE_MIX_MODE) & ~ENABLE_RS_MAN_MODE; // -RS_MAN_MODE
+				sm5705_fg_i2c_write_word(client, SM5705_REG_CNTL, ret);
+			}
+		}
+	}
+	fuelgauge->info.p_batt_voltage = fuelgauge->info.batt_voltage;
+	fuelgauge->info.p_batt_current = fuelgauge->info.batt_current;
+	// iocv error case cover end
+}
+
+static int sm5705_cal_carc (struct i2c_client *client)
+{
+	int p_curr_cal=0, n_curr_cal=0, p_delta_cal=0, n_delta_cal=0, p_fg_delta_cal=0, n_fg_delta_cal=0, temp_curr_offset=0;
+	int volt_cal=0, fg_delta_volcal=0, pn_volt_slope=0, volt_offset=0;
+	int temp_gap, fg_temp_gap, mix_factor=0;
+
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+
+	sm5705_vbatocv_check(client);
+
+#ifdef ENABLE_FULL_OFFSET
+	sm5705_adabt_full_offset(client);
+#endif
+
+	if(fuelgauge->is_charging || (fuelgauge->info.batt_current < LIMIT_N_CURR_MIXFACTOR))
+	{
+		mix_factor = fuelgauge->info.rs_value[1];
+	}
+	else
+	{
+		mix_factor = fuelgauge->info.rs_value[2];
+	}
+	sm5705_fg_i2c_write_word(client, SM5705_REG_RS_MIX_FACTOR, mix_factor);
+
+	fg_temp_gap = (fuelgauge->info.temp_fg/10) - fuelgauge->info.temp_std;
+
+	volt_cal = sm5705_fg_i2c_read_word(client, SM5705_REG_VOLT_CAL);
+	volt_offset = volt_cal & 0x00FF;
+	pn_volt_slope = fuelgauge->info.volt_cal & 0xFF00;
+
+	if (fuelgauge->info.en_fg_temp_volcal)
+	{
+		fg_delta_volcal = (fg_temp_gap / fuelgauge->info.fg_temp_volcal_denom)*fuelgauge->info.fg_temp_volcal_fact;
+		pn_volt_slope = pn_volt_slope + (fg_delta_volcal<<8);
+		volt_cal = pn_volt_slope | volt_offset;
+		sm5705_fg_i2c_write_word(client, SM5705_REG_VOLT_CAL, volt_cal);
+	}
+
+	temp_curr_offset = fuelgauge->info.curr_offset;
+	if(fuelgauge->info.en_high_fg_temp_offset && (fg_temp_gap > 0))
+	{
+		if(temp_curr_offset & 0x0080)
+		{
+			temp_curr_offset = -(temp_curr_offset & 0x007F);
+		}
+		temp_curr_offset = temp_curr_offset + (fg_temp_gap / fuelgauge->info.high_fg_temp_offset_denom)*fuelgauge->info.high_fg_temp_offset_fact;
+		if(temp_curr_offset < 0)
+		{
+			temp_curr_offset = -temp_curr_offset;
+			temp_curr_offset = temp_curr_offset|0x0080;
+		}
+	}
+	else if (fuelgauge->info.en_low_fg_temp_offset && (fg_temp_gap < 0))
+	{
+		if(temp_curr_offset & 0x0080)
+		{
+			temp_curr_offset = -(temp_curr_offset & 0x007F);
+		}
+		temp_curr_offset = temp_curr_offset + ((-fg_temp_gap) / fuelgauge->info.low_fg_temp_offset_denom)*fuelgauge->info.low_fg_temp_offset_fact;
+		if(temp_curr_offset < 0)
+		{
+			temp_curr_offset = -temp_curr_offset;
+			temp_curr_offset = temp_curr_offset|0x0080;
+		}
+	}
+	sm5705_fg_i2c_write_word(client, SM5705_REG_CURR_OFF, temp_curr_offset);
+
+
+	n_curr_cal = fuelgauge->info.n_curr_cal;
+	p_curr_cal = fuelgauge->info.p_curr_cal;
+
+	if (fuelgauge->info.en_high_fg_temp_cal && (fg_temp_gap > 0))
+	{
+		p_fg_delta_cal = (fg_temp_gap / fuelgauge->info.high_fg_temp_p_cal_denom)*fuelgauge->info.high_fg_temp_p_cal_fact;
+		n_fg_delta_cal = (fg_temp_gap / fuelgauge->info.high_fg_temp_n_cal_denom)*fuelgauge->info.high_fg_temp_n_cal_fact;
+	}
+	else if (fuelgauge->info.en_low_fg_temp_cal && (fg_temp_gap < 0))
+	{
+		fg_temp_gap = -fg_temp_gap;
+		p_fg_delta_cal = (fg_temp_gap / fuelgauge->info.low_fg_temp_p_cal_denom)*fuelgauge->info.low_fg_temp_p_cal_fact;
+		n_fg_delta_cal = (fg_temp_gap / fuelgauge->info.low_fg_temp_n_cal_denom)*fuelgauge->info.low_fg_temp_n_cal_fact;
+	}
+	p_curr_cal = p_curr_cal + (p_fg_delta_cal);
+	n_curr_cal = n_curr_cal + (n_fg_delta_cal);
+
+	pr_info("<%d %d %d %d %d %d %d %d %d %d>, temp_fg = %d ,p_curr_cal = 0x%x, n_curr_cal = 0x%x, "
+		"curr_offset = 0x%x, volt_cal = 0x%x ,fg_delta_volcal = 0x%x\n",
+		fuelgauge->info.en_high_fg_temp_cal,
+		fuelgauge->info.high_fg_temp_p_cal_denom, fuelgauge->info.high_fg_temp_p_cal_fact, 
+		fuelgauge->info.high_fg_temp_n_cal_denom, fuelgauge->info.high_fg_temp_n_cal_fact,
+		fuelgauge->info.en_low_fg_temp_cal, 
+		fuelgauge->info.low_fg_temp_p_cal_denom, fuelgauge->info.low_fg_temp_p_cal_fact, 
+		fuelgauge->info.low_fg_temp_n_cal_denom, fuelgauge->info.low_fg_temp_n_cal_fact,
+		fuelgauge->info.temp_fg, p_curr_cal, n_curr_cal, temp_curr_offset,
+		volt_cal, fg_delta_volcal);
+
+	temp_gap = (fuelgauge->info.temperature/10) - fuelgauge->info.temp_std;
+	if (fuelgauge->info.en_high_temp_cal && (temp_gap > 0))
+	{
+		p_delta_cal = (temp_gap / fuelgauge->info.high_temp_p_cal_denom)*fuelgauge->info.high_temp_p_cal_fact;
+		n_delta_cal = (temp_gap / fuelgauge->info.high_temp_n_cal_denom)*fuelgauge->info.high_temp_n_cal_fact;
+	}
+	else if (fuelgauge->info.en_low_temp_cal && (temp_gap < 0))
+	{
+		temp_gap = -temp_gap;
+		p_delta_cal = (temp_gap / fuelgauge->info.low_temp_p_cal_denom)*fuelgauge->info.low_temp_p_cal_fact;
+		n_delta_cal = (temp_gap / fuelgauge->info.low_temp_n_cal_denom)*fuelgauge->info.low_temp_n_cal_fact;
+	}
+	p_curr_cal = p_curr_cal + (p_delta_cal);
+	n_curr_cal = n_curr_cal + (n_delta_cal);
+
+	sm5705_fg_i2c_write_word(client, SM5705_REG_CURR_P_SLOPE, p_curr_cal);
+	sm5705_fg_i2c_write_word(client, SM5705_REG_CURR_N_SLOPE, n_curr_cal);
+
+	pr_info("<%d %d %d %d %d %d %d %d %d %d>, "
+		"p_curr_cal = 0x%x, n_curr_cal = 0x%x, mix_factor=0x%x ,batt_temp = %d\n",
+		fuelgauge->info.en_high_temp_cal,
+		fuelgauge->info.high_temp_p_cal_denom, fuelgauge->info.high_temp_p_cal_fact,
+		fuelgauge->info.high_temp_n_cal_denom, fuelgauge->info.high_temp_n_cal_fact,
+		fuelgauge->info.en_low_temp_cal,
+		fuelgauge->info.low_temp_p_cal_denom, fuelgauge->info.low_temp_p_cal_fact,
+		fuelgauge->info.low_temp_n_cal_denom, fuelgauge->info.low_temp_n_cal_fact,
+		p_curr_cal, n_curr_cal, mix_factor, fuelgauge->info.temperature);
+
+	return 0;
+}
+
+static int sm5705_get_all_value(struct i2c_client *client)
+{
+	union power_supply_propval value;
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+
+	// check charging.
+	value.intval = POWER_SUPPLY_HEALTH_UNKNOWN;
+	psy_do_property("sm5705-charger", get,
+			POWER_SUPPLY_PROP_HEALTH, value);
+#ifdef SM5705_FG_FULL_DEBUG
+	pr_info("get POWER_SUPPLY_PROP_HEALTH = 0x%x\n", value.intval);
+#endif
+	fuelgauge->info.flag_charge_health =
+		(value.intval == POWER_SUPPLY_HEALTH_GOOD) ? 1 : 0;
+
+	fuelgauge->is_charging = (fuelgauge->info.flag_charge_health |
+		fuelgauge->ta_exist) && (fuelgauge->info.batt_current >= 30);
+
+	// check charger status
+	psy_do_property("sm5705-charger", get,
+			POWER_SUPPLY_PROP_STATUS, value);
+	fuelgauge->info.flag_full_charge =
+		(value.intval == POWER_SUPPLY_STATUS_FULL) ? 1 : 0;
+	fuelgauge->info.flag_chg_status =
+		(value.intval == POWER_SUPPLY_STATUS_CHARGING) ? 1 : 0;
+
+	//vbat
+	sm5705_get_vbat(client);
+	//current
+	sm5705_get_curr(client);
+	//ocv
+	sm5705_get_ocv(client);
+	//temperature
+	sm5705_get_temperature(client);
+	//cycle
+	sm5705_get_soc_cycle(client);
+
+	//carc
+	sm5705_cal_carc(client);
+	//soc
+	sm5705_get_soc(client);
+
+	sm5705_fg_test_read(client);
+
+	pr_info("chg_h=%d, chg_f=%d, chg_s=%d, is_chg=%d, ta_exist=%d, "
+		"v=%d, v_avg=%d, i=%d, i_avg=%d, ocv=%d, fg_t=%d, b_t=%d, cycle=%d, soc=%d, state=0x%x\n",
+		fuelgauge->info.flag_charge_health, fuelgauge->info.flag_full_charge,
+		fuelgauge->info.flag_chg_status, fuelgauge->is_charging, fuelgauge->ta_exist,
+		fuelgauge->info.batt_voltage, fuelgauge->info.batt_avgvoltage,
+		fuelgauge->info.batt_current, fuelgauge->info.batt_avgcurrent, fuelgauge->info.batt_ocv,
+		fuelgauge->info.temp_fg, fuelgauge->info.temperature, fuelgauge->info.batt_soc_cycle,
+		fuelgauge->info.batt_soc, sm5705_fg_i2c_read_word(client, SM5705_REG_OCV_STATE));
+
+    return 0;
+}
+
+static int sm5705_fg_get_jig_mode_real_vbat(struct i2c_client *client)
+{
+	int cntl, ret;
+
+	cntl = sm5705_fg_i2c_read_word(client, SM5705_REG_CNTL);
+	pr_info("%s: start, CNTL=0x%x\n", __func__, cntl);
+
+	if(sm5705_fg_check_reg_init_need(client))
+	{
+		return -1;
+	}
+
+	cntl = cntl | ENABLE_MODE_nENQ4;
+	sm5705_fg_i2c_write_word(client, SM5705_REG_CNTL, cntl);
+
+	msleep(300);
+
+	ret = sm5705_get_vbat(client);
+	pr_info("%s: jig mode real batt V = %d, CNTL=0x%x\n", __func__, ret, cntl);
+
+	cntl = sm5705_fg_i2c_read_word(client, SM5705_REG_CNTL);
+	cntl = cntl & (~ENABLE_MODE_nENQ4);
+	sm5705_fg_i2c_write_word(client, SM5705_REG_CNTL, cntl);
+
+	pr_info("%s: end_1, CNTL=0x%x\n", __func__, cntl);
+	msleep(300);
+
+	cntl = sm5705_fg_i2c_read_word(client, SM5705_REG_CNTL);
+	cntl = cntl & (~ENABLE_MODE_nENQ4);
+	sm5705_fg_i2c_write_word(client, SM5705_REG_CNTL, cntl);
+
+	pr_info("%s: end_2, CNTL=0x%x\n", __func__, cntl);
+
+	return ret;
+}
+
+#ifdef CONFIG_OF
+static int get_battery_id(struct sec_fuelgauge_info *fuelgauge)
+{
+	// sm5705fg does not support this function
+	return 0;
+}
+#define PROPERTY_NAME_SIZE 128
+
+#define PINFO(format, args...) \
+	printk(KERN_INFO "%s() line-%d: " format, \
+		__func__, __LINE__, ## args)
+
+#define DECL_PARAM_PROP(_id, _name) {.id = _id, .name = _name,}
+
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+static int temp_parse_dt(struct sec_fuelgauge_info *fuelgauge)
+{
+	struct device_node *np = of_find_node_by_name(NULL, "battery");
+	int len=0, ret;
+	const u32 *p;
+
+	if (np == NULL) {
+		pr_err("%s np NULL\n", __func__);
+	} else {
+		p = of_get_property(np, "battery,age_data", &len);
+		if (p) {
+			fuelgauge->pdata->num_age_step = len / sizeof(sec_age_data_t);
+			fuelgauge->pdata->age_data = kzalloc(len, GFP_KERNEL);
+			ret = of_property_read_u32_array(np, "battery,age_data",
+					(u32 *)fuelgauge->pdata->age_data, len/sizeof(u32));
+			if (ret) {
+				pr_err("%s failed to read battery->pdata->age_data: %d\n",
+						__func__, ret);
+				kfree(fuelgauge->pdata->age_data);
+				fuelgauge->pdata->age_data = NULL;
+				fuelgauge->pdata->num_age_step = 0;
+			}
+			pr_info("%s num_age_step : %d\n", __func__, fuelgauge->pdata->num_age_step);
+			for (len = 0; len < fuelgauge->pdata->num_age_step; ++len) {
+				pr_info("[%d/%d]cycle:%d, float:%d, full_v:%d, recharge_v:%d, soc:%d\n",
+						len, fuelgauge->pdata->num_age_step-1,
+						fuelgauge->pdata->age_data[len].cycle,
+						fuelgauge->pdata->age_data[len].float_voltage,
+						fuelgauge->pdata->age_data[len].full_condition_vcell,
+						fuelgauge->pdata->age_data[len].recharge_condition_vcell,
+						fuelgauge->pdata->age_data[len].full_condition_soc);
+			}
+		} else {
+			fuelgauge->pdata->num_age_step = 0;
+			pr_err("%s there is not age_data\n", __func__);
+		}
+	}
+	return 0;
+}
+#endif
+
+static int sm5705_fg_parse_dt(struct sec_fuelgauge_info *fuelgauge)
+{
+	char prop_name[PROPERTY_NAME_SIZE];
+	int battery_id = -1;
+#ifdef ENABLE_BATT_LONG_LIFE
+	int v_max_table[5];
+	int q_max_table[5];
+#endif
+	int table[16];
+	int rce_value[3];
+	int rs_value[5];
+	int mix_value[2];
+	int topoff_soc[3];
+	int cycle_cfg[3];
+	int v_offset_cancel[4];
+	int temp_volcal[3];
+	int temp_offset[6];
+	int temp_cal[10];
+	int ext_temp_cal[10];
+	int set_temp_poff[4];
+	int curr_offset[2];
+	int curr_lcal[4];
+#ifdef ENABLE_FULL_OFFSET
+	int full_offset[2];	
+#endif
+
+	int ret;
+	int i, j;
+
+	struct device_node *np = of_find_node_by_name(NULL, "sm5705-fuelgauge");
+
+	/* reset, irq gpio info */
+	if (np == NULL) {
+		pr_err("np NULL\n");
+	} else {
+		ret = of_get_named_gpio(np, "fuelgauge,fuel_int", 0);
+		if (ret > 0) {
+			fuelgauge->pdata->fg_irq = ret;
+			pr_info("reading fg_irq = %d\n", ret);
+		}
+
+		ret = of_get_named_gpio(np, "fuelgauge,bat_int", 0);
+		if (ret > 0) {
+			fuelgauge->pdata->bat_irq_gpio = ret;
+			fuelgauge->pdata->bat_irq = gpio_to_irq(ret);
+			pr_info("reading bat_int_gpio = %d\n", ret);
+		}
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_max",
+				&fuelgauge->pdata->capacity_max);
+		if (ret < 0)
+			pr_err("error reading capacity_max %d\n", ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_max_margin",
+				&fuelgauge->pdata->capacity_max_margin);
+		if (ret < 0)
+			pr_err("error reading capacity_max_margin %d\n", ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_min",
+				&fuelgauge->pdata->capacity_min);
+		if (ret < 0)
+			pr_err("error reading capacity_min %d\n", ret);
+
+		pr_info("capacity_max: %d, "
+				"capacity_max_margin: 0x%x, "
+				"capacity_min: %d\n", fuelgauge->pdata->capacity_max,
+				fuelgauge->pdata->capacity_max_margin,
+				fuelgauge->pdata->capacity_min);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_calculation_type",
+				&fuelgauge->pdata->capacity_calculation_type);
+		if (ret < 0)
+			pr_err("error reading capacity_calculation_type %d\n", ret);
+		ret = of_property_read_u32(np, "fuelgauge,fuel_alert_soc",
+				&fuelgauge->pdata->fuel_alert_soc);
+		if (ret < 0)
+			pr_err("error reading pdata->fuel_alert_soc %d\n", ret);
+		fuelgauge->pdata->repeated_fuelalert = of_property_read_bool(np,
+				"fuelgaguge,repeated_fuelalert");
+
+		pr_info("fg_irq: %d, "
+				"calculation_type: 0x%x, fuel_alert_soc: %d,\n"
+				"repeated_fuelalert: %d\n", fuelgauge->pdata->fg_irq,
+				fuelgauge->pdata->capacity_calculation_type,
+				fuelgauge->pdata->fuel_alert_soc, fuelgauge->pdata->repeated_fuelalert);
+	}
+
+	// get battery_params node
+	np = of_find_node_by_name(of_node_get(np), "battery_params");
+	if (np == NULL) {
+		PINFO("Cannot find child node \"battery_params\"\n");
+		return -EINVAL;
+	}
+
+	// get battery_id
+	if (of_property_read_u32(np, "battery,id", &battery_id) < 0)
+		PINFO("not battery,id property\n");
+	if (battery_id == -1)
+		battery_id = get_battery_id(fuelgauge);
+	PINFO("battery id = %d\n", battery_id);
+
+#ifdef ENABLE_BATT_LONG_LIFE
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "v_max_table");
+	ret = of_property_read_u32_array(np, prop_name, v_max_table, fuelgauge->pdata->num_age_step);
+
+	if(ret < 0){
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+
+		for (i = 0; i < fuelgauge->pdata->num_age_step; i++){
+			fuelgauge->info.v_max_table[i] = fuelgauge->info.battery_table[DISCHARGE_TABLE][SM5705_FG_TABLE_LEN-1];
+			PINFO("%s = <v_max_table[%d] 0x%x>\n", prop_name, i, fuelgauge->info.v_max_table[i]);
+		}
+	}else{
+		for (i = 0; i < fuelgauge->pdata->num_age_step; i++){
+			fuelgauge->info.v_max_table[i] = v_max_table[i];
+			PINFO("%s = <v_max_table[%d] 0x%x>\n", prop_name, i, fuelgauge->info.v_max_table[i]);
+		}
+	}
+
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "q_max_table");
+	ret = of_property_read_u32_array(np, prop_name, q_max_table, fuelgauge->pdata->num_age_step);
+
+	if(ret < 0){
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+
+		for (i = 0; i < fuelgauge->pdata->num_age_step; i++){
+			fuelgauge->info.q_max_table[i] = 100;
+			PINFO("%s = <q_max_table[%d] %d>\n", prop_name, i, fuelgauge->info.q_max_table[i]);
+		}
+	}else{
+		for (i = 0; i < fuelgauge->pdata->num_age_step; i++){
+			fuelgauge->info.q_max_table[i] = q_max_table[i];
+			PINFO("%s = <q_max_table[%d] %d>\n", prop_name, i, fuelgauge->info.q_max_table[i]);
+		}
+	}
+	fuelgauge->chg_full_soc = fuelgauge->pdata->age_data[0].full_condition_soc;
+	fuelgauge->info.v_max_now = fuelgauge->info.v_max_table[0];
+	fuelgauge->info.q_max_now = fuelgauge->info.q_max_table[0];
+	PINFO("%s = <v_max_now = 0x%x>, <q_max_now = 0x%x>, <chg_full_soc = %d>\n", prop_name, fuelgauge->info.v_max_now, fuelgauge->info.q_max_now, fuelgauge->chg_full_soc);
+#endif
+
+	// get battery_table
+	for (i = DISCHARGE_TABLE; i < TABLE_MAX; i++) {
+		snprintf(prop_name, PROPERTY_NAME_SIZE,
+			 "battery%d,%s%d", battery_id, "battery_table", i);
+
+		ret = of_property_read_u32_array(np, prop_name, table, 16);
+		if (ret < 0) {
+			PINFO("Can get prop %s (%d)\n", prop_name, ret);
+		}
+		for (j = 0; j <= SM5705_FG_TABLE_LEN; j++)
+		{
+			fuelgauge->info.battery_table[i][j] = table[j];
+			PINFO("%s = <table[%d][%d] 0x%x>\n", prop_name, i, j, table[j]);
+		}
+	}
+
+	// get rce
+	for (i = 0; i < 3; i++) {
+		snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "rce_value");
+		ret = of_property_read_u32_array(np, prop_name, rce_value, 3);
+		if (ret < 0) {
+			PINFO("Can get prop %s (%d)\n", prop_name, ret);
+		}
+        fuelgauge->info.rce_value[i] = rce_value[i];
+	}
+	PINFO("%s = <0x%x 0x%x 0x%x>\n", prop_name, rce_value[0], rce_value[1], rce_value[2]);
+
+	// get dtcd_value
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "dtcd_value");
+	ret = of_property_read_u32_array(np, prop_name, &fuelgauge->info.dtcd_value, 1);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	PINFO("%s = <0x%x>\n",prop_name, fuelgauge->info.dtcd_value);
+
+	// get rs_value
+	for (i = 0; i < 5; i++) {
+		snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "rs_value");
+		ret = of_property_read_u32_array(np, prop_name, rs_value, 5);
+		if (ret < 0) {
+			PINFO("Can get prop %s (%d)\n", prop_name, ret);
+		}
+        fuelgauge->info.rs_value[i] = rs_value[i];
+	}
+	PINFO("%s = <0x%x 0x%x 0x%x 0x%x 0x%x>\n", prop_name, rs_value[0], rs_value[1], rs_value[2], rs_value[3], rs_value[4]);
+
+	// get vit_period
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "vit_period");
+	ret = of_property_read_u32_array(np, prop_name, &fuelgauge->info.vit_period, 1);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	PINFO("%s = <0x%x>\n",prop_name, fuelgauge->info.vit_period);
+
+	// get mix_value
+	for (i = 0; i < 2; i++) {
+		snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "mix_value");
+		ret = of_property_read_u32_array(np, prop_name, mix_value, 2);
+		if (ret < 0) {
+			PINFO("Can get prop %s (%d)\n", prop_name, ret);
+		}
+        fuelgauge->info.mix_value[i] = mix_value[i];
+	}
+	PINFO("%s = <0x%x 0x%x>\n", prop_name, mix_value[0], mix_value[1]);
+
+	// battery_type
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "battery_type");
+	ret = of_property_read_u32_array(np, prop_name, &fuelgauge->info.battery_type, 1);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	PINFO("%s = <%d>\n", prop_name, fuelgauge->info.battery_type);
+
+	// MISC
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "misc");
+	ret = of_property_read_u32_array(np, prop_name, &fuelgauge->info.misc, 1);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	PINFO("%s = <0x%x>\n", prop_name, fuelgauge->info.misc);
+
+	// V_ALARM
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "v_alarm");
+	ret = of_property_read_u32_array(np, prop_name, &fuelgauge->info.value_v_alarm, 1);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	PINFO("%s = <%d>\n", prop_name, fuelgauge->info.value_v_alarm);
+
+	// TOP OFF SOC
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "topoff_soc");
+	ret = of_property_read_u32_array(np, prop_name, topoff_soc, 3);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	fuelgauge->info.enable_topoff_soc = topoff_soc[0];
+	fuelgauge->info.topoff_soc = topoff_soc[1];
+	fuelgauge->info.top_off = topoff_soc[2];
+
+	PINFO("%s = <%d %d %d>\n", prop_name,
+		fuelgauge->info.enable_topoff_soc, fuelgauge->info.topoff_soc, fuelgauge->info.top_off);
+
+	// SOC cycle cfg
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "cycle_cfg");
+	ret = of_property_read_u32_array(np, prop_name, cycle_cfg, 3);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	fuelgauge->info.cycle_high_limit = cycle_cfg[0];
+	fuelgauge->info.cycle_low_limit = cycle_cfg[1];
+	fuelgauge->info.cycle_limit_cntl = cycle_cfg[2];
+
+	PINFO("%s = <%d %d %d>\n", prop_name,
+		fuelgauge->info.cycle_high_limit, fuelgauge->info.cycle_low_limit, fuelgauge->info.cycle_limit_cntl);
+
+	// v_offset_cancel
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "v_offset_cancel");
+	ret = of_property_read_u32_array(np, prop_name, v_offset_cancel, 4);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	fuelgauge->info.enable_v_offset_cancel_p = v_offset_cancel[0];
+	fuelgauge->info.enable_v_offset_cancel_n = v_offset_cancel[1];
+	fuelgauge->info.v_offset_cancel_level = v_offset_cancel[2];
+	fuelgauge->info.v_offset_cancel_mohm = v_offset_cancel[3];
+
+	PINFO("%s = <%d %d %d %d>\n", prop_name,
+		fuelgauge->info.enable_v_offset_cancel_p, fuelgauge->info.enable_v_offset_cancel_n,
+		fuelgauge->info.v_offset_cancel_level, fuelgauge->info.v_offset_cancel_mohm);
+
+	// VOL & CURR CAL
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "volt_cal");
+	ret = of_property_read_u32_array(np, prop_name, &fuelgauge->info.volt_cal, 1);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	PINFO("%s = <0x%x>\n", prop_name, fuelgauge->info.volt_cal);
+
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "curr_offset");
+	ret = of_property_read_u32_array(np, prop_name, curr_offset, 2);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	fuelgauge->info.en_auto_curr_offset = curr_offset[0];
+	fuelgauge->info.curr_offset = curr_offset[1];
+
+	PINFO("%s = <%d 0x%x>\n", prop_name, fuelgauge->info.en_auto_curr_offset, fuelgauge->info.curr_offset);
+
+#ifdef ENABLE_FULL_OFFSET
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "full_offset");
+	ret = of_property_read_u32_array(np, prop_name, full_offset, 2);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	fuelgauge->info.full_offset_margin = full_offset[0];
+	fuelgauge->info.full_extra_offset = full_offset[1];
+
+	PINFO("%s = <%d %d>\n", prop_name, fuelgauge->info.full_offset_margin, fuelgauge->info.full_extra_offset);	
+#endif
+
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "p_curr_cal");
+	ret = of_property_read_u32_array(np, prop_name, &fuelgauge->info.p_curr_cal, 1);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	PINFO("%s = <0x%x>\n", prop_name, fuelgauge->info.p_curr_cal);
+
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "n_curr_cal");
+	ret = of_property_read_u32_array(np, prop_name, &fuelgauge->info.n_curr_cal, 1);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	PINFO("%s = <0x%x>\n", prop_name, fuelgauge->info.n_curr_cal);
+
+	// curr_lcal
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "curr_lcal");
+	ret = of_property_read_u32_array(np, prop_name, curr_lcal, 4);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	fuelgauge->info.curr_lcal_en = curr_lcal[0];
+	fuelgauge->info.curr_lcal_0 = curr_lcal[1];
+	fuelgauge->info.curr_lcal_1 = curr_lcal[2];
+	fuelgauge->info.curr_lcal_2 = curr_lcal[3];
+	PINFO("%s = <%d, 0x%x, 0x%x, 0x%x>\n", prop_name,
+		fuelgauge->info.curr_lcal_en, fuelgauge->info.curr_lcal_0, fuelgauge->info.curr_lcal_1, fuelgauge->info.curr_lcal_2);
+
+	// temp_std
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "temp_std");
+	ret = of_property_read_u32_array(np, prop_name, &fuelgauge->info.temp_std, 1);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	PINFO("%s = <%d>\n", prop_name, fuelgauge->info.temp_std);
+
+	// temp_volcal
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "temp_volcal");
+	ret = of_property_read_u32_array(np, prop_name, temp_volcal, 3);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	fuelgauge->info.en_fg_temp_volcal = temp_volcal[0];
+	fuelgauge->info.fg_temp_volcal_denom = temp_volcal[1];
+	fuelgauge->info.fg_temp_volcal_fact = temp_volcal[2];
+	PINFO("%s = <%d, %d, %d>\n", prop_name,
+		fuelgauge->info.en_fg_temp_volcal, fuelgauge->info.fg_temp_volcal_denom, fuelgauge->info.fg_temp_volcal_fact);
+
+	// temp_offset
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "temp_offset");
+	ret = of_property_read_u32_array(np, prop_name, temp_offset, 6);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	fuelgauge->info.en_high_fg_temp_offset = temp_offset[0];
+	fuelgauge->info.high_fg_temp_offset_denom = temp_offset[1];
+	fuelgauge->info.high_fg_temp_offset_fact = temp_offset[2];
+	fuelgauge->info.en_low_fg_temp_offset = temp_offset[3];
+	fuelgauge->info.low_fg_temp_offset_denom = temp_offset[4];
+	fuelgauge->info.low_fg_temp_offset_fact = temp_offset[5];
+	PINFO("%s = <%d, %d, %d, %d, %d, %d>\n", prop_name,
+		fuelgauge->info.en_high_fg_temp_offset,
+		fuelgauge->info.high_fg_temp_offset_denom, fuelgauge->info.high_fg_temp_offset_fact,
+		fuelgauge->info.en_low_fg_temp_offset,
+		fuelgauge->info.low_fg_temp_offset_denom, fuelgauge->info.low_fg_temp_offset_fact);
+
+	// temp_calc
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "temp_cal");
+	ret = of_property_read_u32_array(np, prop_name, temp_cal, 10);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	fuelgauge->info.en_high_fg_temp_cal = temp_cal[0];
+	fuelgauge->info.high_fg_temp_p_cal_denom = temp_cal[1];
+	fuelgauge->info.high_fg_temp_p_cal_fact = temp_cal[2];
+	fuelgauge->info.high_fg_temp_n_cal_denom = temp_cal[3];
+	fuelgauge->info.high_fg_temp_n_cal_fact = temp_cal[4];
+	fuelgauge->info.en_low_fg_temp_cal = temp_cal[5];
+	fuelgauge->info.low_fg_temp_p_cal_denom = temp_cal[6];
+	fuelgauge->info.low_fg_temp_p_cal_fact = temp_cal[7];
+	fuelgauge->info.low_fg_temp_n_cal_denom = temp_cal[8];
+	fuelgauge->info.low_fg_temp_n_cal_fact = temp_cal[9];
+	PINFO("%s = <%d, %d, %d, %d, %d, %d, %d, %d, %d, %d>\n", prop_name,
+		fuelgauge->info.en_high_fg_temp_cal,
+		fuelgauge->info.high_fg_temp_p_cal_denom, fuelgauge->info.high_fg_temp_p_cal_fact,
+		fuelgauge->info.high_fg_temp_n_cal_denom, fuelgauge->info.high_fg_temp_n_cal_fact,
+		fuelgauge->info.en_low_fg_temp_cal,
+		fuelgauge->info.low_fg_temp_p_cal_denom, fuelgauge->info.low_fg_temp_p_cal_fact,
+		fuelgauge->info.low_fg_temp_n_cal_denom, fuelgauge->info.low_fg_temp_n_cal_fact);
+
+	// ext_temp_calc
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "ext_temp_cal");
+	ret = of_property_read_u32_array(np, prop_name, ext_temp_cal, 10);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	fuelgauge->info.en_high_temp_cal = ext_temp_cal[0];
+	fuelgauge->info.high_temp_p_cal_denom = ext_temp_cal[1];
+	fuelgauge->info.high_temp_p_cal_fact = ext_temp_cal[2];
+	fuelgauge->info.high_temp_n_cal_denom = ext_temp_cal[3];
+	fuelgauge->info.high_temp_n_cal_fact = ext_temp_cal[4];
+	fuelgauge->info.en_low_temp_cal = ext_temp_cal[5];
+	fuelgauge->info.low_temp_p_cal_denom = ext_temp_cal[6];
+	fuelgauge->info.low_temp_p_cal_fact = ext_temp_cal[7];
+	fuelgauge->info.low_temp_n_cal_denom = ext_temp_cal[8];
+	fuelgauge->info.low_temp_n_cal_fact = ext_temp_cal[9];
+	PINFO("%s = <%d, %d, %d, %d, %d, %d, %d, %d, %d, %d>\n", prop_name,
+		fuelgauge->info.en_high_temp_cal,
+		fuelgauge->info.high_temp_p_cal_denom, fuelgauge->info.high_temp_p_cal_fact,
+		fuelgauge->info.high_temp_n_cal_denom, fuelgauge->info.high_temp_n_cal_fact,
+		fuelgauge->info.en_low_temp_cal,
+		fuelgauge->info.low_temp_p_cal_denom, fuelgauge->info.low_temp_p_cal_fact,
+		fuelgauge->info.low_temp_n_cal_denom, fuelgauge->info.low_temp_n_cal_fact);
+
+	// tem poff level
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "tem_poff");
+	ret = of_property_read_u32_array(np, prop_name, set_temp_poff, 4);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	fuelgauge->info.n_tem_poff = set_temp_poff[0];
+	fuelgauge->info.n_tem_poff_offset = set_temp_poff[1];
+	fuelgauge->info.l_tem_poff = set_temp_poff[2];
+	fuelgauge->info.l_tem_poff_offset = set_temp_poff[3];
+
+	PINFO("%s = <%d, %d, %d, %d>\n",
+		prop_name,
+		fuelgauge->info.n_tem_poff, fuelgauge->info.n_tem_poff_offset,
+		fuelgauge->info.l_tem_poff, fuelgauge->info.l_tem_poff_offset);
+
+	// batt data version
+	snprintf(prop_name, PROPERTY_NAME_SIZE, "battery%d,%s", battery_id, "data_ver");
+	ret = of_property_read_u32_array(np, prop_name, &fuelgauge->info.data_ver, 1);
+	if (ret < 0)
+		PINFO("Can get prop %s (%d)\n", prop_name, ret);
+	PINFO("%s = <%d>\n", prop_name, fuelgauge->info.data_ver);
+
+	return 0;
+}
+#else
+static int sm5705_fg_parse_dt(struct sec_fuelgauge_info *fuelgauge)
+{
+	return 0;
+}
+#endif
+
+bool sm5705_fg_fuelalert_init(struct i2c_client *client, int soc)
+{
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+	int ret;
+	int value_v_alarm, value_soc_alarm;
+
+	if (soc >= 0)
+	{
+		// remove interrupt
+		ret = sm5705_fg_i2c_read_word(client, SM5705_REG_INTFG);
+
+		// check status
+		ret = sm5705_fg_i2c_read_word(client, SM5705_REG_STATUS);
+
+		// remove all mask
+		sm5705_fg_i2c_write_word(client,SM5705_REG_INTFG_MASK, 0x0000);
+
+		/* enable volt alert only, other alert mask*/
+		ret = MASK_L_SOC_INT|MASK_H_TEM_INT|MASK_L_TEM_INT;
+		sm5705_fg_i2c_write_word(client,SM5705_REG_INTFG_MASK,ret);
+		fuelgauge->info.irq_ctrl = ~(ret);
+
+		/* set volt and soc alert threshold */
+		value_v_alarm = (((fuelgauge->info.value_v_alarm)<<8)/1000);
+		sm5705_fg_i2c_write_word(client, SM5705_REG_V_ALARM, value_v_alarm);
+		value_soc_alarm = 0x0100; // 1.00%
+		sm5705_fg_i2c_write_word(client, SM5705_REG_SOC_ALARM, value_soc_alarm);
+
+		// enabel volt alert control, other alert disable
+		ret = sm5705_fg_i2c_read_word(client, SM5705_REG_CNTL);
+		ret = ret | ENABLE_V_ALARM;
+		ret = ret & (~ENABLE_SOC_ALARM & ~ENABLE_T_H_ALARM & ~ENABLE_T_L_ALARM);
+		sm5705_fg_i2c_write_word(client, SM5705_REG_CNTL, ret);
+
+		pr_info("irq_ctrl=0x%x, REG_CNTL=0x%x, V_ALARM=%d, SOC_ALARM=0x%x \n",
+			fuelgauge->info.irq_ctrl, ret, value_v_alarm, value_soc_alarm);
+	}
+
+	/* alert flag init*/
+	fuelgauge->info.soc_alert_flag = false;
+	fuelgauge->is_fuel_alerted = false;
+
+	return true;
+}
+
+bool sm5705_fg_is_fuelalerted(struct i2c_client *client)
+{
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+	int ret;
+
+	/* alert process */
+	ret = sm5705_fg_i2c_read_word(client, SM5705_REG_INTFG);
+	pr_info("SM5705_REG_INTFG(0x%x)\n", ret);
+
+	if(ret & fuelgauge->info.irq_ctrl)
+	{
+		// check status
+		ret = sm5705_fg_i2c_read_word(client, SM5705_REG_STATUS);
+		pr_info("SM5705_REG_STATUS(0x%x)\n", ret);
+
+		if(ret & fuelgauge->info.irq_ctrl)
+		{
+			return true;
+		}
+	}
+
+	return false;
+}
+
+bool sm5705_fg_fuelalert_process(void *irq_data, bool is_fuel_alerted)
+{
+	struct sec_fuelgauge_info *fuelgauge = irq_data;
+	struct i2c_client *client = fuelgauge->client;
+	int ret;
+
+	pr_info("is_fuel_alerted=%d \n", is_fuel_alerted);
+
+	if(is_fuel_alerted)
+	{
+		ret = sm5705_fg_i2c_read_word(client, SM5705_REG_STATUS);
+		pr_info("SM5705_REG_STATUS(0x%x)\n", ret);
+
+		/* not use SOC alarm
+		if(ret & fuelgauge->info.irq_ctrl & ENABLE_SOC_ALARM) {
+			fuelgauge->info.soc_alert_flag = true;
+			// todo more action
+		}
+		*/
+
+		if(ret & fuelgauge->info.irq_ctrl & ENABLE_V_ALARM) {
+			fuelgauge->info.volt_alert_flag = true;
+			// todo more action
+		}
+	}
+
+	return true;
+}
+
+/* capacity is  0.1% unit */
+static void sm5705_fg_get_scaled_capacity(
+				struct sec_fuelgauge_info *fuelgauge,
+				union power_supply_propval *val)
+{
+	val->intval = (val->intval < fuelgauge->pdata->capacity_min) ?
+		0 : ((val->intval - fuelgauge->pdata->capacity_min) * 1000 /
+		(fuelgauge->capacity_max - fuelgauge->pdata->capacity_min));
+
+	pr_info("scaled capacity (%d.%d)\n", val->intval/10, val->intval%10);
+}
+
+/* capacity is integer */
+static void sm5705_fg_get_atomic_capacity(
+				struct sec_fuelgauge_info *fuelgauge,
+				union power_supply_propval *val)
+{
+	pr_info("NOW(%d), OLD(%d)\n", val->intval, fuelgauge->capacity_old);
+
+	if (fuelgauge->pdata->capacity_calculation_type &
+		SEC_FUELGAUGE_CAPACITY_TYPE_ATOMIC) {
+		if (fuelgauge->capacity_old < val->intval)
+			val->intval = fuelgauge->capacity_old + 1;
+		else if (fuelgauge->capacity_old > val->intval)
+			val->intval = fuelgauge->capacity_old - 1;
+	}
+
+	/* keep SOC stable in abnormal status */
+	if (fuelgauge->pdata->capacity_calculation_type &
+		SEC_FUELGAUGE_CAPACITY_TYPE_SKIP_ABNORMAL) {
+		if (!fuelgauge->ta_exist &&
+			fuelgauge->capacity_old < val->intval) {
+			pr_info("capacity (old %d : new %d)\n",	fuelgauge->capacity_old, val->intval);
+			val->intval = fuelgauge->capacity_old;
+		}
+	}
+
+	/* updated old capacity */
+	fuelgauge->capacity_old = val->intval;
+}
+
+static int sm5705_fg_check_capacity_max(
+				struct sec_fuelgauge_info *fuelgauge, int capacity_max)
+{
+	int new_capacity_max = capacity_max;
+
+	if (new_capacity_max < (fuelgauge->pdata->capacity_max -
+			fuelgauge->pdata->capacity_max_margin - 10)) {
+		new_capacity_max =
+			(fuelgauge->pdata->capacity_max -
+			fuelgauge->pdata->capacity_max_margin);
+
+		pr_info("set capacity max(%d --> %d)\n", capacity_max, new_capacity_max);
+	} else if (new_capacity_max > (fuelgauge->pdata->capacity_max +
+			fuelgauge->pdata->capacity_max_margin)) {
+		new_capacity_max =
+			(fuelgauge->pdata->capacity_max +
+			fuelgauge->pdata->capacity_max_margin);
+
+		pr_info("set capacity max(%d --> %d)\n", capacity_max, new_capacity_max);
+	}
+
+	return new_capacity_max;
+}
+
+static int sm5705_fg_calculate_dynamic_scale(
+				struct sec_fuelgauge_info *fuelgauge, int capacity)
+{
+	union power_supply_propval raw_soc_val;
+
+	raw_soc_val.intval = sm5705_get_soc(fuelgauge->client);
+
+	if (raw_soc_val.intval <
+		fuelgauge->pdata->capacity_max -
+		fuelgauge->pdata->capacity_max_margin) {
+		fuelgauge->capacity_max =
+			fuelgauge->pdata->capacity_max -
+			fuelgauge->pdata->capacity_max_margin;
+		pr_debug("capacity_max (%d)", fuelgauge->capacity_max);
+	} else {
+		fuelgauge->capacity_max =
+			(raw_soc_val.intval >
+			fuelgauge->pdata->capacity_max +
+			fuelgauge->pdata->capacity_max_margin) ?
+			(fuelgauge->pdata->capacity_max +
+			fuelgauge->pdata->capacity_max_margin) :
+			raw_soc_val.intval;
+		pr_debug("raw soc (%d)", fuelgauge->capacity_max);
+	}
+
+	if (capacity != 100) {
+		fuelgauge->capacity_max = sm5705_fg_check_capacity_max(
+			fuelgauge, (fuelgauge->capacity_max * 100 / (capacity + 1)));
+	} else {
+		fuelgauge->capacity_max =
+			(fuelgauge->capacity_max * 99 / 100);
+	}
+	/* update capacity_old for sec_fg_get_atomic_capacity algorithm */
+	fuelgauge->capacity_old = capacity;
+
+	pr_info("%d is used for capacity_max\n", fuelgauge->capacity_max);
+
+	return fuelgauge->capacity_max;
+}
+
+bool sm5705_fg_reset(struct i2c_client *client)
+{
+	pr_info("Start quick-start\n");
+	// SW reset code
+	sm5705_fg_i2c_verified_write_word(client, SM5705_REG_RESET, SW_RESET_CODE);
+	// delay 800ms
+	msleep(800);
+	// init code
+	sm5705_fg_init(client, false);
+
+	pr_info("End quick-start\n");
+	return true;
+}
+
+static void sm5705_fg_reset_capacity_by_jig_connection(struct sec_fuelgauge_info *fuelgauge)
+{
+	union power_supply_propval value;
+	int ret;
+
+	pr_info("(Jig Connection)\n");
+
+	ret = sm5705_fg_i2c_read_word(fuelgauge->client, SM5705_REG_RESERVED);
+	ret |= SM5705_JIG_CONNECTED;
+	sm5705_fg_i2c_write_word(fuelgauge->client, SM5705_REG_RESERVED, ret);
+	/* If JIG is attached, the voltage is set as 1079 */
+	value.intval = 1079;
+	psy_do_property("battery", set,
+			POWER_SUPPLY_PROP_VOLTAGE_NOW, value);
+}
+
+static int sm5705_fg_get_property(struct power_supply *psy,
+			    enum power_supply_property psp,
+			    union power_supply_propval *val)
+{
+	struct sec_fuelgauge_info *fuelgauge =
+		container_of(psy, struct sec_fuelgauge_info, psy_fg);
+	enum power_supply_ext_property ext_psp = psp;
+
+	switch (psp) {
+	/* Additional Voltage Information (mV) */
+	case POWER_SUPPLY_PROP_PRESENT:
+		// SM5705 is not suport this prop
+		sm5705_fg_get_batt_present(fuelgauge->client);
+		break;
+	/* Cell voltage (VCELL, mV) */
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		sm5705_get_vbat(fuelgauge->client);
+		val->intval = fuelgauge->info.batt_voltage;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_AVG:
+		switch (val->intval) {
+		case SEC_BATTERY_VOLTAGE_AVERAGE:
+			sm5705_get_vbat(fuelgauge->client);
+			val->intval = fuelgauge->info.batt_avgvoltage;
+			break;
+		case SEC_BATTERY_VOLTAGE_OCV:
+			sm5705_get_ocv(fuelgauge->client);
+			val->intval = fuelgauge->info.batt_ocv;
+			break;
+		}
+		break;
+	/* Current (mA) */
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		sm5705_get_curr(fuelgauge->client);
+		if (val->intval == SEC_BATTERY_CURRENT_UA)
+			val->intval = fuelgauge->info.batt_current * 1000;
+		else
+			val->intval = fuelgauge->info.batt_current;
+		break;
+	/* Average Current (mA) */
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+		sm5705_get_curr(fuelgauge->client);
+		if (val->intval == SEC_BATTERY_CURRENT_UA)
+			val->intval = fuelgauge->info.batt_avgcurrent * 1000;
+		else
+			val->intval = fuelgauge->info.batt_avgcurrent;
+		break;
+	/* Battery Temperature */
+	case POWER_SUPPLY_PROP_TEMP:
+	/* Target Temperature */
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		sm5705_get_temperature(fuelgauge->client);
+		val->intval = fuelgauge->info.temp_fg;
+		break;
+	/* SOC (%) */
+	case POWER_SUPPLY_PROP_CAPACITY:
+		sm5705_get_all_value(fuelgauge->client);
+		/* SM5705 F/G unit is 0.1%, raw ==> convert the unit to 0.01% */
+		if (val->intval == SEC_FUELGAUGE_CAPACITY_TYPE_RAW) {
+			val->intval = fuelgauge->info.batt_soc * 10;
+			break;
+		} else
+			val->intval = fuelgauge->info.batt_soc;
+
+		if (fuelgauge->pdata->capacity_calculation_type &
+			(SEC_FUELGAUGE_CAPACITY_TYPE_SCALE |
+			 SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE))
+			sm5705_fg_get_scaled_capacity(fuelgauge, val);
+
+		/* capacity should be between 0% and 100%
+		 * (0.1% degree)
+		 */
+		if (val->intval > 1000)
+			val->intval = 1000;
+		if (val->intval < 0)
+			val->intval = 0;
+
+		/* get only integer part */
+		val->intval /= 10;
+
+		/* check whether doing the wake_unlock */
+		if ((val->intval > fuelgauge->pdata->fuel_alert_soc) &&
+			fuelgauge->is_fuel_alerted) {
+			wake_unlock(&fuelgauge->fuel_alert_wake_lock);
+			sm5705_fg_fuelalert_init(fuelgauge->client,
+				fuelgauge->pdata->fuel_alert_soc);
+		}
+
+		/* (Only for atomic capacity)
+		 * In initial time, capacity_old is 0.
+		 * and in resume from sleep,
+		 * capacity_old is too different from actual soc.
+		 * should update capacity_old
+		 * by val->intval in booting or resume.
+		 */
+		if (fuelgauge->initial_update_of_soc) {
+			/* updated old capacity */
+			fuelgauge->capacity_old = val->intval;
+			fuelgauge->initial_update_of_soc = false;
+			break;
+		}
+
+		if (fuelgauge->pdata->capacity_calculation_type &
+			(SEC_FUELGAUGE_CAPACITY_TYPE_ATOMIC |
+			 SEC_FUELGAUGE_CAPACITY_TYPE_SKIP_ABNORMAL))
+			sm5705_fg_get_atomic_capacity(fuelgauge, val);
+		break;
+	case POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:
+		val->intval = fuelgauge->capacity_max;
+		break;
+	case POWER_SUPPLY_PROP_MAX ... POWER_SUPPLY_EXT_PROP_MAX:
+		switch (ext_psp) {
+		case POWER_SUPPLY_EXT_PROP_INBAT_VOLTAGE_FGSRC_SWITCHING:
+			val->intval = sm5705_fg_get_jig_mode_real_vbat(fuelgauge->client) / 10;
+			break;
+		default:
+			return -EINVAL;
+		}
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int sm5705_fg_set_property(struct power_supply *psy,
+			    enum power_supply_property psp,
+			    const union power_supply_propval *val)
+{
+	struct sec_fuelgauge_info *fuelgauge =
+		container_of(psy, struct sec_fuelgauge_info, psy_fg);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		if (val->intval == POWER_SUPPLY_STATUS_FULL) {
+			fuelgauge->info.flag_full_charge = 1;
+#ifdef ENABLE_BATT_LONG_LIFE
+			pr_info("%s: POWER_SUPPLY_STATUS_FULL : q_max_now = 0x%x \n", __func__, fuelgauge->info.q_max_now);
+			if(fuelgauge->info.q_max_now != 
+					fuelgauge->info.q_max_table[get_v_max_index_by_cycle(fuelgauge->client)]){
+				if (!sm5705_fg_reset(fuelgauge->client))
+					return -EINVAL;
+			}
+#endif
+		}
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+		if (fuelgauge->pdata->capacity_calculation_type &
+				SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE) {
+#if defined(CONFIG_PREVENT_SOC_JUMP)
+			sm5705_fg_calculate_dynamic_scale(fuelgauge, val->intval);
+#else
+			sm5705_fg_calculate_dynamic_scale(fuelgauge, 100);
+#endif
+
+#ifdef ENABLE_BATT_LONG_LIFE
+			pr_info("%s: POWER_SUPPLY_PROP_CHARGE_FULL : q_max_now = 0x%x \n", __func__, fuelgauge->info.q_max_now);
+			if(fuelgauge->info.q_max_now != 
+					fuelgauge->info.q_max_table[get_v_max_index_by_cycle(fuelgauge->client)]){
+				if (!sm5705_fg_reset(fuelgauge->client))
+					return -EINVAL;
+			}
+#endif
+		}
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		fuelgauge->cable_type = val->intval;
+		if (val->intval == POWER_SUPPLY_TYPE_BATTERY) {
+			fuelgauge->ta_exist = false;
+			fuelgauge->is_charging = false;
+		} else {
+			fuelgauge->ta_exist = true;
+			fuelgauge->is_charging = true;
+		}
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		if (val->intval == SEC_FUELGAUGE_CAPACITY_TYPE_RESET) {
+			fuelgauge->initial_update_of_soc = true;
+			if (!sm5705_fg_reset(fuelgauge->client))
+				return -EINVAL;
+			else
+				break;
+		}
+	case POWER_SUPPLY_PROP_TEMP:
+		fuelgauge->info.temperature = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		break;
+	case POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:
+		pr_info("capacity_max changed, %d -> %d\n", fuelgauge->capacity_max, val->intval);
+		fuelgauge->capacity_max = sm5705_fg_check_capacity_max(fuelgauge, val->intval);
+		fuelgauge->initial_update_of_soc = true;
+		break;
+	case POWER_SUPPLY_PROP_ENERGY_NOW:
+          {
+                union power_supply_propval value;
+                value.intval = 0;
+		sm5705_fg_reset_capacity_by_jig_connection(fuelgauge);
+                psy_do_property("sm5705-charger", set, POWER_SUPPLY_PROP_PRESENT, value);
+		break;
+          }
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+	case POWER_SUPPLY_PROP_CAPACITY_LEVEL:
+	  pr_info("%s: full condition soc changed, %d -> %d\n",
+			  __func__, fuelgauge->chg_full_soc, val->intval);
+	  fuelgauge->chg_full_soc = val->intval;
+	  break;
+#endif
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static void sm5705_fg_isr_work(struct work_struct *work)
+{
+	struct sec_fuelgauge_info *fuelgauge =
+		container_of(work, struct sec_fuelgauge_info, isr_work.work);
+
+	/* process for fuel gauge chip */
+	sm5705_fg_fuelalert_process(fuelgauge, fuelgauge->is_fuel_alerted);
+
+	/* process for others */
+	if (fuelgauge->pdata->fuelalert_process != NULL)
+		fuelgauge->pdata->fuelalert_process(fuelgauge->is_fuel_alerted);
+}
+
+static irqreturn_t sm5705_fg_irq_thread(int irq, void *irq_data)
+{
+	struct sec_fuelgauge_info *fuelgauge = irq_data;
+	bool fuel_alerted;
+
+	if (fuelgauge->pdata->fuel_alert_soc >= 0) {
+		fuel_alerted =
+			sm5705_fg_is_fuelalerted(fuelgauge->client);
+
+		pr_info("Fuel-alert %salerted!\n", fuel_alerted ? "" : "NOT ");
+
+		if (fuel_alerted == fuelgauge->is_fuel_alerted) {
+			if (!fuelgauge->pdata->repeated_fuelalert) {
+				pr_debug("Fuel-alert Repeated (%d)\n", fuelgauge->is_fuel_alerted);
+				return IRQ_HANDLED;
+			}
+		}
+
+		if (fuel_alerted)
+			wake_lock(&fuelgauge->fuel_alert_wake_lock);
+		else
+			wake_unlock(&fuelgauge->fuel_alert_wake_lock);
+
+		fuelgauge->is_fuel_alerted = fuel_alerted;
+
+		schedule_delayed_work(&fuelgauge->isr_work, 0);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int sm5705_create_attrs(struct device *dev)
+{
+	int i, rc;
+
+	for (i = 0; i < ARRAY_SIZE(sm5705_fg_attrs); i++) {
+		rc = device_create_file(dev, &sm5705_fg_attrs[i]);
+		if (rc)
+			goto create_attrs_failed;
+	}
+	goto create_attrs_succeed;
+
+create_attrs_failed:
+	pr_err("failed (%d)\n", rc);
+	while (i--)
+		device_remove_file(dev, &sm5705_fg_attrs[i]);
+create_attrs_succeed:
+	return rc;
+}
+
+ssize_t sm5705_fg_show_attrs(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	const ptrdiff_t offset = attr - sm5705_fg_attrs;
+	int i = 0;
+
+	switch (offset) {
+	case FG_REG:
+	case FG_DATA:
+	case FG_REGS:
+		break;
+	default:
+		i = -EINVAL;
+		break;
+	}
+
+	return i;
+}
+
+ssize_t sm5705_fg_store_attrs(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	const ptrdiff_t offset = attr - sm5705_fg_attrs;
+	int ret = 0;
+
+	switch (offset) {
+	case FG_REG:
+	case FG_DATA:
+		ret = count;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static int sm5705_fuelgauge_probe(struct i2c_client *client,
+						const struct i2c_device_id *id)
+{
+	struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
+	struct sec_fuelgauge_info *fuelgauge;
+	sec_battery_platform_data_t *pdata = NULL;
+//	struct battery_data_t *battery_data = NULL;
+	int ret = 0;
+	union power_supply_propval raw_soc_val;
+
+	pr_info("SM5705 Fuelgauge Driver Loading\n");
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE))
+		return -EIO;
+
+	fuelgauge = kzalloc(sizeof(*fuelgauge), GFP_KERNEL);
+	if (!fuelgauge)
+		return -ENOMEM;
+
+	mutex_init(&fuelgauge->fg_lock);
+
+	fuelgauge->client = client;
+
+	if (client->dev.of_node) {
+		int error;
+		pdata = devm_kzalloc(&client->dev, sizeof(sec_battery_platform_data_t), GFP_KERNEL);
+		if (!pdata) {
+			dev_err(&client->dev, "Failed to allocate memory\n");
+			ret = -ENOMEM;
+			goto err_free;
+		}
+
+		fuelgauge->pdata = pdata;
+
+		mutex_init(&fuelgauge->info.param_lock);
+		mutex_lock(&fuelgauge->info.param_lock);
+#if defined(CONFIG_BATTERY_AGE_FORECAST)
+		temp_parse_dt(fuelgauge);
+#endif
+		error = sm5705_fg_parse_dt(fuelgauge);
+		mutex_unlock(&fuelgauge->info.param_lock);
+		if (error < 0) {
+			pr_err("Failed to get fuel_int\n");
+			goto err_parse_dt;
+		}
+	} else	{
+		pr_err("Failed to get of_node\n");
+		fuelgauge->pdata = client->dev.platform_data;
+	}
+	i2c_set_clientdata(client, fuelgauge);
+
+	if (fuelgauge->pdata->fg_gpio_init != NULL) {
+		pr_err("@@@\n");
+		if (!fuelgauge->pdata->fg_gpio_init()) {
+			pr_err("Failed to Initialize GPIO\n");
+			goto err_devm_free;
+		}
+	}
+
+	if (!sm5705_fg_init(fuelgauge->client, false)) {
+		pr_err("Failed to Initialize Fuelgauge\n");
+		goto err_devm_free;
+	}
+
+	fuelgauge->psy_fg.name		= "sm5705-fuelgauge";
+	fuelgauge->psy_fg.type		= POWER_SUPPLY_TYPE_UNKNOWN;
+	fuelgauge->psy_fg.get_property	= sm5705_fg_get_property;
+	fuelgauge->psy_fg.set_property	= sm5705_fg_set_property;
+	fuelgauge->psy_fg.properties	= sm5705_fuelgauge_props;
+	fuelgauge->psy_fg.num_properties =
+		ARRAY_SIZE(sm5705_fuelgauge_props);
+
+        fuelgauge->capacity_max = fuelgauge->pdata->capacity_max;
+	raw_soc_val.intval = sm5705_get_soc(fuelgauge->client);
+
+        if(raw_soc_val.intval > fuelgauge->pdata->capacity_max)
+                sm5705_fg_calculate_dynamic_scale(fuelgauge, 100);
+
+	ret = power_supply_register(&client->dev, &fuelgauge->psy_fg);
+	if (ret) {
+		pr_err("Failed to Register psy_fg\n");
+		goto err_free;
+	}
+
+	fuelgauge->is_fuel_alerted = false;
+	if (fuelgauge->pdata->fuel_alert_soc >= 0) {
+		if (sm5705_fg_fuelalert_init(fuelgauge->client,
+			fuelgauge->pdata->fuel_alert_soc))
+			wake_lock_init(&fuelgauge->fuel_alert_wake_lock,
+				WAKE_LOCK_SUSPEND, "fuel_alerted");
+		else {
+			pr_err("Failed to Initialize Fuel-alert\n");
+			goto err_irq;
+		}
+	}
+
+	if (fuelgauge->pdata->fg_irq > 0) {
+		INIT_DELAYED_WORK(
+			&fuelgauge->isr_work, sm5705_fg_isr_work);
+
+		fuelgauge->fg_irq = gpio_to_irq(fuelgauge->pdata->fg_irq);
+		pr_info("fg_irq = %d\n", fuelgauge->fg_irq);
+		if (fuelgauge->fg_irq > 0) {
+			ret = request_threaded_irq(fuelgauge->fg_irq,
+					NULL, sm5705_fg_irq_thread,
+					IRQF_TRIGGER_FALLING
+					 | IRQF_ONESHOT,
+					"fuelgauge-irq", fuelgauge);
+			if (ret) {
+				pr_err("Failed to Reqeust IRQ\n");
+				goto err_supply_unreg;
+			}
+
+			ret = enable_irq_wake(fuelgauge->fg_irq);
+			if (ret < 0)
+				pr_err("Failed to Enable Wakeup Source(%d)\n", ret);
+		} else {
+			pr_err("Failed gpio_to_irq(%d)\n", fuelgauge->fg_irq);
+			goto err_supply_unreg;
+		}
+	}
+
+	fuelgauge->initial_update_of_soc = true;
+	fuelgauge->info.temperature = 250;
+
+	//if (sec_bat_check_jig_status())
+	//	sm5705_fg_reset_capacity_by_jig_connection(fuelgauge);
+
+	ret = sm5705_create_attrs(fuelgauge->psy_fg.dev);
+	if (ret) {
+		pr_err("Failed to create_attrs\n");
+		goto err_irq;
+	}
+
+	pr_info("SEC Fuelgauge Driver Loaded\n");
+	return 0;
+
+err_irq:
+	if (fuelgauge->fg_irq > 0)
+		free_irq(fuelgauge->fg_irq, fuelgauge);
+	wake_lock_destroy(&fuelgauge->fuel_alert_wake_lock);
+err_supply_unreg:
+	power_supply_unregister(&fuelgauge->psy_fg);
+err_devm_free:
+err_parse_dt:
+	if(pdata)
+		devm_kfree(&client->dev, pdata);
+//	if(battery_data)
+//		devm_kfree(&client->dev, battery_data);
+err_free:
+	mutex_destroy(&fuelgauge->fg_lock);
+	kfree(fuelgauge);
+
+	pr_info("Fuel gauge probe failed\n");
+	return ret;
+}
+
+static int sm5705_fuelgauge_remove(
+						struct i2c_client *client)
+{
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+
+	if (fuelgauge->pdata->fuel_alert_soc >= 0)
+		wake_lock_destroy(&fuelgauge->fuel_alert_wake_lock);
+
+	return 0;
+}
+
+static int sm5705_fuelgauge_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int sm5705_fuelgauge_resume(struct device *dev)
+{
+	struct sec_fuelgauge_info *fuelgauge = dev_get_drvdata(dev);
+
+	fuelgauge->initial_update_of_soc = true;
+
+	return 0;
+}
+
+static void sm5705_fuelgauge_shutdown(struct i2c_client *client)
+{
+}
+
+static const struct i2c_device_id sm5705_fuelgauge_id[] = {
+	{"sm5705-fuelgauge", 0},
+	{}
+};
+
+static const struct dev_pm_ops sm5705_fuelgauge_pm_ops = {
+	.suspend = sm5705_fuelgauge_suspend,
+	.resume  = sm5705_fuelgauge_resume,
+};
+
+MODULE_DEVICE_TABLE(i2c, sm5705_fuelgauge_id);
+static struct of_device_id fuelgague_i2c_match_table[] = {
+	{ .compatible = "sm,sm5705-fuelgauge", },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, fuelgague_i2c_match_table);
+
+static struct i2c_driver sm5705_fuelgauge_driver = {
+	.driver = {
+		   .name = "sm5705-fuelgauge",
+		   .owner = THIS_MODULE,
+		   .of_match_table = fuelgague_i2c_match_table,
+#ifdef CONFIG_PM
+		   .pm = &sm5705_fuelgauge_pm_ops,
+#endif
+	},
+	.probe	= sm5705_fuelgauge_probe,
+	.remove	= sm5705_fuelgauge_remove,
+	.shutdown   = sm5705_fuelgauge_shutdown,
+	.id_table   = sm5705_fuelgauge_id,
+};
+
+static int __init sm5705_fuelgauge_init(void)
+{
+	pr_info("called\n");
+	return i2c_add_driver(&sm5705_fuelgauge_driver);
+}
+
+static void __exit sm5705_fuelgauge_exit(void)
+{
+	i2c_del_driver(&sm5705_fuelgauge_driver);
+}
+
+module_init(sm5705_fuelgauge_init);
+module_exit(sm5705_fuelgauge_exit);
+
+MODULE_DESCRIPTION("Samsung SM5705 Fuel Gauge Driver");
+MODULE_AUTHOR("Samsung Electronics");
+MODULE_LICENSE("GPL");
diff -Naur linux-3.18.14/drivers/battery_v2/sma7p10_charger.c samsung/drivers/battery_v2/sma7p10_charger.c
--- linux-3.18.14/drivers/battery_v2/sma7p10_charger.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/battery_v2/sma7p10_charger.c	2018-10-29 07:24:36.000000000 +0100
@@ -0,0 +1,647 @@
+/*
+ * sma7p10_charger.c - SMA7P10 Charger Driver
+ *
+ * Copyright (C) 2016 Samsung Electronics Co.Ltd
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include "include/charger/sma7p10_charger.h"
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+
+#define DEBUG
+
+#define ENABLE 1
+#define DISABLE 0
+
+static enum power_supply_property sma7p10_charger_props[] = {
+	POWER_SUPPLY_PROP_HEALTH,				/* status */
+	POWER_SUPPLY_PROP_ONLINE,				/* buck enable/disable */
+	POWER_SUPPLY_PROP_CURRENT_MAX,			/* input current */
+	POWER_SUPPLY_PROP_CURRENT_NOW,			/* charge current */
+};
+
+static void sma7p10_set_charger_state(
+	struct sma7p10_charger_data *charger, int enable);
+
+static int sma7p10_read_reg(struct i2c_client *client, u8 reg, u8 *dest)
+{
+	struct sma7p10_charger_data *charger = i2c_get_clientdata(client);
+	int ret = 0;
+ 
+	mutex_lock(&charger->io_lock);
+	ret = i2c_smbus_read_byte_data(client, reg);
+	mutex_unlock(&charger->io_lock);
+
+	if (ret < 0) {
+		pr_err("%s: can't read reg(0x%x), ret(%d)\n", __func__, reg, ret);
+		return ret;
+	}
+
+	reg &= 0xFF;
+	*dest = ret;
+
+	return 0;
+}
+
+static int sma7p10_write_reg(struct i2c_client *client, u8 reg, u8 data)
+{
+	struct sma7p10_charger_data *charger = i2c_get_clientdata(client);
+	int ret = 0;
+
+	mutex_lock(&charger->io_lock);
+	ret = i2c_smbus_write_byte_data(client, reg, data);
+	mutex_unlock(&charger->io_lock);
+
+	if (ret < 0)
+		pr_err("%s: can't write reg(0x%x), ret(%d)\n", __func__, reg, ret);
+
+	return ret;
+}
+
+static int sma7p10_update_reg(struct i2c_client *client, u8 reg, u8 val, u8 mask)
+{
+	struct sma7p10_charger_data *charger = i2c_get_clientdata(client);
+	int ret = 0;
+
+	mutex_lock(&charger->io_lock);
+	ret = i2c_smbus_read_byte_data(client, reg);
+
+	if (ret < 0)
+		pr_err("%s: can't update reg(0x%x), ret(%d)\n", __func__, reg, ret);
+	else {
+		u8 old_val = ret & 0xFF;
+		u8 new_val = (val & mask) | (old_val & (~mask));
+		ret = i2c_smbus_write_byte_data(client, reg, new_val);
+	}
+	mutex_unlock(&charger->io_lock);
+
+	return ret;
+}
+
+static void sma7p10_charger_test_read(
+	struct sma7p10_charger_data *charger)
+{
+	u8 data = 0;
+	u32 addr = 0;
+	char str[1024]={0,};
+	for (addr = 0x4d; addr <= 0x51; addr++) {
+		sma7p10_read_reg(charger->i2c, addr, &data);
+		sprintf(str + strlen(str), "[0x%02x]0x%02x, ", addr, data);
+	}
+	pr_info("%s: SMA7P10 : %s\n", __func__, str);
+}
+
+static int sma7p10_get_charger_state(
+	struct sma7p10_charger_data *charger)
+{
+	u8 reg_data;
+
+	sma7p10_read_reg(charger->i2c, SMA7P10_CHG_STATUS1, &reg_data);
+	if (reg_data & VIN_OK_STATUS_MASK)
+		return POWER_SUPPLY_STATUS_CHARGING;
+	return POWER_SUPPLY_STATUS_NOT_CHARGING;
+}
+
+static int sma7p10_get_charger_health(struct sma7p10_charger_data *charger)
+{
+	u8 reg_data;
+
+	sma7p10_read_reg(charger->i2c, SMA7P10_CHG_STATUS1, &reg_data);
+	if (reg_data & VINOV_OK_STATUS_MASK) {
+			pr_info("%s: VIN overvoltage\n", __func__);
+			return POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+	} else if (reg_data & VINUV_OK_SHIFT) {
+		pr_info("%s: VIN undervoltage\n", __func__);
+		return POWER_SUPPLY_HEALTH_UNDERVOLTAGE;
+	} else
+		return POWER_SUPPLY_HEALTH_GOOD;
+}
+
+static void sma7p10_set_charger_state(
+	struct sma7p10_charger_data *charger, int enable)
+{
+	pr_info("%s: BUCK_EN(%s)\n", enable > 0 ? "ENABLE" : "DISABLE", __func__);
+
+	if (enable)
+		sma7p10_update_reg(charger->i2c,
+			SMA7P10_SC_CTRL1, ENI2C_MASK, ENI2C_MASK);
+	else
+		sma7p10_update_reg(charger->i2c, SMA7P10_SC_CTRL1, 0, ENI2C_MASK);
+
+	sma7p10_charger_test_read(charger);
+}
+
+static int sma7p10_get_charge_current(struct sma7p10_charger_data *charger)
+{
+	u8 reg_data;
+	int charge_current;
+
+	sma7p10_read_reg(charger->i2c, SMA7P10_SC_CTRL0, &reg_data);
+	charge_current = reg_data * 10;
+
+	return charge_current;
+}
+
+static void sma7p10_set_charge_current(struct sma7p10_charger_data *charger,
+	int charge_current)
+{
+	u8 reg_data;
+
+	if (!charge_current) {
+		reg_data = 0x00;
+	} else {
+		charge_current = (charge_current > 2500) ? 2500 : charge_current;
+		reg_data = charge_current  / 10;
+	}
+
+	sma7p10_update_reg(charger->i2c,
+			SMA7P10_SC_CTRL0, reg_data, CHG_CURRENT_MASK);
+	pr_info("%s: charge_current(%d)\n", __func__, charge_current);
+}
+
+static void sma7p10_charger_initialize(struct sma7p10_charger_data *charger)
+{
+	pr_info("%s: \n", __func__);
+
+	/* Battery under-voltage threshold */
+	sma7p10_update_reg(charger->i2c, SMA7P10_SC_CTRL5, V3P14, CPQ_MASK);
+
+	/* Battery over_voltage threshold */	
+	sma7p10_update_reg(charger->i2c, SMA7P10_SC_CTRL5, 0x01, CV_FLG_MASK);
+
+	/* Soft down time */	
+	sma7p10_update_reg(charger->i2c,
+		SMA7P10_SC_CTRL6, (0x01) << SOFT_DOWN_SHIFT, SOFT_DOWN_MASK);
+}
+
+static irqreturn_t sma7p10_irq_handler(int irq, void *data)
+{
+//	struct sma7p10_charger_data *charger = data;
+
+	pr_info("%s: \n", __func__);
+
+	return IRQ_HANDLED;
+}
+
+static int sma7p10_chg_get_property(struct power_supply *psy,
+	enum power_supply_property psp, union power_supply_propval *val)
+{
+	struct sma7p10_charger_data *charger =
+		container_of(psy, struct sma7p10_charger_data, psy_chg);
+	enum power_supply_ext_property ext_psp = psp;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_HEALTH:
+		if (charger->cable_type == POWER_SUPPLY_TYPE_HV_MAINS ||
+			charger->cable_type == POWER_SUPPLY_TYPE_HV_MAINS_12V) {
+			sma7p10_charger_test_read(charger);
+			val->intval = sma7p10_get_charger_health(charger);
+		} else
+			val->intval = POWER_SUPPLY_HEALTH_GOOD;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = sma7p10_get_charger_state(charger);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = sma7p10_get_charge_current(charger);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		return -ENODATA;
+	case POWER_SUPPLY_PROP_MAX ... POWER_SUPPLY_EXT_PROP_MAX:
+		switch (ext_psp) {
+		case POWER_SUPPLY_EXT_PROP_CHECK_SLAVE_I2C:
+			{
+			u8 reg_data;
+			val->intval = (sma7p10_read_reg(charger->i2c, SMA7P10_SC_CTRL0, &reg_data) == 0);
+			}
+			break;
+		case POWER_SUPPLY_EXT_PROP_CHECK_MULTI_CHARGE:
+			val->intval = (sma7p10_get_charger_health(charger) == POWER_SUPPLY_HEALTH_GOOD) ?
+				sma7p10_get_charger_state(charger) : POWER_SUPPLY_STATUS_NOT_CHARGING;
+			break;
+		default:
+			return -EINVAL;
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sma7p10_chg_set_property(struct power_supply *psy,
+	enum power_supply_property psp, const union power_supply_propval *val)
+{
+	struct sma7p10_charger_data *charger =
+		container_of(psy, struct sma7p10_charger_data, psy_chg);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_CHARGING_ENABLED:
+		charger->is_charging = 
+			(val->intval == SEC_BAT_CHG_MODE_CHARGING) ? ENABLE : DISABLE;
+		sma7p10_set_charger_state(charger, charger->is_charging);
+		if (charger->is_charging == DISABLE)
+			sma7p10_set_charge_current(charger, 0);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		charger->charging_current = val->intval;
+		sma7p10_set_charge_current(charger, charger->charging_current);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+		charger->siop_level = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		charger->cable_type = val->intval;
+		if (val->intval != POWER_SUPPLY_TYPE_BATTERY) {
+			sma7p10_charger_initialize(charger);
+		}
+		break;
+	case POWER_SUPPLY_PROP_STATUS:
+	case POWER_SUPPLY_PROP_CURRENT_FULL:
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+	case POWER_SUPPLY_PROP_HEALTH:
+		return -ENODATA;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sma7p10_charger_parse_dt(struct device *dev,
+	sec_charger_platform_data_t *pdata)
+{
+	struct device_node *np = of_find_node_by_name(NULL, "sma7p10-charger");
+	int ret = 0;
+
+	if (!np) {
+		pr_err("%s: np is NULL\n", __func__);
+		return -1;
+	} else {
+		ret = of_get_named_gpio_flags(np, "sma7p10-charger,irq-gpio",
+			0, NULL);
+		if (ret < 0) {
+			pr_err("%s: sma7p10-charger,irq-gpio is empty\n", __func__);
+			pdata->irq_gpio = 0;
+		} else {
+			pdata->irq_gpio = ret;
+			pr_info("%s: irq-gpio = %d\n", __func__, pdata->irq_gpio);
+		}
+
+		pdata->chg_gpio_en = of_get_named_gpio(np,
+			"sma7p10-charger,chg_gpio_en", 0);
+		if (pdata->chg_gpio_en < 0) {
+			pr_err("%s : cannot get chg_gpio_en : %d\n",
+				__func__, pdata->chg_gpio_en);
+			return -ENODATA;	
+		} else {
+			pr_info("%s: chg_gpio_en : %d\n", __func__, pdata->chg_gpio_en);
+		}
+	}
+
+	np = of_find_node_by_name(NULL, "battery");
+	if (!np) {
+		pr_err("%s np is NULL\n", __func__);
+		return -1;
+	}
+
+	return 0;
+}
+
+static ssize_t sma7p10_store_addr(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct sma7p10_charger_data *charger = container_of(psy, struct sma7p10_charger_data, psy_chg);
+	int x;
+	if (sscanf(buf, "0x%x\n", &x) == 1) {
+		charger->addr = x;
+	}
+	return count;
+}
+
+static ssize_t sma7p10_show_addr(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct sma7p10_charger_data *charger = container_of(psy, struct sma7p10_charger_data, psy_chg);
+	return sprintf(buf, "0x%x\n", charger->addr);
+}
+
+static ssize_t sma7p10_store_size(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct sma7p10_charger_data *charger = container_of(psy, struct sma7p10_charger_data, psy_chg);
+	int x;
+	if (sscanf(buf, "%d\n", &x) == 1) {
+		charger->size = x;
+	}
+	return count;
+}
+
+static ssize_t sma7p10_show_size(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct sma7p10_charger_data *charger = container_of(psy, struct sma7p10_charger_data, psy_chg);
+	return sprintf(buf, "0x%x\n", charger->size);
+}
+
+static ssize_t sma7p10_store_data(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct sma7p10_charger_data *charger = container_of(psy, struct sma7p10_charger_data, psy_chg);
+	int x;
+
+	if (sscanf(buf, "0x%x", &x) == 1) {
+		u8 data = x;
+		if (sma7p10_write_reg(charger->i2c, charger->addr, data) < 0)
+		{
+			dev_info(charger->dev,
+					"%s: addr: 0x%x write fail\n", __func__, charger->addr);
+		}
+	}
+	return count;
+}
+
+static ssize_t sma7p10_show_data(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct sma7p10_charger_data *charger = container_of(psy, struct sma7p10_charger_data, psy_chg);
+	u8 data;
+	int i, count = 0;;
+	if (charger->size == 0)
+		charger->size = 1;
+
+	for (i = 0; i < charger->size; i++) {
+		if (sma7p10_read_reg(charger->i2c, charger->addr+i, &data) < 0) {
+			dev_info(charger->dev,
+					"%s: read fail\n", __func__);
+			count += sprintf(buf+count, "addr: 0x%x read fail\n", charger->addr+i);
+			continue;
+		}
+		count += sprintf(buf+count, "addr: 0x%x, data: 0x%x\n", charger->addr+i,data);
+	}
+	return count;
+}
+
+static DEVICE_ATTR(addr, 0644, sma7p10_show_addr, sma7p10_store_addr);
+static DEVICE_ATTR(size, 0644, sma7p10_show_size, sma7p10_store_size);
+static DEVICE_ATTR(data, 0644, sma7p10_show_data, sma7p10_store_data);
+
+static struct attribute *sma7p10_attributes[] = {
+	&dev_attr_addr.attr,
+	&dev_attr_size.attr,
+	&dev_attr_data.attr,
+	NULL
+};
+
+static const struct attribute_group sma7p10_attr_group = {
+	.attrs = sma7p10_attributes,
+};
+
+static int sma7p10_charger_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	struct device_node *of_node = client->dev.of_node;
+	struct sma7p10_charger_data *charger;
+	sec_charger_platform_data_t *pdata = client->dev.platform_data;
+	int ret = 0;
+
+	pr_info("%s: SMA7P10 Charger Driver Loading\n", __func__);
+
+	if (of_node) {
+		pdata = devm_kzalloc(&client->dev, sizeof(*pdata), GFP_KERNEL);
+		if (!pdata) {
+			pr_err("%s: Failed to allocate memory\n", __func__);
+			return -ENOMEM;
+		}
+		ret = sma7p10_charger_parse_dt(&client->dev, pdata);
+		if (ret < 0)
+			goto err_parse_dt;
+	} else {
+		pdata = client->dev.platform_data;
+	}
+
+	charger = kzalloc(sizeof(*charger), GFP_KERNEL);
+	if (!charger) {
+		pr_err("%s: Failed to allocate memory\n", __func__);
+		ret = -ENOMEM;
+		goto err_nomem;
+	}
+
+	mutex_init(&charger->io_lock);
+	charger->dev = &client->dev;
+	ret = i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA |
+		I2C_FUNC_SMBUS_WORD_DATA | I2C_FUNC_SMBUS_I2C_BLOCK);
+	if (!ret) {
+		ret = i2c_get_functionality(client->adapter);
+		dev_err(charger->dev, "I2C functionality is not supported.\n");
+		ret = -ENOSYS;
+		goto err_i2cfunc_not_support;
+	}
+	charger->i2c = client;
+	charger->pdata = pdata;
+	i2c_set_clientdata(client, charger);
+
+	charger->psy_chg.name			= "sma7p10-charger";
+	charger->psy_chg.type			= POWER_SUPPLY_TYPE_UNKNOWN;
+	charger->psy_chg.get_property	= sma7p10_chg_get_property;
+	charger->psy_chg.set_property	= sma7p10_chg_set_property;
+	charger->psy_chg.properties		= sma7p10_charger_props;
+	charger->psy_chg.num_properties	= ARRAY_SIZE(sma7p10_charger_props);
+
+	/* sma7p10_charger_initialize(charger); */
+	charger->cable_type = POWER_SUPPLY_TYPE_BATTERY;
+
+	ret = power_supply_register(charger->dev, &charger->psy_chg);
+	if (ret) {
+		pr_err("%s: Failed to Register psy_chg\n", __func__);
+		ret = -1;
+		goto err_power_supply_register;
+	}
+
+	charger->wqueue =
+		create_singlethread_workqueue(dev_name(charger->dev));
+	if (!charger->wqueue) {
+		pr_err("%s: Fail to Create Workqueue\n", __func__);
+		ret = -1;
+		goto err_create_wqueue;
+	}
+
+	if (pdata->irq_gpio) {
+		charger->chg_irq = gpio_to_irq(pdata->irq_gpio);
+
+		ret = request_threaded_irq(charger->chg_irq, NULL,
+			sma7p10_irq_handler,
+			IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+			"sma7p10-irq", charger);
+		if (ret < 0) {
+			pr_err("%s: Failed to Request IRQ(%d)\n", __func__, ret);
+			goto err_req_irq;
+		}
+
+		ret = enable_irq_wake(charger->chg_irq);
+		if (ret < 0)
+			pr_err("%s: Failed to Enable Wakeup Source(%d)\n",
+				__func__, ret);
+	}
+
+	ret = sysfs_create_group(&charger->psy_chg.dev->kobj, &sma7p10_attr_group);
+	if (ret) {
+		dev_info(&client->dev,
+			"%s: sysfs_create_group failed\n", __func__);
+	}
+
+	/* sma7p10_charger_initialize(charger); */
+	sma7p10_charger_test_read(charger);
+	sma7p10_get_charge_current(charger);
+
+	pr_info("%s: SM7P10 Charger Driver Loaded\n", __func__);
+
+	return 0;
+
+err_req_irq:
+err_create_wqueue:
+	power_supply_unregister(&charger->psy_chg);
+err_power_supply_register:
+err_i2cfunc_not_support:
+	mutex_destroy(&charger->io_lock);
+	kfree(charger);
+err_nomem:
+err_parse_dt:
+	kfree(pdata);
+
+	return ret;
+}
+
+static int sma7p10_charger_remove(struct i2c_client *client)
+{
+	struct sma7p10_charger_data *charger = i2c_get_clientdata(client);
+
+	free_irq(charger->chg_irq, NULL);
+	destroy_workqueue(charger->wqueue);
+	power_supply_unregister(&charger->psy_chg);
+	mutex_destroy(&charger->io_lock);
+	kfree(charger->pdata);
+	kfree(charger);
+
+	return 0;
+}
+
+static void sma7p10_charger_shutdown(struct i2c_client *client)
+{
+}
+
+static const struct i2c_device_id sma7p10_charger_id_table[] = {
+	{"sma7p10-charger", 0},
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, sma7p10_id_table);
+
+#if defined(CONFIG_PM)
+static int sma7p10_charger_suspend(struct device *dev)
+{
+	struct i2c_client *i2c = container_of(dev, struct i2c_client, dev);
+	struct sma7p10_charger_data *charger = i2c_get_clientdata(i2c);
+
+	if (charger->chg_irq) {
+		if (device_may_wakeup(dev))
+			enable_irq_wake(charger->chg_irq);
+		disable_irq(charger->chg_irq);
+	}
+
+	return 0;
+}
+
+static int sma7p10_charger_resume(struct device *dev)
+{
+	struct i2c_client *i2c = container_of(dev, struct i2c_client, dev);
+	struct sma7p10_charger_data *charger = i2c_get_clientdata(i2c);
+
+	if (charger->chg_irq) {
+		if (device_may_wakeup(dev))
+			disable_irq_wake(charger->chg_irq);
+		enable_irq(charger->chg_irq);
+	}
+
+	return 0;
+}
+#else
+#define sma7p10_charger_suspend		NULL
+#define sma7p10_charger_resume		NULL
+#endif /* CONFIG_PM */
+
+const struct dev_pm_ops sma7p10_pm = {
+	.suspend = sma7p10_charger_suspend,
+	.resume = sma7p10_charger_resume,
+};
+
+#ifdef CONFIG_OF
+static struct of_device_id sma7p10_charger_match_table[] = {
+	{.compatible = "samsung,sma7p10-charger"},
+	{},
+};
+#else
+#define sma7p10_charger_match_table NULL
+#endif
+
+static struct i2c_driver sma7p10_charger_driver = {
+	.driver = {
+		.name	= "sma7p10-charger",
+		.owner	= THIS_MODULE,
+		.of_match_table = sma7p10_charger_match_table,
+#if defined(CONFIG_PM)
+		.pm = &sma7p10_pm,
+#endif /* CONFIG_PM */
+	},
+	.probe		= sma7p10_charger_probe,
+	.remove		= sma7p10_charger_remove,
+	.shutdown	= sma7p10_charger_shutdown,
+	.id_table	= sma7p10_charger_id_table,
+};
+
+static int __init sma7p10_charger_init(void)
+{
+	pr_info("%s: \n", __func__);
+	return i2c_add_driver(&sma7p10_charger_driver);
+}
+
+static void __exit sma7p10_charger_exit(void)
+{
+	pr_info("%s: \n", __func__);
+	i2c_del_driver(&sma7p10_charger_driver);
+}
+
+module_init(sma7p10_charger_init);
+module_exit(sma7p10_charger_exit);
+
+MODULE_DESCRIPTION("Samsung SMA7P10 Charger Driver");
+MODULE_AUTHOR("Samsung Electronics");
+MODULE_LICENSE("GPL");
diff -Naur linux-3.18.14/drivers/power/android_battery.c samsung/drivers/power/android_battery.c
--- linux-3.18.14/drivers/power/android_battery.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/power/android_battery.c	2018-10-29 07:24:39.000000000 +0100
@@ -0,0 +1,174 @@
+/*
+ * Android dummy test battery driver.
+ * Based on goldfish_battery.c
+ * Author: Nicu Pavel <npavel@mini-box.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/power_supply.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <asm/io.h>
+
+
+static int adbattery_bat_get_property(struct power_supply *psy,
+				 enum power_supply_property psp,
+				 union power_supply_propval *val);
+
+static int adbattery_ac_get_property(struct power_supply *psy,
+			enum power_supply_property psp,
+			union power_supply_propval *val);
+
+static struct platform_device *adbattery_pdev;
+
+static enum power_supply_property adbattery_battery_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_CAPACITY,
+};
+
+static enum power_supply_property adbattery_ac_props[] = {
+	POWER_SUPPLY_PROP_ONLINE,
+};
+
+static struct power_supply adbattery_bat = {
+	.name = "battery",
+	.type = POWER_SUPPLY_TYPE_BATTERY,
+	.properties 	=  adbattery_battery_props,
+	.num_properties = ARRAY_SIZE(adbattery_battery_props),
+	.get_property	= adbattery_bat_get_property,
+	.use_for_apm 	= 1,
+};
+
+static struct power_supply adbattery_ac = {
+	.name = "ac",
+	.type = POWER_SUPPLY_TYPE_MAINS,
+	.properties 	=  adbattery_ac_props,
+	.num_properties = ARRAY_SIZE(adbattery_ac_props),
+	.get_property	= adbattery_ac_get_property,
+};
+
+static struct power_supply adbattery_usb = {
+	.name = "usb",
+	.type = POWER_SUPPLY_TYPE_MAINS,
+	.properties 	=  adbattery_ac_props,
+	.num_properties = ARRAY_SIZE(adbattery_ac_props),
+	.get_property	= adbattery_ac_get_property,
+};
+
+
+static int adbattery_ac_get_property(struct power_supply *psy,
+			enum power_supply_property psp,
+			union power_supply_propval *val)
+{
+	int ret = 0;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = 1;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static int adbattery_bat_get_property(struct power_supply *psy,
+				 enum power_supply_property psp,
+				 union power_supply_propval *val)
+{
+	int ret = 0;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = POWER_SUPPLY_STATUS_CHARGING;
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = POWER_SUPPLY_HEALTH_GOOD;
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = 1;
+		break;
+	case POWER_SUPPLY_PROP_TECHNOLOGY:
+		val->intval = POWER_SUPPLY_TECHNOLOGY_LION;
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		val->intval = 100;
+		break;
+	case POWER_SUPPLY_PROP_TEMP:
+		val->intval = 20;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = 5;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static int __init adbattery_init(void)
+{
+	int ret = 0;
+
+	adbattery_pdev = platform_device_register_simple("battery", 0, NULL, 0);
+	if (IS_ERR(adbattery_pdev))
+		return PTR_ERR(adbattery_pdev);
+	ret = power_supply_register(&adbattery_pdev->dev, &adbattery_bat);
+	if (ret)
+		goto bat_failed;
+	ret = power_supply_register(&adbattery_pdev->dev, &adbattery_ac);
+	if (ret)
+		goto ac_failed;
+	ret = power_supply_register(&adbattery_pdev->dev, &adbattery_usb);
+	if (ret)
+		goto usb_failed;
+	printk(KERN_INFO "adbattery: android dummy battery driver loaded\n");
+	goto success;
+
+bat_failed:
+	power_supply_unregister(&adbattery_bat);
+ac_failed:
+	power_supply_unregister(&adbattery_ac);
+usb_failed:
+	power_supply_unregister(&adbattery_usb);
+	platform_device_unregister(adbattery_pdev);
+success:
+	return ret;
+}
+
+static void __exit adbattery_exit(void)
+{
+	power_supply_unregister(&adbattery_bat);
+	power_supply_unregister(&adbattery_ac);
+	power_supply_unregister(&adbattery_usb);
+	platform_device_unregister(adbattery_pdev);
+	printk(KERN_INFO "adbattery: android dummy battery driver unloaded\n");
+}
+
+module_init(adbattery_init);
+module_exit(adbattery_exit);
+MODULE_AUTHOR("Nicu Pavel npavel@mini-box.com");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Dummy battery driver for Android battery service ");
+
diff -Naur linux-3.18.14/drivers/power/bq24190_charger.c samsung/drivers/power/bq24190_charger.c
--- linux-3.18.14/drivers/power/bq24190_charger.c	2015-05-20 17:04:50.000000000 +0200
+++ samsung/drivers/power/bq24190_charger.c	2018-10-29 07:24:39.000000000 +0100
@@ -17,13 +17,22 @@
 #include <linux/power_supply.h>
 #include <linux/gpio.h>
 #include <linux/i2c.h>
+#if defined(CONFIG_FUELGAUGE_MAX17058_POWER) || defined(CONFIG_FUELGAUGE_S2MG001_POWER)
+#include <linux/workqueue.h>
+#endif
+
+#ifdef CONFIG_MUIC_NOTIFIER
+#include <linux/muic/muic.h>
+#include <linux/muic/muic_notifier.h>
+#endif
 
 #include <linux/power/bq24190_charger.h>
 
 
 #define	BQ24190_MANUFACTURER	"Texas Instruments"
 
-#define BQ24190_REG_ISC		0x00 /* Input Source Control */
+/* Input Source Control Register */
+#define BQ24190_REG_ISC				0x00
 #define BQ24190_REG_ISC_EN_HIZ_MASK		BIT(7)
 #define BQ24190_REG_ISC_EN_HIZ_SHIFT		7
 #define BQ24190_REG_ISC_VINDPM_MASK		(BIT(6) | BIT(5) | BIT(4) | \
@@ -32,7 +41,8 @@
 #define BQ24190_REG_ISC_IINLIM_MASK		(BIT(2) | BIT(1) | BIT(0))
 #define BQ24190_REG_ISC_IINLIM_SHIFT		0
 
-#define BQ24190_REG_POC		0x01 /* Power-On Configuration */
+/* Power-On Configuration Register */
+#define BQ24190_REG_POC				0x01
 #define BQ24190_REG_POC_RESET_MASK		BIT(7)
 #define BQ24190_REG_POC_RESET_SHIFT		7
 #define BQ24190_REG_POC_WDT_RESET_MASK		BIT(6)
@@ -44,14 +54,16 @@
 #define BQ24190_REG_POC_BOOST_LIM_MASK		BIT(0)
 #define BQ24190_REG_POC_BOOST_LIM_SHIFT		0
 
-#define BQ24190_REG_CCC		0x02 /* Charge Current Control */
+/* Charge Current Control Register */
+#define BQ24190_REG_CCC				0x02
 #define BQ24190_REG_CCC_ICHG_MASK		(BIT(7) | BIT(6) | BIT(5) | \
 						 BIT(4) | BIT(3) | BIT(2))
 #define BQ24190_REG_CCC_ICHG_SHIFT		2
 #define BQ24190_REG_CCC_FORCE_20PCT_MASK	BIT(0)
 #define BQ24190_REG_CCC_FORCE_20PCT_SHIFT	0
 
-#define BQ24190_REG_PCTCC	0x03 /* Pre-charge/Termination Current Cntl */
+/* Pre-charge/Termination Current Cntl Register */
+#define BQ24190_REG_PCTCC			0x03
 #define BQ24190_REG_PCTCC_IPRECHG_MASK		(BIT(7) | BIT(6) | BIT(5) | \
 						 BIT(4))
 #define BQ24190_REG_PCTCC_IPRECHG_SHIFT		4
@@ -59,7 +71,8 @@
 						 BIT(0))
 #define BQ24190_REG_PCTCC_ITERM_SHIFT		0
 
-#define BQ24190_REG_CVC		0x04 /* Charge Voltage Control */
+/* Charge Voltage Control Register */
+#define BQ24190_REG_CVC				0x04
 #define BQ24190_REG_CVC_VREG_MASK		(BIT(7) | BIT(6) | BIT(5) | \
 						 BIT(4) | BIT(3) | BIT(2))
 #define BQ24190_REG_CVC_VREG_SHIFT		2
@@ -68,7 +81,8 @@
 #define BQ24190_REG_CVC_VRECHG_MASK		BIT(0)
 #define BQ24190_REG_CVC_VRECHG_SHIFT		0
 
-#define BQ24190_REG_CTTC	0x05 /* Charge Term/Timer Control */
+/* Charge Term/Timer Control Register */
+#define BQ24190_REG_CTTC			0x05
 #define BQ24190_REG_CTTC_EN_TERM_MASK		BIT(7)
 #define BQ24190_REG_CTTC_EN_TERM_SHIFT		7
 #define BQ24190_REG_CTTC_TERM_STAT_MASK		BIT(6)
@@ -82,7 +96,8 @@
 #define BQ24190_REG_CTTC_JEITA_ISET_MASK	BIT(0)
 #define BQ24190_REG_CTTC_JEITA_ISET_SHIFT	0
 
-#define BQ24190_REG_ICTRC	0x06 /* IR Comp/Thermal Regulation Control */
+/* IR Comp/Thermal Regulation Control Register */
+#define BQ24190_REG_ICTRC			0x06
 #define BQ24190_REG_ICTRC_BAT_COMP_MASK		(BIT(7) | BIT(6) | BIT(5))
 #define BQ24190_REG_ICTRC_BAT_COMP_SHIFT	5
 #define BQ24190_REG_ICTRC_VCLAMP_MASK		(BIT(4) | BIT(3) | BIT(2))
@@ -90,7 +105,8 @@
 #define BQ24190_REG_ICTRC_TREG_MASK		(BIT(1) | BIT(0))
 #define BQ24190_REG_ICTRC_TREG_SHIFT		0
 
-#define BQ24190_REG_MOC		0x07 /* Misc. Operation Control */
+/* Misc. Operation Control Register */
+#define BQ24190_REG_MOC				0x07
 #define BQ24190_REG_MOC_DPDM_EN_MASK		BIT(7)
 #define BQ24190_REG_MOC_DPDM_EN_SHIFT		7
 #define BQ24190_REG_MOC_TMR2X_EN_MASK		BIT(6)
@@ -102,7 +118,8 @@
 #define BQ24190_REG_MOC_INT_MASK_MASK		(BIT(1) | BIT(0))
 #define BQ24190_REG_MOC_INT_MASK_SHIFT		0
 
-#define BQ24190_REG_SS		0x08 /* System Status */
+/* System Status Register */
+#define BQ24190_REG_SS				0x08
 #define BQ24190_REG_SS_VBUS_STAT_MASK		(BIT(7) | BIT(6))
 #define BQ24190_REG_SS_VBUS_STAT_SHIFT		6
 #define BQ24190_REG_SS_CHRG_STAT_MASK		(BIT(5) | BIT(4))
@@ -116,7 +133,8 @@
 #define BQ24190_REG_SS_VSYS_STAT_MASK		BIT(0)
 #define BQ24190_REG_SS_VSYS_STAT_SHIFT		0
 
-#define BQ24190_REG_F		0x09 /* Fault */
+/* Fault Register */
+#define BQ24190_REG_F				0x09
 #define BQ24190_REG_F_WATCHDOG_FAULT_MASK	BIT(7)
 #define BQ24190_REG_F_WATCHDOG_FAULT_SHIFT	7
 #define BQ24190_REG_F_BOOST_FAULT_MASK		BIT(6)
@@ -128,12 +146,13 @@
 #define BQ24190_REG_F_NTC_FAULT_MASK		(BIT(2) | BIT(1) | BIT(0))
 #define BQ24190_REG_F_NTC_FAULT_SHIFT		0
 
-#define BQ24190_REG_VPRS	0x0A /* Vendor/Part/Revision Status */
+/* Vendor/Part/Revision Status Register */
+#define BQ24190_REG_VPRS			0x0A
 #define BQ24190_REG_VPRS_PN_MASK		(BIT(5) | BIT(4) | BIT(3))
 #define BQ24190_REG_VPRS_PN_SHIFT		3
-#define BQ24190_REG_VPRS_PN_24190			0x4
-#define BQ24190_REG_VPRS_PN_24192			0x5 /* Also 24193 */
-#define BQ24190_REG_VPRS_PN_24192I			0x3
+#define BQ24190_REG_VPRS_PN_24190		0x4
+#define BQ24190_REG_VPRS_PN_24192		0x5 /* Also 24193 */
+#define BQ24190_REG_VPRS_PN_24192I		0x3
 #define BQ24190_REG_VPRS_TS_PROFILE_MASK	BIT(2)
 #define BQ24190_REG_VPRS_TS_PROFILE_SHIFT	2
 #define BQ24190_REG_VPRS_DEV_REG_MASK		(BIT(1) | BIT(0))
@@ -154,6 +173,9 @@
 	struct device			*dev;
 	struct power_supply		charger;
 	struct power_supply		battery;
+#if defined(CONFIG_FUELGAUGE_MAX17058_POWER) || defined(CONFIG_FUELGAUGE_S2MG001_POWER)
+	struct delayed_work polling_work;
+#endif
 	char				model_name[I2C_NAME_SIZE];
 	kernel_ulong_t			model;
 	unsigned int			gpio_int;
@@ -166,6 +188,17 @@
 	u8				f_reg;
 	u8				ss_reg;
 	u8				watchdog;
+#if defined(CONFIG_FUELGAUGE_MAX17058_POWER) || defined(CONFIG_FUELGAUGE_S2MG001_POWER)
+	char				*fuelgauge_name;
+	int				voltage_now;
+	int				voltage_avg;
+	int				voltage_ocv;
+	unsigned int			capacity[3];
+	int				soc_cnt;
+#endif
+#if defined(CONFIG_MUIC_NOTIFIER)
+	struct notifier_block		bdi_nb;
+#endif
 };
 
 /*
@@ -929,7 +962,7 @@
 	charger->properties = bq24190_charger_properties;
 	charger->num_properties = ARRAY_SIZE(bq24190_charger_properties);
 	charger->supplied_to = bq24190_charger_supplied_to;
-	charger->num_supplicants = ARRAY_SIZE(bq24190_charger_supplied_to);
+	charger->num_supplies = ARRAY_SIZE(bq24190_charger_supplied_to);
 	charger->get_property = bq24190_charger_get_property;
 	charger->set_property = bq24190_charger_set_property;
 	charger->property_is_writeable = bq24190_charger_property_is_writeable;
@@ -1099,11 +1132,48 @@
 			ARRAY_SIZE(bq24190_ictrc_treg_values), val->intval);
 }
 
+#if defined(CONFIG_FUELGAUGE_MAX17058_POWER) || defined(CONFIG_FUELGAUGE_S2MG001_POWER)
+static void sec_bat_get_battery_info(
+				struct work_struct *work)
+{
+	struct bq24190_dev_info *bdi =
+		container_of(work, struct bq24190_dev_info, polling_work.work);
+
+	union power_supply_propval value;
+
+	psy_do_property(bdi->fuelgauge_name, get,
+		POWER_SUPPLY_PROP_VOLTAGE_NOW, value);
+	bdi->voltage_now = value.intval;
+
+	value.intval = SEC_BATTERY_VOLTAGE_AVERAGE;
+	psy_do_property(bdi->fuelgauge_name, get,
+		POWER_SUPPLY_PROP_VOLTAGE_AVG, value);
+	bdi->voltage_avg = value.intval;
+
+	value.intval = SEC_BATTERY_VOLTAGE_OCV;
+	psy_do_property(bdi->fuelgauge_name, get,
+		POWER_SUPPLY_PROP_VOLTAGE_AVG, value);
+	bdi->voltage_ocv = value.intval;
+
+	/* To get SOC value (NOT raw SOC), need to reset value */
+	value.intval = 0;
+	psy_do_property(bdi->fuelgauge_name, get,
+		POWER_SUPPLY_PROP_CAPACITY, value);
+	bdi->soc_cnt++;
+	bdi->capacity[bdi->soc_cnt % 3] = value.intval;
+
+	schedule_delayed_work(&bdi->polling_work, HZ * 20);
+}
+#endif
+
 static int bq24190_battery_get_property(struct power_supply *psy,
 		enum power_supply_property psp, union power_supply_propval *val)
 {
 	struct bq24190_dev_info *bdi =
 			container_of(psy, struct bq24190_dev_info, battery);
+#if defined(CONFIG_FUELGAUGE_MAX17058_POWER) || defined(CONFIG_FUELGAUGE_S2MG001_POWER)
+	union power_supply_propval value;
+#endif
 	int ret;
 
 	dev_dbg(bdi->dev, "prop: %d\n", psp);
@@ -1132,6 +1202,55 @@
 		val->intval = POWER_SUPPLY_SCOPE_SYSTEM;
 		ret = 0;
 		break;
+#if defined(CONFIG_FUELGAUGE_MAX17058_POWER) || defined(CONFIG_FUELGAUGE_S2MG001_POWER)
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		psy_do_property(bdi->fuelgauge_name, get,
+				POWER_SUPPLY_PROP_VOLTAGE_NOW, value);
+		bdi->voltage_now = value.intval;
+		dev_err(bdi->dev,
+			"%s: voltage now(%d)\n", __func__, bdi->voltage_now);
+		val->intval = bdi->voltage_now * 1000;
+		ret = 0;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_AVG:
+		value.intval = SEC_BATTERY_VOLTAGE_AVERAGE;
+		psy_do_property(bdi->fuelgauge_name, get,
+				POWER_SUPPLY_PROP_VOLTAGE_AVG, value);
+		bdi->voltage_avg = value.intval;
+		dev_err(bdi->dev,
+			"%s: voltage avg(%d)\n", __func__, bdi->voltage_avg);
+		val->intval = bdi->voltage_now * 1000;
+		ret = 0;
+		break;
+#endif
+	case POWER_SUPPLY_PROP_CAPACITY:
+#if defined(CONFIG_FUELGAUGE_MAX17058_POWER) || defined(CONFIG_FUELGAUGE_S2MG001_POWER)
+		if (bq24190_battery_get_status(bdi, val) ==
+			POWER_SUPPLY_STATUS_FULL)
+			val->intval = 100;
+		else {
+			if (!bdi->capacity[0] && !bdi->capacity[1]
+					&& !bdi->capacity[2])
+				val->intval = 0;
+			else {
+				if (!bdi->capacity[bdi->soc_cnt % 3]) {
+					if (bdi->soc_cnt < 3) {
+						ret = -ENODATA;
+						break;
+					}
+					if (!bdi->capacity[(bdi->soc_cnt - 1) % 3])
+						val->intval = bdi->capacity[(bdi->soc_cnt - 2) % 3];
+					else
+						val->intval = bdi->capacity[(bdi->soc_cnt - 1) % 3];
+				} else
+					val->intval = bdi->capacity[bdi->soc_cnt % 3];
+			}
+		}
+#else
+		val->intval = 80;
+#endif
+		ret = 0;
+		break;
 	default:
 		ret = -ENODATA;
 	}
@@ -1191,6 +1310,11 @@
 	POWER_SUPPLY_PROP_TECHNOLOGY,
 	POWER_SUPPLY_PROP_TEMP_ALERT_MAX,
 	POWER_SUPPLY_PROP_SCOPE,
+#if defined(CONFIG_FUELGAUGE_MAX17058_POWER) || defined(CONFIG_FUELGAUGE_S2MG001_POWER)
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_VOLTAGE_AVG,
+#endif
+	POWER_SUPPLY_PROP_CAPACITY,
 };
 
 static void bq24190_battery_init(struct power_supply *battery)
@@ -1235,6 +1359,14 @@
 					ret);
 		}
 
+		if (ss_reg & BQ24190_REG_SS_PG_STAT_MASK) {
+			if ((ss_reg & BQ24190_REG_SS_VBUS_STAT_MASK) == 0x80){
+				ret = bq24190_write_mask(bdi, BQ24190_REG_MOC,
+						BQ24190_REG_MOC_DPDM_EN_MASK,
+						BQ24190_REG_MOC_DPDM_EN_SHIFT,
+						1);
+			}
+		}
 		bdi->ss_reg = ss_reg;
 		alert_userspace = true;
 	}
@@ -1318,6 +1450,12 @@
 	bdi->irq = irq_of_parse_and_map(bdi->dev->of_node, 0);
 	if (bdi->irq <= 0)
 		return -1;
+#if defined(CONFIG_FUELGAUGE_MAX17058_POWER) || defined(CONFIG_FUELGAUGE_S2MG001_POWER)
+	if (of_property_read_string(bdi->dev->of_node, "battery,fuelgauge_name", (char const **)&bdi->fuelgauge_name)) {
+		dev_err(bdi->dev, "failed to get fuelgauge_name\n");
+		return -EINVAL;
+	}
+#endif
 
 	return 0;
 }
@@ -1356,6 +1494,54 @@
 	return -1;
 }
 
+#if defined(CONFIG_MUIC_NOTIFIER)
+static void bq24190_set_otg(struct bq24190_dev_info *bdi,bool enable)
+{
+	if(enable){
+		bq24190_write_mask(bdi, BQ24190_REG_POC,
+			BQ24190_REG_POC_CHG_CONFIG_MASK,
+			BQ24190_REG_POC_CHG_CONFIG_SHIFT, 0x2);
+	}
+	else {
+		bq24190_write_mask(bdi, BQ24190_REG_POC,
+			BQ24190_REG_POC_CHG_CONFIG_MASK,
+			BQ24190_REG_POC_CHG_CONFIG_SHIFT, 0x0);
+	}
+}
+
+static int bq24190_handle_notification(struct notifier_block *nb,
+		unsigned long action, void *data)
+{
+	muic_attached_dev_t attached_dev = *(muic_attached_dev_t *)data;
+	struct bq24190_dev_info *bdi =
+		container_of(nb, struct bq24190_dev_info,
+			     bdi_nb);
+
+	pr_info("%s action=%lu, attached_dev=%d\n",
+		__func__, action, attached_dev);
+
+	switch (attached_dev) {
+	case ATTACHED_DEV_OTG_MUIC:
+	case ATTACHED_DEV_HMT_MUIC:
+		if (action == MUIC_NOTIFY_CMD_DETACH){
+			bq24190_set_otg(bdi, false);
+			pr_info("bq24190: set otg disabled\n");
+		}
+		else if (action == MUIC_NOTIFY_CMD_ATTACH){
+			bq24190_set_otg(bdi,true);
+			pr_info("bq24190: set otg enabled\n");
+		}
+		else
+			pr_err("%s - ACTION Error!\n", __func__);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+#endif
+
 static int bq24190_probe(struct i2c_client *client,
 		const struct i2c_device_id *id)
 {
@@ -1379,12 +1565,15 @@
 	bdi->client = client;
 	bdi->dev = dev;
 	bdi->model = id->driver_data;
-	strncpy(bdi->model_name, id->name, I2C_NAME_SIZE);
+	strncpy(bdi->model_name, id->name, I2C_NAME_SIZE-1);
 	mutex_init(&bdi->f_reg_lock);
 	bdi->first_time = true;
 	bdi->charger_health_valid = false;
 	bdi->battery_health_valid = false;
 	bdi->battery_status_valid = false;
+#if defined(CONFIG_FUELGAUGE_MAX17058_POWER) || defined(CONFIG_FUELGAUGE_S2MG001_POWER)
+	bdi->soc_cnt = -1;
+#endif
 
 	i2c_set_clientdata(client, bdi);
 
@@ -1398,6 +1587,22 @@
 		return -EINVAL;
 	}
 
+	bq24190_charger_init(&bdi->charger);
+
+	ret = power_supply_register(dev, &bdi->charger);
+	if (ret) {
+		dev_err(dev, "Can't register charger\n");
+		goto out2;
+	}
+
+	bq24190_battery_init(&bdi->battery);
+
+	ret = power_supply_register(dev, &bdi->battery);
+	if (ret) {
+		dev_err(dev, "Can't register battery\n");
+		goto out3;
+	}
+
 	ret = devm_request_threaded_irq(dev, bdi->irq, NULL,
 			bq24190_irq_handler_thread,
 			IRQF_TRIGGER_RISING | IRQF_ONESHOT,
@@ -1415,29 +1620,23 @@
 		dev_err(dev, "Hardware init failed\n");
 		goto out2;
 	}
-
-	bq24190_charger_init(&bdi->charger);
-
-	ret = power_supply_register(dev, &bdi->charger);
-	if (ret) {
-		dev_err(dev, "Can't register charger\n");
-		goto out2;
-	}
-
-	bq24190_battery_init(&bdi->battery);
-
-	ret = power_supply_register(dev, &bdi->battery);
-	if (ret) {
-		dev_err(dev, "Can't register battery\n");
-		goto out3;
-	}
-
+	bdi->first_time = false;
+#if defined(CONFIG_FUELGAUGE_MAX17058_POWER) || defined(CONFIG_FUELGAUGE_S2MG001_POWER)
+	INIT_DELAYED_WORK(&bdi->polling_work,
+				sec_bat_get_battery_info);
+	schedule_delayed_work(&bdi->polling_work, HZ * 5);
+#endif
 	ret = bq24190_sysfs_create_group(bdi);
 	if (ret) {
 		dev_err(dev, "Can't create sysfs entries\n");
 		goto out4;
 	}
 
+#if defined(CONFIG_MUIC_NOTIFIER)
+	muic_notifier_register(&bdi->bdi_nb, bq24190_handle_notification,
+			       MUIC_NOTIFY_DEV_USB);
+#endif
+
 	return 0;
 
 out4:
@@ -1515,12 +1714,14 @@
  */
 static const struct i2c_device_id bq24190_i2c_ids[] = {
 	{ "bq24190", BQ24190_REG_VPRS_PN_24190 },
+	{ "bq24193", BQ24190_REG_VPRS_PN_24192 },
 	{ },
 };
 
 #ifdef CONFIG_OF
 static const struct of_device_id bq24190_of_match[] = {
 	{ .compatible = "ti,bq24190", },
+	{ .compatible = "ti,bq24193", },
 	{ },
 };
 MODULE_DEVICE_TABLE(of, bq24190_of_match);
diff -Naur linux-3.18.14/drivers/power/Kconfig samsung/drivers/power/Kconfig
--- linux-3.18.14/drivers/power/Kconfig	2015-05-20 17:04:50.000000000 +0200
+++ samsung/drivers/power/Kconfig	2018-10-29 07:24:39.000000000 +0100
@@ -212,6 +212,17 @@
 	  with MAX17042. This driver also supports max17047/50 chips which are
 	  improved version of max17042.
 
+config BATTERY_ANDROID
+        tristate "Battery driver for Android"
+        help
+          Say Y to enable generic support for battery charging according
+          to common Android policies.
+          This driver adds periodic battery level and health monitoring,
+          kernel log reporting and other debugging features, common board
+          battery file glue logic for battery/case temperature sensors,
+          etc.
+
+
 config BATTERY_Z2
 	tristate "Z2 battery driver"
 	depends on I2C && MACH_ZIPIT2
@@ -368,6 +379,42 @@
 	help
 	  Say Y to enable support for the TI BQ24735 battery charger.
 
+config SEC_CHARGER_S2MU003
+	tristate "Samsung S2MU003 charger driver"
+	depends on MFD_S2MU003 && I2C
+	help
+	  Say Y here to enable support for the Samsung S2MU003
+	  battery charger can supoprt PMIC, FLED, Fuel-gauge.
+
+config SEC_FUELGAUGE_S2MU003
+	tristate "Samsung S2MU003 fuel gauge driver"
+	depends on MFD_S2MU003 && I2C
+	help
+	  Say Y here to enable support for the Samsung S2MU003
+	  fuel-gauge driver which can support only voltage-tracking mode.
+
+config SEC_CHARGER_S2MU005
+	tristate "Samsung S2MU005 charger driver"
+	depends on MFD_S2MU005 && I2C
+	help
+	  Say Y here to enable support for the Samsung S2MU005
+	  battery charger can supoprt PMIC, FLED, Fuel-gauge.
+
+config SEC_FUELGAUGE_S2MU005
+	tristate "Samsung S2MU005 fuel gauge driver"
+	depends on MFD_S2MU005 && I2C
+	help
+	  Say Y here to enable support for the Samsung S2MU003
+	  fuel-gauge driver which can support only voltage-tracking mode.
+
+config FUELGAUGE_MAX17058_POWER
+	tristate "MAX17058 fuel gauge driver"
+	default n
+	depends on I2C
+	help
+	 Say Y to include support
+	 for MAXIM MAX17058 fuel gauge driver.
+
 config CHARGER_SMB347
 	tristate "Summit Microelectronics SMB347 Battery Charger"
 	depends on I2C
diff -Naur linux-3.18.14/drivers/power/Makefile samsung/drivers/power/Makefile
--- linux-3.18.14/drivers/power/Makefile	2015-05-20 17:04:50.000000000 +0200
+++ samsung/drivers/power/Makefile	2018-10-29 07:24:39.000000000 +0100
@@ -55,7 +55,13 @@
 obj-$(CONFIG_CHARGER_BQ2415X)	+= bq2415x_charger.o
 obj-$(CONFIG_CHARGER_BQ24190)	+= bq24190_charger.o
 obj-$(CONFIG_CHARGER_BQ24735)	+= bq24735-charger.o
+obj-$(CONFIG_SEC_CHARGER_S2MU003)   += s2mu003_charger.o
+obj-$(CONFIG_SEC_FUELGAUGE_S2MU003)   += s2mu003_fuelgauge.o
+obj-$(CONFIG_SEC_CHARGER_S2MU005)   += s2mu005_charger.o
+obj-$(CONFIG_SEC_FUELGAUGE_S2MU005)   += s2mu005_fuelgauge.o
+obj-$(CONFIG_FUELGAUGE_MAX17058_POWER) += max17058_fuelgauge.o sec_fuelgauge.o
 obj-$(CONFIG_POWER_AVS)		+= avs/
 obj-$(CONFIG_CHARGER_SMB347)	+= smb347-charger.o
 obj-$(CONFIG_CHARGER_TPS65090)	+= tps65090-charger.o
 obj-$(CONFIG_POWER_RESET)	+= reset/
+obj-$(CONFIG_BATTERY_ANDROID)	+= android_battery.o
diff -Naur linux-3.18.14/drivers/power/max17058_fuelgauge.c samsung/drivers/power/max17058_fuelgauge.c
--- linux-3.18.14/drivers/power/max17058_fuelgauge.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/power/max17058_fuelgauge.c	2018-10-29 07:24:39.000000000 +0100
@@ -0,0 +1,328 @@
+/*
+ *  max17058_fuelgauge.c
+ *  Samsung MAX17058 Fuel Gauge Driver
+ *
+ *  Copyright (C) 2012 Samsung Electronics
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#define DEBUG
+
+#include <linux/power/sec_fuelgauge.h>
+
+static int max17058_write_reg(struct i2c_client *client, int reg, u8 *buf)
+{
+	int ret;
+
+	ret = i2c_smbus_write_i2c_block_data(client, reg, 2, buf);
+
+	if (ret < 0)
+		dev_err(&client->dev, "%s: Error(%d)\n", __func__, ret);
+
+	return ret;
+}
+
+static int max17058_read_reg(struct i2c_client *client, int reg, u8 *buf)
+{
+	int ret;
+
+	ret = i2c_smbus_read_i2c_block_data(client, reg, 2, buf);
+
+	if (ret < 0)
+		dev_err(&client->dev, "%s: Error(%d)\n", __func__, ret);
+
+	return ret;
+}
+
+static void max17058_init_regs(struct i2c_client *client)
+{
+	u8 data[2];
+
+	if (max17058_read_reg(client, MAX17058_REG_STATUS, data) < 0)
+		return ;
+	data[0] |= (1 << 0);
+	max17058_write_reg(client, MAX17058_REG_STATUS, data);
+
+	if (max17058_read_reg(client, MAX17058_REG_STATUS, data) < 0)
+		return ;
+	data[0] &= ~(1 << 0);
+	max17058_write_reg(client, MAX17058_REG_STATUS, data);
+
+	return ;
+}
+
+static void max17058_get_version(struct i2c_client *client)
+{
+	u8 data[2];
+
+	if (max17058_read_reg(client, MAX17058_REG_VERSION, data) < 0)
+		return;
+
+	dev_dbg(&client->dev, "MAX17058 Fuel-Gauge Ver %d%d\n",
+		data[0], data[1]);
+}
+
+/* soc should be 0.01% unit */
+static int max17058_get_soc(struct i2c_client *client)
+{
+	u8 data[2];
+	int soc;
+
+	if (max17058_read_reg(client, MAX17058_REG_SOC, data) < 0)
+		return -EINVAL;
+
+	soc = ((data[0] * 100) + (data[1] * 100 / 256));
+
+	dev_dbg(&client->dev, "%s: raw capacity (%d)\n", __func__, soc);
+
+	return min(soc, 10000);
+}
+
+static int max17058_get_vcell(struct i2c_client *client)
+{
+	u8 data[2];
+	u32 vcell = 0;
+
+	if (max17058_read_reg(client, MAX17058_REG_VCELL, data) < 0)
+		return -EINVAL;
+
+	vcell = ((data[0] << 8) | data[1]) * 78 / 1000;
+
+	dev_dbg(&client->dev, "%s: vcell (%d)\n", __func__, vcell);
+
+	return vcell;
+}
+
+bool sec_hal_fg_init(struct i2c_client *client)
+{
+	/* initialize fuel gauge registers */
+	max17058_init_regs(client);
+
+	max17058_get_version(client);
+
+	return true;
+}
+
+bool sec_hal_fg_suspend(struct i2c_client *client)
+{
+	return true;
+}
+
+bool sec_hal_fg_resume(struct i2c_client *client)
+{
+	return true;
+}
+
+bool sec_hal_fg_fuelalert_init(struct i2c_client *client, int soc)
+{
+	return true;
+}
+
+bool sec_hal_fg_is_fuelalerted(struct i2c_client *client)
+{
+	u8 data[2];
+
+	max17058_read_reg(client, MAX17058_REG_CONFIG, data);
+	if (data[1] & (1 << 5))
+		return true;
+	else
+		return false;
+}
+
+bool sec_hal_fg_fuelalert_process(void *irq_data, bool is_fuel_alerted)
+{
+	struct sec_fuelgauge_info *fuelgauge = irq_data;
+	u8 data[2];
+
+	if (is_fuel_alerted) {
+		dev_info(&fuelgauge->client->dev,
+			"%s: Fuel-alert Alerted!! (%02x%02x)\n",
+			__func__, data[1], data[0]);
+	} else {
+		dev_info(&fuelgauge->client->dev,
+			"%s: Fuel-alert Released!! (%02x%02x)\n",
+			__func__, data[1], data[0]);
+	}
+
+	max17058_read_reg(fuelgauge->client, MAX17058_REG_VCELL, data);
+	dev_dbg(&fuelgauge->client->dev,
+		"%s: MAX17058_REG_VCELL(%02x%02x)\n",
+		 __func__, data[1], data[0]);
+
+	max17058_read_reg(fuelgauge->client, MAX17058_REG_SOC, data);
+	dev_dbg(&fuelgauge->client->dev,
+		"%s: MAX17058_REG_SOC(%02x%02x)\n",
+		 __func__, data[1], data[0]);
+
+	max17058_read_reg(fuelgauge->client, MAX17058_REG_CONFIG, data);
+	dev_dbg(&fuelgauge->client->dev,
+		"%s: MAX17058_REG_CONFIG(%02x%02x)\n",
+		 __func__, data[1], data[0]);
+
+	dev_dbg(&fuelgauge->client->dev,
+		"%s: FUEL GAUGE IRQ (%d)\n",
+		 __func__,
+		 gpio_get_value(fuelgauge->pdata->fg_irq));
+
+	return true;
+}
+
+bool sec_hal_fg_full_charged(struct i2c_client *client)
+{
+	return true;
+}
+
+bool sec_hal_fg_reset(struct i2c_client *client)
+{
+	u8 data[2];
+
+	if (max17058_read_reg(client, MAX17058_REG_STATUS, data) < 0)
+		return false;
+	data[0] |= (1 << 0);
+	max17058_write_reg(client, MAX17058_REG_STATUS, data);
+
+	if (max17058_read_reg(client, MAX17058_REG_STATUS, data) < 0)
+		return false;
+	data[0] &= ~(1 << 0);
+	max17058_write_reg(client, MAX17058_REG_STATUS, data);
+
+	return true;
+
+}
+
+bool sec_hal_fg_get_property(struct i2c_client *client,
+			     enum power_supply_property psp,
+			     union power_supply_propval *val)
+{
+	switch (psp) {
+		/* Cell voltage (VCELL, mV) */
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = max17058_get_vcell(client);
+		break;
+		/* Additional Voltage Information (mV) */
+	case POWER_SUPPLY_PROP_VOLTAGE_AVG:
+		switch (val->intval) {
+		case SEC_BATTERY_VOLTAGE_AVERAGE:
+			val->intval = 0;
+			break;
+		case SEC_BATTERY_VOLTAGE_OCV:
+			val->intval = 0;
+			break;
+		}
+		break;
+		/* Current (mA) */
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = 0;
+		break;
+	case POWER_SUPPLY_PROP_ENERGY_NOW:
+		val->intval = 0;
+		break;
+		/* Average Current (mA) */
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+		val->intval = 0;
+		break;
+		/* SOC (%) */
+	case POWER_SUPPLY_PROP_CAPACITY:
+		if (val->intval == SEC_FUELGAUGE_CAPACITY_TYPE_RAW)
+			val->intval = max17058_get_soc(client);
+		else
+			val->intval = max17058_get_soc(client) / 10;
+		break;
+		/* Battery Temperature */
+	case POWER_SUPPLY_PROP_TEMP:
+		/* Target Temperature */
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		val->intval = 0;
+		break;
+	default:
+		return false;
+	}
+	return true;
+}
+
+bool sec_hal_fg_set_property(struct i2c_client *client,
+			     enum power_supply_property psp,
+			     const union power_supply_propval *val)
+{
+	switch (psp) {
+		/* Battery Temperature */
+	case POWER_SUPPLY_PROP_TEMP:
+		/* Target Temperature */
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		break;
+	default:
+		return false;
+	}
+	return true;
+}
+
+ssize_t sec_hal_fg_show_attrs(struct device *dev,
+				const ptrdiff_t offset, char *buf)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct sec_fuelgauge_info *fg =
+		container_of(psy, struct sec_fuelgauge_info, psy_fg);
+	int i = 0;
+
+	switch (offset) {
+/*	case FG_REG: */
+/*		break; */
+	case FG_DATA:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%02x%02x\n",
+			fg->reg_data[1], fg->reg_data[0]);
+		break;
+	default:
+		i = -EINVAL;
+		break;
+	}
+
+	return i;
+}
+
+ssize_t sec_hal_fg_store_attrs(struct device *dev,
+				const ptrdiff_t offset,
+				const char *buf, size_t count)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct sec_fuelgauge_info *fg =
+		container_of(psy, struct sec_fuelgauge_info, psy_fg);
+	int ret = 0;
+	int x = 0;
+	u8 data[2];
+
+	switch (offset) {
+	case FG_REG:
+		if (sscanf(buf, "%x\n", &x) == 1) {
+			fg->reg_addr = x;
+			max17058_read_reg(fg->client,
+				fg->reg_addr, fg->reg_data);
+			dev_dbg(&fg->client->dev,
+				"%s: (read) addr = 0x%x, data = 0x%02x%02x\n",
+				 __func__, fg->reg_addr,
+				 fg->reg_data[1], fg->reg_data[0]);
+			ret = count;
+		}
+		break;
+	case FG_DATA:
+		if (sscanf(buf, "%x\n", &x) == 1) {
+			data[0] = (x & 0xFF00) >> 8;
+			data[1] = (x & 0x00FF);
+			dev_dbg(&fg->client->dev,
+				"%s: (write) addr = 0x%x, data = 0x%02x%02x\n",
+				__func__, fg->reg_addr, data[1], data[0]);
+			max17058_write_reg(fg->client,
+				fg->reg_addr, data);
+			ret = count;
+		}
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
diff -Naur linux-3.18.14/drivers/power/power_supply_core.c samsung/drivers/power/power_supply_core.c
--- linux-3.18.14/drivers/power/power_supply_core.c	2015-05-20 17:04:50.000000000 +0200
+++ samsung/drivers/power/power_supply_core.c	2018-10-29 07:24:39.000000000 +0100
@@ -15,7 +15,6 @@
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/device.h>
-#include <linux/notifier.h>
 #include <linux/err.h>
 #include <linux/power_supply.h>
 #include <linux/thermal.h>
@@ -25,9 +24,6 @@
 struct class *power_supply_class;
 EXPORT_SYMBOL_GPL(power_supply_class);
 
-ATOMIC_NOTIFIER_HEAD(power_supply_notifier);
-EXPORT_SYMBOL_GPL(power_supply_notifier);
-
 static struct device_type power_supply_dev_type;
 
 static bool __power_supply_is_supplied_by(struct power_supply *supplier,
@@ -58,7 +54,7 @@
 
 static int __power_supply_changed_work(struct device *dev, void *data)
 {
-	struct power_supply *psy = data;
+	struct power_supply *psy = (struct power_supply *)data;
 	struct power_supply *pst = dev_get_drvdata(dev);
 
 	if (__power_supply_is_supplied_by(psy, pst)) {
@@ -78,31 +74,19 @@
 	dev_dbg(psy->dev, "%s\n", __func__);
 
 	spin_lock_irqsave(&psy->changed_lock, flags);
-	/*
-	 * Check 'changed' here to avoid issues due to race between
-	 * power_supply_changed() and this routine. In worst case
-	 * power_supply_changed() can be called again just before we take above
-	 * lock. During the first call of this routine we will mark 'changed' as
-	 * false and it will stay false for the next call as well.
-	 */
-	if (likely(psy->changed)) {
+	if (psy->changed) {
 		psy->changed = false;
 		spin_unlock_irqrestore(&psy->changed_lock, flags);
+
 		class_for_each_device(power_supply_class, NULL, psy,
 				      __power_supply_changed_work);
+
 		power_supply_update_leds(psy);
-		atomic_notifier_call_chain(&power_supply_notifier,
-				PSY_EVENT_PROP_CHANGED, psy);
+
 		kobject_uevent(&psy->dev->kobj, KOBJ_CHANGE);
 		spin_lock_irqsave(&psy->changed_lock, flags);
 	}
-
-	/*
-	 * Hold the wakeup_source until all events are processed.
-	 * power_supply_changed() might have called again and have set 'changed'
-	 * to true.
-	 */
-	if (likely(!psy->changed))
+	if (!psy->changed)
 		pm_relax(psy->dev);
 	spin_unlock_irqrestore(&psy->changed_lock, flags);
 }
@@ -127,7 +111,7 @@
 static int __power_supply_populate_supplied_from(struct device *dev,
 						 void *data)
 {
-	struct power_supply *psy = data;
+	struct power_supply *psy = (struct power_supply *)data;
 	struct power_supply *epsy = dev_get_drvdata(dev);
 	struct device_node *np;
 	int i = 0;
@@ -135,17 +119,15 @@
 	do {
 		np = of_parse_phandle(psy->of_node, "power-supplies", i++);
 		if (!np)
-			break;
+			continue;
 
 		if (np == epsy->of_node) {
 			dev_info(psy->dev, "%s: Found supply : %s\n",
 				psy->name, epsy->name);
 			psy->supplied_from[i-1] = (char *)epsy->name;
 			psy->num_supplies++;
-			of_node_put(np);
 			break;
 		}
-		of_node_put(np);
 	} while (np);
 
 	return 0;
@@ -166,12 +148,12 @@
 static int  __power_supply_find_supply_from_node(struct device *dev,
 						 void *data)
 {
-	struct device_node *np = data;
+	struct device_node *np = (struct device_node *)data;
 	struct power_supply *epsy = dev_get_drvdata(dev);
 
-	/* returning non-zero breaks out of class_for_each_device loop */
+	/* return error breaks out of class_for_each_device loop */
 	if (epsy->of_node == np)
-		return 1;
+		return -EINVAL;
 
 	return 0;
 }
@@ -179,21 +161,30 @@
 static int power_supply_find_supply_from_node(struct device_node *supply_node)
 {
 	int error;
+	struct device *dev;
+	struct class_dev_iter iter;
+
+	/*
+	 * Use iterator to see if any other device is registered.
+	 * This is required since class_for_each_device returns 0
+	 * if there are no devices registered.
+	 */
+	class_dev_iter_init(&iter, power_supply_class, NULL, NULL);
+	dev = class_dev_iter_next(&iter);
+
+	if (!dev)
+		return -EPROBE_DEFER;
 
 	/*
-	 * class_for_each_device() either returns its own errors or values
-	 * returned by __power_supply_find_supply_from_node().
-	 *
-	 * __power_supply_find_supply_from_node() will return 0 (no match)
-	 * or 1 (match).
-	 *
-	 * We return 0 if class_for_each_device() returned 1, -EPROBE_DEFER if
-	 * it returned 0, or error as returned by it.
+	 * We have to treat the return value as inverted, because if
+	 * we return error on not found, then it won't continue looking.
+	 * So we trick it by returning error on success to stop looking
+	 * once the matching device is found.
 	 */
 	error = class_for_each_device(power_supply_class, NULL, supply_node,
 				       __power_supply_find_supply_from_node);
 
-	return error ? (error == 1 ? 0 : error) : -EPROBE_DEFER;
+	return error ? 0 : -EPROBE_DEFER;
 }
 
 static int power_supply_check_supplies(struct power_supply *psy)
@@ -214,21 +205,15 @@
 
 		np = of_parse_phandle(psy->of_node, "power-supplies", cnt++);
 		if (!np)
-			break;
+			continue;
 
 		ret = power_supply_find_supply_from_node(np);
-		of_node_put(np);
-
 		if (ret) {
-			dev_dbg(psy->dev, "Failed to find supply!\n");
-			return ret;
+			dev_dbg(psy->dev, "Failed to find supply, defer!\n");
+			return -EPROBE_DEFER;
 		}
 	} while (np);
 
-	/* Missing valid "power-supplies" entries */
-	if (cnt == 1)
-		return 0;
-
 	/* All supplies found, allocate char ** array for filling */
 	psy->supplied_from = devm_kzalloc(psy->dev, sizeof(psy->supplied_from),
 					  GFP_KERNEL);
@@ -237,7 +222,7 @@
 		return -ENOMEM;
 	}
 
-	*psy->supplied_from = devm_kzalloc(psy->dev, sizeof(char *) * (cnt - 1),
+	*psy->supplied_from = devm_kzalloc(psy->dev, sizeof(char *) * cnt,
 					   GFP_KERNEL);
 	if (!*psy->supplied_from) {
 		dev_err(psy->dev, "Couldn't allocate memory for supply list\n");
@@ -256,12 +241,14 @@
 static int __power_supply_am_i_supplied(struct device *dev, void *data)
 {
 	union power_supply_propval ret = {0,};
-	struct power_supply *psy = data;
+	struct power_supply *psy = (struct power_supply *)data;
 	struct power_supply *epsy = dev_get_drvdata(dev);
 
 	if (__power_supply_is_supplied_by(epsy, psy))
-		if (!epsy->get_property(epsy, POWER_SUPPLY_PROP_ONLINE, &ret))
-			return ret.intval;
+		if (!epsy->get_property(epsy, POWER_SUPPLY_PROP_ONLINE, &ret)) {
+			if (ret.intval)
+				return ret.intval;
+		}
 
 	return 0;
 }
@@ -286,10 +273,12 @@
 	unsigned int *count = data;
 
 	(*count)++;
-	if (psy->type != POWER_SUPPLY_TYPE_BATTERY)
-		if (!psy->get_property(psy, POWER_SUPPLY_PROP_ONLINE, &ret))
+	if (psy->type != POWER_SUPPLY_TYPE_BATTERY) {
+		if (psy->get_property(psy, POWER_SUPPLY_PROP_ONLINE, &ret))
+			return 0;
+		if (ret.intval)
 			return ret.intval;
-
+	}
 	return 0;
 }
 
@@ -340,32 +329,6 @@
 }
 EXPORT_SYMBOL_GPL(power_supply_get_by_name);
 
-#ifdef CONFIG_OF
-static int power_supply_match_device_node(struct device *dev, const void *data)
-{
-	return dev->parent && dev->parent->of_node == data;
-}
-
-struct power_supply *power_supply_get_by_phandle(struct device_node *np,
-							const char *property)
-{
-	struct device_node *power_supply_np;
-	struct device *dev;
-
-	power_supply_np = of_parse_phandle(np, property, 0);
-	if (!power_supply_np)
-		return ERR_PTR(-ENODEV);
-
-	dev = class_find_device(power_supply_class, NULL, power_supply_np,
-						power_supply_match_device_node);
-
-	of_node_put(power_supply_np);
-
-	return dev ? dev_get_drvdata(dev) : NULL;
-}
-EXPORT_SYMBOL_GPL(power_supply_get_by_phandle);
-#endif /* CONFIG_OF */
-
 int power_supply_powers(struct power_supply *psy, struct device *dev)
 {
 	return sysfs_create_link(&psy->dev->kobj, &dev->kobj, "powers");
@@ -378,19 +341,7 @@
 	kfree(dev);
 }
 
-int power_supply_reg_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_register(&power_supply_notifier, nb);
-}
-EXPORT_SYMBOL_GPL(power_supply_reg_notifier);
-
-void power_supply_unreg_notifier(struct notifier_block *nb)
-{
-	atomic_notifier_chain_unregister(&power_supply_notifier, nb);
-}
-EXPORT_SYMBOL_GPL(power_supply_unreg_notifier);
-
-#ifdef CONFIG_THERMAL
+#if defined(CONFIG_THERMAL) && !defined(CONFIG_SOC_EXYNOS7580) && !defined(CONFIG_SOC_EXYNOS7870)
 static int power_supply_read_temp(struct thermal_zone_device *tzd,
 		unsigned long *temp)
 {
@@ -417,15 +368,14 @@
 {
 	int i;
 
-	if (psy->no_thermal)
-		return 0;
-
 	/* Register battery zone device psy reports temperature */
 	for (i = 0; i < psy->num_properties; i++) {
 		if (psy->properties[i] == POWER_SUPPLY_PROP_TEMP) {
 			psy->tzd = thermal_zone_device_register(psy->name, 0, 0,
 					psy, &psy_tzd_ops, NULL, 0, 0);
-			return PTR_ERR_OR_ZERO(psy->tzd);
+			if (IS_ERR(psy->tzd))
+				return PTR_ERR(psy->tzd);
+			break;
 		}
 	}
 	return 0;
@@ -503,7 +453,9 @@
 			psy->tcd = thermal_cooling_device_register(
 							(char *)psy->name,
 							psy, &psy_tcd_ops);
-			return PTR_ERR_OR_ZERO(psy->tcd);
+			if (IS_ERR(psy->tcd))
+				return PTR_ERR(psy->tcd);
+			break;
 		}
 	}
 	return 0;
@@ -535,8 +487,7 @@
 }
 #endif
 
-static int __power_supply_register(struct device *parent,
-				   struct power_supply *psy, bool ws)
+int power_supply_register(struct device *parent, struct power_supply *psy)
 {
 	struct device *dev;
 	int rc;
@@ -554,10 +505,6 @@
 	dev_set_drvdata(dev, psy);
 	psy->dev = dev;
 
-	rc = dev_set_name(dev, "%s", psy->name);
-	if (rc)
-		goto dev_set_name_failed;
-
 	INIT_WORK(&psy->changed_work, power_supply_changed_work);
 
 	rc = power_supply_check_supplies(psy);
@@ -566,15 +513,19 @@
 		goto check_supplies_failed;
 	}
 
-	spin_lock_init(&psy->changed_lock);
-	rc = device_init_wakeup(dev, ws);
+	rc = kobject_set_name(&dev->kobj, "%s", psy->name);
 	if (rc)
-		goto wakeup_init_failed;
+		goto kobject_set_name_failed;
 
 	rc = device_add(dev);
 	if (rc)
 		goto device_add_failed;
 
+	spin_lock_init(&psy->changed_lock);
+	rc = device_init_wakeup(dev, true);
+	if (rc)
+		goto wakeup_init_failed;
+
 	rc = psy_register_thermal(psy);
 	if (rc)
 		goto register_thermal_failed;
@@ -589,34 +540,24 @@
 
 	power_supply_changed(psy);
 
-	return 0;
+	goto success;
 
 create_triggers_failed:
 	psy_unregister_cooler(psy);
 register_cooler_failed:
 	psy_unregister_thermal(psy);
 register_thermal_failed:
+wakeup_init_failed:
 	device_del(dev);
+kobject_set_name_failed:
 device_add_failed:
-wakeup_init_failed:
 check_supplies_failed:
-dev_set_name_failed:
 	put_device(dev);
+success:
 	return rc;
 }
-
-int power_supply_register(struct device *parent, struct power_supply *psy)
-{
-	return __power_supply_register(parent, psy, true);
-}
 EXPORT_SYMBOL_GPL(power_supply_register);
 
-int power_supply_register_no_ws(struct device *parent, struct power_supply *psy)
-{
-	return __power_supply_register(parent, psy, false);
-}
-EXPORT_SYMBOL_GPL(power_supply_register_no_ws);
-
 void power_supply_unregister(struct power_supply *psy)
 {
 	cancel_work_sync(&psy->changed_work);
@@ -624,7 +565,6 @@
 	power_supply_remove_triggers(psy);
 	psy_unregister_cooler(psy);
 	psy_unregister_thermal(psy);
-	device_init_wakeup(psy->dev, false);
 	device_unregister(psy->dev);
 }
 EXPORT_SYMBOL_GPL(power_supply_unregister);
diff -Naur linux-3.18.14/drivers/power/power_supply_sysfs.c samsung/drivers/power/power_supply_sysfs.c
--- linux-3.18.14/drivers/power/power_supply_sysfs.c	2015-05-20 17:04:50.000000000 +0200
+++ samsung/drivers/power/power_supply_sysfs.c	2018-10-29 07:24:39.000000000 +0100
@@ -45,18 +45,28 @@
 					  char *buf) {
 	static char *type_text[] = {
 		"Unknown", "Battery", "UPS", "Mains", "USB",
-		"USB_DCP", "USB_CDP", "USB_ACA"
+		"USB_DCP", "USB_CDP", "USB_ACA", "BMS", "MISC",
+		"Wireless", "HV_Wireless", "PMA_Wireless", "CARDOCK", "UARTOFF", "OTG", "LAN_HUB",
+		"MHL_500", "MHL_900", "MHL_1500", "MHL_USB",
+		"SMART_OTG", "SMART_NOTG", "POWER_SHARING",
+		"HV_Mains", "HV_Mains_12V", "HV_Prepare_Mains", "HV_ERR", "MHL_USB_100", "MHL_2000",
+		"HV_Unknown", "MDOCK_TA", "HMT_CONNECTED", "HMT_CHARGE", 
+		"Wireless_Pack", "Wireless_Pack_TA",
+#if defined(CONFIG_BATTERY_SAMSUNG_V2)
+		"Wireless_Stand", "HV_Wireless_Stand", "PDIC", "HV_Mains_CHG_LIMIT", "HV_QC20", "HV_QC30"
+#endif
 	};
 	static char *status_text[] = {
 		"Unknown", "Charging", "Discharging", "Not charging", "Full"
 	};
 	static char *charge_type[] = {
-		"Unknown", "N/A", "Trickle", "Fast"
+		"Unknown", "N/A", "Trickle", "Fast", "Slow"
 	};
 	static char *health_text[] = {
-		"Unknown", "Good", "Overheat", "Dead", "Over voltage",
-		"Unspecified failure", "Cold", "Watchdog timer expire",
-		"Safety timer expire"
+		"Unknown", "Good", "Overheat", "Warm", "Dead", "Over voltage",
+		"Unspecified failure", "Cold", "Cool",
+		"Watchdog timer expire", "Safety timer expire",
+		"Under voltage", "OverheatLimit"
 	};
 	static char *technology_text[] = {
 		"Unknown", "NiMH", "Li-ion", "Li-poly", "LiFe", "NiCd",
@@ -106,7 +116,10 @@
 	else if (off >= POWER_SUPPLY_PROP_MODEL_NAME)
 		return sprintf(buf, "%s\n", value.strval);
 
-	return sprintf(buf, "%d\n", value.intval);
+	if (off == POWER_SUPPLY_PROP_CHARGE_COUNTER_EXT)
+		return sprintf(buf, "%lld\n", value.int64val);
+	else
+		return sprintf(buf, "%d\n", value.intval);
 }
 
 static ssize_t power_supply_store_property(struct device *dev,
@@ -141,6 +154,7 @@
 	POWER_SUPPLY_ATTR(present),
 	POWER_SUPPLY_ATTR(online),
 	POWER_SUPPLY_ATTR(authentic),
+	POWER_SUPPLY_ATTR(charging_enabled),
 	POWER_SUPPLY_ATTR(technology),
 	POWER_SUPPLY_ATTR(cycle_count),
 	POWER_SUPPLY_ATTR(voltage_max),
@@ -150,13 +164,18 @@
 	POWER_SUPPLY_ATTR(voltage_now),
 	POWER_SUPPLY_ATTR(voltage_avg),
 	POWER_SUPPLY_ATTR(voltage_ocv),
-	POWER_SUPPLY_ATTR(voltage_boot),
+	POWER_SUPPLY_ATTR(input_voltage_regulation),
 	POWER_SUPPLY_ATTR(current_max),
+	POWER_SUPPLY_ATTR(input_current_max),
 	POWER_SUPPLY_ATTR(current_now),
 	POWER_SUPPLY_ATTR(current_avg),
-	POWER_SUPPLY_ATTR(current_boot),
+	POWER_SUPPLY_ATTR(current_full),
+	POWER_SUPPLY_ATTR(power_design),
 	POWER_SUPPLY_ATTR(power_now),
 	POWER_SUPPLY_ATTR(power_avg),
+#if defined(CONFIG_BATTERY_SAMSUNG_V2)
+	POWER_SUPPLY_ATTR(filter_cfg),
+#endif
 	POWER_SUPPLY_ATTR(charge_full_design),
 	POWER_SUPPLY_ATTR(charge_empty_design),
 	POWER_SUPPLY_ATTR(charge_full),
@@ -164,13 +183,16 @@
 	POWER_SUPPLY_ATTR(charge_now),
 	POWER_SUPPLY_ATTR(charge_avg),
 	POWER_SUPPLY_ATTR(charge_counter),
+	POWER_SUPPLY_ATTR(charge_otg_control),
+	POWER_SUPPLY_ATTR(charge_powered_otg_control),
+	POWER_SUPPLY_ATTR(charge_uno_control),
 	POWER_SUPPLY_ATTR(constant_charge_current),
 	POWER_SUPPLY_ATTR(constant_charge_current_max),
 	POWER_SUPPLY_ATTR(constant_charge_voltage),
 	POWER_SUPPLY_ATTR(constant_charge_voltage_max),
 	POWER_SUPPLY_ATTR(charge_control_limit),
 	POWER_SUPPLY_ATTR(charge_control_limit_max),
-	POWER_SUPPLY_ATTR(input_current_limit),
+	POWER_SUPPLY_ATTR(charge_counter_shadow),
 	POWER_SUPPLY_ATTR(energy_full_design),
 	POWER_SUPPLY_ATTR(energy_empty_design),
 	POWER_SUPPLY_ATTR(energy_full),
@@ -182,10 +204,10 @@
 	POWER_SUPPLY_ATTR(capacity_alert_max),
 	POWER_SUPPLY_ATTR(capacity_level),
 	POWER_SUPPLY_ATTR(temp),
-	POWER_SUPPLY_ATTR(temp_max),
-	POWER_SUPPLY_ATTR(temp_min),
 	POWER_SUPPLY_ATTR(temp_alert_min),
 	POWER_SUPPLY_ATTR(temp_alert_max),
+	POWER_SUPPLY_ATTR(temp_cool),
+	POWER_SUPPLY_ATTR(temp_warm),
 	POWER_SUPPLY_ATTR(temp_ambient),
 	POWER_SUPPLY_ATTR(temp_ambient_alert_min),
 	POWER_SUPPLY_ATTR(temp_ambient_alert_max),
@@ -195,12 +217,25 @@
 	POWER_SUPPLY_ATTR(time_to_full_avg),
 	POWER_SUPPLY_ATTR(type),
 	POWER_SUPPLY_ATTR(scope),
-	POWER_SUPPLY_ATTR(charge_term_current),
-	POWER_SUPPLY_ATTR(calibrate),
+	POWER_SUPPLY_ATTR(system_temp_level),
+	POWER_SUPPLY_ATTR(resistance),
+	/* Local extensions */
+	POWER_SUPPLY_ATTR(usb_otg),
+	POWER_SUPPLY_ATTR(charge_enabled),
+	/* Local extensions of type int64_t */
+	POWER_SUPPLY_ATTR(charge_counter_ext),
 	/* Properties of type `const char *' */
-	POWER_SUPPLY_ATTR(model_name),
 	POWER_SUPPLY_ATTR(manufacturer),
 	POWER_SUPPLY_ATTR(serial_number),
+	POWER_SUPPLY_ATTR(afc_charger_mode),
+	POWER_SUPPLY_ATTR(usb_hc),
+	POWER_SUPPLY_ATTR(model_name),
+	POWER_SUPPLY_ATTR(fuelgauge_factory),
+	POWER_SUPPLY_ATTR(current_measure),
+	POWER_SUPPLY_ATTR(factory_voltage_regulation),
+#if !defined(CONFIG_BATTERY_SAMSUNG_V2)
+	POWER_SUPPLY_ATTR(inbat_voltage_fgsrc_switchg),
+#endif
 };
 
 static struct attribute *
diff -Naur linux-3.18.14/drivers/power/s2mu003_charger.c samsung/drivers/power/s2mu003_charger.c
--- linux-3.18.14/drivers/power/s2mu003_charger.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/power/s2mu003_charger.c	2018-10-29 07:24:39.000000000 +0100
@@ -0,0 +1,1781 @@
+/*
+ * S2MU003 Charger Driver
+ *
+ * Copyright (c) 2015 Samsung Electronics Co., Ltd.
+ *		http://www.samsung.com
+ * Author: Junhan Bae <junhan84.bae@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ */
+
+#include <linux/mfd/samsung/s2mu003.h>
+#include <linux/power/s2mu003_charger.h>
+#include <linux/version.h>
+#include <linux/iio/consumer.h>
+
+#if defined(CONFIG_MUIC_NOTIFIER)
+#include <linux/muic/muic.h>
+#include <linux/muic/muic_notifier.h>
+#endif
+
+#define ENABLE_MIVR 1
+
+#define EN_OVP_IRQ 1
+#define EN_IEOC_IRQ 1
+#define EN_TOPOFF_IRQ 1
+#define EN_BATP_IRQ 1
+#define EN_RECHG_REQ_IRQ 1
+#define EN_TR_IRQ 0
+#define EN_MIVR_SW_REGULATION 0
+#define EN_BST_IRQ 0
+#define MINVAL(a, b) ((a <= b) ? a : b)
+
+#define EOC_DEBOUNCE_CNT 2
+#define HEALTH_DEBOUNCE_CNT 3
+
+#define EOC_SLEEP 200
+#define EOC_TIMEOUT (EOC_SLEEP * 6)
+#ifndef EN_TEST_READ
+#define EN_TEST_READ 0
+#endif
+
+#define MAX_FG_CHECK 100000
+
+struct s2mu003_charger_data {
+	struct i2c_client	*client;
+	struct device		*dev;
+	s2mu003_mfd_chip_t	*s2mu003;
+	struct delayed_work	charger_work;
+	struct workqueue_struct	*charger_wqueue;
+	struct power_supply	psy_chg;
+	struct power_supply	psy_battery;
+	struct power_supply	psy_usb;
+	struct power_supply	psy_ac;
+	s2mu003_charger_platform_data_t *pdata;
+	int charging_current;
+	int siop_level;
+	int cable_type;
+	int battery_cable_type;
+	bool is_charging;
+	struct mutex io_lock;
+	bool noti_check;
+	bool adc_check;
+	int rev_id;
+
+	/* register programming */
+	int reg_addr;
+	int reg_data;
+
+	bool full_charged;
+	bool ovp;
+	bool battery_valid;
+	int unhealth_cnt;
+	int status;
+	int health;
+	struct delayed_work polling_work;
+#if defined(CONFIG_SEC_FUELGAUGE_S2MU003)
+	int voltage_now;
+	int voltage_avg;
+	int voltage_ocv;
+	unsigned int capacity;
+	int temp_val;
+#endif
+#if defined(CONFIG_MUIC_NOTIFIER)
+	struct notifier_block cable_check;
+#endif
+	struct iio_channel *adc_val;
+};
+
+static char *s2mu003_supplied_to[] = {
+	"s2mu003-battery",
+};
+
+static enum power_supply_property s2mu003_power_props[] = {
+	POWER_SUPPLY_PROP_ONLINE,
+};
+
+static enum power_supply_property s2mu003_charger_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_CHARGE_TYPE,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_CURRENT_MAX,
+	POWER_SUPPLY_PROP_CURRENT_AVG,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL,
+};
+
+static enum power_supply_property s2mu003_battery_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_CHARGE_TYPE,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
+	POWER_SUPPLY_PROP_CHARGE_FULL,
+	POWER_SUPPLY_PROP_CHARGE_NOW,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_CAPACITY_LEVEL,
+	POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG,
+	POWER_SUPPLY_PROP_TIME_TO_FULL_NOW,
+	POWER_SUPPLY_PROP_MODEL_NAME,
+	POWER_SUPPLY_PROP_MANUFACTURER,
+	POWER_SUPPLY_PROP_SERIAL_NUMBER,
+	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+};
+
+static int s2mu003_get_charging_health(struct s2mu003_charger_data *charger);
+
+static void s2mu003_test_read(struct i2c_client *i2c)
+{
+	int data;
+	char str[1024] = {0,};
+	int i;
+
+	/* S2MU003 REG: 0x00 ~ 0x0E */
+	for (i = 0x0; i <= 0x0E; i++) {
+		data = s2mu003_reg_read(i2c, i);
+		snprintf(str+strlen(str), sizeof(str) - strlen(str),
+						  "0x%02x, ", data);
+	}
+
+	pr_info("%s: %s\n", __func__, str);
+}
+
+static void s2mu003_enable_charging_termination(struct i2c_client *i2c,
+		int onoff)
+{
+	pr_info("%s:[BATT] Do termination set(%d)\n", __func__, onoff);
+
+	if (onoff)
+		s2mu003_set_bits(i2c, S2MU003_CHG_CTRL1, S2MU003_TEEN_MASK);
+	else
+		s2mu003_clr_bits(i2c, S2MU003_CHG_CTRL1, S2MU003_TEEN_MASK);
+}
+
+static int s2mu003_input_current_limit[] = {
+	100,
+	500,
+	700,
+	900,
+	1000,
+	1500,
+	2000,
+};
+
+static void s2mu003_set_input_current_limit(
+		struct s2mu003_charger_data *charger, int current_limit)
+{
+	int i, curr_reg = 0, curr_limit = 0;
+
+	for (i = 0; i < ARRAY_SIZE(s2mu003_input_current_limit); i++) {
+		if (current_limit <= s2mu003_input_current_limit[i]) {
+			curr_reg = i + 1;
+			break;
+		}
+	}
+
+	if (charger->rev_id == 0xB) {
+		curr_limit = current_limit >= 1500 ? 0xA : 0x0;
+		s2mu003_assign_bits(charger->client, 0x92, 0xF, curr_limit);
+	}
+
+	mutex_lock(&charger->io_lock);
+	s2mu003_assign_bits(charger->client, S2MU003_CHG_CTRL1,
+		S2MU003_AICR_LIMIT_MASK, curr_reg << S2MU003_AICR_LIMIT_SHIFT);
+	mutex_unlock(&charger->io_lock);
+}
+
+static int s2mu003_get_input_current_limit(struct i2c_client *i2c)
+{
+	int ret = s2mu003_reg_read(i2c, S2MU003_CHG_CTRL1);
+
+	if (ret < 0)
+		return ret;
+
+	ret &= S2MU003_AICR_LIMIT_MASK;
+	ret >>= S2MU003_AICR_LIMIT_SHIFT;
+	if (ret == 0)
+		return 2000 + 1; /* no limitation */
+
+	return s2mu003_input_current_limit[ret - 1];
+}
+
+static void s2mu003_set_regulation_voltage(struct s2mu003_charger_data *charger,
+					   int float_voltage)
+{
+	int data;
+
+	if (float_voltage < 3650)
+		data = 0;
+	else if (float_voltage >= 3650 && float_voltage <= 4375)
+		data = (float_voltage - 3650) / 25;
+	else
+		data = 0x37;
+
+	mutex_lock(&charger->io_lock);
+	s2mu003_assign_bits(charger->client,
+			S2MU003_CHG_CTRL2, S2MU003_VOREG_MASK,
+			data << S2MU003_VOREG_SHIFT);
+	mutex_unlock(&charger->io_lock);
+}
+
+static void s2mu003_set_fast_charging_current(struct i2c_client *i2c,
+					      int charging_current)
+{
+	int data;
+
+	if (charging_current < 700)
+		data = 0;
+	else if (charging_current >= 700 && charging_current <= 2000)
+		data = (charging_current - 700) / 100;
+	else
+		data = 0xd;
+
+	s2mu003_assign_bits(i2c, S2MU003_CHG_CTRL5, S2MU003_ICHRG_MASK,
+			data << S2MU003_ICHRG_SHIFT);
+}
+
+static int s2mu003_eoc_level[] = {
+	0,
+	150,
+	200,
+	250,
+	300,
+	400,
+	500,
+	600,
+};
+
+static int s2mu003_get_eoc_level(int eoc_current)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(s2mu003_eoc_level); i++) {
+		if (eoc_current < s2mu003_eoc_level[i]) {
+			if (i == 0)
+				return 0;
+			return i - 1;
+		}
+	}
+
+	return ARRAY_SIZE(s2mu003_eoc_level) - 1;
+}
+
+static int s2mu003_get_current_eoc_setting(struct s2mu003_charger_data *charger)
+{
+	int ret;
+
+	mutex_lock(&charger->io_lock);
+	ret = s2mu003_reg_read(charger->client, S2MU003_CHG_CTRL4);
+	mutex_unlock(&charger->io_lock);
+
+	if (ret < 0) {
+		pr_info("%s: warning --> fail to read i2c register(%d)\n",
+							__func__, ret);
+		return ret;
+	}
+	return s2mu003_eoc_level[(S2MU003_IEOC_MASK & ret)
+					>> S2MU003_IEOC_SHIFT];
+}
+
+static int s2mu003_get_fast_charging_current(struct i2c_client *i2c)
+{
+	int data = s2mu003_reg_read(i2c, S2MU003_CHG_CTRL5);
+
+	if (data < 0)
+		return data;
+
+	data = (data >> 4) & 0x0f;
+
+	if (data > 0xd)
+		data = 0xd;
+
+	return data * 100 + 700;
+}
+
+static void s2mu003_set_termination_current_limit(struct i2c_client *i2c,
+						  int current_limit)
+{
+	int data = s2mu003_get_eoc_level(current_limit);
+
+	pr_info("%s : Set Termination\n", __func__);
+
+	s2mu003_assign_bits(i2c, S2MU003_CHG_CTRL4, S2MU003_IEOC_MASK,
+			    data << S2MU003_IEOC_SHIFT);
+}
+/* eoc re set */
+static void s2mu003_set_charging_current(struct s2mu003_charger_data *charger,
+		int eoc)
+{
+	int adj_current;
+
+	adj_current = charger->charging_current * charger->siop_level / 100;
+
+	mutex_lock(&charger->io_lock);
+	s2mu003_set_fast_charging_current(charger->client, adj_current);
+	if (eoc) /* set EOC RESET */
+		s2mu003_set_termination_current_limit(charger->client, eoc);
+	mutex_unlock(&charger->io_lock);
+}
+
+enum {
+	S2MU003_MIVR_DISABLE = 0,
+	S2MU003_MIVR_4200MV,
+	S2MU003_MIVR_4300MV,
+	S2MU003_MIVR_4400MV,
+	S2MU003_MIVR_4500MV,
+	S2MU003_MIVR_4600MV,
+	S2MU003_MIVR_4700MV,
+	S2MU003_MIVR_4800MV,
+};
+
+#if ENABLE_MIVR
+/* charger input regulation voltage setting */
+static void s2mu003_set_mivr_level(struct s2mu003_charger_data *charger)
+{
+	int mivr = S2MU003_MIVR_4600MV;
+
+	mutex_lock(&charger->io_lock);
+	s2mu003_assign_bits(charger->client, S2MU003_CHG_CTRL4,
+			S2MU003_MIVR_MASK, mivr << S2MU003_MIVR_SHIFT);
+	mutex_unlock(&charger->io_lock);
+}
+#endif /*ENABLE_MIVR*/
+
+static void s2mu003_charger_otg_control(struct s2mu003_charger_data *charger,
+					bool enable)
+{
+	pr_info("%s: called charger otg control : %s\n", __func__,
+			enable ? "on" : "off");
+
+	if (!enable) {
+		/* turn off OTG */
+		s2mu003_clr_bits(charger->client, S2MU003_CHG_CTRL8, 0x80);
+		s2mu003_set_bits(charger->client, S2MU003_CHG_CTRL1,
+						    S2MU003_SEL_SWFREQ_MASK);
+		s2mu003_clr_bits(charger->client,
+			S2MU003_CHG_CTRL1, S2MU003_OPAMODE_MASK);
+	} else {
+		/* Set OTG boost vout = 5V, turn on OTG */
+		s2mu003_assign_bits(charger->client,
+				S2MU003_CHG_CTRL2, S2MU003_VOREG_MASK,
+				0x37 << S2MU003_VOREG_SHIFT);
+		s2mu003_set_bits(charger->client,
+				S2MU003_CHG_CTRL1, S2MU003_OPAMODE_MASK);
+		s2mu003_clr_bits(charger->client, S2MU003_CHG_CTRL1,
+						    S2MU003_SEL_SWFREQ_MASK);
+		s2mu003_set_bits(charger->client, S2MU003_CHG_CTRL8, 0x80);
+		charger->cable_type = POWER_SUPPLY_TYPE_OTG;
+	}
+}
+
+/* this function will work well on CHIP_REV = 3 or later */
+static void s2mu003_enable_charger_switch(struct s2mu003_charger_data *charger,
+					  int onoff)
+{
+	int prev_charging_status = charger->is_charging;
+	union power_supply_propval val;
+
+	charger->is_charging = onoff ? true : false;
+	if ((onoff > 0) && (prev_charging_status == false)) {
+		pr_info("%s: turn on charger\n", __func__);
+		s2mu003_set_bits(charger->client,
+			S2MU003_CHG_CTRL3, S2MU003_CHG_EN_MASK);
+	} else if (onoff == 0) {
+		psy_do_property("battery", get,
+				POWER_SUPPLY_PROP_STATUS, val);
+		if (val.intval != POWER_SUPPLY_STATUS_FULL)
+			charger->full_charged = false;
+		pr_info("%s: turn off charger\n", __func__);
+		charger->charging_current = 1700;
+		s2mu003_set_input_current_limit(charger, 500);
+		s2mu003_set_charging_current(charger, 250);
+		charger->charging_current = 0;
+	} else {
+		pr_info("%s: repeated to set charger switch(%d), prev stat = %d\n",
+				__func__, onoff, prev_charging_status ? 1 : 0);
+	}
+}
+
+static void s2mu003_configure_charger(struct s2mu003_charger_data *charger)
+{
+	int eoc;
+	union power_supply_propval val;
+
+	pr_info("%s : Set config charging\n", __func__);
+	if (charger->charging_current < 0) {
+		pr_info("%s : OTG is activated. Ignore command!\n",
+				__func__);
+		return;
+	}
+
+	s2mu003_clr_bits(charger->client,
+			S2MU003_CHG_CTRL3, S2MU003_CHG_EN_MASK);
+#if ENABLE_MIVR
+	s2mu003_set_mivr_level(charger);
+#endif /*DISABLE_MIVR*/
+	psy_do_property("battery", get,
+			POWER_SUPPLY_PROP_CHARGE_NOW, val);
+
+	/* Input current limit */
+	pr_info("%s : input current (%dmA)\n",
+			__func__, charger->pdata->charging_current_table
+			[charger->cable_type].input_current_limit);
+
+	s2mu003_set_input_current_limit(charger,
+			charger->pdata->charging_current_table
+			[charger->cable_type].input_current_limit);
+
+	/* Float voltage */
+	pr_info("%s : float voltage (%dmV)\n",
+			__func__, charger->pdata->chg_float_voltage);
+
+	s2mu003_set_regulation_voltage(charger,
+			charger->pdata->chg_float_voltage);
+
+	charger->charging_current = charger->pdata->charging_current_table
+		[charger->cable_type].fast_charging_current;
+	eoc = charger->pdata->charging_current_table
+		[charger->cable_type].full_check_current_1st;
+	/* Fast charge and Termination current */
+	pr_info("%s : fast charging current (%dmA)\n",
+			__func__, charger->charging_current);
+
+	pr_info("%s : termination current (%dmA)\n",
+			__func__, eoc);
+
+	s2mu003_set_charging_current(charger, eoc);
+	s2mu003_set_bits(charger->client,
+			S2MU003_CHG_CTRL3, S2MU003_CHG_EN_MASK);
+
+	s2mu003_enable_charger_switch(charger, 1);
+}
+#if defined(CONFIG_SEC_FUELGAUGE_S2MU003)
+static void s2mu003_adc_init(struct s2mu003_charger_data *charger)
+{
+	charger->adc_val = iio_channel_get_all(charger->dev);
+}
+#endif
+/* here is set init charger data */
+static bool s2mu003_chg_init(struct s2mu003_charger_data *charger)
+{
+	int ret = 0;
+
+	dev_info(&charger->client->dev, "%s : DEV ID : 0x%x\n", __func__,
+			charger->rev_id);
+
+	if (charger->pdata->is_1MHz_switching)
+		ret = s2mu003_set_bits(charger->client,
+			S2MU003_CHG_CTRL1, S2MU003_SEL_SWFREQ_MASK);
+	else
+		ret = s2mu003_clr_bits(charger->client,
+			S2MU003_CHG_CTRL1, S2MU003_SEL_SWFREQ_MASK);
+
+	ret = s2mu003_set_bits(charger->client, 0x8D, 0x80);
+
+	s2mu003_assign_bits(charger->client, 0x95, 0x07, 0x0);
+	s2mu003_assign_bits(charger->client, 0x8C, 0x70, 0x4 << 4);
+	/* disable ic reset even if battery removed */
+	s2mu003_clr_bits(charger->client, 0x8A, 0x80);
+
+	s2mu003_clr_bits(charger->client, 0x8A, 0x1 << 5);
+
+	/* Disable Timer function (Charging timeout fault) */
+	s2mu003_clr_bits(charger->client,
+			S2MU003_CHG_CTRL3, S2MU003_TIMEREN_MASK);
+
+	/* Disable TE */
+	s2mu003_enable_charging_termination(charger->client, 0);
+
+	/* EMI improvement , let reg0x18 bit2~5 be 1100*/
+	/* s2mu003_assign_bits(charger->s2mu003->i2c_client, 0x18, 0x3C, 0x30); */
+
+	/* MUST set correct regulation voltage first
+	 * Before MUIC pass cable type information to charger
+	 * charger would be already enabled (default setting)
+	 * it might cause EOC event by incorrect regulation voltage */
+	s2mu003_set_regulation_voltage(charger,
+			charger->pdata->chg_float_voltage);
+#if !(ENABLE_MIVR)
+	s2mu003_assign_bits(charger->client,
+			S2MU003_CHG_CTRL4, S2MU003_MIVR_MASK,
+			S2MU003_MIVR_DISABLE << S2MU003_MIVR_SHIFT);
+#endif
+	/* TOP-OFF debounce time set 256us */
+	s2mu003_assign_bits(charger->client, S2MU003_CHG_CTRL2, 0x3, 0x3);
+
+	s2mu003_clr_bits(charger->client,
+			S2MU003_CHG_CTRL1, S2MU003_EN_CHGT_MASK);
+
+	s2mu003_assign_bits(charger->client, 0x8A, 0x07, 0x03);
+
+	return true;
+
+}
+
+static int s2mu003_get_charging_status(struct s2mu003_charger_data *charger)
+{
+	int status = POWER_SUPPLY_STATUS_UNKNOWN;
+	int ret;
+
+	ret = s2mu003_reg_read(charger->client, S2MU003_CHG_STATUS1);
+	if (ret < 0)
+		pr_info("Error : can't get charging status (%d)\n", ret);
+
+	if (charger->full_charged)
+		return POWER_SUPPLY_STATUS_FULL;
+
+	switch (ret & 0x30) {
+	case 0x00:
+		status = POWER_SUPPLY_STATUS_DISCHARGING;
+		break;
+	case 0x20:
+		status = POWER_SUPPLY_STATUS_CHARGING;
+		break;
+	case 0x30:
+		status = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		break;
+	}
+
+	if (charger->charging_current < 0) {
+		/* For OTG mode, S2MU003 would still report "charging" */
+		status = POWER_SUPPLY_STATUS_DISCHARGING;
+		ret = s2mu003_reg_read(charger->client, S2MU003_CHG_IRQ3);
+		if (ret & 0x80) {
+			pr_info("%s: otg overcurrent limit\n", __func__);
+			s2mu003_charger_otg_control(charger, false);
+		}
+
+	}
+
+	return status;
+}
+
+static int s2mu003_get_charge_type(struct i2c_client *iic)
+{
+	int status = POWER_SUPPLY_CHARGE_TYPE_UNKNOWN;
+	int ret;
+
+	ret = s2mu003_reg_read(iic, S2MU003_CHG_STATUS1);
+	if (ret < 0)
+		dev_err(&iic->dev, "%s fail\n", __func__);
+
+	switch (ret&0x40) {
+	case 0x40:
+		status = POWER_SUPPLY_CHARGE_TYPE_FAST;
+		break;
+	default:
+		/* pre-charge mode */
+		status = POWER_SUPPLY_CHARGE_TYPE_TRICKLE;
+		break;
+	}
+
+	return status;
+}
+
+static bool s2mu003_get_batt_present(struct i2c_client *iic)
+{
+	int ret = s2mu003_reg_read(iic, S2MU003_CHG_STATUS2);
+	if (ret < 0)
+		return false;
+	return (ret & 0x08) ? false : true;
+}
+
+static int s2mu003_get_charging_health(struct s2mu003_charger_data *charger)
+{
+	int ret = s2mu003_reg_read(charger->client, S2MU003_CHG_STATUS1);
+
+	if (ret < 0)
+		return POWER_SUPPLY_HEALTH_UNKNOWN;
+
+	if (ret & (0x03 << 2)) {
+		charger->ovp = false;
+		charger->unhealth_cnt = 0;
+		return POWER_SUPPLY_HEALTH_GOOD;
+	}
+	charger->unhealth_cnt++;
+	if (charger->unhealth_cnt < HEALTH_DEBOUNCE_CNT)
+		return POWER_SUPPLY_HEALTH_GOOD;
+
+	charger->unhealth_cnt = HEALTH_DEBOUNCE_CNT;
+	if (charger->ovp)
+		return POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+	return POWER_SUPPLY_HEALTH_UNDERVOLTAGE;
+}
+
+static int sec_chg_get_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		union power_supply_propval *val)
+{
+	int chg_curr, aicr;
+	struct s2mu003_charger_data *charger =
+		container_of(psy, struct s2mu003_charger_data, psy_chg);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = charger->charging_current ? 1 : 0;
+		break;
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = s2mu003_get_charging_status(charger);
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = s2mu003_get_charging_health(charger);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		val->intval = 2000;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		if (charger->charging_current) {
+			aicr = s2mu003_get_input_current_limit(charger->client);
+			chg_curr =
+			s2mu003_get_fast_charging_current(charger->client);
+			val->intval = MINVAL(aicr, chg_curr);
+		} else
+			val->intval = 0;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+		val->intval = s2mu003_get_charge_type(charger->client);
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = s2mu003_get_batt_present(charger->client);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sec_chg_set_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		const union power_supply_propval *val)
+{
+	struct s2mu003_charger_data *charger =
+		container_of(psy, struct s2mu003_charger_data, psy_chg);
+
+	int eoc;
+	int previous_cable_type = charger->cable_type;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		charger->status = val->intval;
+		break;
+		/* val->intval : type */
+	case POWER_SUPPLY_PROP_ONLINE:
+		charger->cable_type = val->intval;
+		if (charger->cable_type == POWER_SUPPLY_TYPE_BATTERY ||
+				charger->cable_type ==
+				POWER_SUPPLY_TYPE_UNKNOWN) {
+			pr_info("%s:[BATT] Type Battery\n", __func__);
+			s2mu003_enable_charger_switch(charger, 0);
+
+			if (previous_cable_type == POWER_SUPPLY_TYPE_OTG)
+				s2mu003_charger_otg_control(charger, false);
+			s2mu003_clr_bits(charger->client, 0x8A, 0x1 << 5);
+		} else if (charger->cable_type == POWER_SUPPLY_TYPE_OTG) {
+			pr_info("%s: OTG mode\n", __func__);
+			s2mu003_clr_bits(charger->client, 0x8A, 0x1 << 5);
+			s2mu003_charger_otg_control(charger, true);
+		} else {
+			pr_info("%s:[BATT] Set charging"", Cable type = %d\n",
+						__func__, charger->cable_type);
+			s2mu003_set_bits(charger->client, 0x8A, 0x1 << 5);
+			/* Enable charger */
+			s2mu003_configure_charger(charger);
+		}
+#if EN_TEST_READ
+		msleep(100);
+		s2mu003_test_read(charger->s2mu003->i2c_client);
+#endif
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		/* set charging current */
+		if (charger->is_charging) {
+			/* decrease the charging current
+					according to siop level */
+			charger->siop_level = val->intval;
+			pr_info("%s:SIOP level = %d, chg current = %d\n",
+			__func__, val->intval, charger->charging_current);
+			eoc = s2mu003_get_current_eoc_setting(charger);
+			s2mu003_set_charging_current(charger, 0);
+		}
+		break;
+	case POWER_SUPPLY_PROP_POWER_NOW:
+		eoc = s2mu003_get_current_eoc_setting(charger);
+		pr_info("%s:Set Power Now -> chg current = %d mA, eoc = %d mA\n",
+						__func__, val->intval, eoc);
+		s2mu003_set_charging_current(charger, 0);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL:
+		s2mu003_charger_otg_control(charger, val->intval);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+struct s2mu003_chg_irq_handler {
+	char *name;
+	int irq_index;
+	irqreturn_t (*handler)(int irq, void *data);
+};
+
+#if EN_BATP_IRQ
+static irqreturn_t s2mu003_chg_batp_irq_handler(int irq, void *data)
+{
+	struct s2mu003_charger_data *charger = data;
+
+	pr_info("%s : battery is Disconnected\n", __func__);
+	if (charger->rev_id == 0x02 || charger->rev_id == 0x0a ||
+			charger->rev_id == 0x0b || charger->rev_id == 0x0c) {
+		s2mu003_set_bits(charger->client, 0x64, 0x1 << 3);
+		s2mu003_set_bits(charger->client, 0x75, 0x1);
+		s2mu003_assign_bits(charger->client, 0x8A, 0x7, 0x1);
+		charger->battery_valid = false;
+		if (charger->rev_id == 0x0c)
+			s2mu003_clr_bits(charger->client, 0x8A, 0x1 << 5);
+	}
+
+	return IRQ_HANDLED;
+}
+#endif /* EN_BATP_IRQ */
+
+#if EN_OVP_IRQ
+static void s2mu003_ovp_work(struct work_struct *work)
+{
+	struct s2mu003_charger_data *charger =
+	container_of(work, struct s2mu003_charger_data, charger_work.work);
+	union power_supply_propval value;
+	int status;
+
+	status = s2mu003_reg_read(charger->client, S2MU003_CHG_STATUS1);
+
+	/* PWR ready = 0*/
+	if ((status & (0x04)) == 0) {
+		/* No need to disable charger,
+		 * H/W will do it automatically */
+		charger->unhealth_cnt = HEALTH_DEBOUNCE_CNT;
+		charger->ovp = true;
+		pr_info("%s: OVP triggered\n", __func__);
+		value.intval = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+		psy_do_property("battery", set,
+				POWER_SUPPLY_PROP_HEALTH, value);
+	} else {
+		charger->unhealth_cnt = 0;
+		charger->ovp = false;
+	}
+}
+
+static irqreturn_t s2mu003_chg_vin_ovp_irq_handler(int irq, void *data)
+{
+	struct s2mu003_charger_data *charger = data;
+
+	/* Delay 100ms for debounce */
+	queue_delayed_work(charger->charger_wqueue,
+				&charger->charger_work, msecs_to_jiffies(100));
+
+	return IRQ_HANDLED;
+}
+#endif /* EN_OVP_IRQ */
+
+#if EN_IEOC_IRQ
+static irqreturn_t s2mu003_chg_ieoc_irq_handler(int irq, void *data)
+{
+	struct s2mu003_charger_data *charger = data;
+
+	pr_info("%s : Full charged\n", __func__);
+	charger->full_charged = true;
+
+	return IRQ_HANDLED;
+}
+#endif /* EN_IEOC_IRQ */
+
+#if EN_TOPOFF_IRQ
+static irqreturn_t s2mu003_chg_topoff_irq_handler(int irq, void *data)
+{
+	struct s2mu003_charger_data *charger = data;
+
+	pr_info("%s : Full charged\n", __func__);
+	charger->full_charged = true;
+	return IRQ_HANDLED;
+}
+#endif /* EN_IEOC_IRQ */
+
+#if EN_RECHG_REQ_IRQ
+static irqreturn_t s2mu003_chg_rechg_request_irq_handler(int irq, void *data)
+{
+	struct s2mu003_charger_data *charger = data;
+	pr_info("%s: Recharging requesting\n", __func__);
+
+	charger->full_charged = false;
+
+	return IRQ_HANDLED;
+}
+#endif /* EN_RECHG_REQ_IRQ */
+
+#if EN_TR_IRQ
+static irqreturn_t s2mu003_chg_otp_tr_irq_handler(int irq, void *data)
+{
+	pr_info("%s : Over temperature : thermal regulation loop active\n",
+			__func__);
+	/* if needs callback, do it here */
+	return IRQ_HANDLED;
+}
+#endif
+
+const struct s2mu003_chg_irq_handler s2mu003_chg_irq_handlers[] = {
+#if EN_BATP_IRQ
+	{
+		.name = "chg_batp",
+		.handler = s2mu003_chg_batp_irq_handler,
+		.irq_index = S2MU003_BATP_IRQ,
+	},
+#endif /* EN_BATP_IRQ */
+#if EN_OVP_IRQ
+	{
+		.name = "chg_cinovp",
+		.handler = s2mu003_chg_vin_ovp_irq_handler,
+		.irq_index = S2MU003_CINOVP_IRQ,
+	},
+#endif /* EN_OVP_IRQ */
+#if EN_IEOC_IRQ
+	{
+		.name = "chg_eoc",
+		.handler = s2mu003_chg_ieoc_irq_handler,
+		.irq_index = S2MU003_EOC_IRQ,
+	},
+#endif /* EN_IEOC_IRQ */
+#if EN_TOPOFF_IRQ
+	{
+		.name = "chg_topoff",
+		.handler = s2mu003_chg_topoff_irq_handler,
+		.irq_index = S2MU003_TOPOFF_IRQ,
+	},
+#endif /* EN_IEOC_IRQ */
+#if EN_RECHG_REQ_IRQ
+	{
+		.name = "chg_rechg",
+		.handler = s2mu003_chg_rechg_request_irq_handler,
+		.irq_index = S2MU003_RECHG_IRQ,
+	},
+#endif /* EN_RECHG_REQ_IRQ*/
+#if EN_TR_IRQ
+	{
+		.name = "chg_chgtr",
+		.handler = s2mu003_chg_otp_tr_irq_handler,
+		.irq_index = S2MU003_CHGTR_IRQ,
+	},
+#endif /* EN_TR_IRQ */
+
+#if EN_MIVR_SW_REGULATION
+	{
+		.name = "chg_chgvinvr",
+		.handler = s2mu003_chg_mivr_irq_handler,
+		.irq_index = S2MU003_CHGVINVR_IRQ,
+	},
+#endif /* EN_MIVR_SW_REGULATION */
+#if EN_BST_IRQ
+	{
+		.name = "chg_bstinlv",
+		.handler = s2mu003_chg_otg_fail_irq_handler,
+		.irq_index = S2MU003_BSTINLV_IRQ,
+	},
+	{
+		.name = "chg_bstilim",
+		.handler = s2mu003_chg_otg_fail_irq_handler,
+		.irq_index = S2MU003_BSTILIM_IRQ,
+	},
+	{
+		.name = "chg_vmidovp",
+		.handler = s2mu003_chg_otg_fail_irq_handler,
+		.irq_index = S2MU003_VMIDOVP_IRQ,
+	},
+#endif /* EN_BST_IRQ */
+};
+
+static int register_irq(struct platform_device *pdev,
+		struct s2mu003_charger_data *charger)
+{
+	int irq;
+	int i, j;
+	int ret;
+	const struct s2mu003_chg_irq_handler *irq_handler =
+					s2mu003_chg_irq_handlers;
+	const char *irq_name;
+	for (i = 0; i < ARRAY_SIZE(s2mu003_chg_irq_handlers); i++) {
+		irq_name = s2mu003_get_irq_name_by_index
+				(irq_handler[i].irq_index);
+		irq = platform_get_irq_byname(pdev, irq_name);
+		ret = request_threaded_irq(irq, NULL, irq_handler[i].handler,
+				IRQF_ONESHOT | IRQF_TRIGGER_RISING |
+				IRQF_NO_SUSPEND, irq_name, charger);
+		if (ret < 0) {
+			pr_err("%s : Failed to request IRQ (%s): #%d: %d\n",
+					__func__, irq_name, irq, ret);
+			goto err_irq;
+		}
+
+		pr_info("%s : Register IRQ%d(%s) successfully\n",
+				__func__, irq, irq_name);
+	}
+
+	return 0;
+err_irq:
+	for (j = 0; j < i; j++) {
+		irq_name = s2mu003_get_irq_name_by_index
+				(irq_handler[j].irq_index);
+		irq = platform_get_irq_byname(pdev, irq_name);
+		free_irq(irq, charger);
+	}
+
+	return ret;
+}
+
+static void unregister_irq(struct platform_device *pdev,
+		struct s2mu003_charger_data *charger)
+{
+	int irq;
+	int i;
+	const char *irq_name;
+	const struct s2mu003_chg_irq_handler *irq_handler =
+					s2mu003_chg_irq_handlers;
+
+	for (i = 0; i < ARRAY_SIZE(s2mu003_chg_irq_handlers); i++) {
+		irq_name = s2mu003_get_irq_name_by_index
+				(irq_handler[i].irq_index);
+		irq = platform_get_irq_byname(pdev, irq_name);
+		free_irq(irq, charger);
+	}
+}
+
+static int s2mu003_usb_get_property(struct power_supply *psy,
+				enum power_supply_property psp,
+				union power_supply_propval *val)
+{
+	struct s2mu003_charger_data *charger =
+		container_of(psy, struct s2mu003_charger_data, psy_usb);
+
+	if (psp != POWER_SUPPLY_PROP_ONLINE)
+		return -EINVAL;
+
+	/* Set enable=1 only if the USB charger is connected */
+	switch (charger->battery_cable_type) {
+	case POWER_SUPPLY_TYPE_USB:
+	case POWER_SUPPLY_TYPE_USB_DCP:
+	case POWER_SUPPLY_TYPE_USB_CDP:
+	case POWER_SUPPLY_TYPE_USB_ACA:
+		val->intval = 1;
+		break;
+	default:
+		val->intval = 0;
+		break;
+	}
+
+	return 0;
+}
+
+static int s2mu003_ac_get_property(struct power_supply *psy,
+			       enum power_supply_property psp,
+			       union power_supply_propval *val)
+{
+	struct s2mu003_charger_data *charger =
+		container_of(psy, struct s2mu003_charger_data, psy_ac);
+
+	if (psp != POWER_SUPPLY_PROP_ONLINE)
+		return -EINVAL;
+
+	/* Set enable=1 only if the AC charger is connected */
+	switch (charger->battery_cable_type) {
+	case POWER_SUPPLY_TYPE_MAINS:
+	case POWER_SUPPLY_TYPE_UARTOFF:
+	case POWER_SUPPLY_TYPE_LAN_HUB:
+	case POWER_SUPPLY_TYPE_UNKNOWN:
+	case POWER_SUPPLY_TYPE_HV_PREPARE_MAINS:
+	case POWER_SUPPLY_TYPE_HV_ERR:
+	case POWER_SUPPLY_TYPE_HV_UNKNOWN:
+	case POWER_SUPPLY_TYPE_HV_MAINS:
+		val->intval = 1;
+		break;
+	default:
+		val->intval = 0;
+		break;
+	}
+
+	return 0;
+}
+
+static int s2mu003_battery_get_property(struct power_supply *psy,
+		enum power_supply_property psp, union power_supply_propval *val)
+{
+	struct s2mu003_charger_data *charger =
+		container_of(psy, struct s2mu003_charger_data, psy_battery);
+#if defined(CONFIG_SEC_FUELGAUGE_S2MU003)
+	union power_supply_propval value;
+	int charger_status = 0;
+#endif
+	int ret = 0;
+
+	dev_dbg(&charger->client->dev, "prop: %d\n", psp);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = s2mu003_get_charging_status(charger);
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = s2mu003_get_charging_health(charger);
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = charger->battery_cable_type;
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = charger->battery_valid;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+		val->intval = POWER_SUPPLY_CHARGE_TYPE_FAST;
+		break;
+	case POWER_SUPPLY_PROP_TECHNOLOGY:
+		val->intval = POWER_SUPPLY_TECHNOLOGY_LIPO;
+		break;
+	case POWER_SUPPLY_PROP_SCOPE:
+		val->intval = POWER_SUPPLY_SCOPE_SYSTEM;
+		break;
+#if defined(CONFIG_SEC_FUELGAUGE_S2MU003)
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		if (!charger->battery_valid)
+			val->intval = FAKE_BAT_LEVEL;
+		else {
+			psy_do_property_dup(charger->pdata->fuelgauge_name, get,
+					POWER_SUPPLY_PROP_VOLTAGE_NOW, value);
+			charger->voltage_now = value.intval;
+			dev_err(&charger->client->dev,
+				"%s: voltage now(%d)\n", __func__,
+							charger->voltage_now);
+			val->intval = charger->voltage_now * 1000;
+		}
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_AVG:
+		value.intval = SEC_BATTERY_VOLTAGE_AVERAGE;
+		psy_do_property_dup(charger->pdata->fuelgauge_name, get,
+				POWER_SUPPLY_PROP_VOLTAGE_AVG, value);
+		charger->voltage_avg = value.intval;
+		dev_err(&charger->client->dev,
+			"%s: voltage avg(%d)\n", __func__,
+						charger->voltage_avg);
+		val->intval = charger->voltage_now * 1000;
+		break;
+	case POWER_SUPPLY_PROP_TEMP:
+		if (!charger->battery_valid)
+			val->intval = FAKE_BAT_LEVEL;
+		else
+			val->intval = charger->temp_val;
+		break;
+#endif
+	case POWER_SUPPLY_PROP_CAPACITY:
+#if defined(CONFIG_SEC_FUELGAUGE_S2MU003)
+		if (!charger->battery_valid)
+			val->intval = FAKE_BAT_LEVEL;
+		else {
+			charger_status = s2mu003_get_charging_status(charger);
+			if (charger_status
+					== POWER_SUPPLY_STATUS_FULL)
+				val->intval = 100;
+			else
+				val->intval = charger->capacity;
+		}
+#else
+		val->intval = FAKE_BAT_LEVEL;
+#endif
+		break;
+	default:
+		ret = -ENODATA;
+	}
+
+	return ret;
+}
+
+static int s2mu003_battery_set_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		const union power_supply_propval *val)
+{
+	struct s2mu003_charger_data *charger =
+		container_of(psy, struct s2mu003_charger_data, psy_battery);
+	int ret = 0;
+
+	dev_dbg(&charger->client->dev, "prop: %d\n", psp);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		charger->status = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		charger->health = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		charger->battery_cable_type = val->intval;
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+#if defined(CONFIG_MUIC_NOTIFIER)
+static int s2mu003_bat_cable_check(struct s2mu003_charger_data *charger,
+				muic_attached_dev_t attached_dev)
+{
+	int current_cable_type = -1;
+
+	pr_debug("[%s]ATTACHED(%d)\n", __func__, attached_dev);
+
+	switch (attached_dev) {
+	case ATTACHED_DEV_JIG_UART_OFF_MUIC:
+		break;
+	case ATTACHED_DEV_SMARTDOCK_MUIC:
+	case ATTACHED_DEV_DESKDOCK_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_BATTERY;
+		break;
+	case ATTACHED_DEV_OTG_MUIC:
+	case ATTACHED_DEV_JIG_UART_OFF_VB_OTG_MUIC:
+	case ATTACHED_DEV_HMT_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_OTG;
+		break;
+	case ATTACHED_DEV_USB_MUIC:
+	case ATTACHED_DEV_JIG_USB_OFF_MUIC:
+	case ATTACHED_DEV_JIG_USB_ON_MUIC:
+	case ATTACHED_DEV_SMARTDOCK_USB_MUIC:
+	case ATTACHED_DEV_UNOFFICIAL_ID_USB_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_USB;
+		break;
+	case ATTACHED_DEV_JIG_UART_OFF_VB_MUIC:
+	case ATTACHED_DEV_JIG_UART_OFF_VB_FG_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_UARTOFF;
+		break;
+	case ATTACHED_DEV_TA_MUIC:
+	case ATTACHED_DEV_CARDOCK_MUIC:
+	case ATTACHED_DEV_DESKDOCK_VB_MUIC:
+	case ATTACHED_DEV_SMARTDOCK_TA_MUIC:
+	case ATTACHED_DEV_AFC_CHARGER_5V_MUIC:
+	case ATTACHED_DEV_UNOFFICIAL_TA_MUIC:
+	case ATTACHED_DEV_UNOFFICIAL_ID_TA_MUIC:
+	case ATTACHED_DEV_UNOFFICIAL_ID_ANY_MUIC:
+	case ATTACHED_DEV_QC_CHARGER_5V_MUIC:
+	case ATTACHED_DEV_UNSUPPORTED_ID_VB_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_MAINS;
+		break;
+	case ATTACHED_DEV_CDP_MUIC:
+	case ATTACHED_DEV_UNOFFICIAL_ID_CDP_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_USB_CDP;
+		break;
+	case ATTACHED_DEV_USB_LANHUB_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_LAN_HUB;
+		break;
+	case ATTACHED_DEV_CHARGING_CABLE_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_POWER_SHARING;
+		break;
+	case ATTACHED_DEV_AFC_CHARGER_PREPARE_MUIC:
+	case ATTACHED_DEV_QC_CHARGER_PREPARE_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_HV_PREPARE_MAINS;
+		break;
+	case ATTACHED_DEV_AFC_CHARGER_9V_MUIC:
+	case ATTACHED_DEV_QC_CHARGER_9V_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_HV_MAINS;
+		break;
+	case ATTACHED_DEV_AFC_CHARGER_ERR_V_MUIC:
+	case ATTACHED_DEV_QC_CHARGER_ERR_V_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_HV_ERR;
+		break;
+	case ATTACHED_DEV_UNDEFINED_CHARGING_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_UNKNOWN;
+		break;
+	case ATTACHED_DEV_HV_ID_ERR_UNDEFINED_MUIC:
+	case ATTACHED_DEV_HV_ID_ERR_UNSUPPORTED_MUIC:
+	case ATTACHED_DEV_HV_ID_ERR_SUPPORTED_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_HV_UNKNOWN;
+		break;
+	default:
+		pr_err("%s: invalid type for charger:%d\n",
+			__func__, attached_dev);
+	}
+
+	return current_cable_type;
+
+}
+
+static int charger_handle_notification(struct notifier_block *nb,
+		unsigned long action, void *data)
+{
+	muic_attached_dev_t attached_dev = *(muic_attached_dev_t *)data;
+	const char *cmd;
+	int cable_type;
+	struct s2mu003_charger_data *charger =
+		container_of(nb, struct s2mu003_charger_data,
+			     cable_check);
+	union power_supply_propval value;
+
+	if (attached_dev == ATTACHED_DEV_MHL_MUIC)
+		return 0;
+
+	switch (action) {
+	case MUIC_NOTIFY_CMD_DETACH:
+	case MUIC_NOTIFY_CMD_LOGICALLY_DETACH:
+		cmd = "DETACH";
+		cable_type = POWER_SUPPLY_TYPE_BATTERY;
+		break;
+	case MUIC_NOTIFY_CMD_ATTACH:
+	case MUIC_NOTIFY_CMD_LOGICALLY_ATTACH:
+		cmd = "ATTACH";
+		cable_type = s2mu003_bat_cable_check(charger, attached_dev);
+		break;
+	default:
+		cmd = "ERROR";
+		cable_type = -1;
+		break;
+	}
+
+	pr_info("%s: current_cable(%d) former cable_type(%d) battery_valid(%d)\n",
+			__func__, cable_type, charger->battery_cable_type,
+						   charger->battery_valid);
+	if (charger->battery_valid == false) {
+		pr_info("%s: Battery is disconnected\n",
+						__func__);
+		return 0;
+	}
+
+	if (attached_dev == ATTACHED_DEV_OTG_MUIC) {
+		if (!strcmp(cmd, "ATTACH")) {
+			value.intval = true;
+			charger->battery_cable_type = cable_type;
+			psy_do_property(charger->pdata->charger_name, set,
+					POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL,
+					value);
+			pr_info("%s: OTG cable attached\n", __func__);
+		} else {
+			value.intval = false;
+			charger->battery_cable_type = cable_type;
+			psy_do_property(charger->pdata->charger_name, set,
+					POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL,
+					value);
+			pr_info("%s: OTG cable detached\n", __func__);
+		}
+	}
+
+	if ((cable_type >= 0) &&
+	    cable_type <= SEC_SIZEOF_POWER_SUPPLY_TYPE) {
+		if (cable_type != charger->battery_cable_type) {
+			value.intval = charger->battery_cable_type = cable_type;
+			psy_do_property(charger->pdata->charger_name, set,
+					POWER_SUPPLY_PROP_ONLINE,
+					value);
+		} else {
+			pr_info("%s: Cable is Not Changed(%d)\n",
+				__func__, charger->battery_cable_type);
+		}
+	}
+	power_supply_changed(&charger->psy_battery);
+
+	pr_info("%s: CMD=%s, attached_dev=%d battery_cable=%d\n",
+		__func__, cmd, attached_dev, charger->battery_cable_type);
+
+	return 0;
+}
+#endif /* CONFIG_MUIC_NOTIFIER */
+#if defined(CONFIG_SEC_FUELGAUGE_S2MU003)
+static int sec_bat_adc_to_data(struct s2mu003_charger_data *charger,
+							    int data)
+{
+	const sec_bat_adc_table_data_t *temp_adc_table =
+				charger->pdata->temp_adc_table;
+	unsigned int temp_adc_table_size =
+				charger->pdata->temp_adc_table_size;
+	int i;
+	int temp_adc;
+
+	for (i = 0; i < temp_adc_table_size; i++) {
+		if (data <= temp_adc_table[i].adc)
+			break;
+	}
+
+	if (i == 0)
+		return temp_adc_table[0].data;
+	else if (i == temp_adc_table_size)
+		return temp_adc_table[temp_adc_table_size - 1].data;
+
+	temp_adc = temp_adc_table[i].data -
+		   ((temp_adc_table[i].data - temp_adc_table[i - 1].data) *
+		   (temp_adc_table[i].adc - data) /
+		   (temp_adc_table[i].adc - temp_adc_table[i - 1].adc));
+
+	return temp_adc;
+}
+static void sec_bat_get_adc_info(struct s2mu003_charger_data *charger,
+				 union power_supply_propval *value)
+{
+	int data = -1;
+	int ret = iio_read_channel_raw(&charger->adc_val[0], &data);
+	if (ret < 0)
+		pr_err("%s: read channel error[%d]\n", __func__, ret);
+	else
+		pr_debug("TEMP ADC(%d)\n", data);
+	value->intval = sec_bat_adc_to_data(charger, data);
+}
+#endif /* CONFIG_SEC_FUELGAUGE_S2MU003 */
+#if defined(CONFIG_SEC_FUELGAUGE_S2MU003) || defined(CONFIG_MUIC_NOTIFIER)
+static void sec_bat_get_battery_info(struct work_struct *work)
+{
+	struct s2mu003_charger_data *charger =
+	container_of(work, struct s2mu003_charger_data, polling_work.work);
+
+#if defined(CONFIG_SEC_FUELGAUGE_S2MU003)
+	int ret = 0;
+	union power_supply_propval value;
+
+	if (!charger->adc_check) {
+		s2mu003_adc_init(charger);
+		if (IS_ERR_OR_NULL(charger->adc_val))
+			charger->adc_check = false;
+		else
+			charger->adc_check = true;
+	}
+
+	if (charger->adc_check) {
+		sec_bat_get_adc_info(charger, &value);
+		charger->temp_val = value.intval;
+	}
+
+	psy_do_property(charger->pdata->fuelgauge_name, get,
+		POWER_SUPPLY_PROP_VOLTAGE_NOW, value);
+	charger->voltage_now = value.intval;
+
+	value.intval = SEC_BATTERY_VOLTAGE_AVERAGE;
+	psy_do_property(charger->pdata->fuelgauge_name, get,
+		POWER_SUPPLY_PROP_VOLTAGE_AVG, value);
+	charger->voltage_avg = value.intval;
+
+	value.intval = SEC_BATTERY_VOLTAGE_OCV;
+	psy_do_property(charger->pdata->fuelgauge_name, get,
+		POWER_SUPPLY_PROP_VOLTAGE_AVG, value);
+	charger->voltage_ocv = value.intval;
+
+	/* To get SOC value (NOT raw SOC), need to reset value */
+	value.intval = 0;
+	psy_do_property(charger->pdata->fuelgauge_name, get,
+		POWER_SUPPLY_PROP_CAPACITY, value);
+	charger->capacity = value.intval;
+
+	pr_info("%s, battery_info: voltage_now: (%d), voltage_avg: (%d),"
+		"voltage_ocv: (%d), capacity: (%d), temp_val: (%d)\n",
+		__func__, charger->voltage_now, charger->voltage_avg,
+		charger->voltage_ocv, charger->capacity, charger->temp_val);
+
+	if (!charger->battery_valid) {
+		ret = s2mu003_reg_read(charger->client,
+				   S2MU003_CHG_STATUS2);
+		charger->battery_valid =
+		(ret & S2MU003_CHG_BATP) ? false : true;
+
+		if (charger->rev_id == 0x02 || charger->rev_id == 0x0a ||
+						charger->rev_id == 0x0b) {
+			if (charger->battery_valid) {
+				s2mu003_clr_bits(charger->client, 0x64, 0x1 << 3);
+				s2mu003_clr_bits(charger->client, 0x75, 0x1);
+			}
+		}
+	}
+
+	s2mu003_test_read(charger->client);
+
+	power_supply_changed(&charger->psy_battery);
+	schedule_delayed_work(&charger->polling_work, HZ * 10);
+#endif
+
+#if defined(CONFIG_MUIC_NOTIFIER)
+	if (!charger->noti_check)
+		muic_notifier_register(&charger->cable_check,
+				       charger_handle_notification,
+					       MUIC_NOTIFY_DEV_CHARGER);
+	charger->noti_check = true;
+#endif
+}
+#endif
+
+#ifdef CONFIG_OF
+static int s2mu003_charger_parse_dt(struct device *dev,
+		struct s2mu003_charger_platform_data *pdata)
+{
+	s2mu003_mfd_chip_t *chip = dev_get_drvdata(dev->parent);
+	struct device_node *np = of_find_node_by_name(NULL, "s2mu003-charger");
+	const u32 *p;
+	int ret, i, len, temp;
+
+	if (of_find_property(np, "battery,is_1MHz_switching", NULL))
+		pdata->is_1MHz_switching = 1;
+	pr_info("%s : is_1MHz_switching = %d\n", __func__,
+			pdata->is_1MHz_switching);
+
+	if (np == NULL)
+		pr_err("%s np NULL\n", __func__);
+	else
+		ret = of_property_read_u32(np, "battery,chg_float_voltage",
+				&pdata->chg_float_voltage);
+
+	np = of_find_node_by_name(NULL, "battery");
+	if (!np) {
+		pr_err("%s np NULL\n", __func__);
+	} else {
+		ret = of_property_read_string(np,
+			"battery,charger_name",
+			(char const **)&pdata->charger_name);
+
+#if defined(CONFIG_SEC_FUELGAUGE_S2MU003)
+		ret = of_property_read_string(np,
+			"battery,fuelgauge_name",
+			(char const **)&pdata->fuelgauge_name);
+#endif
+		ret = of_property_read_u32(np, "battery,thermal_source",
+			&pdata->thermal_source);
+		if (ret)
+			pr_info("%s : Thermal source is Empty\n", __func__);
+
+		if (pdata->thermal_source == SEC_BATTERY_THERMAL_SOURCE_ADC) {
+			p = of_get_property(np, "battery,temp_table_adc", &len);
+			if (!p)
+				return 1;
+
+			len = len / sizeof(u32);
+
+			pdata->temp_adc_table_size = len;
+
+			pdata->temp_adc_table =
+				kzalloc(sizeof(sec_bat_adc_table_data_t) *
+					pdata->temp_adc_table_size, GFP_KERNEL);
+
+			for (i = 0; i < pdata->temp_adc_table_size; i++) {
+				ret = of_property_read_u32_index(np,
+					"battery,temp_table_adc", i, &temp);
+				pdata->temp_adc_table[i].adc = (int)temp;
+				if (ret)
+					pr_info("%s : Temp_adc_table(adc) is Empty\n",
+						__func__);
+
+				ret = of_property_read_u32_index(np,
+					"battery,temp_table_data", i, &temp);
+				pdata->temp_adc_table[i].data = (int)temp;
+				if (ret)
+					pr_info("%s : Temp_adc_table(data) is Empty\n",
+						__func__);
+			}
+		}
+
+		p = of_get_property(np, "battery,input_current_limit", &len);
+		if (!p)
+			return 1;
+
+		len = len / sizeof(u32);
+
+		pdata->charging_current_table =
+		kzalloc(sizeof(sec_charging_current_t) * len, GFP_KERNEL);
+
+		for (i = 0; i < len; i++) {
+			if (chip->dev_id >= 0x0C) {
+				ret = of_property_read_u32_index(np,
+					"battery,input_current_limit_new", i,
+					&pdata->charging_current_table[i].
+							input_current_limit);
+				if (ret)
+					pr_info("%s: input_current_limit is Empty\n", __func__);
+				ret = of_property_read_u32_index(np,
+					"battery,fast_charging_current_new", i,
+					&pdata->charging_current_table[i].
+							fast_charging_current);
+				if (ret)
+					pr_info("%s: fast_charging_current is Empty\n", __func__);
+			} else {
+				ret = of_property_read_u32_index(np,
+					"battery,input_current_limit", i,
+					&pdata->charging_current_table[i].
+							input_current_limit);
+				if (ret)
+					pr_info("%s: input_current_limit is Empty\n", __func__);
+				ret = of_property_read_u32_index(np,
+					"battery,fast_charging_current", i,
+					&pdata->charging_current_table[i].
+							fast_charging_current);
+				if (ret)
+					pr_info("%s: fast_charging_current is Empty\n", __func__);
+			}
+			ret = of_property_read_u32_index(np,
+					"battery,full_check_current_1st", i,
+					&pdata->charging_current_table[i].
+							full_check_current_1st);
+			if (ret)
+				pr_info("%s: full_check_current_1st is Empty\n", __func__);
+			ret = of_property_read_u32_index(np,
+					"battery,full_check_current_2nd", i,
+					&pdata->charging_current_table[i].
+							full_check_current_2nd);
+			if (ret)
+				pr_info("%s: full_check_current_2nd is Empty\n", __func__);
+		}
+	}
+
+	dev_info(dev, "s2mu003 charger parse dt retval = %d\n", ret);
+	return ret;
+}
+
+static struct of_device_id s2mu003_charger_match_table[] = {
+	{ .compatible = "samsung,s2mu003-charger",},
+	{},
+};
+#else
+static int s2mu003_charger_parse_dt(struct device *dev,
+		struct s2mu003_charger_platform_data *pdata)
+{
+	return -ENOSYS;
+}
+
+#define s2mu003_charger_match_table NULL
+#endif /* CONFIG_OF */
+
+static int s2mu003_charger_probe(struct platform_device *pdev)
+{
+	s2mu003_mfd_chip_t *chip = dev_get_drvdata(pdev->dev.parent);
+#ifndef CONFIG_OF
+	struct s2mu003_mfd_platform_data *mfd_pdata =
+				dev_get_platdata(chip->dev);
+#endif
+	struct s2mu003_charger_data *charger;
+	int ret = 0;
+
+	pr_info("%s:[BATT] S2MU003 Charger driver probe\n", __func__);
+	charger = kzalloc(sizeof(*charger), GFP_KERNEL);
+	if (!charger)
+		return -ENOMEM;
+
+	mutex_init(&charger->io_lock);
+
+	charger->s2mu003 = chip;
+	charger->client = chip->i2c_client;
+	charger->dev = chip->dev;
+#if defined(CONFIG_SEC_FUELGAUGE_S2MU003)
+	charger->temp_val = 0;
+#endif
+	charger->rev_id = chip->dev_id;
+
+#ifdef CONFIG_OF
+	charger->pdata = devm_kzalloc(&pdev->dev, sizeof(*(charger->pdata)),
+			GFP_KERNEL);
+	if (!charger->pdata) {
+		dev_err(&pdev->dev, "Failed to allocate memory\n");
+		ret = -ENOMEM;
+		goto err_parse_dt_nomem;
+	}
+	ret = s2mu003_charger_parse_dt(&pdev->dev, charger->pdata);
+	if (ret < 0)
+		goto err_parse_dt;
+#else
+	charger->pdata = mfd_pdata->charger_platform_data;
+#endif
+
+	platform_set_drvdata(pdev, charger);
+
+	if (charger->pdata->charger_name == NULL)
+		charger->pdata->charger_name = "s2mu003-charger";
+
+	charger->psy_chg.name		= charger->pdata->charger_name;
+	charger->psy_chg.type		= POWER_SUPPLY_TYPE_UNKNOWN;
+	charger->psy_chg.get_property	= sec_chg_get_property;
+	charger->psy_chg.set_property	= sec_chg_set_property;
+	charger->psy_chg.properties	= s2mu003_charger_props;
+	charger->psy_chg.num_properties	= ARRAY_SIZE(s2mu003_charger_props);
+
+	charger->siop_level = 100;
+	s2mu003_chg_init(charger);
+
+	ret = power_supply_register(&pdev->dev, &charger->psy_chg);
+	if (ret) {
+		pr_err("%s: Failed to Register psy_chg\n", __func__);
+		goto err_power_supply_register;
+	}
+#ifdef CONFIG_SEC_FUELGAUGE_S2MU003
+	if (charger->pdata->fuelgauge_name == NULL)
+		charger->pdata->fuelgauge_name = "s2mu003-fuelgauge";
+#endif
+	charger->psy_battery.name = "s2mu003-battery";
+	charger->psy_battery.type = POWER_SUPPLY_TYPE_BATTERY;
+	charger->psy_battery.properties =
+			s2mu003_battery_props;
+	charger->psy_battery.num_properties =
+			ARRAY_SIZE(s2mu003_battery_props);
+	charger->psy_battery.get_property =
+			s2mu003_battery_get_property;
+	charger->psy_battery.set_property =
+			s2mu003_battery_set_property;
+
+	ret = power_supply_register(&pdev->dev, &charger->psy_battery);
+	if (ret) {
+		pr_err("%s: Failed to Register psy_battery\n", __func__);
+		goto err_power_supply_register;
+	}
+#if defined(CONFIG_SEC_FUELGAUGE_S2MU003)
+	charger->capacity = 0;
+#endif
+	charger->psy_usb.name = "s2mu003-usb";
+	charger->psy_usb.type = POWER_SUPPLY_TYPE_USB;
+	charger->psy_usb.supplied_to = s2mu003_supplied_to;
+	charger->psy_usb.num_supplicants =
+			ARRAY_SIZE(s2mu003_supplied_to),
+	charger->psy_usb.properties =
+			s2mu003_power_props;
+	charger->psy_usb.num_properties =
+			ARRAY_SIZE(s2mu003_power_props);
+	charger->psy_usb.get_property =
+			s2mu003_usb_get_property;
+
+	ret = power_supply_register(&pdev->dev, &charger->psy_usb);
+	if (ret) {
+		pr_err("%s: Failed to Register psy_usb\n", __func__);
+		goto err_power_supply_register;
+	}
+
+	charger->psy_ac.name = "s2mu003-ac";
+	charger->psy_ac.type = POWER_SUPPLY_TYPE_MAINS;
+	charger->psy_ac.supplied_to = s2mu003_supplied_to;
+	charger->psy_ac.num_supplicants =
+			ARRAY_SIZE(s2mu003_supplied_to),
+	charger->psy_ac.properties =
+			s2mu003_power_props;
+	charger->psy_ac.num_properties =
+			ARRAY_SIZE(s2mu003_power_props);
+	charger->psy_ac.get_property =
+			s2mu003_ac_get_property;
+
+	ret = power_supply_register(&pdev->dev, &charger->psy_ac);
+	if (ret) {
+		pr_err("%s: Failed to Register psy_usb\n", __func__);
+		goto err_power_supply_register;
+	}
+
+	ret = register_irq(pdev, charger);
+	if (ret < 0)
+		goto err_reg_irq;
+
+	s2mu003_test_read(charger->client);
+
+	charger->battery_cable_type = POWER_SUPPLY_TYPE_BATTERY;
+	charger->cable_type = POWER_SUPPLY_TYPE_BATTERY;
+
+	charger->charger_wqueue = create_singlethread_workqueue("charger-wq");
+	if (!charger->charger_wqueue) {
+		dev_info(chip->dev, "%s: failed to create wq.\n", __func__);
+		ret = -ESRCH;
+		goto err_create_wq;
+	}
+
+	INIT_DELAYED_WORK(&charger->charger_work, s2mu003_ovp_work);
+	charger->noti_check = false;
+	charger->adc_check = false;
+	msleep(500);
+
+#if defined(CONFIG_SEC_FUELGAUGE_S2MU003) || defined(CONFIG_MUIC_NOTIFIER)
+	INIT_DELAYED_WORK(&charger->polling_work,
+				sec_bat_get_battery_info);
+	schedule_delayed_work(&charger->polling_work, HZ * 5);
+#endif
+
+	pr_info("%s:[BATT] S2MU003 charger driver loaded OK\n", __func__);
+
+	return 0;
+err_create_wq:
+err_reg_irq:
+	power_supply_unregister(&charger->psy_chg);
+	power_supply_unregister(&charger->psy_battery);
+err_power_supply_register:
+err_parse_dt:
+err_parse_dt_nomem:
+	mutex_destroy(&charger->io_lock);
+	kfree(charger);
+	return ret;
+}
+
+static int s2mu003_charger_remove(struct platform_device *pdev)
+{
+	struct s2mu003_charger_data *charger =
+		platform_get_drvdata(pdev);
+
+	unregister_irq(pdev, charger);
+	power_supply_unregister(&charger->psy_chg);
+	power_supply_unregister(&charger->psy_battery);
+	mutex_destroy(&charger->io_lock);
+	kfree(charger);
+	return 0;
+}
+
+#if defined CONFIG_PM
+static int s2mu003_charger_suspend(struct device *dev)
+{
+	struct s2mu003_charger_data *charger = dev_get_drvdata(dev);
+	cancel_delayed_work_sync(&charger->polling_work);
+
+	return 0;
+}
+
+static int s2mu003_charger_resume(struct device *dev)
+{
+	struct s2mu003_charger_data *charger = dev_get_drvdata(dev);
+	schedule_delayed_work(&charger->polling_work, 0);
+
+	return 0;
+}
+#else
+#define s2mu003_charger_suspend NULL
+#define s2mu003_charger_resume NULL
+#endif
+
+static void s2mu003_charger_shutdown(struct device *dev)
+{
+	pr_info("%s: S2MU003 Charger driver shutdown\n", __func__);
+}
+
+static SIMPLE_DEV_PM_OPS(s2mu003_charger_pm_ops, s2mu003_charger_suspend,
+		s2mu003_charger_resume);
+
+static struct platform_driver s2mu003_charger_driver = {
+	.driver		= {
+		.name	= "s2mu003-charger",
+		.owner	= THIS_MODULE,
+		.of_match_table = s2mu003_charger_match_table,
+		.pm	= &s2mu003_charger_pm_ops,
+		.shutdown = s2mu003_charger_shutdown,
+	},
+	.probe		= s2mu003_charger_probe,
+	.remove		= s2mu003_charger_remove,
+};
+
+static int __init s2mu003_charger_init(void)
+{
+	int ret = 0;
+
+	ret = platform_driver_register(&s2mu003_charger_driver);
+
+	return ret;
+}
+subsys_initcall(s2mu003_charger_init);
+
+static void __exit s2mu003_charger_exit(void)
+{
+	platform_driver_unregister(&s2mu003_charger_driver);
+}
+module_exit(s2mu003_charger_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Junhan Bae <junhan84.bae@samsung.com");
+MODULE_DESCRIPTION("S2MU003 Charger driver");
diff -Naur linux-3.18.14/drivers/power/s2mu003_fuelgauge.c samsung/drivers/power/s2mu003_fuelgauge.c
--- linux-3.18.14/drivers/power/s2mu003_fuelgauge.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/power/s2mu003_fuelgauge.c	2018-10-29 07:24:39.000000000 +0100
@@ -0,0 +1,759 @@
+/*
+ *  Samsung S2MU003 Fuel Gauge Driver
+ *
+ * Copyright (c) 2015 Samsung Electronics Co., Ltd.
+ *		http://www.samsung.com
+ * Author: Junhan Bae <junhan84.bae@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/mfd/samsung/s2mu003.h>
+#include <linux/power/s2mu003_fuelgauge.h>
+#include <linux/of_gpio.h>
+
+static enum power_supply_property s2mu003_fuelgauge_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_VOLTAGE_AVG,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CURRENT_AVG,
+	POWER_SUPPLY_PROP_CHARGE_FULL,
+	POWER_SUPPLY_PROP_ENERGY_NOW,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_TEMP_AMBIENT,
+};
+
+static int s2mu003_init_regs(struct s2mu003_fuelgauge_data *fuelgauge)
+{
+	int ret = 0;
+	u8 data;
+
+	pr_info("%s: s2mu003 fuelgauge initialize\n", __func__);
+
+	data = i2c_smbus_read_byte_data(fuelgauge->i2c, 0x2e);
+	data &= ~(0x01 << 3);
+	ret = i2c_smbus_write_byte_data(fuelgauge->i2c, 0x2e, data);
+
+	data = i2c_smbus_read_byte_data(fuelgauge->i2c, 0x1A);
+	data |= 0x03;
+	ret = i2c_smbus_write_byte_data(fuelgauge->i2c, 0x1A, data);
+
+	if (ret < 0)
+		dev_err(&fuelgauge->i2c->dev, "%s: Error(%d)\n", __func__, ret);
+
+	return ret;
+}
+
+static void s2mu003_alert_init(struct s2mu003_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+
+	/* VBAT Threshold setting */
+	data[0] = 0x00 & 0x0f;
+
+	/* SOC Threshold setting */
+	data[0] = data[0] | (fuelgauge->pdata->fuel_alert_soc << 4);
+
+	data[1] = 0x00;
+	i2c_smbus_write_i2c_block_data(fuelgauge->i2c,
+			S2MU003_REG_IRQ_LVL, 2, data);
+}
+
+static bool s2mu003_check_status(struct i2c_client *client)
+{
+	u8 data[2];
+	bool ret = false;
+
+	/* check if Smn was generated */
+	if (i2c_smbus_read_i2c_block_data(client, S2MU003_REG_STATUS, 2, data) < 0)
+		return ret;
+
+	dev_dbg(&client->dev, "%s: status to (%02x%02x)\n",
+		__func__, data[1], data[0]);
+
+	if (data[1] & (0x1 << 1))
+		return true;
+	else
+		return false;
+}
+
+static int s2mu003_set_temperature(struct s2mu003_fuelgauge_data *fuelgauge,
+			int temperature)
+{
+	u8 data[2];
+	char val;
+
+	val = temperature / 10;
+
+	if (val < -5)
+		val = 0xf6;
+	else if (val >= -5 && val < 5)
+		val = 0x00;
+	else if (val >= 5 && val < 15)
+		val = 0x0a;
+	else if (val >= 15 && val < 35)
+		val = 0x19;
+	else if (val >= 35)
+		val = 0x28;
+	data[0] = val;
+	data[1] = 0x00;
+#if 0
+	s2mu003_block_write_device(fuelgauge->i2c, S2MU003_REG_RTEMP, 2, data);
+#endif
+	dev_dbg(&fuelgauge->i2c->dev, "%s: temperature to (%d)\n",
+		__func__, temperature);
+
+	return temperature;
+}
+
+static int s2mu003_get_temperature(struct s2mu003_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	s32 temperature = 0;
+
+	if (i2c_smbus_read_i2c_block_data(fuelgauge->i2c,
+			S2MU003_REG_RTEMP, 2, data) < 0)
+		return -ERANGE;
+
+	/* data[] store 2's compliment format number */
+	if (data[0] & (0x1 << 7)) {
+		/* Negative */
+		temperature = ((~(data[0])) & 0xFF) + 1;
+		temperature *= -10;
+	} else {
+		temperature = data[0] & 0x7F;
+		temperature *= 10;
+	}
+
+	dev_dbg(&fuelgauge->i2c->dev, "%s: temperature (%d)\n",
+		__func__, temperature);
+
+	return temperature;
+}
+
+/* soc should be 0.01% unit */
+static int s2mu003_get_soc(struct s2mu003_fuelgauge_data *fuelgauge)
+{
+	u8 data[2], check_data[2];
+	u16 compliment;
+	int rsoc, i;
+
+	for (i = 0; i < 50; i++) {
+		if (i2c_smbus_read_i2c_block_data(fuelgauge->i2c,
+				S2MU003_REG_RSOC, 2, data) < 0)
+			return -EINVAL;
+		if (i2c_smbus_read_i2c_block_data(fuelgauge->i2c,
+				S2MU003_REG_RSOC, 2, check_data) < 0)
+			return -EINVAL;
+		if ((data[0] == check_data[0]) && (data[1] == check_data[1]))
+			break;
+	}
+
+	compliment = (data[1] << 8) | (data[0]);
+
+	/* data[] store 2's compliment format number */
+	if (compliment & (0x1 << 15)) {
+		/* Negative */
+		rsoc = ((~compliment) & 0xFFFF) + 1;
+		rsoc = (rsoc * (-10000)) / (0x1 << 12);
+	} else {
+		rsoc = compliment & 0x7FFF;
+		rsoc = ((rsoc * 10000) / (0x1 << 12));
+	}
+
+	dev_info(&fuelgauge->i2c->dev, "%s: raw capacity (0x%x:%d)\n", __func__,
+		compliment, rsoc);
+
+	return min(rsoc, 10000) / 10;
+}
+
+static int s2mu003_get_rawsoc(struct s2mu003_fuelgauge_data *fuelgauge)
+{
+	u8 data[2], check_data[2];
+	u16 compliment;
+	int rsoc, i;
+
+	for (i = 0; i < 50; i++) {
+		if (i2c_smbus_read_i2c_block_data(fuelgauge->i2c,
+				S2MU003_REG_RSOC, 2, data) < 0)
+			return -EINVAL;
+		if (i2c_smbus_read_i2c_block_data(fuelgauge->i2c,
+				S2MU003_REG_RSOC, 2, check_data) < 0)
+			return -EINVAL;
+		if ((data[0] == check_data[0]) && (data[1] == check_data[1]))
+			break;
+	}
+
+	compliment = (data[1] << 8) | (data[0]);
+
+	/* data[] store 2's compliment format number */
+	if (compliment & (0x1 << 15)) {
+		/* Negative */
+		rsoc = ((~compliment) & 0xFFFF) + 1;
+		rsoc = (rsoc * (-10000)) / (0x1 << 12);
+	} else {
+		rsoc = compliment & 0x7FFF;
+		rsoc = ((rsoc * 10000) / (0x1 << 12));
+	}
+
+	dev_info(&fuelgauge->i2c->dev, "%s: raw capacity (0x%x:%d)\n", __func__,
+			compliment, rsoc);
+
+	return min(rsoc, 10000);
+}
+
+static int s2mu003_get_ocv(struct s2mu003_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u32 rocv = 0;
+
+	if (i2c_smbus_read_i2c_block_data(fuelgauge->i2c,
+			S2MU003_REG_ROCV, 2, data) < 0)
+		return -EINVAL;
+
+	rocv = ((data[0] + (data[1] << 8)) * 1000) >> 13;
+
+	dev_dbg(&fuelgauge->i2c->dev, "%s: rocv (%d)\n", __func__, rocv);
+
+	return rocv;
+}
+
+static int s2mu003_get_vbat(struct s2mu003_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u32 vbat = 0;
+
+	if (i2c_smbus_read_i2c_block_data(fuelgauge->i2c,
+			S2MU003_REG_RVBAT, 2, data) < 0)
+		return -EINVAL;
+	vbat = ((data[0] + (data[1] << 8)) * 1000) >> 13;
+
+	dev_dbg(&fuelgauge->i2c->dev, "%s: vbat (%d)\n", __func__, vbat);
+
+	return vbat;
+}
+
+static int s2mu003_get_avgvbat(struct s2mu003_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u32 new_vbat, old_vbat = 0;
+	int cnt;
+
+	for (cnt = 0; cnt < 5; cnt++) {
+		if (i2c_smbus_read_i2c_block_data(fuelgauge->i2c,
+			S2MU003_REG_RVBAT, 2, data) < 0)
+			return -EINVAL;
+
+		new_vbat = ((data[0] + (data[1] << 8)) * 1000) >> 13;
+
+		if (cnt == 0)
+			old_vbat = new_vbat;
+		else
+			old_vbat = new_vbat / 2 + old_vbat / 2;
+	}
+
+	dev_dbg(&fuelgauge->i2c->dev, "%s: avgvbat (%d)\n", __func__, old_vbat);
+
+	return old_vbat;
+}
+
+/* capacity is  0.1% unit */
+static void s2mu003_fg_get_scaled_capacity(
+		struct s2mu003_fuelgauge_data *fuelgauge,
+		union power_supply_propval *val)
+{
+	val->intval = (val->intval < fuelgauge->pdata->capacity_min) ?
+		0 : ((val->intval - fuelgauge->pdata->capacity_min) * 1000 /
+		(fuelgauge->capacity_max - fuelgauge->pdata->capacity_min));
+
+	dev_dbg(&fuelgauge->i2c->dev,
+			"%s: scaled capacity (%d.%d)\n",
+			__func__, val->intval/10, val->intval%10);
+}
+
+/* capacity is integer */
+static void s2mu003_fg_get_atomic_capacity(
+		struct s2mu003_fuelgauge_data *fuelgauge,
+		union power_supply_propval *val)
+{
+	if (fuelgauge->pdata->capacity_calculation_type &
+			SEC_FUELGAUGE_CAPACITY_TYPE_ATOMIC) {
+		if (fuelgauge->capacity_old < val->intval)
+			val->intval = fuelgauge->capacity_old + 1;
+		else if (fuelgauge->capacity_old > val->intval)
+			val->intval = fuelgauge->capacity_old - 1;
+	}
+
+	/* updated old capacity */
+	fuelgauge->capacity_old = val->intval;
+}
+
+static int s2mu003_fg_calculate_dynamic_scale(
+		struct s2mu003_fuelgauge_data *fuelgauge, int capacity)
+{
+	union power_supply_propval raw_soc_val;
+	raw_soc_val.intval = s2mu003_get_rawsoc(fuelgauge) / 10;
+
+	if (raw_soc_val.intval <
+			fuelgauge->pdata->capacity_max -
+			fuelgauge->pdata->capacity_max_margin) {
+		fuelgauge->capacity_max =
+			fuelgauge->pdata->capacity_max -
+			fuelgauge->pdata->capacity_max_margin;
+		pr_debug("%s: capacity_max (%d)", __func__,
+				fuelgauge->capacity_max);
+	} else {
+		fuelgauge->capacity_max =
+			(raw_soc_val.intval >
+			 fuelgauge->pdata->capacity_max +
+			 fuelgauge->pdata->capacity_max_margin) ?
+			(fuelgauge->pdata->capacity_max +
+			 fuelgauge->pdata->capacity_max_margin) :
+			raw_soc_val.intval;
+		pr_debug("%s: raw soc (%d)", __func__,
+				fuelgauge->capacity_max);
+	}
+
+	if (capacity != 100) {
+		fuelgauge->capacity_max =
+			(fuelgauge->capacity_max * 100 / capacity);
+		fuelgauge->capacity_old = capacity;
+	} else {
+		fuelgauge->capacity_max =
+			(fuelgauge->capacity_max * 99 / 100);
+		fuelgauge->capacity_old = 100;
+	}
+
+	pr_info("%s: %d is used for capacity_max, capacity(%d)\n",
+			__func__, fuelgauge->capacity_max, capacity);
+
+	return fuelgauge->capacity_max;
+}
+
+bool s2mu003_fuelgauge_fuelalert_init(struct i2c_client *client, int soc)
+{
+	struct s2mu003_fuelgauge_data *fuelgauge = i2c_get_clientdata(client);
+	u8 data[2];
+
+	/* 1. Set s2mu003 alert configuration. */
+	s2mu003_alert_init(fuelgauge);
+
+	if (i2c_smbus_read_i2c_block_data(client, S2MU003_REG_IRQ, 2, data) < 0)
+		return -1;
+
+	/*Enable VBAT, SOC */
+	data[1] &= 0xfc;
+
+	/*Disable IDLE_ST, INIT)ST */
+	data[1] |= 0x0c;
+
+	i2c_smbus_write_i2c_block_data(client, S2MU003_REG_IRQ, 2, data);
+
+	dev_dbg(&client->dev, "%s: irq_reg(%02x%02x) irq(%d)\n",
+			__func__, data[1], data[0], fuelgauge->pdata->fg_irq);
+
+	return true;
+}
+
+bool s2mu003_fuelgauge_is_fuelalerted(struct s2mu003_fuelgauge_data *fuelgauge)
+{
+	return s2mu003_check_status(fuelgauge->i2c);
+}
+
+bool s2mu003_hal_fg_fuelalert_process(void *irq_data, bool is_fuel_alerted)
+{
+	struct s2mu003_fuelgauge_data *fuelgauge = irq_data;
+	int ret;
+
+	ret = i2c_smbus_write_byte_data(fuelgauge->i2c, S2MU003_REG_IRQ, 0x00);
+	if (ret < 0)
+		dev_err(&fuelgauge->i2c->dev, "%s: Error(%d)\n", __func__, ret);
+
+	return ret;
+}
+
+bool s2mu003_hal_fg_full_charged(struct i2c_client *client)
+{
+	return true;
+}
+
+static int s2mu003_fg_get_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		union power_supply_propval *val)
+{
+	struct s2mu003_fuelgauge_data *fuelgauge =
+		container_of(psy, struct s2mu003_fuelgauge_data, psy_fg);
+
+	switch (psp) {
+		/* Cell voltage (VCELL, mV) */
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = s2mu003_get_vbat(fuelgauge);
+		break;
+		/* Additional Voltage Information (mV) */
+	case POWER_SUPPLY_PROP_VOLTAGE_AVG:
+		switch (val->intval) {
+		case SEC_BATTERY_VOLTAGE_AVERAGE:
+			val->intval = s2mu003_get_avgvbat(fuelgauge);
+			break;
+		case SEC_BATTERY_VOLTAGE_OCV:
+			val->intval = s2mu003_get_ocv(fuelgauge);
+			break;
+		}
+		break;
+		/* Current (mA) */
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = 0;
+		break;
+		/* Average Current (mA) */
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+		val->intval = 0;
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		if (val->intval == SEC_FUELGAUGE_CAPACITY_TYPE_RAW) {
+			val->intval = s2mu003_get_rawsoc(fuelgauge);
+		} else {
+			val->intval = s2mu003_get_soc(fuelgauge);
+
+			if (fuelgauge->pdata->capacity_calculation_type &
+				(SEC_FUELGAUGE_CAPACITY_TYPE_SCALE |
+				SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE))
+				s2mu003_fg_get_scaled_capacity(fuelgauge, val);
+
+			/* capacity should be between 0% and 100%
+			 * (0.1% degree)
+			 */
+			if (val->intval > 1000)
+				val->intval = 1000;
+			if (val->intval < 0)
+				val->intval = 0;
+
+			/* get only integer part */
+			val->intval /= 10;
+
+			/* check whether doing the wake_unlock */
+			if ((val->intval > fuelgauge->pdata->fuel_alert_soc) &&
+					fuelgauge->is_fuel_alerted) {
+				wake_unlock(&fuelgauge->fuel_alert_wake_lock);
+				s2mu003_fuelgauge_fuelalert_init(fuelgauge
+				->i2c, fuelgauge->pdata->fuel_alert_soc);
+			}
+
+			/* (Only for atomic capacity)
+			 * In initial time, capacity_old is 0.
+			 * and in resume from sleep,
+			 * capacity_old is too different from actual soc.
+			 * should update capacity_old
+			 * by val->intval in booting or resume.
+			 */
+			if (fuelgauge->initial_update_of_soc) {
+				/* updated old capacity */
+				fuelgauge->capacity_old = val->intval;
+				fuelgauge->initial_update_of_soc = false;
+				break;
+			}
+
+			if (fuelgauge->pdata->capacity_calculation_type &
+				(SEC_FUELGAUGE_CAPACITY_TYPE_ATOMIC |
+				SEC_FUELGAUGE_CAPACITY_TYPE_SKIP_ABNORMAL))
+				s2mu003_fg_get_atomic_capacity(fuelgauge, val);
+		}
+
+		break;
+	/* Battery Temperature */
+	case POWER_SUPPLY_PROP_TEMP:
+	/* Target Temperature */
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		val->intval = s2mu003_get_temperature(fuelgauge);
+		break;
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = POWER_SUPPLY_STATUS_UNKNOWN;
+		break;
+	default:
+		return false;
+	}
+	return true;
+}
+
+static int s2mu003_fg_set_property(struct power_supply *psy,
+			enum power_supply_property psp,
+			const union power_supply_propval *val)
+{
+	struct s2mu003_fuelgauge_data *fuelgauge =
+		container_of(psy, struct s2mu003_fuelgauge_data, psy_fg);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_TEMP:
+		/* Target Temperature */
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		s2mu003_set_temperature(fuelgauge, val->intval);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static int s2mu003_fuelgauge_parse_dt(struct s2mu003_fuelgauge_data *fuelgauge)
+{
+
+	struct device_node *np =
+		of_find_node_by_name(NULL, "s2mu003-fuelgauge");
+	int ret;
+	int i, len;
+	const u32 *p;
+
+	/* reset, irq gpio info */
+	if (np == NULL) {
+		pr_err("%s np NULL1\n", __func__);
+	} else {
+		ret = of_property_read_u32(np, "fuelgauge,capacity_max",
+				&fuelgauge->pdata->capacity_max);
+		if (ret < 0)
+			pr_err("%s error reading capacity_max %d\n",
+							__func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_max_margin",
+				&fuelgauge->pdata->capacity_max_margin);
+		if (ret < 0)
+			pr_err("%s error reading capacity_max_margin %d\n",
+								__func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_min",
+				&fuelgauge->pdata->capacity_min);
+		if (ret < 0)
+			pr_err("%s error reading capacity_min %d\n",
+								__func__, ret);
+
+		ret = of_property_read_u32(np,
+				"fuelgauge,capacity_calculation_type",
+				&fuelgauge->pdata->capacity_calculation_type);
+		if (ret < 0)
+			pr_err("%s error reading capacity_calculation_type %d\n",
+					__func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,fuel_alert_soc",
+				&fuelgauge->pdata->fuel_alert_soc);
+		if (ret < 0)
+			pr_err("%s error reading pdata->fuel_alert_soc %d\n",
+					__func__, ret);
+		fuelgauge->pdata->repeated_fuelalert = of_property_read_bool(np,
+				"fuelgauge,repeated_fuelalert");
+
+		np = of_find_node_by_name(NULL, "battery");
+		if (!np) {
+			pr_err("%s np NULL2\n", __func__);
+			return 1;
+		} else {
+			ret = of_property_read_string(np,
+				"battery,fuelgauge_name",
+				(char const **)&fuelgauge->
+					pdata->fuelgauge_name);
+			p = of_get_property(np,
+					"battery,input_current_limit", &len);
+			if (!p)
+				return 1;
+
+			len = len / sizeof(u32);
+			fuelgauge->pdata->charging_current =
+				kzalloc(sizeof(struct sec_charging_current)
+							* len, GFP_KERNEL);
+
+			for (i = 0; i < len; i++) {
+				ret = of_property_read_u32_index(np,
+					"battery,input_current_limit", i,
+				&fuelgauge->pdata->charging_current[i].
+							input_current_limit);
+				ret = of_property_read_u32_index(np,
+					"battery,fast_charging_current", i,
+				&fuelgauge->pdata->charging_current[i].
+							fast_charging_current);
+				ret = of_property_read_u32_index(np,
+					"battery,full_check_current_1st", i,
+				&fuelgauge->pdata->charging_current[i].
+							full_check_current_1st);
+				ret = of_property_read_u32_index(np,
+					"battery,full_check_current_2nd", i,
+					&fuelgauge->pdata->charging_current[i].
+							full_check_current_2nd);
+			}
+		}
+	}
+
+	return 0;
+}
+
+static struct of_device_id s2mu003_fuelgauge_match_table[] = {
+	{ .compatible = "samsung,s2mu003-fuelgauge",},
+	{},
+};
+#else
+static int s2mu003_fuelgauge_parse_dt(struct s2mu003_fuelgauge_data *fuelgauge)
+{
+	return -ENOSYS;
+}
+
+#define s2mu003_fuelgauge_match_table NULL
+#endif /* CONFIG_OF */
+
+static int s2mu003_fuelgauge_probe(struct i2c_client *client,
+						const struct i2c_device_id *id)
+{
+	struct s2mu003_fuelgauge_data *fuelgauge;
+	union power_supply_propval raw_soc_val;
+	int ret = 0;
+
+	pr_info("%s: S2MU003 Fuelgauge Driver Loading\n", __func__);
+
+	fuelgauge = kzalloc(sizeof(*fuelgauge), GFP_KERNEL);
+	if (!fuelgauge)
+		return -ENOMEM;
+
+	mutex_init(&fuelgauge->fg_lock);
+
+	fuelgauge->i2c = client;
+
+#ifdef CONFIG_OF
+	fuelgauge->pdata = devm_kzalloc(&client->dev,
+			sizeof(*(fuelgauge->pdata)), GFP_KERNEL);
+	if (!fuelgauge->pdata) {
+		dev_err(&client->dev, "Failed to allocate memory\n");
+		ret = -ENOMEM;
+		goto err_parse_dt_nomem;
+	}
+	ret = s2mu003_fuelgauge_parse_dt(fuelgauge);
+	if (ret < 0)
+		goto err_parse_dt;
+#else
+		fuelgauge->pdata = mfd_pdata->charger_platform_data;
+#endif
+
+	i2c_set_clientdata(client, fuelgauge);
+
+	if (fuelgauge->pdata->fuelgauge_name == NULL)
+		fuelgauge->pdata->fuelgauge_name = "sec-fuelgauge";
+
+	fuelgauge->psy_fg.name          = fuelgauge->pdata->fuelgauge_name;
+	fuelgauge->psy_fg.type          = POWER_SUPPLY_TYPE_UNKNOWN;
+	fuelgauge->psy_fg.get_property  = s2mu003_fg_get_property;
+	fuelgauge->psy_fg.set_property  = s2mu003_fg_set_property;
+	fuelgauge->psy_fg.properties    = s2mu003_fuelgauge_props;
+	fuelgauge->psy_fg.num_properties =
+			ARRAY_SIZE(s2mu003_fuelgauge_props);
+
+	fuelgauge->capacity_max = fuelgauge->pdata->capacity_max;
+	raw_soc_val.intval = s2mu003_get_rawsoc(fuelgauge) / 10;
+
+	if (raw_soc_val.intval > fuelgauge->capacity_max)
+		s2mu003_fg_calculate_dynamic_scale(fuelgauge, 100);
+
+	ret = s2mu003_init_regs(fuelgauge);
+	if (ret < 0) {
+		pr_err("%s: Failed to Initialize Fuelgauge\n", __func__);
+		/* goto err_data_free; */
+	}
+
+	ret = power_supply_register(&client->dev, &fuelgauge->psy_fg);
+	if (ret) {
+		pr_err("%s: Failed to Register psy_fg\n", __func__);
+		goto err_data_free;
+	}
+
+	fuelgauge->initial_update_of_soc = true;
+
+	pr_info("%s: S2MU003 Fuelgauge Driver Loaded\n", __func__);
+	return 0;
+
+err_data_free:
+	if (client->dev.of_node)
+		kfree(fuelgauge->pdata);
+
+err_parse_dt:
+err_parse_dt_nomem:
+	mutex_destroy(&fuelgauge->fg_lock);
+	kfree(fuelgauge);
+
+	return ret;
+}
+
+static void s2mu003_fuelgauge_shutdown(struct i2c_client *i2c)
+{
+}
+
+static int s2mu003_fuelgauge_remove(struct i2c_client *i2c)
+{
+	struct s2mu003_fuelgauge_data *fuelgauge =
+				i2c_get_clientdata(i2c);
+
+	if (fuelgauge->pdata->fuel_alert_soc >= 0)
+		wake_lock_destroy(&fuelgauge->fuel_alert_wake_lock);
+
+	return 0;
+}
+
+#if defined CONFIG_PM
+static int s2mu003_fuelgauge_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int s2mu003_fuelgauge_resume(struct device *dev)
+{
+	struct i2c_client *i2c =
+		container_of(dev, struct i2c_client, dev);
+	struct s2mu003_fuelgauge_data *fuelgauge =
+				i2c_get_clientdata(i2c);
+	fuelgauge->initial_update_of_soc = true;
+
+	return 0;
+}
+#else
+#define s2mu003_fuelgauge_suspend NULL
+#define s2mu003_fuelgauge_resume NULL
+#endif
+
+static const struct i2c_device_id s2mu003_fuelgauge_id[] = {
+	{"s2mu003-fuelgauge", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, s2mu003_fuelgauge_id);
+
+static SIMPLE_DEV_PM_OPS(s2mu003_fuelgauge_pm_ops, s2mu003_fuelgauge_suspend,
+		s2mu003_fuelgauge_resume);
+
+static struct i2c_driver s2mu003_fuelgauge_driver = {
+	.driver = {
+		.name = "s2mu003-fuelgauge",
+		.owner = THIS_MODULE,
+		.pm = &s2mu003_fuelgauge_pm_ops,
+		.of_match_table = s2mu003_fuelgauge_match_table,
+	},
+	.probe  = s2mu003_fuelgauge_probe,
+	.remove = s2mu003_fuelgauge_remove,
+	.shutdown   = s2mu003_fuelgauge_shutdown,
+	.id_table   = s2mu003_fuelgauge_id,
+};
+
+static int __init s2mu003_fuelgauge_init(void)
+{
+	int ret = 0;
+
+	ret = i2c_add_driver(&s2mu003_fuelgauge_driver);
+
+	return ret;
+}
+
+static void __exit s2mu003_fuelgauge_exit(void)
+{
+	i2c_del_driver(&s2mu003_fuelgauge_driver);
+}
+module_init(s2mu003_fuelgauge_init);
+module_exit(s2mu003_fuelgauge_exit);
+
+MODULE_DESCRIPTION("Samsung S2MU003 Fuel Gauge Driver");
+MODULE_AUTHOR("Samsung Electronics");
+MODULE_LICENSE("GPL");
diff -Naur linux-3.18.14/drivers/power/s2mu005_charger.c samsung/drivers/power/s2mu005_charger.c
--- linux-3.18.14/drivers/power/s2mu005_charger.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/power/s2mu005_charger.c	2018-10-29 07:24:39.000000000 +0100
@@ -0,0 +1,1572 @@
+/* drivers/battery/s2mu005_charger.c
+ * S2MU005 Charger Driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ */
+#include <linux/mfd/samsung/s2mu005.h>
+#include <linux/power/s2mu005_charger.h>
+#include <linux/version.h>
+
+#if defined(CONFIG_MUIC_NOTIFIER)
+#include <linux/muic/muic.h>
+#include <linux/muic/muic_notifier.h>
+#endif
+
+#define ENABLE_MIVR 1
+
+#define EN_OVP_IRQ 1
+#define EN_IEOC_IRQ 1
+#define EN_TOPOFF_IRQ 1
+#define EN_RECHG_REQ_IRQ 0
+#define EN_TR_IRQ 0
+#define EN_MIVR_SW_REGULATION 0
+#define EN_BST_IRQ 0
+#define MINVAL(a, b) ((a <= b) ? a : b)
+
+#define EOC_DEBOUNCE_CNT 2
+#define HEALTH_DEBOUNCE_CNT 3
+#define DEFAULT_CHARGING_CURRENT 500
+
+#define EOC_SLEEP 200
+#define EOC_TIMEOUT (EOC_SLEEP * 6)
+#ifndef EN_TEST_READ
+#define EN_TEST_READ 1
+#endif
+
+struct s2mu005_charger_data {
+	struct i2c_client       *client;
+	struct device *dev;
+	struct s2mu005_platform_data *s2mu005_pdata;
+	struct delayed_work	charger_work;
+	struct workqueue_struct *charger_wqueue;
+	struct power_supply	psy_chg;
+	struct power_supply	psy_battery;
+	struct power_supply	psy_usb;
+	struct power_supply	psy_ac;
+	s2mu005_charger_platform_data_t *pdata;
+	int dev_id;
+	int charging_current;
+	int siop_level;
+	int cable_type;
+	int battery_cable_type;
+	int charge_mode;
+	bool is_charging;
+	struct mutex io_lock;
+	bool noti_check;
+
+	/* register programming */
+	int reg_addr;
+	int reg_data;
+
+	bool full_charged;
+	bool ovp;
+	int unhealth_cnt;
+	bool battery_valid;
+	int status;
+	int health;
+
+	/* s2mu005 */
+	int irq_det_bat;
+	int irq_chg;
+	struct delayed_work polling_work;
+#if defined(CONFIG_SEC_FUELGAUGE_S2MU005)
+	int voltage_now;
+	int voltage_avg;
+	int voltage_ocv;
+	unsigned int capacity;
+#endif
+#if defined(CONFIG_MUIC_NOTIFIER)
+	struct notifier_block cable_check;
+#endif
+};
+
+static char *s2mu005_supplied_to[] = {
+	"s2mu005-battery",
+};
+
+static enum power_supply_property s2mu005_power_props[] = {
+	POWER_SUPPLY_PROP_ONLINE,
+};
+
+static enum power_supply_property s2mu005_charger_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_CHARGE_TYPE,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_CURRENT_MAX,
+	POWER_SUPPLY_PROP_CURRENT_AVG,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL,
+};
+
+static enum power_supply_property s2mu005_battery_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_CHARGE_TYPE,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
+	POWER_SUPPLY_PROP_CHARGE_FULL,
+	POWER_SUPPLY_PROP_CHARGE_NOW,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_CAPACITY_LEVEL,
+	POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG,
+	POWER_SUPPLY_PROP_TIME_TO_FULL_NOW,
+	POWER_SUPPLY_PROP_MODEL_NAME,
+	POWER_SUPPLY_PROP_MANUFACTURER,
+	POWER_SUPPLY_PROP_SERIAL_NUMBER,
+	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+};
+
+static int s2mu005_get_charging_health(struct s2mu005_charger_data *charger);
+
+static void s2mu005_test_read(struct i2c_client *i2c)
+{
+	u8 data;
+	char str[1016] = {0,};
+	int i;
+
+	for (i = 0x8; i <= 0x1A; i++) {
+		s2mu005_read_reg(i2c, i, &data);
+
+		sprintf(str+strlen(str), "0x%02x:0x%02x, ", i, data);
+	}
+
+	pr_err("[DEBUG]%s: %s\n", __func__, str);
+}
+
+
+static void s2mu005_charger_otg_control(struct s2mu005_charger_data *charger,
+		bool enable)
+{
+	if (!enable) {
+		/* turn off OTG */
+		s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL15,
+			0 << T_EN_OTG_SHIFT, T_EN_OTG_MASK);
+
+		/* set mode to BUCK mode */
+		s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL0,
+			1 << REG_MODE_SHIFT, REG_MODE_MASK);
+
+		/* mask VMID_INT */
+		s2mu005_update_reg(charger->client, S2MU005_REG_SC_INT_MASK,
+			1 << VMID_M_SHIFT, VMID_M_MASK);
+
+		pr_info("%s : Turn off OTG\n",	__func__);
+	} else {
+		/* unmask VMID_INT */
+		s2mu005_update_reg(charger->client, S2MU005_REG_SC_INT_MASK,
+			0 << VMID_M_SHIFT, VMID_M_MASK);
+
+		/* set mode to OTG */
+		s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL0,
+			4 << REG_MODE_SHIFT, REG_MODE_MASK);
+
+		/* set boost frequency to 2MHz */
+		s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL11,
+			3 << SET_OSC_BST_SHIFT, SET_OSC_BST_MASK);
+
+		/* set OTG current limit to 1.5 A */
+		s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL4,
+			3 << SET_OTG_OCP_SHIFT, SET_OTG_OCP_MASK);
+
+		/* VBUS switches are OFF when OTG over-current happen */
+		s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL4,
+			1 << OTG_OCP_SW_OFF_SHIFT, OTG_OCP_SW_OFF_MASK);
+
+		/* set OTG voltage to 5.1 V */
+		s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL5,
+			0x16 << SET_VF_VMID_BST_SHIFT, SET_VF_VMID_BST_MASK);
+
+		/* turn on OTG */
+		s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL15,
+			3 << T_EN_OTG_SHIFT, T_EN_OTG_MASK);
+
+		pr_info("%s : Turn on OTG\n",	__func__);
+	}
+}
+
+static void s2mu005_enable_charger_switch(struct s2mu005_charger_data *charger,
+		int onoff)
+{
+	if (onoff > 0) {
+		pr_err("[DEBUG]%s: turn on charger\n", __func__);
+		s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL0,
+			0 << REG_MODE_SHIFT, REG_MODE_MASK);
+		msleep(50);
+		s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL0,
+			2 << REG_MODE_SHIFT, REG_MODE_MASK);
+	} else {
+		charger->full_charged = false;
+		pr_err("[DEBUG] %s: turn off charger\n", __func__);
+		s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL0,
+			0 << REG_MODE_SHIFT, REG_MODE_MASK);
+	}
+}
+
+
+static void s2mu005_set_regulation_voltage(struct s2mu005_charger_data *charger,
+		int float_voltage)
+{
+	int data;
+
+	pr_err("[DEBUG]%s: float_voltage %d \n", __func__, float_voltage);
+	if (float_voltage <= 3900)
+		data = 0;
+	else if (float_voltage > 3900 && float_voltage <= 4400)
+		data = (float_voltage - 3900) / 10;
+	else
+		data = 0x32;
+
+	s2mu005_update_reg(charger->client,
+		S2MU005_CHG_CTRL8, data << SET_VF_VBAT_SHIFT, SET_VF_VBAT_MASK);
+}
+
+static void s2mu005_set_input_current_limit(struct s2mu005_charger_data *charger,
+		int charging_current)
+{
+	int data;
+
+	pr_err("[DEBUG]%s: current  %d \n", __func__, charging_current);
+	if (charging_current <= 100)
+		data = 0;
+	else if (charging_current >= 100 && charging_current <= 2600)
+		data = (charging_current - 100) / 50;
+	else
+		data = 0x3F;
+
+	s2mu005_update_reg(charger->client, S2MU005_CHG_CTRL2,
+	data << INPUT_CURRENT_LIMIT_SHIFT, INPUT_CURRENT_LIMIT_MASK);
+	s2mu005_test_read(charger->client);
+}
+
+static int s2mu005_get_input_current_limit(struct i2c_client *i2c)
+{
+	u8 data;
+
+	s2mu005_read_reg(i2c, S2MU005_CHG_CTRL2, &data);
+	if (data < 0)
+		return data;
+
+	data = data & INPUT_CURRENT_LIMIT_MASK;
+
+	if (data > 0x3F)
+		data = 0x3F;
+	return  data * 50 + 100;
+
+}
+
+static void s2mu005_set_fast_charging_current(struct i2c_client *i2c,
+		int charging_current)
+{
+	int data;
+
+	pr_err("[DEBUG]%s: current  %d \n", __func__, charging_current);
+	if (charging_current <= 100)
+		data = 0;
+	else if (charging_current >= 100 && charging_current <= 2600)
+		data = ((charging_current - 100) / 50) + 1;
+	else
+		data = 0x33;
+
+	s2mu005_update_reg(i2c, S2MU005_CHG_CTRL7, data << FAST_CHARGING_CURRENT_SHIFT,
+			FAST_CHARGING_CURRENT_MASK);
+	s2mu005_test_read(i2c);
+}
+
+static int s2mu005_get_fast_charging_current(struct i2c_client *i2c)
+{
+	u8 data;
+
+	s2mu005_read_reg(i2c, S2MU005_CHG_CTRL7, &data);
+	if (data < 0)
+		return data;
+
+	data = data & FAST_CHARGING_CURRENT_MASK;
+
+	if (data > 0x33)
+		data = 0x33;
+	return (data - 1) * 50 + 100;
+}
+
+static int s2mu005_get_current_eoc_setting(struct s2mu005_charger_data *charger)
+{
+	u8 data;
+
+	s2mu005_read_reg(charger->client, S2MU005_CHG_CTRL10, &data);
+	if (data < 0)
+		return data;
+
+	data = data & FIRST_TOPOFF_CURRENT_MASK;
+
+	if (data > 0x0F)
+		data = 0x0F;
+	return data * 25 + 100;
+}
+
+static void s2mu005_set_topoff_current(struct i2c_client *i2c,
+		int eoc_1st_2nd, int current_limit)
+{
+	int data;
+
+	pr_err("[DEBUG]%s: current  %d \n", __func__, current_limit);
+	if (current_limit <= 100)
+		data = 0;
+	else if (current_limit > 100 && current_limit <= 475)
+		data = (current_limit - 100) / 25;
+	else
+		data = 0x0F;
+
+	switch (eoc_1st_2nd) {
+	case 1:
+		s2mu005_update_reg(i2c, S2MU005_CHG_CTRL10, data << FIRST_TOPOFF_CURRENT_SHIFT,
+			FIRST_TOPOFF_CURRENT_MASK);
+		break;
+	case 2:
+		s2mu005_update_reg(i2c, S2MU005_CHG_CTRL10, data << SECOND_TOPOFF_CURRENT_SHIFT,
+			SECOND_TOPOFF_CURRENT_MASK);
+		break;
+	default:
+		break;
+	}
+}
+
+/* eoc reset */
+static void s2mu005_set_charging_current(struct s2mu005_charger_data *charger)
+{
+	int adj_current = 0;
+
+	pr_err("[DEBUG]%s: charger->siop_level  %d \n", __func__, charger->siop_level);
+	adj_current = charger->charging_current * charger->siop_level / 100;
+	s2mu005_set_fast_charging_current(charger->client, adj_current);
+	s2mu005_test_read(charger->client);
+}
+
+enum {
+	S2MU005_MIVR_4200MV = 0,
+	S2MU005_MIVR_4300MV,
+	S2MU005_MIVR_4400MV,
+	S2MU005_MIVR_4500MV,
+	S2MU005_MIVR_4600MV,
+	S2MU005_MIVR_4700MV,
+	S2MU005_MIVR_4800MV,
+	S2MU005_MIVR_4900MV,
+};
+
+#if ENABLE_MIVR
+/* charger input regulation voltage setting */
+static void s2mu005_set_mivr_level(struct s2mu005_charger_data *charger)
+{
+	int mivr = S2MU005_MIVR_4400MV;
+
+	s2mu005_update_reg(charger->client,
+			S2MU005_CHG_CTRL1, mivr << SET_VIN_DROP_SHIFT, SET_VIN_DROP_MASK);
+}
+#endif /* ENABLE_MIVR */
+
+static void s2mu005_configure_charger(struct s2mu005_charger_data *charger)
+{
+
+	int eoc, current_limit = 0;
+	union power_supply_propval chg_mode;
+	union power_supply_propval swelling_state;
+
+	pr_err("[DEBUG] %s \n", __func__);
+	if (charger->charging_current < 0) {
+		pr_info("%s : OTG is activated. Ignore command!\n",
+				__func__);
+		return;
+	}
+
+#if ENABLE_MIVR
+	s2mu005_set_mivr_level(charger);
+#endif /* DISABLE_MIVR */
+
+	/* msleep(200); */
+
+	/* Input current limit */
+	if ((charger->dev_id == 0) && (charger->cable_type == POWER_SUPPLY_TYPE_USB)) {
+		current_limit = 700; /* only for EVT0 */
+	} else {
+		current_limit = charger->pdata->charging_current_table
+			[charger->cable_type].input_current_limit;
+	}
+	pr_err("[DEBUG] %s : input current (%dmA)\n", __func__, current_limit);
+
+	s2mu005_set_input_current_limit(charger, current_limit);
+
+	/* Float voltage */
+	pr_err("[DEBUG] %s : float voltage (%dmV)\n",
+			__func__, charger->pdata->chg_float_voltage);
+
+	s2mu005_set_regulation_voltage(charger,
+			charger->pdata->chg_float_voltage);
+
+	charger->charging_current = charger->pdata->charging_current_table
+		[charger->cable_type].fast_charging_current;
+
+	/* Fast charge */
+	pr_err("[DEBUG] %s : fast charging current (%dmA)\n",
+			__func__, charger->charging_current);
+
+	s2mu005_set_charging_current(charger);
+
+	/* Termination current */
+	if (charger->pdata->chg_eoc_dualpath == true) {
+		eoc = charger->pdata->charging_current_table
+			[charger->cable_type].full_check_current_1st;
+		s2mu005_set_topoff_current(charger->client, 1, eoc);
+
+		eoc = charger->pdata->charging_current_table
+			[charger->cable_type].full_check_current_2nd;
+		s2mu005_set_topoff_current(charger->client, 2, eoc);
+	} else {
+		if (charger->pdata->full_check_type_2nd == SEC_BATTERY_FULLCHARGED_CHGPSY) {
+			psy_do_property("battery", get,
+					POWER_SUPPLY_PROP_CHARGE_NOW,
+					chg_mode);
+#if defined(CONFIG_BATTERY_SWELLING)
+			psy_do_property("battery", get,
+					POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT,
+					swelling_state);
+#else
+			swelling_state.intval = 0;
+#endif
+			if (chg_mode.intval == SEC_BATTERY_CHARGING_2ND || swelling_state.intval) {
+				s2mu005_enable_charger_switch(charger, 0);
+				eoc = charger->pdata->charging_current_table
+					[charger->cable_type].full_check_current_2nd;
+			} else {
+				eoc = charger->pdata->charging_current_table
+					[charger->cable_type].full_check_current_1st;
+			}
+		} else {
+			eoc = charger->pdata->charging_current_table
+				[charger->cable_type].full_check_current_1st;
+		}
+		pr_info("[DEBUG]%s : termination current (%dmA)\n",
+			__func__, eoc);
+		s2mu005_set_topoff_current(charger->client, 1, eoc);
+	}
+	s2mu005_enable_charger_switch(charger, 1);
+}
+
+/* here is set init charger data */
+#define S2MU005_MRSTB_CTRL 0X47
+static bool s2mu005_chg_init(struct s2mu005_charger_data *charger)
+{
+	u8 temp;
+	/* Read Charger IC Dev ID */
+	s2mu005_read_reg(charger->client, S2MU005_REG_REV_ID, &temp);
+	charger->dev_id = temp & 0x0F;
+
+	dev_info(&charger->client->dev, "%s : DEV ID : 0x%x\n", __func__,
+			charger->dev_id);
+	s2mu005_update_reg(charger->client, 0x59, 0x00, 0x01 << 3);
+	s2mu005_update_reg(charger->client, 0x20, 0x7 << 3, 0x07 << 3);
+	s2mu005_update_reg(charger->client, 0x7C, 0x01, 0x01);
+	s2mu005_update_reg(charger->client, 0x29, 0x00, 0x01 << 7);
+	s2mu005_update_reg(charger->client, 0x13, 0x00, 0x01 << 7);
+	s2mu005_update_reg(charger->client, 0x1A, 0x00, 0x01 << 4);
+	s2mu005_update_reg(charger->client, 0x01, 0x01 << 7, 0x01 << 7);
+	/* Buck switching mode frequency setting */
+
+	/* Disable Timer function (Charging timeout fault) */
+	/* to be */
+
+	/* Disable TE */
+	/* to be */
+
+	/* MUST set correct regulation voltage first
+	 * Before MUIC pass cable type information to charger
+	 * charger would be already enabled (default setting)
+	 * it might cause EOC event by incorrect regulation voltage */
+	/* to be */
+
+#if !(ENABLE_MIVR)
+	/* voltage regulatio disable does not exist mu005 */
+#endif
+	/* TOP-OFF debounce time set 256us */
+	/* only 003 ? need to check */
+
+	/* Disable (set 0min TOP OFF Timer) */
+	/* to be */
+
+
+	return true;
+}
+
+static int s2mu005_get_charging_status(struct s2mu005_charger_data *charger)
+{
+	int status = POWER_SUPPLY_STATUS_UNKNOWN;
+	int ret;
+	u8 chg_sts;
+	union power_supply_propval chg_mode;
+	union power_supply_propval value;
+
+	ret = s2mu005_read_reg(charger->client, S2MU005_CHG_STATUS0, &chg_sts);
+	psy_do_property("s2mu005-battery", get, POWER_SUPPLY_PROP_CHARGE_NOW, chg_mode);
+	psy_do_property(charger->pdata->fuelgauge_name, get, POWER_SUPPLY_PROP_CURRENT_AVG, value);
+
+	if (ret < 0)
+		return status;
+
+	switch (chg_sts & 0x0F) {
+	case 0x00:	/* charger is off */
+		status = POWER_SUPPLY_STATUS_DISCHARGING;
+		break;
+	case 0x02:	/* Pre-charge state */
+	case 0x03:	/* Cool-charge state */
+	case 0x04:	/* CC state */
+	case 0x05:	/* CV state */
+		status = POWER_SUPPLY_STATUS_CHARGING;
+		break;
+	case 0x07:	/* Top-off state */
+	case 0x06:	/* Done Flag */
+	case 0x08:	/* Done state */
+		if (value.intval < charger->pdata->charging_current_table
+			[charger->cable_type].full_check_current_1st) {
+			status = POWER_SUPPLY_STATUS_FULL;
+			charger->charge_mode = SEC_BATTERY_CHARGING_NONE;
+			s2mu005_enable_charger_switch(charger, 0);
+		} else
+			status = POWER_SUPPLY_STATUS_CHARGING;
+		break;
+	case 0x0F:	/* Input is invalid */
+		status = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		break;
+	default:
+		break;
+	}
+
+	return status;
+}
+
+static int s2mu005_get_charge_type(struct i2c_client *iic)
+{
+	int status = POWER_SUPPLY_CHARGE_TYPE_UNKNOWN;
+	u8 ret;
+
+	s2mu005_read_reg(iic, S2MU005_CHG_STATUS0, &ret);
+	if (ret < 0)
+		dev_err(&iic->dev, "%s fail\n", __func__);
+
+	switch (ret & CHG_OK_MASK) {
+	case CHG_OK_MASK:
+		status = POWER_SUPPLY_CHARGE_TYPE_FAST;
+		break;
+	default:
+		/* 005 does not need to do this */
+		/* pre-charge mode */
+		status = POWER_SUPPLY_CHARGE_TYPE_TRICKLE;
+		break;
+	}
+
+	return status;
+}
+
+static bool s2mu005_get_batt_present(struct i2c_client *iic)
+{
+	u8 ret;
+
+	s2mu005_read_reg(iic, S2MU005_CHG_STATUS1, &ret);
+	if (ret < 0)
+		return false;
+
+	return (ret & DET_BAT_STATUS_MASK) ? true : false;
+}
+
+static int s2mu005_get_charging_health(struct s2mu005_charger_data *charger)
+{
+
+	u8 ret;
+
+	s2mu005_read_reg(charger->client, S2MU005_CHG_STATUS0, &ret);
+
+	if (ret < 0)
+		return POWER_SUPPLY_HEALTH_UNKNOWN;
+
+	if (ret & (CHG_STATUS_MASK)) {
+		charger->ovp = false;
+		return POWER_SUPPLY_HEALTH_GOOD;
+	}
+
+	/* 005 need to check ovp & health count */
+	charger->unhealth_cnt = HEALTH_DEBOUNCE_CNT;
+	if (charger->ovp)
+		return POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+	return POWER_SUPPLY_HEALTH_UNDERVOLTAGE;
+}
+
+static int sec_chg_get_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		union power_supply_propval *val)
+{
+	int chg_curr, aicr;
+	struct s2mu005_charger_data *charger =
+		container_of(psy, struct s2mu005_charger_data, psy_chg);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = charger->charging_current ? 1 : 0;
+		break;
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = s2mu005_get_charging_status(charger);
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = s2mu005_get_charging_health(charger);
+		s2mu005_test_read(charger->client);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		val->intval = 2000;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		if (charger->charging_current) {
+			aicr = s2mu005_get_input_current_limit(charger->client);
+			chg_curr = s2mu005_get_fast_charging_current(charger->client);
+			val->intval = MINVAL(aicr, chg_curr);
+		} else
+			val->intval = 0;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+		val->intval = s2mu005_get_charge_type(charger->client);
+		break;
+#if defined(CONFIG_BATTERY_SWELLING) || defined(CONFIG_BATTERY_SWELLING_SELF_DISCHARGING)
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+		val->intval = charger->pdata->chg_float_voltage;
+		break;
+#endif
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = s2mu005_get_batt_present(charger->client);
+		break;
+	case POWER_SUPPLY_PROP_CHARGING_ENABLED:
+		val->intval = charger->is_charging;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sec_chg_set_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		const union power_supply_propval *val)
+{
+	struct s2mu005_charger_data *charger =
+		container_of(psy, struct s2mu005_charger_data, psy_chg);
+
+	int eoc;
+	int previous_cable_type = charger->cable_type;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		charger->status = val->intval;
+		break;
+		/* val->intval : type */
+	case POWER_SUPPLY_PROP_ONLINE:
+		charger->cable_type = val->intval;
+		if (charger->cable_type == POWER_SUPPLY_TYPE_BATTERY ||
+				charger->cable_type == POWER_SUPPLY_TYPE_UNKNOWN) {
+			pr_err("[DEBUG]%s:[BATT] Type Battery\n", __func__);
+
+			if (previous_cable_type == POWER_SUPPLY_TYPE_OTG)
+				s2mu005_charger_otg_control(charger, false);
+
+
+			charger->charging_current = charger->pdata->charging_current_table
+				[POWER_SUPPLY_TYPE_USB].fast_charging_current;
+			s2mu005_set_input_current_limit(charger,
+					charger->pdata->charging_current_table
+					[POWER_SUPPLY_TYPE_USB].input_current_limit);
+			s2mu005_set_charging_current(charger);
+			s2mu005_set_topoff_current(charger->client, 1,
+					charger->pdata->charging_current_table
+					[POWER_SUPPLY_TYPE_USB].full_check_current_1st);
+
+			charger->is_charging = false;
+			charger->full_charged = false;
+			charger->charge_mode = SEC_BATTERY_CHARGING_NONE;
+			s2mu005_enable_charger_switch(charger, 0);
+		} else if (charger->cable_type == POWER_SUPPLY_TYPE_OTG) {
+			pr_err("[DEBUG]%s: OTG mode\n", __func__);
+			s2mu005_charger_otg_control(charger, true);
+		} else {
+			pr_err("[DEBUG]%s:[BATT] Set charging"
+				", Cable type = %d\n", __func__, charger->cable_type);
+			/* Enable charger */
+			s2mu005_configure_charger(charger);
+			charger->charge_mode = SEC_BATTERY_CHARGING_1ST;
+			charger->is_charging = true;
+		}
+#if EN_TEST_READ
+		msleep(100);
+#endif
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		pr_err("[DEBUG] %s: is_charging %d\n", __func__, charger->is_charging);
+		/* set charging current */
+		if (charger->is_charging) {
+			/* decrease the charging current according to siop level */
+			charger->siop_level = val->intval;
+			pr_err("[DEBUG] %s:SIOP level = %d, chg current = %d\n", __func__,
+					val->intval, charger->charging_current);
+			eoc = s2mu005_get_current_eoc_setting(charger);
+			s2mu005_set_charging_current(charger);
+			s2mu005_set_topoff_current(charger->client, 1, 0);
+		}
+		break;
+#if defined(CONFIG_BATTERY_SWELLING) || defined(CONFIG_BATTERY_SWELLING_SELF_DISCHARGING)
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+		pr_err("[DEBUG]%s: float voltage(%d)\n", __func__, val->intval);
+		charger->pdata->chg_float_voltage = val->intval;
+		s2mu005_set_regulation_voltage(charger,
+				charger->pdata->chg_float_voltage);
+		break;
+#endif
+	case POWER_SUPPLY_PROP_POWER_NOW:
+		eoc = s2mu005_get_current_eoc_setting(charger);
+		pr_err("[DEBUG]%s:Set Power Now -> chg current = %d mA, eoc = %d mA\n", __func__,
+				val->intval, eoc);
+		s2mu005_set_charging_current(charger);
+		s2mu005_set_topoff_current(charger->client, 1, 0);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL:
+		s2mu005_charger_otg_control(charger, val->intval);
+		break;
+	case POWER_SUPPLY_PROP_CHARGING_ENABLED:
+		pr_err("[DEBUG]%s: CHARGING_ENABLE\n", __func__);
+		/* charger->is_charging = val->intval; */
+		s2mu005_enable_charger_switch(charger, val->intval);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*
+ssize_t s2mu003_chg_show_attrs(struct device *dev,
+		const ptrdiff_t offset, char *buf)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct s2mu003_charger_data *charger =
+		container_of(psy, struct s2mu003_charger_data, psy_chg);
+	int i = 0;
+	char *str = NULL;
+
+	switch (offset) {
+	case CHG_REG:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%x\n",
+				charger->reg_addr);
+		break;
+	case CHG_DATA:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%x\n",
+				charger->reg_data);
+		break;
+	case CHG_REGS:
+		str = kzalloc(sizeof(char) * 256, GFP_KERNEL);
+		if (!str)
+			return -ENOMEM;
+
+	//	s2mu005_read_regs(charger->client, str);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%s\n",
+				str);
+
+		kfree(str);
+		break;
+	default:
+		i = -EINVAL;
+		break;
+	}
+
+	return i;
+}
+
+ssize_t s2mu003_chg_store_attrs(struct device *dev,
+		const ptrdiff_t offset,
+		const char *buf, size_t count)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct s2mu003_charger_data *charger =
+		container_of(psy, struct s2mu003_charger_data, psy_chg);
+
+	int ret = 0;
+	int x = 0;
+	uint8_t data = 0;
+
+	switch (offset) {
+	case CHG_REG:
+		if (sscanf(buf, "%x\n", &x) == 1) {
+			charger->reg_addr = x;
+			data = s2mu003_reg_read(charger->client,
+					charger->reg_addr);
+			charger->reg_data = data;
+			dev_dbg(dev, "%s: (read) addr = 0x%x, data = 0x%x\n",
+					__func__, charger->reg_addr, charger->reg_data);
+			ret = count;
+		}
+		break;
+	case CHG_DATA:
+		if (sscanf(buf, "%x\n", &x) == 1) {
+			data = (u8)x;
+
+			dev_dbg(dev, "%s: (write) addr = 0x%x, data = 0x%x\n",
+					__func__, charger->reg_addr, data);
+			ret = s2mu003_reg_write(charger->client,
+					charger->reg_addr, data);
+			if (ret < 0) {
+				dev_dbg(dev, "I2C write fail Reg0x%x = 0x%x\n",
+						(int)charger->reg_addr, (int)data);
+			}
+			ret = count;
+		}
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+*/
+
+static int s2mu005_usb_get_property(struct power_supply *psy,
+				enum power_supply_property psp,
+				union power_supply_propval *val)
+{
+	struct s2mu005_charger_data *charger =
+		container_of(psy, struct s2mu005_charger_data, psy_usb);
+
+	if (psp != POWER_SUPPLY_PROP_ONLINE)
+		return -EINVAL;
+
+	/* Set enable=1 only if the USB charger is connected */
+	switch (charger->battery_cable_type) {
+	case POWER_SUPPLY_TYPE_USB:
+	case POWER_SUPPLY_TYPE_USB_DCP:
+	case POWER_SUPPLY_TYPE_USB_CDP:
+	case POWER_SUPPLY_TYPE_USB_ACA:
+		val->intval = 1;
+		break;
+	default:
+		val->intval = 0;
+		break;
+	}
+
+	return 0;
+}
+
+static int s2mu005_ac_get_property(struct power_supply *psy,
+			       enum power_supply_property psp,
+			       union power_supply_propval *val)
+{
+	struct s2mu005_charger_data *charger =
+		container_of(psy, struct s2mu005_charger_data, psy_ac);
+
+	if (psp != POWER_SUPPLY_PROP_ONLINE)
+		return -EINVAL;
+
+	/* Set enable=1 only if the AC charger is connected */
+	switch (charger->battery_cable_type) {
+	case POWER_SUPPLY_TYPE_MAINS:
+	case POWER_SUPPLY_TYPE_UARTOFF:
+	case POWER_SUPPLY_TYPE_LAN_HUB:
+	case POWER_SUPPLY_TYPE_UNKNOWN:
+	case POWER_SUPPLY_TYPE_HV_PREPARE_MAINS:
+	case POWER_SUPPLY_TYPE_HV_ERR:
+	case POWER_SUPPLY_TYPE_HV_UNKNOWN:
+	case POWER_SUPPLY_TYPE_HV_MAINS:
+		val->intval = 1;
+		break;
+	default:
+		val->intval = 0;
+		break;
+	}
+
+	return 0;
+}
+
+static int s2mu005_battery_get_property(struct power_supply *psy,
+		enum power_supply_property psp, union power_supply_propval *val)
+{
+	struct s2mu005_charger_data *charger =
+		container_of(psy, struct s2mu005_charger_data, psy_battery);
+#if defined(CONFIG_SEC_FUELGAUGE_S2MU005)
+	union power_supply_propval value;
+	int charger_status = 0;
+#endif
+	int ret = 0;
+
+	dev_dbg(&charger->client->dev, "prop: %d\n", psp);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = s2mu005_get_charging_status(charger);
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = s2mu005_get_charging_health(charger);
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = charger->battery_cable_type;
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = charger->battery_valid;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+		val->intval = POWER_SUPPLY_CHARGE_TYPE_FAST;
+		break;
+	case POWER_SUPPLY_PROP_TECHNOLOGY:
+		val->intval = POWER_SUPPLY_TECHNOLOGY_LIPO;
+		break;
+	case POWER_SUPPLY_PROP_SCOPE:
+		val->intval = POWER_SUPPLY_SCOPE_SYSTEM;
+		break;
+#if defined(CONFIG_SEC_FUELGAUGE_S2MU005)
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		if (!charger->battery_valid)
+			val->intval = FAKE_BAT_LEVEL;
+		else {
+			psy_do_property_dup(charger->pdata->fuelgauge_name, get,
+					POWER_SUPPLY_PROP_VOLTAGE_NOW, value);
+			charger->voltage_now = value.intval;
+			dev_err(&charger->client->dev,
+				"%s: voltage now(%d)\n", __func__,
+							charger->voltage_now);
+			val->intval = charger->voltage_now * 1000;
+		}
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_AVG:
+		value.intval = SEC_BATTERY_VOLTAGE_AVERAGE;
+		psy_do_property_dup(charger->pdata->fuelgauge_name, get,
+				POWER_SUPPLY_PROP_VOLTAGE_AVG, value);
+		charger->voltage_avg = value.intval;
+		dev_err(&charger->client->dev,
+			"%s: voltage avg(%d)\n", __func__,
+						charger->voltage_avg);
+		val->intval = charger->voltage_now * 1000;
+		break;
+	case POWER_SUPPLY_PROP_TEMP:
+		val->intval = FAKE_BAT_LEVEL;
+		break;
+#endif
+	case POWER_SUPPLY_PROP_CAPACITY:
+#if defined(CONFIG_SEC_FUELGAUGE_S2MU005)
+		if (!charger->battery_valid)
+			val->intval = FAKE_BAT_LEVEL;
+		else {
+			charger_status = s2mu005_get_charging_status(charger);
+			if (charger_status
+					== POWER_SUPPLY_STATUS_FULL)
+				val->intval = 100;
+			else
+				val->intval = charger->capacity;
+		}
+#else
+		val->intval = FAKE_BAT_LEVEL;
+#endif
+		break;
+	default:
+		ret = -ENODATA;
+	}
+
+	return ret;
+}
+
+static int s2mu005_battery_set_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		const union power_supply_propval *val)
+{
+	struct s2mu005_charger_data *charger =
+		container_of(psy, struct s2mu005_charger_data, psy_battery);
+	int ret = 0;
+
+	dev_dbg(&charger->client->dev, "prop: %d\n", psp);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		charger->status = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		charger->health = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		charger->battery_cable_type = val->intval;
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+#if defined(CONFIG_MUIC_NOTIFIER)
+static int s2mu005_bat_cable_check(struct s2mu005_charger_data *charger,
+				muic_attached_dev_t attached_dev)
+{
+	int current_cable_type = -1;
+
+	pr_debug("[%s]ATTACHED(%d)\n", __func__, attached_dev);
+
+	switch (attached_dev) {
+	case ATTACHED_DEV_JIG_UART_OFF_MUIC:
+		break;
+	case ATTACHED_DEV_SMARTDOCK_MUIC:
+	case ATTACHED_DEV_DESKDOCK_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_BATTERY;
+		break;
+	case ATTACHED_DEV_OTG_MUIC:
+	case ATTACHED_DEV_JIG_UART_OFF_VB_OTG_MUIC:
+	case ATTACHED_DEV_HMT_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_OTG;
+		break;
+	case ATTACHED_DEV_USB_MUIC:
+	case ATTACHED_DEV_JIG_USB_OFF_MUIC:
+	case ATTACHED_DEV_JIG_USB_ON_MUIC:
+	case ATTACHED_DEV_SMARTDOCK_USB_MUIC:
+	case ATTACHED_DEV_UNOFFICIAL_ID_USB_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_USB;
+		break;
+	case ATTACHED_DEV_JIG_UART_OFF_VB_MUIC:
+	case ATTACHED_DEV_JIG_UART_OFF_VB_FG_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_UARTOFF;
+		break;
+	case ATTACHED_DEV_TA_MUIC:
+	case ATTACHED_DEV_CARDOCK_MUIC:
+	case ATTACHED_DEV_DESKDOCK_VB_MUIC:
+	case ATTACHED_DEV_SMARTDOCK_TA_MUIC:
+	case ATTACHED_DEV_AFC_CHARGER_5V_MUIC:
+	case ATTACHED_DEV_UNOFFICIAL_TA_MUIC:
+	case ATTACHED_DEV_UNOFFICIAL_ID_TA_MUIC:
+	case ATTACHED_DEV_UNOFFICIAL_ID_ANY_MUIC:
+	case ATTACHED_DEV_QC_CHARGER_5V_MUIC:
+	case ATTACHED_DEV_UNSUPPORTED_ID_VB_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_MAINS;
+		break;
+	case ATTACHED_DEV_CDP_MUIC:
+	case ATTACHED_DEV_UNOFFICIAL_ID_CDP_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_USB_CDP;
+		break;
+	case ATTACHED_DEV_USB_LANHUB_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_LAN_HUB;
+		break;
+	case ATTACHED_DEV_CHARGING_CABLE_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_POWER_SHARING;
+		break;
+	case ATTACHED_DEV_AFC_CHARGER_PREPARE_MUIC:
+	case ATTACHED_DEV_QC_CHARGER_PREPARE_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_HV_PREPARE_MAINS;
+		break;
+	case ATTACHED_DEV_AFC_CHARGER_9V_MUIC:
+	case ATTACHED_DEV_QC_CHARGER_9V_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_HV_MAINS;
+		break;
+	case ATTACHED_DEV_AFC_CHARGER_ERR_V_MUIC:
+	case ATTACHED_DEV_QC_CHARGER_ERR_V_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_HV_ERR;
+		break;
+	case ATTACHED_DEV_UNDEFINED_CHARGING_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_UNKNOWN;
+		break;
+	case ATTACHED_DEV_HV_ID_ERR_UNDEFINED_MUIC:
+	case ATTACHED_DEV_HV_ID_ERR_UNSUPPORTED_MUIC:
+	case ATTACHED_DEV_HV_ID_ERR_SUPPORTED_MUIC:
+		current_cable_type = POWER_SUPPLY_TYPE_HV_UNKNOWN;
+		break;
+	default:
+		pr_err("%s: invalid type for charger:%d\n",
+			__func__, attached_dev);
+	}
+
+	return current_cable_type;
+
+}
+
+static int charger_handle_notification(struct notifier_block *nb,
+		unsigned long action, void *data)
+{
+	muic_attached_dev_t attached_dev = *(muic_attached_dev_t *)data;
+	const char *cmd;
+	int cable_type;
+	struct s2mu005_charger_data *charger =
+		container_of(nb, struct s2mu005_charger_data,
+			     cable_check);
+	union power_supply_propval value;
+
+	if (attached_dev == ATTACHED_DEV_MHL_MUIC)
+		return 0;
+
+	switch (action) {
+	case MUIC_NOTIFY_CMD_DETACH:
+	case MUIC_NOTIFY_CMD_LOGICALLY_DETACH:
+		cmd = "DETACH";
+		cable_type = POWER_SUPPLY_TYPE_BATTERY;
+		break;
+	case MUIC_NOTIFY_CMD_ATTACH:
+	case MUIC_NOTIFY_CMD_LOGICALLY_ATTACH:
+		cmd = "ATTACH";
+		cable_type = s2mu005_bat_cable_check(charger, attached_dev);
+		break;
+	default:
+		cmd = "ERROR";
+		cable_type = -1;
+		break;
+	}
+
+	pr_info("%s: current_cable(%d) former cable_type(%d) battery_valid(%d)\n",
+			__func__, cable_type, charger->battery_cable_type,
+						   charger->battery_valid);
+	if (charger->battery_valid == false) {
+		pr_info("%s: Battery is disconnected\n",
+						__func__);
+		return 0;
+	}
+
+	if (attached_dev == ATTACHED_DEV_OTG_MUIC) {
+		if (!strcmp(cmd, "ATTACH")) {
+			value.intval = true;
+			charger->battery_cable_type = cable_type;
+			psy_do_property(charger->pdata->charger_name, set,
+					POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL,
+					value);
+			pr_info("%s: OTG cable attached\n", __func__);
+		} else {
+			value.intval = false;
+			charger->battery_cable_type = cable_type;
+			psy_do_property(charger->pdata->charger_name, set,
+					POWER_SUPPLY_PROP_CHARGE_OTG_CONTROL,
+					value);
+			pr_info("%s: OTG cable detached\n", __func__);
+		}
+	}
+
+	if ((cable_type >= 0) &&
+	    cable_type <= SEC_SIZEOF_POWER_SUPPLY_TYPE) {
+		if (cable_type != charger->battery_cable_type) {
+			value.intval = charger->battery_cable_type = cable_type;
+			psy_do_property(charger->pdata->charger_name, set,
+					POWER_SUPPLY_PROP_ONLINE,
+					value);
+		} else {
+			pr_info("%s: Cable is Not Changed(%d)\n",
+				__func__, charger->battery_cable_type);
+		}
+	}
+	power_supply_changed(&charger->psy_battery);
+
+	pr_info("%s: CMD=%s, attached_dev=%d battery_cable=%d\n",
+		__func__, cmd, attached_dev, charger->battery_cable_type);
+
+	return 0;
+}
+#endif /* CONFIG_MUIC_NOTIFIER */
+
+#if defined(CONFIG_SEC_FUELGAUGE_S2MU005) || defined(CONFIG_MUIC_NOTIFIER)
+static void sec_bat_get_battery_info(struct work_struct *work)
+{
+	struct s2mu005_charger_data *charger =
+	container_of(work, struct s2mu005_charger_data, polling_work.work);
+
+#if defined(CONFIG_SEC_FUELGAUGE_S2MU005)
+	u8 ret = 0;
+	union power_supply_propval value;
+
+	psy_do_property(charger->pdata->fuelgauge_name, get,
+		POWER_SUPPLY_PROP_VOLTAGE_NOW, value);
+	charger->voltage_now = value.intval;
+
+	value.intval = SEC_BATTERY_VOLTAGE_AVERAGE;
+	psy_do_property(charger->pdata->fuelgauge_name, get,
+		POWER_SUPPLY_PROP_VOLTAGE_AVG, value);
+	charger->voltage_avg = value.intval;
+
+	value.intval = SEC_BATTERY_VOLTAGE_OCV;
+	psy_do_property(charger->pdata->fuelgauge_name, get,
+		POWER_SUPPLY_PROP_VOLTAGE_AVG, value);
+	charger->voltage_ocv = value.intval;
+
+	/* To get SOC value (NOT raw SOC), need to reset value */
+	value.intval = 0;
+	psy_do_property(charger->pdata->fuelgauge_name, get,
+		POWER_SUPPLY_PROP_CAPACITY, value);
+	charger->capacity = value.intval;
+
+	if (charger->voltage_now < charger->pdata->recharge_vcell &&
+		charger->charge_mode == SEC_BATTERY_CHARGING_NONE &&
+		charger->is_charging) {
+		s2mu005_enable_charger_switch(charger, 1);
+		charger->charge_mode = SEC_BATTERY_CHARGING_1ST;
+	}
+
+	pr_info("%s: voltage_now: (%d), voltage_avg: (%d),"
+		"voltage_ocv: (%d), capacity: (%d)\n",
+		__func__, charger->voltage_now, charger->voltage_avg,
+				charger->voltage_ocv, charger->capacity);
+
+	if (!charger->battery_valid) {
+		s2mu005_read_reg(charger->client,
+			S2MU005_CHG_STATUS1, &ret);
+		charger->battery_valid =
+		(ret & DET_BAT_STATUS_MASK) ? true : false;
+	}
+
+	s2mu005_test_read(charger->client);
+
+	power_supply_changed(&charger->psy_battery);
+	schedule_delayed_work(&charger->polling_work, HZ * 10);
+#endif
+
+#if defined(CONFIG_MUIC_NOTIFIER)
+	if (!charger->noti_check)
+		muic_notifier_register(&charger->cable_check,
+				       charger_handle_notification,
+					       MUIC_NOTIFY_DEV_CHARGER);
+	charger->noti_check = true;
+#endif
+}
+#endif
+
+
+/* s2mu005 interrupt service routine */
+static irqreturn_t s2mu005_det_bat_isr(int irq, void *data)
+{
+	struct s2mu005_charger_data *charger = data;
+	u8 val;
+
+	s2mu005_read_reg(charger->client, S2MU005_CHG_STATUS1, &val);
+	if ((val & DET_BAT_STATUS_MASK) == 0) {
+		s2mu005_enable_charger_switch(charger, 0);
+		pr_err("charger-off if battery removed \n");
+	}
+	return IRQ_HANDLED;
+}
+#if 0
+static irqreturn_t s2mu005_chg_isr(int irq, void *data)
+{
+	struct s2mu005_charger_data *charger = data;
+	u8 val;
+
+	s2mu005_read_reg(charger->client, S2MU005_CHG_STATUS0, &val);
+	pr_err("[DEBUG] %s , %02x \n " , __func__, val);
+	if (val & (CHG_STATUS_DONE << CHG_STATUS_SHIFT)) {
+		pr_err("add self chg done \n");
+		/* add chg done code here */
+	}
+	return IRQ_HANDLED;
+}
+#endif
+
+static int s2mu005_charger_parse_dt(struct device *dev,
+		struct s2mu005_charger_platform_data *pdata)
+{
+	struct device_node *np = of_find_node_by_name(NULL, "s2mu005-charger");
+	const u32 *p;
+	int ret, i , len;
+
+	/* SC_CTRL8 , SET_VF_VBAT , Battery regulation voltage setting */
+	ret = of_property_read_u32(np, "battery,chg_float_voltage",
+				&pdata->chg_float_voltage);
+
+	np = of_find_node_by_name(NULL, "battery");
+	if (!np) {
+		pr_err("%s np NULL\n", __func__);
+	} else {
+		ret = of_property_read_string(np,
+			"battery,charger_name", (char const **)&pdata->charger_name);
+#if defined(CONFIG_SEC_FUELGAUGE_S2MU005)
+		ret = of_property_read_string(np,
+			"battery,fuelgauge_name",
+			(char const **)&pdata->fuelgauge_name);
+#endif
+
+		ret = of_property_read_u32(np, "battery,full_check_type_2nd",
+				&pdata->full_check_type_2nd);
+		if (ret)
+			pr_info("%s : Full check type 2nd is Empty\n", __func__);
+
+		pdata->chg_eoc_dualpath = of_property_read_bool(np,
+				"battery,chg_eoc_dualpath");
+
+		ret = of_property_read_u32(np, "battery,recharge_condition_vcell",
+		&pdata->recharge_vcell);
+
+		p = of_get_property(np, "battery,input_current_limit", &len);
+		if (!p)
+			return 1;
+
+		len = len / sizeof(u32);
+
+		pdata->charging_current_table = kzalloc(sizeof(sec_charging_current_t) * len,
+				GFP_KERNEL);
+
+		for (i = 0; i < len; i++) {
+			ret = of_property_read_u32_index(np,
+					"battery,input_current_limit", i,
+					&pdata->charging_current_table[i].input_current_limit);
+			ret = of_property_read_u32_index(np,
+					"battery,fast_charging_current", i,
+					&pdata->charging_current_table[i].fast_charging_current);
+			ret = of_property_read_u32_index(np,
+					"battery,full_check_current_1st", i,
+					&pdata->charging_current_table[i].full_check_current_1st);
+			ret = of_property_read_u32_index(np,
+					"battery,full_check_current_2nd", i,
+					&pdata->charging_current_table[i].full_check_current_2nd);
+		}
+	}
+
+	dev_info(dev, "s2mu005 charger parse dt retval = %d\n", ret);
+	return ret;
+}
+
+/* if need to set s2mu005 pdata */
+static struct of_device_id s2mu005_charger_match_table[] = {
+	{ .compatible = "samsung,s2mu005-charger",},
+	{},
+};
+
+static int s2mu005_charger_probe(struct platform_device *pdev)
+{
+	struct s2mu005_dev *s2mu005 = dev_get_drvdata(pdev->dev.parent);
+	struct s2mu005_platform_data *pdata = dev_get_platdata(s2mu005->dev);
+	struct s2mu005_charger_data *charger;
+	int ret = 0;
+	pr_err("%s:[BATT] S2MU005 Charger driver probe\n", __func__);
+	charger = kzalloc(sizeof(*charger), GFP_KERNEL);
+	if (!charger)
+		return -ENOMEM;
+
+	mutex_init(&charger->io_lock);
+
+	charger->dev = &pdev->dev;
+	charger->client = s2mu005->i2c;
+
+	charger->pdata = devm_kzalloc(&pdev->dev, sizeof(*(charger->pdata)),
+			GFP_KERNEL);
+	if (!charger->pdata) {
+		dev_err(&pdev->dev, "Failed to allocate memory\n");
+		ret = -ENOMEM;
+		goto err_parse_dt_nomem;
+	}
+	ret = s2mu005_charger_parse_dt(&pdev->dev, charger->pdata);
+	if (ret < 0)
+		goto err_parse_dt;
+
+	platform_set_drvdata(pdev, charger);
+
+	if (charger->pdata->charger_name == NULL)
+		charger->pdata->charger_name = "sec-charger";
+
+	charger->psy_chg.name           = charger->pdata->charger_name;
+	charger->psy_chg.type           = POWER_SUPPLY_TYPE_UNKNOWN;
+	charger->psy_chg.get_property   = sec_chg_get_property;
+	charger->psy_chg.set_property   = sec_chg_set_property;
+	charger->psy_chg.properties     = s2mu005_charger_props;
+	charger->psy_chg.num_properties = ARRAY_SIZE(s2mu005_charger_props);
+
+#ifdef CONFIG_SEC_FUELGAUGE_S2MU005
+	if (charger->pdata->fuelgauge_name == NULL)
+		charger->pdata->fuelgauge_name = "s2mu005-fuelgauge";
+#endif
+	charger->psy_battery.name = "s2mu005-battery";
+	charger->psy_battery.type = POWER_SUPPLY_TYPE_BATTERY;
+	charger->psy_battery.properties =
+			s2mu005_battery_props;
+	charger->psy_battery.num_properties =
+			ARRAY_SIZE(s2mu005_battery_props);
+	charger->psy_battery.get_property =
+			s2mu005_battery_get_property;
+	charger->psy_battery.set_property =
+			s2mu005_battery_set_property;
+
+	ret = power_supply_register(&pdev->dev, &charger->psy_battery);
+	if (ret) {
+		pr_err("%s: Failed to Register psy_battery\n", __func__);
+		goto err_power_supply_register;
+	}
+#if defined(CONFIG_SEC_FUELGAUGE_S2MU005)
+	charger->capacity = 0;
+#endif
+	charger->psy_usb.name = "s2mu005-usb";
+	charger->psy_usb.type = POWER_SUPPLY_TYPE_USB;
+	charger->psy_usb.supplied_to = s2mu005_supplied_to;
+	charger->psy_usb.num_supplicants =
+			ARRAY_SIZE(s2mu005_supplied_to),
+	charger->psy_usb.properties =
+			s2mu005_power_props;
+	charger->psy_usb.num_properties =
+			ARRAY_SIZE(s2mu005_power_props);
+	charger->psy_usb.get_property =
+			s2mu005_usb_get_property;
+
+	ret = power_supply_register(&pdev->dev, &charger->psy_usb);
+	if (ret) {
+		pr_err("%s: Failed to Register psy_usb\n", __func__);
+		goto err_power_supply_register;
+	}
+
+	charger->psy_ac.name = "s2mu005-ac";
+	charger->psy_ac.type = POWER_SUPPLY_TYPE_MAINS;
+	charger->psy_ac.supplied_to = s2mu005_supplied_to;
+	charger->psy_ac.num_supplicants =
+			ARRAY_SIZE(s2mu005_supplied_to),
+	charger->psy_ac.properties =
+			s2mu005_power_props;
+	charger->psy_ac.num_properties =
+			ARRAY_SIZE(s2mu005_power_props);
+	charger->psy_ac.get_property =
+			s2mu005_ac_get_property;
+
+	ret = power_supply_register(&pdev->dev, &charger->psy_ac);
+	if (ret) {
+		pr_err("%s: Failed to Register psy_usb\n", __func__);
+		goto err_power_supply_register;
+	}
+
+	/* need to check siop level */
+	charger->siop_level = 100;
+
+	s2mu005_chg_init(charger);
+
+	ret = power_supply_register(&pdev->dev, &charger->psy_chg);
+	if (ret) {
+		pr_err("%s: Failed to Register psy_chg\n", __func__);
+		goto err_power_supply_register;
+	}
+
+	/*
+	 * irq request
+	 * if you need to add irq , please refer below code.
+	 */
+	charger->irq_det_bat = pdata->irq_base + S2MU005_CHG_IRQ_DET_BAT;
+	ret = request_threaded_irq(charger->irq_det_bat, NULL,
+			s2mu005_det_bat_isr, 0 , "det-bat-in-irq", charger);
+	if (ret < 0) {
+		dev_err(s2mu005->dev, "%s: Fail to request det bat in IRQ: %d: %d\n",
+					__func__, charger->irq_det_bat, ret);
+		goto err_reg_irq;
+	}
+#if 0
+	charger->irq_chg = pdata->irq_base + S2MU005_CHG_IRQ_CHG;
+	ret = request_threaded_irq(charger->irq_chg, NULL,
+			s2mu005_chg_isr, 0 , "chg-irq", charger);
+	if (ret < 0) {
+		dev_err(s2mu005->dev, "%s: Fail to request det bat in IRQ: %d: %d\n",
+					__func__, charger->irq_chg, ret);
+		goto err_reg_irq;
+	}
+#endif
+	s2mu005_test_read(charger->client);
+
+	charger->battery_cable_type = POWER_SUPPLY_TYPE_BATTERY;
+	charger->cable_type = POWER_SUPPLY_TYPE_BATTERY;
+
+	charger->charger_wqueue = create_singlethread_workqueue("charger-wq");
+	if (!charger->charger_wqueue) {
+		dev_info(&pdev->dev, "%s: failed to create wq.\n", __func__);
+		ret = -ESRCH;
+		goto err_create_wq;
+	}
+
+	charger->noti_check = false;
+
+#if defined(CONFIG_SEC_FUELGAUGE_S2MU005) || defined(CONFIG_MUIC_NOTIFIER)
+	INIT_DELAYED_WORK(&charger->polling_work,
+				sec_bat_get_battery_info);
+	schedule_delayed_work(&charger->polling_work, HZ * 5);
+#endif
+
+	pr_info("%s:[BATT] S2MU005 charger driver loaded OK\n", __func__);
+
+	return 0;
+err_create_wq:
+err_reg_irq:
+	destroy_workqueue(charger->charger_wqueue);
+	power_supply_unregister(&charger->psy_chg);
+	power_supply_unregister(&charger->psy_battery);
+err_power_supply_register:
+err_parse_dt:
+err_parse_dt_nomem:
+	mutex_destroy(&charger->io_lock);
+	kfree(charger);
+	return ret;
+}
+
+static int s2mu005_charger_remove(struct platform_device *pdev)
+{
+	struct s2mu005_charger_data *charger =
+		platform_get_drvdata(pdev);
+
+	power_supply_unregister(&charger->psy_chg);
+	mutex_destroy(&charger->io_lock);
+	kfree(charger);
+	return 0;
+}
+
+#if defined CONFIG_PM
+static int s2mu005_charger_suspend(struct device *dev)
+{
+	struct s2mu005_charger_data *charger = dev_get_drvdata(dev);
+	cancel_delayed_work_sync(&charger->polling_work);
+
+	return 0;
+}
+
+static int s2mu005_charger_resume(struct device *dev)
+{
+	struct s2mu005_charger_data *charger = dev_get_drvdata(dev);
+	schedule_delayed_work(&charger->polling_work, 0);
+
+	return 0;
+}
+#else
+#define s2mu005_charger_suspend NULL
+#define s2mu005_charger_resume NULL
+#endif
+
+static void s2mu005_charger_shutdown(struct device *dev)
+{
+	pr_info("%s: S2MU005 Charger driver shutdown\n", __func__);
+}
+
+static SIMPLE_DEV_PM_OPS(s2mu005_charger_pm_ops, s2mu005_charger_suspend,
+		s2mu005_charger_resume);
+
+static struct platform_driver s2mu005_charger_driver = {
+	.driver         = {
+		.name   = "s2mu005-charger",
+		.owner  = THIS_MODULE,
+		.of_match_table = s2mu005_charger_match_table,
+		.pm     = &s2mu005_charger_pm_ops,
+		.shutdown = s2mu005_charger_shutdown,
+	},
+	.probe          = s2mu005_charger_probe,
+	.remove		= s2mu005_charger_remove,
+};
+
+static int __init s2mu005_charger_init(void)
+{
+	int ret = 0;
+
+	ret = platform_driver_register(&s2mu005_charger_driver);
+
+	return ret;
+}
+subsys_initcall(s2mu005_charger_init);
+
+static void __exit s2mu005_charger_exit(void)
+{
+	platform_driver_unregister(&s2mu005_charger_driver);
+}
+module_exit(s2mu005_charger_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Samsung Electronics");
+MODULE_DESCRIPTION("Charger driver for S2MU005");
diff -Naur linux-3.18.14/drivers/power/s2mu005_fuelgauge.c samsung/drivers/power/s2mu005_fuelgauge.c
--- linux-3.18.14/drivers/power/s2mu005_fuelgauge.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/power/s2mu005_fuelgauge.c	2018-10-29 07:24:39.000000000 +0100
@@ -0,0 +1,1016 @@
+/*
+ *  s2mu005_fuelgauge.c
+ *  Samsung S2MU005 Fuel Gauge Driver
+ *
+ *  Copyright (C) 2015 Samsung Electronics
+ *  Developed by Nguyen Tien Dat (tiendat.nt@samsung.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#define DEBUG
+
+#define SINGLE_BYTE	1
+
+#include <linux/power/s2mu005_fuelgauge.h>
+#include <linux/of_gpio.h>
+
+static enum power_supply_property s2mu005_fuelgauge_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_VOLTAGE_AVG,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CURRENT_AVG,
+	POWER_SUPPLY_PROP_CHARGE_FULL,
+	POWER_SUPPLY_PROP_ENERGY_NOW,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_TEMP_AMBIENT,
+	POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN,
+	POWER_SUPPLY_PROP_CHARGE_TYPE,
+};
+
+
+static int s2mu005_write_reg_byte(struct i2c_client *client, int reg, u8 data)
+{
+	int ret, i = 0;
+
+	ret = i2c_smbus_write_byte_data(client, reg,  data);
+	if (ret < 0) {
+		for (i = 0; i < 3; i++) {
+			ret = i2c_smbus_write_byte_data(client, reg,  data);
+			if (ret >= 0)
+				break;
+		}
+
+		if (i >= 3)
+			dev_err(&client->dev, "%s: Error(%d)\n", __func__, ret);
+	}
+
+	return ret;
+}
+
+static int s2mu005_write_reg(struct i2c_client *client, int reg, u8 *buf)
+{
+#if SINGLE_BYTE
+	int ret = 0 ;
+	s2mu005_write_reg_byte(client, reg, buf[0]);
+	s2mu005_write_reg_byte(client, reg+1, buf[1]);
+#else
+	int ret, i = 0;
+
+	ret = i2c_smbus_write_i2c_block_data(client, reg, 2, buf);
+	if (ret < 0) {
+		for (i = 0; i < 3; i++) {
+			ret = i2c_smbus_write_i2c_block_data(client, reg, 2, buf);
+			if (ret >= 0)
+				break;
+		}
+
+		if (i >= 3)
+			dev_err(&client->dev, "%s: Error(%d)\n", __func__, ret);
+	}
+#endif
+	return ret;
+}
+
+static int s2mu005_read_reg_byte(struct i2c_client *client, int reg, void *data)
+{
+	int ret = 0;
+
+	ret = i2c_smbus_read_byte_data(client, reg);
+	if (ret < 0)
+		return ret;
+	*(u8 *)data = (u8)ret;
+
+	return ret;
+}
+
+static int s2mu005_read_reg(struct i2c_client *client, int reg, u8 *buf)
+{
+
+#if SINGLE_BYTE
+	int ret = 0;
+	u8 data1 = 0 , data2 = 0;
+	s2mu005_read_reg_byte(client, reg, &data1);
+	s2mu005_read_reg_byte(client, reg+1, &data2);
+	buf[0] = data1;
+	buf[1] = data2;
+#else
+	int ret = 0, i = 0;
+
+	ret = i2c_smbus_read_i2c_block_data(client, reg, 2, buf);
+	if (ret < 0) {
+		for (i = 0; i < 3; i++) {
+			ret = i2c_smbus_read_i2c_block_data(client, reg, 2, buf);
+			if (ret >= 0)
+				break;
+		}
+
+		if (i >= 3)
+			dev_err(&client->dev, "%s: Error(%d)\n", __func__, ret);
+	}
+#endif
+	return ret;
+}
+
+static int s2mu005_init_regs(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	int ret = 0;
+
+	pr_err("%s: s2mu005 fuelgauge initialize\n", __func__);
+
+	s2mu005_write_reg_byte(fuelgauge->i2c, 0x21, 0x13);
+
+	return ret;
+}
+
+static void s2mu005_alert_init(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+
+	/* VBAT Threshold setting: 3.55V */
+	data[0] = 0x00 & 0x0f;
+
+	/* SOC Threshold setting */
+	data[0] = data[0] | (fuelgauge->pdata->fuel_alert_soc << 4);
+
+	data[1] = 0x00;
+	s2mu005_write_reg(fuelgauge->i2c, S2MU005_REG_IRQ_LVL, data);
+}
+
+static bool s2mu005_check_status(struct i2c_client *client)
+{
+	u8 data[2];
+	bool ret = false;
+
+	/* check if Smn was generated */
+	if (s2mu005_read_reg(client, S2MU005_REG_STATUS, data) < 0)
+		return ret;
+
+	dev_dbg(&client->dev, "%s: status to (%02x%02x)\n",
+		__func__, data[1], data[0]);
+
+	if (data[1] & (0x1 << 1))
+		return true;
+	else
+		return false;
+}
+
+static int s2mu005_set_temperature(struct s2mu005_fuelgauge_data *fuelgauge,
+			int temperature)
+{
+	/*
+	 * s5mu005 include temperature sensor so,
+	 * do not need to set temperature value.
+	 */
+	return temperature;
+}
+
+static int s2mu005_get_temperature(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	s32 temperature = 0;
+
+	/*
+	 *  use monitor regiser.
+	 *  monitor register default setting is temperature
+	 */
+	if (s2mu005_read_reg(fuelgauge->i2c, S2MU005_REG_MONOUT, data) < 0)
+		return -ERANGE;
+
+	/* data[] store 2's compliment format number */
+	if (data[0] & (0x1 << 7)) {
+		/* Negative */
+		temperature = ((~(data[0])) & 0xFF) + 1;
+		temperature *= -10;
+	} else {
+		temperature = data[0] & 0x7F;
+		temperature *= 10;
+	}
+
+	dev_dbg(&fuelgauge->i2c->dev, "%s: temperature (%d)\n",
+		__func__, temperature);
+
+	return temperature;
+}
+
+/* soc should be 0.01% unit */
+static int s2mu005_get_soc(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	u8 data[2], check_data[2];
+	u16 compliment;
+	int rsoc, i;
+
+	for (i = 0; i < 50; i++) {
+		if (s2mu005_read_reg(fuelgauge->i2c, S2MU005_REG_RSOC, data) < 0)
+			return -EINVAL;
+		if (s2mu005_read_reg(fuelgauge->i2c, S2MU005_REG_RSOC, check_data) < 0)
+			return -EINVAL;
+	dev_dbg(&fuelgauge->i2c->dev, "[DEBUG]%s: data0 (%d) data1 (%d) \n", __func__, data[0], data[1]);
+
+	if ((data[0] == check_data[0]) && (data[1] == check_data[1]))
+			break;
+	}
+
+	dev_dbg(&fuelgauge->i2c->dev, "[DEBUG]%s: data0 (%d) data1 (%d) \n", __func__, data[0], data[1]);
+	compliment = (data[1] << 8) | (data[0]);
+
+	/* data[] store 2's compliment format number */
+	if (compliment & (0x1 << 15)) {
+		/* Negative */
+		rsoc = ((~compliment) & 0xFFFF) + 1;
+		rsoc = (rsoc * (-10000)) / (0x1 << 14);
+	} else {
+		rsoc = compliment & 0x7FFF;
+		rsoc = ((rsoc * 10000) / (0x1 << 14));
+	}
+
+	dev_info(&fuelgauge->i2c->dev, "[DEBUG]%s: raw capacity (0x%x:%d)\n", __func__,
+		compliment, rsoc);
+
+	return (min(rsoc, 10000) / 10);
+}
+
+static int s2mu005_get_rawsoc(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	u8 data[2], check_data[2];
+	u16 compliment;
+	int rsoc, i;
+
+	for (i = 0; i < 50; i++) {
+		if (s2mu005_read_reg(fuelgauge->i2c, S2MU005_REG_RSOC, data) < 0)
+			return -EINVAL;
+		if (s2mu005_read_reg(fuelgauge->i2c, S2MU005_REG_RSOC, check_data) < 0)
+			return -EINVAL;
+		if ((data[0] == check_data[0]) && (data[1] == check_data[1]))
+			break;
+	}
+
+	compliment = (data[1] << 8) | (data[0]);
+
+	/* data[] store 2's compliment format number */
+	if (compliment & (0x1 << 15)) {
+		/* Negative */
+		rsoc = ((~compliment) & 0xFFFF) + 1;
+		rsoc = (rsoc * (-10000)) / (0x1 << 14);
+	} else {
+		rsoc = compliment & 0x7FFF;
+		rsoc = ((rsoc * 10000) / (0x1 << 14));
+	}
+
+	dev_dbg(&fuelgauge->i2c->dev, "[DEBUG]%s: raw capacity (0x%x:%d)\n", __func__,
+			compliment, rsoc);
+	return min(rsoc, 10000) ;
+}
+
+static int s2mu005_get_current(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u16 compliment;
+	int curr = 0;
+
+	if (s2mu005_read_reg(fuelgauge->i2c, S2MU005_REG_RCUR_CC, data) < 0)
+		return -EINVAL;
+	compliment = (data[1] << 8) | (data[0]);
+	dev_dbg(&fuelgauge->i2c->dev, "%s: rCUR_CC(0x%4x)\n", __func__, compliment);
+
+	if (compliment & (0x1 << 15)) { /* Charging */
+		curr = ((~compliment) & 0xFFFF) + 1;
+		curr = (curr * 1000) >> 12;
+	} else { /* dischaging */
+		curr = compliment & 0x7FFF;
+		curr = (curr * (-1000)) >> 12;
+	}
+
+	dev_info(&fuelgauge->i2c->dev, "%s: current (%d)mA\n", __func__, curr);
+
+	return curr;
+}
+
+static int s2mu005_get_ocv(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	u32 rocv = 0;
+	/*
+	 * s5mu005 does not have ocv.
+	 */
+
+	return rocv;
+}
+
+static int s2mu005_get_avgcurrent(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u16 compliment;
+	int curr = 0;
+
+	s2mu005_write_reg_byte(fuelgauge->i2c, S2MU005_REG_MONOUT_SEL, 0x26);
+
+	if (s2mu005_read_reg(fuelgauge->i2c, S2MU005_REG_MONOUT, data) < 0)
+		return -EINVAL;
+	compliment = (data[1] << 8) | (data[0]);
+	dev_dbg(&fuelgauge->i2c->dev, "%s: MONOUT(0x%4x)\n", __func__, compliment);
+
+	if (compliment & (0x1 << 15)) { /* Charging */
+		curr = ((~compliment) & 0xFFFF) + 1;
+		curr = (curr * 1000) >> 12;
+	} else { /* dischaging */
+		curr = compliment & 0x7FFF;
+		curr = (curr * (-1000)) >> 12;
+	}
+	s2mu005_write_reg_byte(fuelgauge->i2c, S2MU005_REG_MONOUT_SEL, 0x10);
+
+	dev_info(&fuelgauge->i2c->dev, "%s: avg current (%d)mA\n", __func__, curr);
+
+	return curr;
+}
+
+static int s2mu005_get_vbat(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u32 vbat = 0;
+
+	if (s2mu005_read_reg(fuelgauge->i2c, S2MU005_REG_RVBAT, data) < 0)
+		return -EINVAL;
+
+	dev_dbg(&fuelgauge->i2c->dev, "%s: data0 (%d) data1 (%d) \n", __func__, data[0], data[1]);
+	vbat = ((data[0] + (data[1] << 8)) * 1000) >> 13;
+
+	dev_info(&fuelgauge->i2c->dev, "%s: vbat (%d)\n", __func__, vbat);
+
+	return vbat;
+}
+
+static int s2mu005_get_avgvbat(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	u8 data[2];
+	u32 new_vbat, old_vbat = 0;
+	int cnt;
+
+	for (cnt = 0; cnt < 5; cnt++) {
+		if (s2mu005_read_reg(fuelgauge->i2c, S2MU005_REG_RVBAT, data) < 0)
+			return -EINVAL;
+
+		new_vbat = ((data[0] + (data[1] << 8)) * 1000) >> 13;
+
+		if (cnt == 0)
+			old_vbat = new_vbat;
+		else
+			old_vbat = new_vbat / 2 + old_vbat / 2;
+	}
+
+	dev_info(&fuelgauge->i2c->dev, "%s: avgvbat (%d)\n", __func__, old_vbat);
+
+	return old_vbat;
+}
+
+/* capacity is  0.1% unit */
+static void s2mu005_fg_get_scaled_capacity(
+		struct s2mu005_fuelgauge_data *fuelgauge,
+		union power_supply_propval *val)
+{
+	val->intval = (val->intval < fuelgauge->pdata->capacity_min) ?
+		0 : ((val->intval - fuelgauge->pdata->capacity_min) * 1000 /
+		(fuelgauge->capacity_max - fuelgauge->pdata->capacity_min));
+
+	dev_info(&fuelgauge->i2c->dev,
+			"%s: scaled capacity (%d.%d)\n",
+			__func__, val->intval/10, val->intval%10);
+}
+
+/* capacity is integer */
+static void s2mu005_fg_get_atomic_capacity(
+		struct s2mu005_fuelgauge_data *fuelgauge,
+		union power_supply_propval *val)
+{
+	if (fuelgauge->pdata->capacity_calculation_type &
+			SEC_FUELGAUGE_CAPACITY_TYPE_ATOMIC) {
+		if (fuelgauge->capacity_old < val->intval)
+			val->intval = fuelgauge->capacity_old + 1;
+		else if (fuelgauge->capacity_old > val->intval)
+			val->intval = fuelgauge->capacity_old - 1;
+	}
+
+	/* updated old capacity */
+	fuelgauge->capacity_old = val->intval;
+}
+
+static int s2mu005_fg_check_capacity_max(
+		struct s2mu005_fuelgauge_data *fuelgauge, int capacity_max)
+{
+	int new_capacity_max = capacity_max;
+
+	if (new_capacity_max < (fuelgauge->pdata->capacity_max -
+				fuelgauge->pdata->capacity_max_margin - 10)) {
+		new_capacity_max =
+			(fuelgauge->pdata->capacity_max -
+			 fuelgauge->pdata->capacity_max_margin);
+
+		dev_info(&fuelgauge->i2c->dev, "%s: set capacity max(%d --> %d)\n",
+				__func__, capacity_max, new_capacity_max);
+	} else if (new_capacity_max > (fuelgauge->pdata->capacity_max +
+				fuelgauge->pdata->capacity_max_margin)) {
+		new_capacity_max =
+			(fuelgauge->pdata->capacity_max +
+			 fuelgauge->pdata->capacity_max_margin);
+
+		dev_info(&fuelgauge->i2c->dev, "%s: set capacity max(%d --> %d)\n",
+				__func__, capacity_max, new_capacity_max);
+	}
+
+	return new_capacity_max;
+}
+
+static int s2mu005_fg_calculate_dynamic_scale(
+		struct s2mu005_fuelgauge_data *fuelgauge, int capacity)
+{
+	union power_supply_propval raw_soc_val;
+	raw_soc_val.intval = s2mu005_get_rawsoc(fuelgauge) / 10;
+
+	if (raw_soc_val.intval <
+			fuelgauge->pdata->capacity_max -
+			fuelgauge->pdata->capacity_max_margin) {
+		fuelgauge->capacity_max =
+			fuelgauge->pdata->capacity_max -
+			fuelgauge->pdata->capacity_max_margin;
+		dev_dbg(&fuelgauge->i2c->dev, "%s: capacity_max (%d)",
+				__func__, fuelgauge->capacity_max);
+	} else {
+		fuelgauge->capacity_max =
+			(raw_soc_val.intval >
+			 fuelgauge->pdata->capacity_max +
+			 fuelgauge->pdata->capacity_max_margin) ?
+			(fuelgauge->pdata->capacity_max +
+			 fuelgauge->pdata->capacity_max_margin) :
+			raw_soc_val.intval;
+		dev_dbg(&fuelgauge->i2c->dev, "%s: raw soc (%d)",
+				__func__, fuelgauge->capacity_max);
+	}
+
+	if (capacity != 100) {
+		fuelgauge->capacity_max = s2mu005_fg_check_capacity_max(
+			fuelgauge, (fuelgauge->capacity_max * 100 / capacity));
+	} else  {
+		fuelgauge->capacity_max =
+			(fuelgauge->capacity_max * 99 / 100);
+	}
+
+	/* update capacity_old for sec_fg_get_atomic_capacity algorithm */
+	fuelgauge->capacity_old = capacity;
+
+	dev_info(&fuelgauge->i2c->dev, "%s: %d is used for capacity_max\n",
+			__func__, fuelgauge->capacity_max);
+
+	return fuelgauge->capacity_max;
+}
+
+bool s2mu005_fuelgauge_fuelalert_init(struct i2c_client *client, int soc)
+{
+	struct s2mu005_fuelgauge_data *fuelgauge = i2c_get_clientdata(client);
+	u8 data[2];
+
+	/* 1. Set s2mu005 alert configuration. */
+	s2mu005_alert_init(fuelgauge);
+
+	if (s2mu005_read_reg(client, S2MU005_REG_IRQ, data) < 0)
+		return -1;
+
+	/*Enable VBAT, SOC */
+	data[1] &= 0xfc;
+
+	/*Disable IDLE_ST, INIT)ST */
+	data[1] |= 0x0c;
+
+	s2mu005_write_reg(client, S2MU005_REG_IRQ, data);
+
+	dev_dbg(&client->dev, "%s: irq_reg(%02x%02x) irq(%d)\n",
+			__func__, data[1], data[0], fuelgauge->pdata->fg_irq);
+
+	return true;
+}
+
+bool s2mu005_fuelgauge_is_fuelalerted(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	return s2mu005_check_status(fuelgauge->i2c);
+}
+
+bool s2mu005_hal_fg_fuelalert_process(void *irq_data, bool is_fuel_alerted)
+{
+	struct s2mu005_fuelgauge_data *fuelgauge = irq_data;
+	int ret;
+
+	ret = i2c_smbus_write_byte_data(fuelgauge->i2c, S2MU005_REG_IRQ, 0x00);
+	if (ret < 0)
+		dev_err(&fuelgauge->i2c->dev, "%s: Error(%d)\n", __func__, ret);
+
+	return ret;
+}
+
+bool s2mu005_hal_fg_full_charged(struct i2c_client *client)
+{
+	return true;
+}
+
+static int s2mu005_fg_get_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		union power_supply_propval *val)
+{
+	struct s2mu005_fuelgauge_data *fuelgauge =
+		container_of(psy, struct s2mu005_fuelgauge_data, psy_fg);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+	case POWER_SUPPLY_PROP_ENERGY_NOW:
+		return -ENODATA;
+		/* Cell voltage (VCELL, mV) */
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = s2mu005_get_vbat(fuelgauge);
+		break;
+		/* Additional Voltage Information (mV) */
+	case POWER_SUPPLY_PROP_VOLTAGE_AVG:
+		switch (val->intval) {
+		case SEC_BATTERY_VOLTAGE_AVERAGE:
+			val->intval = s2mu005_get_avgvbat(fuelgauge);
+			break;
+		case SEC_BATTERY_VOLTAGE_OCV:
+			val->intval = s2mu005_get_ocv(fuelgauge);
+			break;
+		}
+		break;
+		/* Current (mA) */
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = s2mu005_get_current(fuelgauge);
+		break;
+		/* Average Current (mA) */
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+		val->intval = s2mu005_get_avgcurrent(fuelgauge);
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		if (val->intval == SEC_FUELGAUGE_CAPACITY_TYPE_RAW) {
+			val->intval = s2mu005_get_rawsoc(fuelgauge);
+		} else {
+			val->intval = s2mu005_get_soc(fuelgauge);
+
+			if (fuelgauge->pdata->capacity_calculation_type &
+				(SEC_FUELGAUGE_CAPACITY_TYPE_SCALE |
+					SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE))
+				s2mu005_fg_get_scaled_capacity(fuelgauge, val);
+
+			/* capacity should be between 0% and 100%
+			 * (0.1% degree)
+			 */
+			if (val->intval > 1000)
+				val->intval = 1000;
+			if (val->intval < 0)
+				val->intval = 0;
+
+			/* get only integer part */
+			val->intval /= 10;
+
+			/* check whether doing the wake_unlock */
+			if ((val->intval > fuelgauge->pdata->fuel_alert_soc) &&
+					fuelgauge->is_fuel_alerted) {
+				wake_unlock(&fuelgauge->fuel_alert_wake_lock);
+				s2mu005_fuelgauge_fuelalert_init(fuelgauge->i2c,
+						fuelgauge->pdata->fuel_alert_soc);
+			}
+
+			/* (Only for atomic capacity)
+			 * In initial time, capacity_old is 0.
+			 * and in resume from sleep,
+			 * capacity_old is too different from actual soc.
+			 * should update capacity_old
+			 * by val->intval in booting or resume.
+			 */
+			if (fuelgauge->initial_update_of_soc) {
+				/* updated old capacity */
+				fuelgauge->capacity_old = val->intval;
+				fuelgauge->initial_update_of_soc = false;
+				break;
+			}
+
+			if (fuelgauge->pdata->capacity_calculation_type &
+				(SEC_FUELGAUGE_CAPACITY_TYPE_ATOMIC |
+					 SEC_FUELGAUGE_CAPACITY_TYPE_SKIP_ABNORMAL))
+				s2mu005_fg_get_atomic_capacity(fuelgauge, val);
+		}
+
+		break;
+	/* Battery Temperature */
+	case POWER_SUPPLY_PROP_TEMP:
+	/* Target Temperature */
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		val->intval = s2mu005_get_temperature(fuelgauge);
+		break;
+	case POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:
+		val->intval = fuelgauge->capacity_max;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+		val->intval = 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int s2mu005_fg_set_property(struct power_supply *psy,
+			enum power_supply_property psp,
+			const union power_supply_propval *val)
+{
+	struct s2mu005_fuelgauge_data *fuelgauge =
+		container_of(psy, struct s2mu005_fuelgauge_data, psy_fg);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+		if (fuelgauge->pdata->capacity_calculation_type &
+				SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE) {
+#if defined(CONFIG_PREVENT_SOC_JUMP)
+			s2mu005_fg_calculate_dynamic_scale(fuelgauge, val->intval);
+#else
+			s2mu005_fg_calculate_dynamic_scale(fuelgauge, 100);
+#endif
+		}
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		fuelgauge->cable_type = val->intval;
+		if (val->intval == POWER_SUPPLY_TYPE_BATTERY)
+			fuelgauge->is_charging = false;
+		else
+			fuelgauge->is_charging = true;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		if (val->intval == SEC_FUELGAUGE_CAPACITY_TYPE_RESET) {
+			fuelgauge->initial_update_of_soc = true;
+#if 0
+			if (!sec_hal_fg_reset(fuelgauge->i2c))
+				return -EINVAL;
+			else
+				break;
+#endif
+		}
+		break;
+	case POWER_SUPPLY_PROP_TEMP:
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		s2mu005_set_temperature(fuelgauge, val->intval);
+		break;
+	case POWER_SUPPLY_PROP_ENERGY_NOW:
+	{
+		u8 temp = 0;
+		s2mu005_read_reg_byte(fuelgauge->i2c, 0x27, &temp);
+		if (val->intval) {
+			temp |= 0x80;
+		} else {
+			temp &= ~0x80;
+		}
+		s2mu005_write_reg_byte(fuelgauge->i2c, 0x27, temp);
+	}
+		break;
+	case POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:
+		dev_info(&fuelgauge->i2c->dev,
+			"%s: capacity_max changed, %d -> %d\n",
+			__func__, fuelgauge->capacity_max, val->intval);
+		fuelgauge->capacity_max = s2mu005_fg_check_capacity_max(fuelgauge, val->intval);
+		fuelgauge->initial_update_of_soc = true;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+		/* rt5033_fg_reset_capacity_by_jig_connection(fuelgauge->i2c); */
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void s2mu005_fg_isr_work(struct work_struct *work)
+{
+	struct s2mu005_fuelgauge_data *fuelgauge =
+		container_of(work, struct s2mu005_fuelgauge_data, isr_work.work);
+	u8 fg_alert_status = 0;
+
+	s2mu005_read_reg_byte(fuelgauge->i2c, S2MU005_REG_STATUS, &fg_alert_status);
+	dev_info(&fuelgauge->i2c->dev, "%s : fg_alert_status(0x%x)\n",
+		__func__, fg_alert_status);
+
+	fg_alert_status &= 0x03;
+	if (fg_alert_status & 0x01) {
+		pr_info("%s : Battery Level is very Low!\n", __func__);
+	}
+
+	if (fg_alert_status & 0x02) {
+		pr_info("%s : Battery Voltage is Very Low!\n", __func__);
+	}
+
+	if (!fg_alert_status) {
+		pr_info("%s : SOC or Volage is Good!\n", __func__);
+		wake_unlock(&fuelgauge->fuel_alert_wake_lock);
+	}
+}
+
+static irqreturn_t s2mu005_fg_irq_thread(int irq, void *irq_data)
+{
+	struct s2mu005_fuelgauge_data *fuelgauge = irq_data;
+	u8 fg_irq = 0;
+
+	s2mu005_read_reg_byte(fuelgauge->i2c, S2MU005_REG_IRQ, &fg_irq);
+	dev_info(&fuelgauge->i2c->dev, "%s: fg_irq(0x%x)\n",
+		__func__, fg_irq);
+	wake_lock(&fuelgauge->fuel_alert_wake_lock);
+	schedule_delayed_work(&fuelgauge->isr_work, 0);
+
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_OF
+static int s2mu005_fuelgauge_parse_dt(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+	struct device_node *np = of_find_node_by_name(NULL, "s2mu005-fuelgauge");
+	int ret;
+	int i, len;
+	const u32 *p;
+
+	/* reset, irq gpio info */
+	if (np == NULL) {
+		pr_err("%s np NULL\n", __func__);
+	} else {
+		fuelgauge->pdata->fg_irq = of_get_named_gpio(np, "fuelgauge,fuel_int", 0);
+		if (fuelgauge->pdata->fg_irq < 0)
+			pr_err("%s error reading fg_irq = %d\n",
+				__func__, fuelgauge->pdata->fg_irq);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_max",
+				&fuelgauge->pdata->capacity_max);
+		if (ret < 0)
+			pr_err("%s error reading capacity_max %d\n", __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_max_margin",
+				&fuelgauge->pdata->capacity_max_margin);
+		if (ret < 0)
+			pr_err("%s error reading capacity_max_margin %d\n", __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_min",
+				&fuelgauge->pdata->capacity_min);
+		if (ret < 0)
+			pr_err("%s error reading capacity_min %d\n", __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_calculation_type",
+				&fuelgauge->pdata->capacity_calculation_type);
+		if (ret < 0)
+			pr_err("%s error reading capacity_calculation_type %d\n",
+					__func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,fuel_alert_soc",
+				&fuelgauge->pdata->fuel_alert_soc);
+		if (ret < 0)
+			pr_err("%s error reading pdata->fuel_alert_soc %d\n",
+					__func__, ret);
+		fuelgauge->pdata->repeated_fuelalert = of_property_read_bool(np,
+				"fuelgauge,repeated_fuelalert");
+
+		np = of_find_node_by_name(NULL, "battery");
+		if (!np) {
+			pr_err("%s np NULL\n", __func__);
+		} else {
+			ret = of_property_read_string(np,
+				"battery,fuelgauge_name",
+				(char const **)&fuelgauge->pdata->fuelgauge_name);
+			p = of_get_property(np,
+					"battery,input_current_limit", &len);
+			if (!p)
+				return 1;
+
+			len = len / sizeof(u32);
+			fuelgauge->pdata->charging_current =
+					kzalloc(sizeof(struct sec_charging_current) * len,
+					GFP_KERNEL);
+
+			for (i = 0; i < len; i++) {
+				ret = of_property_read_u32_index(np,
+					"battery,input_current_limit", i,
+					&fuelgauge->pdata->charging_current[i].input_current_limit);
+				ret = of_property_read_u32_index(np,
+					"battery,fast_charging_current", i,
+					&fuelgauge->pdata->charging_current[i].fast_charging_current);
+				ret = of_property_read_u32_index(np,
+					"battery,full_check_current_1st", i,
+					&fuelgauge->pdata->charging_current[i].full_check_current_1st);
+				ret = of_property_read_u32_index(np,
+					"battery,full_check_current_2nd", i,
+					&fuelgauge->pdata->charging_current[i].full_check_current_2nd);
+			}
+		}
+	}
+
+	return 0;
+}
+
+static struct of_device_id s2mu005_fuelgauge_match_table[] = {
+	{ .compatible = "samsung,s2mu005-fuelgauge",},
+	{},
+};
+#else
+static int s2mu005_fuelgauge_parse_dt(struct s2mu005_fuelgauge_data *fuelgauge)
+{
+    return -ENOSYS;
+}
+
+#define s2mu005_fuelgauge_match_table NULL
+#endif /* CONFIG_OF */
+
+static int s2mu005_fuelgauge_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+	struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
+	struct s2mu005_fuelgauge_data *fuelgauge;
+	union power_supply_propval raw_soc_val;
+	int ret = 0;
+
+	pr_info("%s: S2MU005 Fuelgauge Driver Loading\n", __func__);
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE))
+		return -EIO;
+
+	fuelgauge = kzalloc(sizeof(*fuelgauge), GFP_KERNEL);
+	if (!fuelgauge)
+		return -ENOMEM;
+
+	mutex_init(&fuelgauge->fg_lock);
+
+	fuelgauge->i2c = client;
+
+	if (client->dev.of_node) {
+		fuelgauge->pdata = devm_kzalloc(&client->dev, sizeof(*(fuelgauge->pdata)),
+				GFP_KERNEL);
+		if (!fuelgauge->pdata) {
+			dev_err(&client->dev, "Failed to allocate memory\n");
+			ret = -ENOMEM;
+			goto err_parse_dt_nomem;
+		}
+		ret = s2mu005_fuelgauge_parse_dt(fuelgauge);
+		if (ret < 0)
+			goto err_parse_dt;
+	} else {
+		fuelgauge->pdata = client->dev.platform_data;
+	}
+
+	i2c_set_clientdata(client, fuelgauge);
+
+	if (fuelgauge->pdata->fuelgauge_name == NULL)
+		fuelgauge->pdata->fuelgauge_name = "sec-fuelgauge";
+
+	fuelgauge->psy_fg.name          = fuelgauge->pdata->fuelgauge_name;
+	fuelgauge->psy_fg.type          = POWER_SUPPLY_TYPE_UNKNOWN;
+	fuelgauge->psy_fg.get_property  = s2mu005_fg_get_property;
+	fuelgauge->psy_fg.set_property  = s2mu005_fg_set_property;
+	fuelgauge->psy_fg.properties    = s2mu005_fuelgauge_props;
+	fuelgauge->psy_fg.num_properties =
+			ARRAY_SIZE(s2mu005_fuelgauge_props);
+
+	fuelgauge->capacity_max = fuelgauge->pdata->capacity_max;
+	raw_soc_val.intval = s2mu005_get_rawsoc(fuelgauge);
+	s2mu005_init_regs(fuelgauge);
+	if (raw_soc_val.intval == 0) {
+		s2mu005_init_regs(fuelgauge);
+		raw_soc_val.intval = s2mu005_get_rawsoc(fuelgauge);
+	}
+
+	raw_soc_val.intval = raw_soc_val.intval / 10;
+
+	if (raw_soc_val.intval > fuelgauge->capacity_max)
+		s2mu005_fg_calculate_dynamic_scale(fuelgauge, 100);
+
+	ret = power_supply_register(&client->dev, &fuelgauge->psy_fg);
+	if (ret) {
+		pr_err("%s: Failed to Register psy_fg\n", __func__);
+		goto err_data_free;
+	}
+
+	if (fuelgauge->pdata->fuel_alert_soc >= 0) {
+		s2mu005_fuelgauge_fuelalert_init(fuelgauge->i2c,
+					fuelgauge->pdata->fuel_alert_soc);
+		wake_lock_init(&fuelgauge->fuel_alert_wake_lock,
+					WAKE_LOCK_SUSPEND, "fuel_alerted");
+
+		if (fuelgauge->pdata->fg_irq > 0) {
+			INIT_DELAYED_WORK(
+					&fuelgauge->isr_work, s2mu005_fg_isr_work);
+
+			fuelgauge->fg_irq = gpio_to_irq(fuelgauge->pdata->fg_irq);
+			dev_info(&client->dev,
+					"%s : fg_irq = %d\n", __func__, fuelgauge->fg_irq);
+			if (fuelgauge->fg_irq > 0) {
+				ret = request_threaded_irq(fuelgauge->fg_irq,
+						NULL, s2mu005_fg_irq_thread,
+						IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING
+						| IRQF_ONESHOT,
+						"fuelgauge-irq", fuelgauge);
+				if (ret) {
+					dev_err(&client->dev,
+							"%s: Failed to Request IRQ\n", __func__);
+					goto err_supply_unreg;
+				}
+
+				ret = enable_irq_wake(fuelgauge->fg_irq);
+				if (ret < 0)
+					dev_err(&client->dev,
+							"%s: Failed to Enable Wakeup Source(%d)\n",
+							__func__, ret);
+			} else {
+				dev_err(&client->dev, "%s: Failed gpio_to_irq(%d)\n",
+						__func__, fuelgauge->fg_irq);
+				goto err_supply_unreg;
+			}
+		}
+	}
+
+	fuelgauge->initial_update_of_soc = true;
+
+	pr_info("%s: S2MU005 Fuelgauge Driver Loaded\n", __func__);
+	return 0;
+
+err_supply_unreg:
+	power_supply_unregister(&fuelgauge->psy_fg);
+err_data_free:
+	if (client->dev.of_node)
+		kfree(fuelgauge->pdata);
+
+err_parse_dt:
+err_parse_dt_nomem:
+	mutex_destroy(&fuelgauge->fg_lock);
+	kfree(fuelgauge);
+
+	return ret;
+}
+
+static const struct i2c_device_id s2mu005_fuelgauge_id[] = {
+	{"s2mu005-fuelgauge", 0},
+	{}
+};
+
+static void s2mu005_fuelgauge_shutdown(struct i2c_client *client)
+{
+}
+
+static int s2mu005_fuelgauge_remove(struct i2c_client *client)
+{
+	struct s2mu005_fuelgauge_data *fuelgauge = i2c_get_clientdata(client);
+
+	if (fuelgauge->pdata->fuel_alert_soc >= 0)
+		wake_lock_destroy(&fuelgauge->fuel_alert_wake_lock);
+
+	return 0;
+}
+
+#if defined CONFIG_PM
+static int s2mu005_fuelgauge_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int s2mu005_fuelgauge_resume(struct device *dev)
+{
+	return 0;
+}
+#else
+#define s2mu005_fuelgauge_suspend NULL
+#define s2mu005_fuelgauge_resume NULL
+#endif
+
+static SIMPLE_DEV_PM_OPS(s2mu005_fuelgauge_pm_ops, s2mu005_fuelgauge_suspend,
+		s2mu005_fuelgauge_resume);
+
+static struct i2c_driver s2mu005_fuelgauge_driver = {
+	.driver = {
+		.name = "s2mu005-fuelgauge",
+		.owner = THIS_MODULE,
+		.pm = &s2mu005_fuelgauge_pm_ops,
+		.of_match_table = s2mu005_fuelgauge_match_table,
+	},
+	.probe  = s2mu005_fuelgauge_probe,
+	.remove = s2mu005_fuelgauge_remove,
+	.shutdown   = s2mu005_fuelgauge_shutdown,
+	.id_table   = s2mu005_fuelgauge_id,
+};
+
+static int __init s2mu005_fuelgauge_init(void)
+{
+	pr_info("%s: S2MU005 Fuelgauge Init\n", __func__);
+	return i2c_add_driver(&s2mu005_fuelgauge_driver);
+}
+
+static void __exit s2mu005_fuelgauge_exit(void)
+{
+	i2c_del_driver(&s2mu005_fuelgauge_driver);
+}
+module_init(s2mu005_fuelgauge_init);
+module_exit(s2mu005_fuelgauge_exit);
+
+MODULE_DESCRIPTION("Samsung S2MU005 Fuel Gauge Driver");
+MODULE_AUTHOR("Samsung Electronics");
+MODULE_LICENSE("GPL");
diff -Naur linux-3.18.14/drivers/power/sec_fuelgauge.c samsung/drivers/power/sec_fuelgauge.c
--- linux-3.18.14/drivers/power/sec_fuelgauge.c	1970-01-01 01:00:00.000000000 +0100
+++ samsung/drivers/power/sec_fuelgauge.c	2018-10-29 07:24:39.000000000 +0100
@@ -0,0 +1,659 @@
+/*
+ *  sec_fuelgauge.c
+ *  Samsung Mobile Fuel Gauge Driver
+ *
+ *  Copyright (C) 2012 Samsung Electronics
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#define DEBUG
+
+#include <linux/power/sec_fuelgauge.h>
+#include <linux/of_gpio.h>
+
+static struct device_attribute sec_fg_attrs[] = {
+	SEC_FG_ATTR(reg),
+	SEC_FG_ATTR(data),
+	SEC_FG_ATTR(regs),
+};
+
+static enum power_supply_property sec_fuelgauge_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_VOLTAGE_AVG,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CURRENT_AVG,
+	POWER_SUPPLY_PROP_CHARGE_FULL,
+	POWER_SUPPLY_PROP_ENERGY_NOW,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_TEMP_AMBIENT,
+};
+
+/* capacity is  0.1% unit */
+static void sec_fg_get_scaled_capacity(
+				struct sec_fuelgauge_info *fuelgauge,
+				union power_supply_propval *val)
+{
+	val->intval = (val->intval < fuelgauge->pdata->capacity_min) ?
+		0 : ((val->intval - fuelgauge->pdata->capacity_min) * 1000 /
+		(fuelgauge->capacity_max - fuelgauge->pdata->capacity_min));
+
+	dev_dbg(&fuelgauge->client->dev,
+		"%s: scaled capacity (%d.%d)\n",
+		__func__, val->intval/10, val->intval%10);
+}
+
+/* capacity is integer */
+static void sec_fg_get_atomic_capacity(
+				struct sec_fuelgauge_info *fuelgauge,
+				union power_supply_propval *val)
+{
+	if (fuelgauge->pdata->capacity_calculation_type &
+		SEC_FUELGAUGE_CAPACITY_TYPE_ATOMIC) {
+	if (fuelgauge->capacity_old < val->intval)
+		val->intval = fuelgauge->capacity_old + 1;
+	else if (fuelgauge->capacity_old > val->intval)
+		val->intval = fuelgauge->capacity_old - 1;
+	}
+
+	/* keep SOC stable in abnormal status */
+	if (fuelgauge->pdata->capacity_calculation_type &
+		SEC_FUELGAUGE_CAPACITY_TYPE_SKIP_ABNORMAL) {
+		if (!fuelgauge->is_charging &&
+			fuelgauge->capacity_old < val->intval) {
+			dev_err(&fuelgauge->client->dev,
+				"%s: capacity (old %d : new %d)\n",
+				__func__, fuelgauge->capacity_old, val->intval);
+			val->intval = fuelgauge->capacity_old;
+		}
+	}
+
+	/* updated old capacity */
+	fuelgauge->capacity_old = val->intval;
+}
+
+static int sec_fg_get_property(struct power_supply *psy,
+			    enum power_supply_property psp,
+			    union power_supply_propval *val)
+{
+	struct sec_fuelgauge_info *fuelgauge =
+		container_of(psy, struct sec_fuelgauge_info, psy_fg);
+	int soc_type = val->intval;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+	case POWER_SUPPLY_PROP_VOLTAGE_AVG:
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+	case POWER_SUPPLY_PROP_ENERGY_NOW:
+	case POWER_SUPPLY_PROP_CAPACITY:
+	case POWER_SUPPLY_PROP_TEMP:
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		if (!sec_hal_fg_get_property(fuelgauge->client, psp, val))
+			return -EINVAL;
+		if (psp == POWER_SUPPLY_PROP_CAPACITY) {
+			if (soc_type == SEC_FUELGAUGE_CAPACITY_TYPE_RAW)
+				break;
+
+			if (fuelgauge->pdata->capacity_calculation_type &
+				(SEC_FUELGAUGE_CAPACITY_TYPE_SCALE |
+				 SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE))
+				sec_fg_get_scaled_capacity(fuelgauge, val);
+
+			/* capacity should be between 0% and 100%
+			 * (0.1% degree)
+			 */
+			if (val->intval > 1000)
+				val->intval = 1000;
+			if (val->intval < 0)
+				val->intval = 0;
+
+			/* get only integer part */
+			val->intval /= 10;
+
+			/* check whether doing the wake_unlock */
+			if ((val->intval > fuelgauge->pdata->fuel_alert_soc) &&
+				fuelgauge->is_fuel_alerted) {
+				wake_unlock(&fuelgauge->fuel_alert_wake_lock);
+				sec_hal_fg_fuelalert_init(fuelgauge->client,
+					fuelgauge->pdata->fuel_alert_soc);
+			}
+
+			/* (Only for atomic capacity)
+			 * In initial time, capacity_old is 0.
+			 * and in resume from sleep,
+			 * capacity_old is too different from actual soc.
+			 * should update capacity_old
+			 * by val->intval in booting or resume.
+			 */
+			if (fuelgauge->initial_update_of_soc) {
+				/* updated old capacity */
+				fuelgauge->capacity_old = val->intval;
+				fuelgauge->initial_update_of_soc = false;
+				break;
+			}
+
+			if (fuelgauge->pdata->capacity_calculation_type &
+				(SEC_FUELGAUGE_CAPACITY_TYPE_ATOMIC |
+				 SEC_FUELGAUGE_CAPACITY_TYPE_SKIP_ABNORMAL))
+				sec_fg_get_atomic_capacity(fuelgauge, val);
+		}
+		break;
+	case POWER_SUPPLY_PROP_STATUS:
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+		return -ENODATA;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int sec_fg_calculate_dynamic_scale(
+				struct sec_fuelgauge_info *fuelgauge)
+{
+	union power_supply_propval raw_soc_val;
+
+	raw_soc_val.intval = SEC_FUELGAUGE_CAPACITY_TYPE_RAW;
+	if (!sec_hal_fg_get_property(fuelgauge->client,
+		POWER_SUPPLY_PROP_CAPACITY,
+		&raw_soc_val))
+		return -EINVAL;
+	raw_soc_val.intval /= 10;
+
+	if (raw_soc_val.intval <
+		fuelgauge->pdata->capacity_max -
+		fuelgauge->pdata->capacity_max_margin) {
+		fuelgauge->capacity_max =
+			fuelgauge->pdata->capacity_max -
+			fuelgauge->pdata->capacity_max_margin;
+		dev_dbg(&fuelgauge->client->dev, "%s: capacity_max (%d)",
+			__func__, fuelgauge->capacity_max);
+	} else {
+		fuelgauge->capacity_max =
+			(raw_soc_val.intval >
+			fuelgauge->pdata->capacity_max +
+			fuelgauge->pdata->capacity_max_margin) ?
+			(fuelgauge->pdata->capacity_max +
+			fuelgauge->pdata->capacity_max_margin) :
+			raw_soc_val.intval;
+		dev_dbg(&fuelgauge->client->dev, "%s: raw soc (%d)",
+			__func__, fuelgauge->capacity_max);
+	}
+
+	fuelgauge->capacity_max =
+		(fuelgauge->capacity_max * 99 / 100);
+
+	/* update capacity_old for sec_fg_get_atomic_capacity algorithm */
+	fuelgauge->capacity_old = 100;
+
+	dev_info(&fuelgauge->client->dev, "%s: %d is used for capacity_max\n",
+		__func__, fuelgauge->capacity_max);
+
+	return fuelgauge->capacity_max;
+}
+
+static int sec_fg_set_property(struct power_supply *psy,
+			    enum power_supply_property psp,
+			    const union power_supply_propval *val)
+{
+	struct sec_fuelgauge_info *fuelgauge =
+		container_of(psy, struct sec_fuelgauge_info, psy_fg);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		if (val->intval == POWER_SUPPLY_STATUS_FULL)
+			sec_hal_fg_full_charged(fuelgauge->client);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+		if (val->intval == POWER_SUPPLY_TYPE_BATTERY) {
+			if (fuelgauge->pdata->capacity_calculation_type &
+				SEC_FUELGAUGE_CAPACITY_TYPE_DYNAMIC_SCALE)
+				sec_fg_calculate_dynamic_scale(fuelgauge);
+		}
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		fuelgauge->cable_type = val->intval;
+		if (val->intval == POWER_SUPPLY_TYPE_BATTERY)
+			fuelgauge->is_charging = false;
+		else
+			fuelgauge->is_charging = true;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		if (val->intval == SEC_FUELGAUGE_CAPACITY_TYPE_RESET) {
+			fuelgauge->initial_update_of_soc = true;
+			if (!sec_hal_fg_reset(fuelgauge->client))
+				return -EINVAL;
+			else
+				break;
+		}
+	case POWER_SUPPLY_PROP_TEMP:
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		if (!sec_hal_fg_set_property(fuelgauge->client, psp, val))
+			return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static void sec_fg_isr_work(struct work_struct *work)
+{
+	struct sec_fuelgauge_info *fuelgauge =
+		container_of(work, struct sec_fuelgauge_info, isr_work.work);
+
+	/* process for fuel gauge chip */
+	sec_hal_fg_fuelalert_process(fuelgauge, fuelgauge->is_fuel_alerted);
+
+	/* process for others */
+	if (fuelgauge->pdata->fuelalert_process != NULL)
+		fuelgauge->pdata->fuelalert_process(fuelgauge->is_fuel_alerted);
+}
+
+static irqreturn_t sec_fg_irq_thread(int irq, void *irq_data)
+{
+	struct sec_fuelgauge_info *fuelgauge = irq_data;
+	bool fuel_alerted;
+
+	if (fuelgauge->pdata->fuel_alert_soc >= 0) {
+		fuel_alerted =
+			sec_hal_fg_is_fuelalerted(fuelgauge->client);
+
+		dev_info(&fuelgauge->client->dev,
+			"%s: Fuel-alert %salerted!\n",
+			__func__, fuel_alerted ? "" : "NOT ");
+
+		if (fuel_alerted == fuelgauge->is_fuel_alerted) {
+			if (!fuelgauge->pdata->repeated_fuelalert) {
+				dev_dbg(&fuelgauge->client->dev,
+					"%s: Fuel-alert Repeated (%d)\n",
+					__func__, fuelgauge->is_fuel_alerted);
+				return IRQ_HANDLED;
+			}
+		}
+
+		if (fuel_alerted)
+			wake_lock(&fuelgauge->fuel_alert_wake_lock);
+		else
+			wake_unlock(&fuelgauge->fuel_alert_wake_lock);
+
+		schedule_delayed_work(&fuelgauge->isr_work, 0);
+
+		fuelgauge->is_fuel_alerted = fuel_alerted;
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int sec_fg_create_attrs(struct device *dev)
+{
+	int i, rc;
+
+	for (i = 0; i < ARRAY_SIZE(sec_fg_attrs); i++) {
+		rc = device_create_file(dev, &sec_fg_attrs[i]);
+		if (rc)
+			goto create_attrs_failed;
+	}
+	goto create_attrs_succeed;
+
+create_attrs_failed:
+	dev_err(dev, "%s: failed (%d)\n", __func__, rc);
+	while (i--)
+		device_remove_file(dev, &sec_fg_attrs[i]);
+create_attrs_succeed:
+	return rc;
+}
+
+ssize_t sec_fg_show_attrs(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	const ptrdiff_t offset = attr - sec_fg_attrs;
+	int i = 0;
+
+	switch (offset) {
+	case FG_REG:
+	case FG_DATA:
+	case FG_REGS:
+		i = sec_hal_fg_show_attrs(dev, offset, buf);
+		break;
+	default:
+		i = -EINVAL;
+		break;
+	}
+
+	return i;
+}
+
+ssize_t sec_fg_store_attrs(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	const ptrdiff_t offset = attr - sec_fg_attrs;
+	int ret = 0;
+
+	switch (offset) {
+	case FG_REG:
+	case FG_DATA:
+		ret = sec_hal_fg_store_attrs(dev, offset, buf, count);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+#ifdef CONFIG_OF
+static int fuelgauge_parse_dt(struct device *dev,
+			struct sec_fuelgauge_info *fuelgauge)
+{
+	struct device_node *np = dev->of_node;
+	sec_battery_platform_data_t *pdata = fuelgauge->pdata;
+	int ret;
+#if 0
+	int ta_int_gpio;
+	sec_battery_platform_data_t sec_battery_pdata;
+#endif
+
+	/* reset, irq gpio info */
+	if (np == NULL) {
+		pr_err("%s np NULL\n", __func__);
+	} else {
+		pdata->fg_irq = of_get_named_gpio(np, "fuelgauge,fuel_int", 0);
+		if (pdata->fg_irq < 0) {
+			pr_err("%s error reading fg_irq = %d\n", __func__, pdata->fg_irq);
+			pdata->fg_irq = 0;
+		}
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_max",
+				&pdata->capacity_max);
+		if (ret < 0)
+			pr_err("%s error reading capacity_max %d\n", __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_max_margin",
+				&pdata->capacity_max_margin);
+		if (ret < 0)
+			pr_err("%s error reading capacity_max_margin %d\n", __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_min",
+				&pdata->capacity_min);
+		if (ret < 0)
+			pr_err("%s error reading capacity_min %d\n", __func__, ret);
+
+		ret = of_property_read_u32(np, "fuelgauge,capacity_calculation_type",
+				&pdata->capacity_calculation_type);
+		if (ret < 0)
+			pr_err("%s error reading capacity_calculation_type %d\n",
+					__func__, ret);
+		ret = of_property_read_u32(np, "fuelgauge,fuel_alert_soc",
+				&pdata->fuel_alert_soc);
+		if (ret < 0)
+			pr_err("%s error reading pdata->fuel_alert_soc %d\n",
+					__func__, ret);
+		pdata->repeated_fuelalert = of_property_read_bool(np,
+				"fuelgaguge,repeated_fuelalert");
+
+		pr_info("%s fg_irq: %d, capacity_max: %d\n"
+			"cpacity_max_margin: %d, capacity_min: %d\n"
+			"calculation_type: 0x%x, fuel_alert_soc: %d,\n"
+			"repeated_fuelalert: %d\n",
+			__func__, pdata->fg_irq,
+			pdata->capacity_max, pdata->capacity_max_margin,
+			pdata->capacity_min, pdata->capacity_calculation_type,
+			pdata->fuel_alert_soc, pdata->repeated_fuelalert);
+	}
+	return 0;
+}
+#endif
+
+static int sec_fuelgauge_probe(struct i2c_client *client,
+						const struct i2c_device_id *id)
+{
+	struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
+	struct sec_fuelgauge_info *fuelgauge;
+	sec_battery_platform_data_t *pdata = NULL;
+	struct battery_data_t *battery_data = NULL;
+	int ret = 0;
+	union power_supply_propval raw_soc_val;
+
+	dev_info(&client->dev,
+		"%s: SEC Fuelgauge Driver Loading\n", __func__);
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE))
+		return -EIO;
+
+	fuelgauge = kzalloc(sizeof(*fuelgauge), GFP_KERNEL);
+	if (!fuelgauge)
+		return -ENOMEM;
+
+	mutex_init(&fuelgauge->fg_lock);
+
+	fuelgauge->client = client;
+
+	if (client->dev.of_node) {
+		int error;
+		pdata = devm_kzalloc(&client->dev,
+			sizeof(sec_battery_platform_data_t),
+				GFP_KERNEL);
+		if (!pdata) {
+			dev_err(&client->dev, "Failed to allocate memory\n");
+			ret = -ENOMEM;
+			goto err_free;
+		}
+		battery_data = devm_kzalloc(&client->dev,
+			sizeof(struct battery_data_t),
+				GFP_KERNEL);
+		if (!battery_data) {
+			dev_err(&client->dev, "Failed to allocate memory\n");
+			devm_kfree(&client->dev, pdata);
+			ret = -ENOMEM;
+			goto err_free;
+		}
+		pdata->battery_data = (void *)battery_data;
+		fuelgauge->pdata = pdata;
+		error = fuelgauge_parse_dt(&client->dev, fuelgauge);
+		if (error) {
+			dev_err(&client->dev,
+				"%s: Failed to get fuel_int\n", __func__);
+		}
+	} else	{
+		dev_err(&client->dev,
+			"%s: Failed to get of_node\n", __func__);
+		fuelgauge->pdata = client->dev.platform_data;
+	}
+
+	i2c_set_clientdata(client, fuelgauge);
+
+	if (!sec_hal_fg_init(fuelgauge->client)) {
+		dev_err(&client->dev,
+			"%s: Failed to Initialize Fuelgauge\n", __func__);
+		goto err_free;
+	}
+
+	fuelgauge->psy_fg.name		= "sec-fuelgauge";
+	fuelgauge->psy_fg.type		= POWER_SUPPLY_TYPE_UNKNOWN;
+	fuelgauge->psy_fg.get_property	= sec_fg_get_property;
+	fuelgauge->psy_fg.set_property	= sec_fg_set_property;
+	fuelgauge->psy_fg.properties	= sec_fuelgauge_props;
+	fuelgauge->psy_fg.num_properties =
+		ARRAY_SIZE(sec_fuelgauge_props);
+	fuelgauge->capacity_max = fuelgauge->pdata->capacity_max;
+	raw_soc_val.intval = SEC_FUELGAUGE_CAPACITY_TYPE_RAW;
+	sec_hal_fg_get_property(fuelgauge->client,
+			POWER_SUPPLY_PROP_CAPACITY, &raw_soc_val);
+	raw_soc_val.intval /= 10;
+	if (raw_soc_val.intval > fuelgauge->pdata->capacity_max)
+		sec_fg_calculate_dynamic_scale(fuelgauge);
+/*
+	if (!fuelgauge->pdata->fg_gpio_init()) {
+		dev_err(&client->dev,
+			"%s: Failed to Initialize GPIO\n", __func__);
+		goto err_free;
+	}
+*/
+	ret = power_supply_register(&client->dev, &fuelgauge->psy_fg);
+	if (ret) {
+		dev_err(&client->dev,
+			"%s: Failed to Register psy_fg\n", __func__);
+		goto err_free;
+	}
+
+	if (fuelgauge->pdata->fg_irq) {
+		fuelgauge->fg_irq = gpio_to_irq(fuelgauge->pdata->fg_irq);
+		INIT_DELAYED_WORK(
+			&fuelgauge->isr_work, sec_fg_isr_work);
+
+		ret = request_threaded_irq(fuelgauge->fg_irq,
+				NULL, sec_fg_irq_thread,
+			        IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING | IRQF_ONESHOT,
+				"fuelgauge-irq", fuelgauge);
+		if (ret) {
+			dev_err(&client->dev,
+				"%s: Failed to Reqeust IRQ\n", __func__);
+			goto err_supply_unreg;
+		}
+
+		ret = enable_irq_wake(fuelgauge->fg_irq);
+		if (ret < 0)
+			dev_err(&client->dev,
+				"%s: Failed to Enable Wakeup Source(%d)\n",
+				__func__, ret);
+	}
+
+	fuelgauge->is_fuel_alerted = false;
+	if (fuelgauge->pdata->fuel_alert_soc >= 0) {
+		if (sec_hal_fg_fuelalert_init(fuelgauge->client,
+			fuelgauge->pdata->fuel_alert_soc))
+			wake_lock_init(&fuelgauge->fuel_alert_wake_lock,
+				WAKE_LOCK_SUSPEND, "fuel_alerted");
+		else {
+			dev_err(&client->dev,
+				"%s: Failed to Initialize Fuel-alert\n",
+				__func__);
+			goto err_irq;
+		}
+	}
+
+	fuelgauge->initial_update_of_soc = true;
+
+	ret = sec_fg_create_attrs(fuelgauge->psy_fg.dev);
+	if (ret) {
+		dev_err(&client->dev,
+			"%s : Failed to create_attrs\n", __func__);
+		goto err_irq;
+	}
+
+	dev_info(&client->dev,
+		"%s: SEC Fuelgauge Driver Loaded\n", __func__);
+	return 0;
+
+err_irq:
+	if (fuelgauge->fg_irq)
+		free_irq(fuelgauge->fg_irq, fuelgauge);
+	wake_lock_destroy(&fuelgauge->fuel_alert_wake_lock);
+err_supply_unreg:
+	power_supply_unregister(&fuelgauge->psy_fg);
+err_free:
+	mutex_destroy(&fuelgauge->fg_lock);
+	kfree(fuelgauge);
+
+	return ret;
+}
+
+static int sec_fuelgauge_remove(
+						struct i2c_client *client)
+{
+	struct sec_fuelgauge_info *fuelgauge = i2c_get_clientdata(client);
+
+	if (fuelgauge->pdata->fuel_alert_soc >= 0)
+		wake_lock_destroy(&fuelgauge->fuel_alert_wake_lock);
+
+	return 0;
+}
+
+static int sec_fuelgauge_suspend(struct device *dev)
+{
+	struct sec_fuelgauge_info *fuelgauge = dev_get_drvdata(dev);
+
+	if (!sec_hal_fg_suspend(fuelgauge->client))
+		dev_err(&fuelgauge->client->dev,
+			"%s: Failed to Suspend Fuelgauge\n", __func__);
+
+	return 0;
+}
+
+static int sec_fuelgauge_resume(struct device *dev)
+{
+	struct sec_fuelgauge_info *fuelgauge = dev_get_drvdata(dev);
+
+	if (!sec_hal_fg_resume(fuelgauge->client))
+		dev_err(&fuelgauge->client->dev,
+			"%s: Failed to Resume Fuelgauge\n", __func__);
+
+	fuelgauge->initial_update_of_soc = true;
+
+	return 0;
+}
+
+static void sec_fuelgauge_shutdown(struct i2c_client *client)
+{
+}
+
+static const struct i2c_device_id sec_fuelgauge_id[] = {
+	{"sec-fuelgauge", 0},
+	{}
+};
+
+static const struct dev_pm_ops sec_fuelgauge_pm_ops = {
+	.suspend = sec_fuelgauge_suspend,
+	.resume  = sec_fuelgauge_resume,
+};
+
+MODULE_DEVICE_TABLE(i2c, sec_fuelgauge_id);
+
+#if defined(CONFIG_OF)
+static struct of_device_id sec_fuelgauge_i2c_dt_ids[] = {
+	{ .compatible = "sec-fuelgauge,i2c" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, sec_fuelgauge_i2c_dt_ids);
+#endif /* CONFIG_OF */
+
+static struct i2c_driver sec_fuelgauge_driver = {
+	.driver = {
+		   .name = "sec-fuelgauge",
+		   .owner = THIS_MODULE,
+#ifdef CONFIG_PM
+			.pm = &sec_fuelgauge_pm_ops,
+#endif
+#if defined(CONFIG_OF)
+		.of_match_table	= sec_fuelgauge_i2c_dt_ids,
+#endif /* CONFIG_OF */
+		   },
+	.probe	= sec_fuelgauge_probe,
+	.remove	= sec_fuelgauge_remove,
+	.shutdown   = sec_fuelgauge_shutdown,
+	.id_table   = sec_fuelgauge_id,
+};
+
+static int __init sec_fuelgauge_init(void)
+{
+	return i2c_add_driver(&sec_fuelgauge_driver);
+}
+
+static void __exit sec_fuelgauge_exit(void)
+{
+	i2c_del_driver(&sec_fuelgauge_driver);
+}
+
+module_init(sec_fuelgauge_init);
+module_exit(sec_fuelgauge_exit);
+
+MODULE_DESCRIPTION("Samsung Fuel Gauge Driver");
+MODULE_AUTHOR("Samsung Electronics");
+MODULE_LICENSE("GPL");
